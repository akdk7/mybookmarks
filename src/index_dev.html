<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ title }}</title>
  <!-- Favicon Placeholder - Replace FAVICON_BASE64_HERE with your base64 data -->
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="stylesheet" href="style.css">
  <script src="external.js"></script>
  <style rel="stylesheet">
    /* Enhanced CSS Variables System - Override these in Custom CSS without !important */
    :root {
      /* Core Colors */
      --bg-primary: #fafbfc;
      --bg-secondary: #ffffff;
      --bg-header-start: #ffffff;
      --bg-header-end: #f8f9fa;
      --text-primary: #1a1a1a;
      --text-secondary: #555;
      --text-muted: #aaa;
      --text-subtle: #bbb;
      --border-color: #e9ecef;
      --border-light: #dee2e6;
      --shadow-sm: rgba(0, 0, 0, 0.03);
      --shadow-md: rgba(0, 0, 0, 0.1);
      --card-bg: #fff;
      --input-bg: #fff;
      --input-border: #ced4da;
      --btn-primary-bg: #007bff;
      --btn-primary-hover: #0056b3;
      --link-color: #007bff;
      --link-hover: #0056b3;
      
      /* Layout & Spacing */
      --container-padding: 0;
      --toolbar-padding: 0;
      --titlebar-padding: 0;
      --group-padding: 16px 8px 16px 12px;
      --group-margin-bottom: 0;
      --group-border-radius: 16px;
      --group-shadow: 0 1px 2px rgba(0, 0, 0, 0.04), 0 8px 16px -4px rgba(0, 0, 0, 0.08);
      --group-shadow-hover: 0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.1), 0 20px 40px -10px rgba(0, 0, 0, 0.15);
      
      /* Group Header */
      --group-header-bg: linear-gradient(135deg, rgba(255, 255, 255, 0.6) 0%, rgba(250, 250, 251, 0.4) 100%);
      --group-header-border: 1px solid rgba(0, 0, 0, 0.05);
      
      /* Links */
      --link-padding: 2px 8px;
      --link-font-size: inherit;
      --link-border-bottom: 1px solid rgba(0, 0, 0, 0.02);
      --link-hover-bg: rgba(0, 0, 0, 0.02);
      
      /* Buttons */
      --btn-padding: 0.375rem 0.75rem;
      --btn-font-size: 0.875rem;
      --btn-border-radius: 8px;
      --btn-gap: 0.5rem;
      
      /* Typography */
      --font-family-base: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      --font-family-mono: 'Courier New', Courier, Monaco, Menlo, monospace;
      --font-size-base: 14px;
      --font-size-sm: 12px;
      --font-size-lg: 16px;
      --line-height-base: 1.5;
      
      /* Transitions */
      --transition-speed: 0.3s;
      --transition-timing: ease;
      
      /* App-level dynamic variables (set via JS) */
      --app-bg: var(--bg-primary);
      --app-bg-image: none;
      --app-text-color: var(--text-primary);
    }

    /* Modal Scrollability and Height Constraints */
    .modal-dialog {
      max-height: 90vh;
      display: flex;
      flex-direction: column;
    }
    
    .modal-content {
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .modal-header {
      flex-shrink: 0;
    }
    
    .modal-body {
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1 1 auto;
      max-height: calc(90vh - 120px); /* Account for header and footer */
    }
    
    .modal-footer {
      flex-shrink: 0;
    }

    .mb-edit-favicon-preview {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .mb-edit-favicon-actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-left: 1rem;
      flex-shrink: 0;
    }

    .mb-edit-favicon-actions button {
      white-space: nowrap;
    }

    @media (max-width: 576px) {
      .mb-edit-favicon-actions {
        flex-wrap: wrap;
        justify-content: flex-end;
        margin-left: 0.5rem;
        row-gap: 0.25rem;
      }
    }

    /* Ensure centered modals respect height constraints */
    .modal-dialog-centered {
      min-height: calc(100% - 3.5rem);
      max-height: 90vh;
    }
    
    /* For large modals, ensure they don't exceed viewport */
    .modal-lg .modal-body {
      max-height: calc(90vh - 140px);
    }
    
    /* Prevent content from making dialog too wide */
    .modal-body > * {
      max-width: 100%;
      overflow-wrap: break-word;
    }

    /* Base styles */
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    body {
      /* Default styles - can be overridden by custom CSS */
      background-color: #fafbfc;
      color: #1a1a1a;
    }

    #app {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      min-height: calc(100vh - 45px);
      /* Ensure content pushes footer down */
      box-sizing: border-box;
      padding: 0 15px 80px 15px;
      /* Top padding removed, managed by header */
      /* Removed CSS variables to allow custom CSS to override */
    }
    
    /* App container - custom CSS can override these */
    #app.container-fluid {
      /* Default styles - can be overridden by custom CSS */
      min-height: 100vh;
    }
    
    /* Modern Header Bar Styling */
    #app > h1 {
      font-size: 1.25rem;
      font-weight: 700;
      margin: 0;
      padding: var(--custom-titlebar-bg-padding, 0.75rem 1rem 0 0rem);  /* Increased left padding */
      color: #1a1a1a;
      /* Removed CSS variables to allow custom CSS to override */
      opacity: var(--custom-titlebar-bg-opacity, 1);
      border-style: var(--custom-titlebar-bg-border_style, none);
      border-width: var(--custom-titlebar-bg-border_width, 0);
      border-color: var(--custom-titlebar-bg-border_color, transparent);
      border-radius: var(--custom-titlebar-bg-border_radius, 0);
      font-family: var(--custom-title-color-font_family, inherit);
      font-size: var(--custom-title-color-font_size, 1.25rem);
      font-weight: var(--custom-title-color-font_weight, 700);
      letter-spacing: -0.5px;
      display: flex;
      align-items: center;
      justify-content: flex-start;  /* Changed to flex-start for left alignment */
      background: var(--custom-titlebar-bg-background_color, var(--custom-titlebar-bg, linear-gradient(135deg, var(--bg-header-start) 0%, var(--bg-header-end) 100%)));
      border-bottom: 1px solid var(--border-color);
      text-align: left;  /* Ensure text is left-aligned */
    }
    
    /* Compact Toolbar Container */
    .container-fluid.mt-3.mb-3 {
      background: var(--custom-toolbar-bg-background_color, var(--custom-toolbar-bg, var(--bg-secondary)));
      color: var(--custom-toolbar-bg-color, inherit);
      opacity: var(--custom-toolbar-bg-opacity, 1);
      border-style: var(--custom-toolbar-bg-border_style, none);
      border-width: var(--custom-toolbar-bg-border_width, 0);
      border-color: var(--custom-toolbar-bg-border_color, transparent);
      border-radius: var(--custom-toolbar-bg-border_radius, 0);
      padding: var(--custom-toolbar-bg-padding, 0.5rem 0);
      margin-top: 0 !important;
      border-bottom: 1px solid var(--border-color);
      box-shadow: 0 1px 2px var(--shadow-sm);
      flex-shrink: 0;  /* Don't shrink */
    }
    
    /* Row adjustments for compact layout */
    .container-fluid.mt-3.mb-3 .row {
      margin: 0;
      --bs-gutter-x: 0;
    }
    
    .container-fluid.mt-3.mb-3 .col-md-auto,
    .container-fluid.mt-3.mb-3 .col {
      padding: 0.25rem 0;
      --bs-gutter-x: 0;
    }
    
    /* Keywords row optimization */
    .row.mt-2 {
      margin-top: 0.5rem !important;
    }
    
    .input-group-sm .input-group-text + .form-control[style*="height:auto"] {
      min-height: 32px;
      max-height: 60px;
      overflow-y: auto;
      padding: 0.25rem 0.5rem;
    }
    
    /* Keyword badges more compact */
    .keyword-badge {
      padding: 0.15rem 0.4rem !important;
      font-size: 0.75rem !important;
      margin: 0.1rem !important;
      opacity: 1 !important;
    }
    
    /* Ensure badge colors are not overridden */
    .badge.keyword-badge {
      opacity: 1 !important;
    }
    
    /* Integrate title and toolbar visually */
    #app {
      padding-top: 0;
    }
    
    /* Create a unified header section */
    #app > h1 + .container-fluid {
      border-top-left-radius: 0;
      border-top-right-radius: 0;
    }
    
    /* Adjust button toolbar spacing */
    .btn-toolbar {
      gap: 0.5rem;
    }
        
    /* Link count badge in group headers */
    .groupLinkCount {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background-color: #6c757d;
      color: white;
      border-radius: 10px;
      padding: 2px 8px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-left: 8px;
      min-width: 24px;
      height: 20px;
    }
    
    .groupLinkCount.empty {
      background-color: #dee2e6;
      color: #6c757d;
    }
    
    /* Keyword badges */
    .keyword-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25em 0.6em;
      font-size: 0.75rem;
      font-weight: 600;
      border-radius: 0.375rem;
      background-color: #6c757d;
      color: white;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }
    
    .keyword-badge:hover {
      opacity: 0.8;
    }
    
    /* General badge styles */
    .badge {
      display: inline-block;
      padding: 0.35em 0.65em;
      font-size: 0.75em;
      font-weight: 700;
      line-height: 1;
      text-align: center;
      white-space: nowrap;
      vertical-align: baseline;
      border-radius: 0.375rem;
    }
    
    .badge.rounded-pill {
      border-radius: 50rem;
    }
    
    /* Make reset button less prominent */
    .btn-toolbar .btn-danger {
      background-color: #fff;
      color: #dc3545;
      border-color: #dc3545;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      opacity: 0.8;
      transition: all 0.2s ease;
    }
    
    .btn-toolbar .btn-danger:hover {
      background-color: #dc3545;
      color: #fff;
      opacity: 1;
      box-shadow: 0 2px 4px rgba(220, 53, 69, 0.2);
    }
    
    /* Compact add group button */
    .btn-toolbar .btn-success {
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
      background-color: #28a745;
      border-color: #28a745;
      transition: all 0.2s ease;
    }
    
    .btn-toolbar .btn-success:hover {
      background-color: #218838;
      box-shadow: 0 2px 4px rgba(40, 167, 69, 0.2);
    }

    /* Text and Link Styles */
    .text-strikethrough {
      text-decoration: line-through;
    }

    .groupName {
      cursor: move;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      /* font-size removed - now controlled by inline styles */
      margin-bottom: 15px;
      display: flex;
      /* Use flex for alignment */
      align-items: center;
      /* Vertically align items */
    }

    .groupLinkCount {
      display: inline-block;
      /* Background now controlled via inline style from getPillStyle */
      color: white;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 12px;
      min-width: 24px;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-left: 8px;
      vertical-align: middle;
      position: relative;
      top: 1px;
      transition: all 0.2s ease;
    }
    
    .groupLinkCount:hover {
      transform: scale(1.05);
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
    }
    
    .groupLinkCount.empty {
      /* Default for empty pills comes from getPillStyle; keep class for semantics */
    }

    .linkText {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 1em;
      display: flex;
      /* Use flex for alignment */
      align-items: center;
      /* Vertically align items */
      flex: 1;
      min-width: 0;
      position: relative;
    }
    
    /* URL preview on hover */
    .link-url-preview {
      display: none;
      color: #6b7280;
      font-size: 0.85em;
      white-space: nowrap;
      max-width: clamp(110px, 34%, 260px);
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
      margin-left: 8px;
      margin-right: 0;
      flex: 0 1 clamp(110px, 34%, 260px);
      min-width: 0;
    }
    
    .linkContainerListItem:hover .link-url-preview,
    .linkContainerListItem:focus-within .link-url-preview {
      display: inline-block;
    }

    .linkContainerListItem:hover .linkText .text-truncate,
    .linkContainerListItem:focus-within .linkText .text-truncate {
      min-width: 0;
      flex: 0 1 auto;
      width: fit-content;
      max-width: 100%;
    }
    
    .linkText > span:first-child {
      display: inline-block;
      width: fit-content;
      max-width: 100%;
    }
    
    /* Allow badges to wrap if needed but keep inline when possible */
    .linkText .badge.keyword-badge {
      white-space: nowrap;
      flex-shrink: 0;
    }

    .mb-keyword-add-badge {
      width: 1.3rem;
      height: 1.3rem;
      min-width: 1.3rem;
      aspect-ratio: 1 / 1;
      border-radius: 999px !important;
      padding: 0 !important;
      display: inline-flex !important;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.9rem;
      line-height: 1;
      flex-shrink: 0;
      cursor: pointer;
      color: #fff;
      background: #198754;
      border: 1px solid rgba(0, 0, 0, 0.08);
      user-select: none;
      transition: transform 0.15s ease, filter 0.15s ease;
    }

    .mb-keyword-add-badge:hover,
    .mb-keyword-add-badge:focus {
      transform: scale(1.05);
      filter: brightness(0.95);
      outline: none;
    }

    .linkTextCategory {
      font-weight: bold;
      font-style: italic;
      /* Differentiate categories */
      color: var(--text-secondary);
    }

    .linkTextGrip {
      cursor: grab;
      width: 12px;
      /* Slightly wider */
      height: 20px;
      padding: 0px;
      margin: 0px 5px 0px -5px;
      /* Adjust spacing */
      color: #bbb;
      /* Make grip subtle */
    }

    .qrCodeUrl {
      font-size: 1.5em;
      /* Adjusted for better readability */
      word-wrap: break-word;
      /* Allow long URLs to wrap */
    }

    /* Buttons and Icons */
    .svg-button {
      cursor: pointer;
      vertical-align: middle;
      /* Align icons nicely */
    }
    
    /* Make action button icons properly sized */
    .groupActions .svg-button.actionIcon {
      width: 18px !important;
      height: 18px !important;
      margin: 0;
    }
    
    .groupActions .svg-button.actionIconLink {
      width: 16px !important;
      height: 16px !important;
      margin: 0;
    }
    
    /* Elegant Tool Buttons Styling */
    .btn-group-sm .btn-outline-secondary {
      border-color: #dee2e6;
      background-color: #ffffff;
      color: #6c757d;
      transition: all 0.2s ease-in-out;
      position: relative;
      overflow: hidden;
      border-radius: 6px;
      padding: 0.25rem 0.5rem;  /* Standard btn-sm padding für einheitliche Größe */
    }
    
    /* Fix border-radius for buttons inside button groups */
    .btn-group > .btn:not(:first-child),
    .btn-group > .btn-group:not(:first-child) {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }
    
    .btn-group > .btn:not(:last-child):not(.dropdown-toggle),
    .btn-group > .btn-group:not(:last-child) > .btn {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
    
    /* Ensure middle buttons have no radius */
    .btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) {
      border-radius: 0;
    }
    
    .btn-group-sm .btn-outline-secondary:hover {
      background-color: #f8f9fa;
      border-color: #adb5bd;
      color: #495057;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
    }
    
    .btn-group-sm .btn-outline-secondary:active {
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    
    .btn-group-sm .btn-outline-secondary svg {
      transition: transform 0.2s ease;
    }
    
    .btn-group-sm .btn-outline-secondary:hover svg {
      opacity: 1;
    }
    
    /* Button group styling */
    .btn-group {
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      border-radius: 8px;
    }
    
    .btn-group .btn:first-child {
      border-top-left-radius: 8px !important;
      border-bottom-left-radius: 8px !important;
    }
    
    .btn-group .btn:last-child {
      border-top-right-radius: 8px !important;
      border-bottom-right-radius: 8px !important;
    }
    
    .btn-group .btn:not(:first-child) {
      margin-left: -1px;
    }
    
    /* Dropdown button special styling */
    .btn-group .dropdown-toggle {
      border-left: 1px solid #dee2e6;
    }
    
    .btn-group .dropdown-toggle::after {
      transition: transform 0.2s ease;
    }
    
    .btn-group .dropdown-toggle[aria-expanded="true"]::after {
      transform: rotate(180deg);
    }
    
    /* Focus state for accessibility */
    .btn-group-sm .btn-outline-secondary:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.1);
    }
    
    /* Separator between button groups */
    .btn-group + .btn-group {
      margin-left: 0.5rem;
    }
    
    /* Undo/Redo special styling - same size as other buttons */
    .btn-group-sm .btn-outline-secondary[title*="undo"],
    .btn-group-sm .btn-outline-secondary[title*="redo"],
    .btn-group-sm .btn-outline-secondary[title*="Undo"],
    .btn-group-sm .btn-outline-secondary[title*="Redo"] {
      font-size: 0.875rem;  /* Standard btn-sm font-size statt 1.1rem */
      padding: 0.25rem 0.5rem;
      line-height: 1.5;
    }
    
    /* Smooth icon rotation for expand/collapse buttons */
    .btn-group-sm .btn-outline-secondary svg[viewBox="0 0 16 16"] {
      transition: transform 0.3s ease;
    }
    
    /* Tooltip-like effect on hover (optional) */
    .btn-group-sm .btn-outline-secondary {
      position: relative;
    }
    
    .btn-group-sm .btn-outline-secondary:hover::before {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.25rem 0.5rem;
      background-color: #333;
      color: white;
      font-size: 0.75rem;
      border-radius: 4px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      margin-bottom: 5px;
      z-index: 1000;
    }
    
    /* Disable tooltip for buttons with native tooltips */
    .btn-group-sm .btn-outline-secondary[data-bs-toggle]:hover::before {
      display: none;
    }
    
    /* Search input group styling to match tool buttons */
    .input-group-sm .btn-outline-secondary {
      border-color: #dee2e6;
      background-color: #ffffff;
      color: #6c757d;
      transition: all 0.2s ease-in-out;
      position: relative;
      overflow: hidden;
      padding: 0.25rem 0.5rem !important;  /* Standard btn-sm padding für einheitliche Größe */
      font-size: 0.875rem !important;      /* Standard btn-sm font-size */
      line-height: 1.5 !important;
    }
    
    .input-group-sm .btn-outline-secondary:hover {
      background-color: #f8f9fa;
      border-color: #adb5bd;
      color: #495057;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
    }
    
    .input-group-sm .btn-outline-secondary:active {
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    
    .input-group-sm .btn-outline-secondary svg {
      transition: transform 0.2s ease;
    }
    
    .input-group-sm .btn-outline-secondary:hover svg {
      transform: scale(1.1);
    }
    
    /* Search input group special styling */
    .input-group-sm {
      box-shadow: none;
      border-radius: 6px;
    }
    
    .input-group-sm:focus-within {
      box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.08);
      border-color: #adb5bd;
    }
    
    .input-group-sm .input-group-text {
      background-color: #f8f9fa;
      border-color: #dee2e6;
      color: #6c757d;
      font-weight: 500;
      padding: 0.25rem 0.5rem;  /* Standard btn-sm padding für einheitliche Größe */
      font-size: 0.875rem;
      line-height: 1.5;
    }

    .input-group-sm .form-control {
      border-color: #dee2e6;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      padding: 0.25rem 0.5rem;  /* Standard btn-sm padding für einheitliche Größe */
      font-size: 0.875rem;
      height: calc(1.5em + 0.5rem + 2px);  /* Angepasst an das neue Padding */
      line-height: 1.5;
    }
    
    /* Ensure search buttons match the height */
    .input-group-sm .btn {
      padding: 0.25rem 0.5rem;  /* Standard btn-sm padding für einheitliche Größe */
      font-size: 0.875rem;
      height: calc(1.5em + 0.5rem + 2px);  /* Angepasst an das neue Padding */
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1.5;
    }
    
    .input-group-sm .form-control:focus {
      border-color: #adb5bd;
      box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.1);
    }
    
    /* Clear button special effect */
    .input-group-sm .btn-outline-secondary[title*="Clear"],
    .input-group-sm .btn-outline-secondary[title*="clear"] {
      border-radius: 0;
    }
    
    .input-group-sm .btn-outline-secondary[title*="Clear"]:hover svg,
    .input-group-sm .btn-outline-secondary[title*="clear"]:hover svg {
      transform: rotate(90deg) scale(1.1);
    }
    
    /* Save search button special effect */
    .input-group-sm .btn-outline-secondary[title*="save"],
    .input-group-sm .btn-outline-secondary[title*="Save"] {
      border-radius: 0;
    }
    
    /* Delete button in search group */
    .input-group-sm .btn-outline-danger {
      border-color: #dc3545;
      color: #dc3545;
      background-color: #ffffff;
      transition: all 0.2s ease-in-out;
    }
    
    .input-group-sm .btn-outline-danger:hover {
      background-color: #dc3545;
      color: #ffffff;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(220, 53, 69, 0.2);
    }
    
    .input-group-sm .btn-outline-danger:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      transform: none;
    }
    
    /* Select dropdown in search group */
    .input-group-sm .form-select {
      border-color: #dee2e6;
      transition: border-color 0.2s ease;
      cursor: pointer;
      padding: 0.25rem 0.5rem;  /* Standard btn-sm padding für einheitliche Größe */
      font-size: 0.875rem;
      height: calc(1.5em + 0.5rem + 2px);  /* Angepasst an das neue Padding */
      line-height: 1.5;
    }

    .input-group-sm .form-select:hover {
      border-color: #adb5bd;
    }

    .input-group-sm .form-select:focus {
      border-color: #adb5bd;
      box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.1);
    }

    /* Ensure all dropdown toggles have consistent size */
    .btn-group-sm .dropdown-toggle {
      padding: 0.25rem 0.5rem !important;  /* Standard btn-sm padding */
      font-size: 0.875rem !important;
      line-height: 1.5 !important;
      height: calc(1.5em + 0.5rem + 2px) !important;  /* Explizite Höhe für Konsistenz */
    }

    /* Make the app take full height and prevent body scrolling */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;  /* Prevent body scrolling */
    }

    #app {
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;  /* Prevent app scrolling */
    }

    /* Ensure main app container uses flexbox properly */
    #app.container-fluid {
      max-width: 100%;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .actionAdd {
      width: 28px;
      height: 28px;
      color: #10b981;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      filter: drop-shadow(0 2px 4px rgba(16, 185, 129, 0.15));
    }
    
    .actionAdd:hover {
      transform: rotate(90deg) scale(1.1);
      color: #059669;
      filter: drop-shadow(0 4px 8px rgba(16, 185, 129, 0.25));
    }

    .actionIcon {
      width: 18px;
      height: 18px;
      padding: 0;
      margin: 0 2px;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      border-radius: 6px;
      transition: all 0.2s ease;
      opacity: 0.7;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-sizing: content-box;
    }
    
    .groupContainer:hover .actionIcon {
      opacity: 1;
      background: transparent;
      color: var(--text-primary);
    }
    
    .actionIcon:hover {
      color: var(--link-color);
      background: var(--bg-secondary);
      opacity: 1;
      transform: scale(1.1);
    }
    
    .actionIcon:active {
      transform: scale(0.95);
      opacity: 0.8;
    }

    .actionIconLink {
      width: 16px;
      height: 16px;
      padding: 0;
      margin: 0 1px;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      border-radius: 4px;
      transition: all 0.15s ease;
      opacity: 0.7;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-sizing: content-box;
    }
    
    .linkContainerListItem:hover .actionIconLink {
      opacity: 1;
      background: transparent;
      color: var(--text-primary);
    }
    
    .actionIconLink:hover {
      color: var(--link-color);
      background: var(--bg-secondary);
      opacity: 1;
      transform: scale(1.1);
    }
    
    .actionIconLink:active {
      transform: scale(0.92);
      opacity: 0.8;
    }

    .collapseIcon {
      cursor: pointer;
      color: #999;
      transition: transform 0.3s ease;
    }
    
    /* Rotate icon when collapsed - for settings dialog */
    .modal .collapsed .collapseIcon {
      transform: rotate(-90deg);
    }

    /* Layout and Containers */
    .groupsTable {
      width: 100%;
      table-layout: fixed;
      border-spacing: 0 10px;
      padding: 0px 8px 50px 8px;
      /* Add vertical space between groups */
      min-height: 100%;  /* Ensure table takes at least full height */
    }

    .groupCell {
      vertical-align: top;
      padding-right: 0; /* Remove padding - spacing handled by vertical dropzones */
      transition: box-shadow 0.15s ease;
    }

    .groupCell.group-cell--resizing {
      box-shadow: inset 0 0 0 2px rgba(13, 110, 253, 0.2);
    }

    .groupCell:last-child {
      padding-right: 0;
    }

    .linkCell {
      vertical-align: top;
      padding: 0;
      margin: 0;
    }

    .linksList {
      list-style: none;
      /* Ensure no list bullets */
      padding: 0px;
      margin: 0px;
    }

    .linksTable {
      width: 100%;
      table-layout: fixed;
    }
    
    /* Link colors - manual or default */
    .groupContainer .linkText a {
      transition: all 0.2s ease;
      text-decoration: none;
      position: relative;
    }
    
    .groupContainer .linkText a:hover {
      text-decoration: underline;
      text-underline-offset: 2px;
      text-decoration-thickness: 1px;
      opacity: 0.8;
    }

    .groupContainer {
      border: none;
      border-radius: 16px;
      margin-bottom: 0;
      /* removed - spacing handled by dropzones */
      padding: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 
        0 0.5px 2px rgba(0, 0, 0, 0.05),
        0 2px 8px rgba(0, 0, 0, 0.08),
        0 10px 20px -5px rgba(0, 0, 0, 0.1);
      transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
      position: relative;
      transform-style: preserve-3d;
    }
    
    .groupContainer::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 16px;
      padding: 1px;
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.2) 0%, 
        rgba(255, 255, 255, 0) 100%);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask-composite: exclude;
      pointer-events: none;
    }

    .groupContainer:hover {
      box-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.05),
        0 4px 12px rgba(0, 0, 0, 0.1),
        0 20px 40px -10px rgba(0, 0, 0, 0.15);
    }

    .groupContainerHeader {
      padding: 16px 8px 16px 12px;
      margin: 0;
      position: relative;
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.6) 0%, 
        rgba(250, 250, 251, 0.4) 100%);
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      transition: all 0.3s ease;
      z-index: 1;
    }
    
    .groupContainerHeader:hover {
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.8) 0%, 
        rgba(250, 250, 251, 0.6) 100%);
    }
    
    /* Modern integrated group title design */
    .groupContainerHeader .groupTitle {
      /* Font styling removed - now controlled by inline styles from formatting settings */
      /* Inherit font properties from parent h2 element which has the inline styles */
      font-family: inherit;
      font-weight: inherit;
      font-size: inherit;
      color: inherit;
      letter-spacing: inherit;
      transition: all 0.25s ease;
      display: inline-block;
      position: relative;
      padding: 2px 0;
      margin-left: 4px;
    }
    
    /* Hover effect on title - subtle opacity change */
    .groupContainer:hover .groupTitle {
      opacity: 0.9;
    }
    
    /* Integrate collapse icon with title */
    .groupContainerHeader .collapseIcon {
      opacity: 0.75;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      width: 24px;
      height: 24px;
      padding: 2px;
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.02);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    .groupContainerHeader .collapseIcon:hover {
      opacity: 1;
      background: rgba(0, 0, 0, 0.06);
    }
    
    /* Icon animation for collapse state */
    .groupContainer .collapseIcon {
      transform: rotate(0deg);
    }
    
    .groupContainer .collapseIcon path {
      transition: d 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .mb-group__body {
      overflow-y: auto;
      overflow-x: hidden;
      scrollbar-gutter: stable;
    }

    .mb-group__body.collapsing,
    .mb-group__body.collapse:not(.show) {
      overflow: hidden;
    }

    .mb-group-resize-handle {
      height: 10px;
      border-top: 1px solid transparent;
      background: transparent;
      cursor: ns-resize;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transition: background-color 0.15s ease;
    }

    .mb-group-resize-handle::before {
      content: '';
      width: 42px;
      height: 2px;
      border-radius: 2px;
      background: rgba(108, 117, 125, 0.6);
      opacity: 0;
      transition: opacity 0.15s ease, background-color 0.15s ease, box-shadow 0.15s ease;
    }

    .groupContainer:hover .mb-group-resize-handle {
      border-top-color: rgba(0, 0, 0, 0.06);
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.015), rgba(0, 0, 0, 0.035));
    }

    .groupContainer:hover .mb-group-resize-handle::before {
      opacity: 1;
    }

    .mb-group-resize-handle:hover {
      background: rgba(0, 0, 0, 0.08);
    }

    .mb-group-resize-handle:hover::before {
      background: rgba(52, 58, 64, 0.8);
    }

    .mb-group-resize-handle.resizing {
      background: rgba(13, 110, 253, 0.18);
    }

    .mb-group-resize-handle.resizing::before {
      opacity: 1;
    }

    .mb-group--resizing {
      box-shadow:
        0 0 0 2px rgba(13, 110, 253, 0.32),
        0 1px 3px rgba(0, 0, 0, 0.06),
        0 6px 18px rgba(0, 0, 0, 0.12);
    }

    .mb-group--resizing .mb-group__body {
      box-shadow: inset 0 0 0 2px rgba(13, 110, 253, 0.2);
    }

    .mb-group-resize-readout {
      position: absolute;
      right: 10px;
      top: -28px;
      background: rgba(13, 110, 253, 0.94);
      color: #fff;
      font-size: 0.72rem;
      line-height: 1;
      font-weight: 700;
      border-radius: 10px;
      padding: 4px 8px;
      letter-spacing: 0.01em;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(13, 110, 253, 0.35);
      white-space: nowrap;
      z-index: 3;
    }

    body.mb-group-resizing,
    body.mb-group-resizing * {
      cursor: ns-resize !important;
      user-select: none !important;
    }

    body.mb-group-column-resizing,
    body.mb-group-column-resizing * {
      cursor: ew-resize !important;
      user-select: none !important;
    }


    .linkContainerListItem {
      padding: 2px 8px;
      margin: 0;
      /* no margin - spacing handled by dropzones */
      border: 0;
      border-bottom: none;
      transition: all 0.2s ease;
      position: relative;
      background: transparent;
      display: flex;
      align-items: center;
      gap: 8px;
      min-height: 24px;
      width: 100%;
      container-type: inline-size;
    }
    
    .linkContainerListItem:hover {
      background: rgba(0, 0, 0, 0.015);
    }
    
    /* Subtle accent indicator */
    .linkContainerListItem::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 2px;
      height: 0;
      background: var(--group-accent-color, #6c757d);
      transition: height 0.2s ease;
      border-radius: 1px;
    }
    
    .linkContainerListItem:hover::before {
      height: 60%;
    }

    .mb-link-separator-row {
      cursor: default;
    }

    .mb-link-separator-row::before {
      display: none;
    }

    .mb-link-note-row {
      align-items: flex-start;
      padding-top: 6px;
      padding-bottom: 6px;
    }

    .mb-link-note-row .mb-link__actions {
      align-self: flex-start;
      margin-top: 2px;
    }

    .mb-link-separator {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #6c757d;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      user-select: none;
    }

    .mb-link-separator::before,
    .mb-link-separator::after {
      content: '';
      height: 1px;
      background: rgba(108, 117, 125, 0.35);
      flex: 1 1 auto;
      min-width: 12px;
    }

    .mb-link-separator__label {
      white-space: nowrap;
      max-width: 65%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .mb-link-note {
      width: 100%;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
      white-space: normal;
    }

    .mb-link-note__header {
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 0;
      width: 100%;
    }

    .mb-link-note__toggle {
      border: 0;
      background: transparent;
      color: #6c757d;
      padding: 0;
      margin: 0;
      cursor: pointer;
      line-height: 1;
      flex: 0 0 auto;
      width: 24px;
      height: 24px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .mb-link-note__toggle:hover {
      color: #334155;
    }

    .mb-link-note__chevron {
      display: block;
      width: 100%;
      line-height: 1;
      font-size: 1.6rem;
      text-align: center;
      user-select: none;
    }

    .mb-link-note__title {
      min-width: 0;
      flex: 1 1 auto;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: 600;
    }

    .mb-link-note__body {
      margin-left: 30px;
      font-size: 0.85rem;
      line-height: 1.35;
      color: #475569;
      word-break: break-word;
      white-space: normal;
    }

    .mb-link-note__body p {
      margin: 0;
    }

    /* Make headers and link rows easy drag targets */
    .groupContainerHeader {
      cursor: grab;
    }

    .linkContainerListItem {
      cursor: grab;
    }
    
    .linkContainerListItem a {
      color: #334155;
      text-decoration: none;
      transition: all 0.2s ease;
      font-size: 0.875rem;
      font-weight: 450;
      letter-spacing: -0.01em;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .linkContainerListItem:hover a {
      color: var(--group-text-hover-color, var(--group-accent-color, #2563eb));
    }
    
    .linkContainerListItem .link-favicon {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      flex-shrink: 0;
      filter: saturate(0.9);
      transition: all 0.2s ease;
    }
    
    .linkText {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      display: flex;
      align-items: center;
    }

    .linkanchor {
      min-width: 0;
    }
    
    .linkText .text-truncate {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      display: inline-block;
      width: fit-content;
      max-width: 100%;
      min-width: 0;
      flex: 0 1 auto;
    }

    .mb-link-text-with-marker {
      display: inline;
    }

    .mb-ref-marker {
      font-size: 0.75em;
      line-height: 1;
      vertical-align: super;
      margin-left: 0.02rem;
      opacity: 0.55;
      font-weight: 700;
      user-select: none;
    }

    .linkText .mb-link__badges {
      flex-shrink: 0;
      max-width: 45%;
      min-width: 0;
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
    }

    .linkText .mb-link__badge-list {
      display: inline-block;
      flex: 1 1 auto;
      min-width: 0;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    @container (max-width: 420px) {
      .linkText .mb-link__badges {
        max-width: 55%;
      }
    }

    @container (max-width: 340px) {
      .linkText .mb-link__badges {
        max-width: 40%;
      }
    }
    
    .linkContainerListItem:hover .link-favicon {
      filter: saturate(1.2);
    }

    /* Hide tiny drag handle icons */
    .groupDragHandle,
    .linkTextGrip {
      display: none !important;
    }

    .linkContainerListItem:last-child {
      border-bottom: none;
    }

    /* Vertical spacing and separators between link columns */
    .linksTable {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0px 0;
      /* horizontal gap between columns */
    }

    .linksTable td.linkCell {
      vertical-align: top;
      padding: 0px;
    }

    .linksTable td.linkVerticalDropZone {
      vertical-align: top;
      padding: 0;
    }

    .linksTable td:first-child {
      border-left: 0;
    }

    .linkContainer {
      padding: 0;
      border: 0px solid #ccc;
    }

    /* Conflict Resolution Indicators */
    .conflict-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #fbbf24;
      margin-left: 4px;
      animation: pulse 2s infinite;
      cursor: help;
      vertical-align: middle;
    }
    
    .conflict-resolved {
      background-color: #10b981;
      animation: none;
    }
    
    @keyframes pulse {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.1); }
      100% { opacity: 1; transform: scale(1); }
    }
    
    .conflict-notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 12px 16px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 9999;
      max-width: 300px;
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    .conflict-notification-title {
      font-weight: 600;
      margin-bottom: 4px;
      color: #111827;
    }
    
    .conflict-notification-text {
      font-size: 0.875rem;
      color: #6b7280;
    }
    
    .addLinkContainer {
      padding: 16px 20px;
      background: linear-gradient(135deg, 
        rgba(250, 250, 251, 0.6) 0%, 
        rgba(255, 255, 255, 0.9) 100%);
      border-top: 1px solid rgba(0, 0, 0, 0.03);
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      position: relative;
    }
    
    .addLinkContainer::before {
      content: '';
      position: absolute;
      top: 0;
      left: 20px;
      right: 20px;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent 0%, 
        var(--group-accent-color, #cbd5e1) 50%, 
        transparent 100%);
      opacity: 0.3;
    }
    
    .addLinkContainer:hover {
      background: linear-gradient(135deg, 
        rgba(250, 250, 251, 0.8) 0%, 
        rgba(255, 255, 255, 1) 100%);
    }
    
    .addLinkContainer .form-control {
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      font-size: 0.875rem;
      border-radius: 10px;
      padding: 8px 12px;
    }
    
    .addLinkContainer .form-control:focus {
      border-color: var(--group-accent-color, #3b82f6);
      background: rgba(255, 255, 255, 1);
      box-shadow: 
        0 0 0 3px color-mix(in srgb, var(--group-accent-color, #3b82f6) 15%, transparent),
        0 1px 2px rgba(0, 0, 0, 0.05);
    }
    
    .addLinkContainer .btn-primary {
      background: linear-gradient(135deg, 
        var(--group-accent-color, #3b82f6) 0%, 
        color-mix(in srgb, var(--group-accent-color, #3b82f6) 85%, #000) 100%);
      border: none;
      padding: 8px 16px;
      font-size: 0.875rem;
      font-weight: 600;
      border-radius: 10px;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      box-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.1),
        0 4px 6px -2px color-mix(in srgb, var(--group-accent-color, #3b82f6) 30%, transparent);
      position: relative;
      overflow: hidden;
    }
    
    .addLinkContainer .btn-primary::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.3) 50%, 
        transparent 100%);
      transition: left 0.5s ease;
    }
    
    .addLinkContainer .btn-primary:hover {
      box-shadow: 
        0 4px 8px rgba(0, 0, 0, 0.15),
        0 8px 16px -4px color-mix(in srgb, var(--group-accent-color, #3b82f6) 40%, transparent);
    }
    
    .addLinkContainer .btn-primary:hover::before {
      left: 100%;
    }
    
    .addLinkContainer .btn-primary:active {
      box-shadow:
        0 1px 3px rgba(0, 0, 0, 0.1),
        0 2px 4px -2px color-mix(in srgb, var(--group-accent-color, #3b82f6) 30%, transparent);
    }

    /* Vertical drop zones between columns - acts as permanent spacing */
    .verticalDropZone {
      width: 10px !important;
      min-width: 10px !important;
      max-width: 10px !important;
      padding: 0 !important;
      margin: 0 !important;
      border: 0 !important;
      background: transparent;
      position: relative;
      vertical-align: top;
      pointer-events: none;
      transition: all 0.2s ease;
      height: 100%;
    }

    .verticalDropZoneIndicator {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 0px;
      background: transparent;
      transition: all 0.2s ease;
    }

    .groupColumnResizeHandle {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 10px;
      cursor: ew-resize;
      pointer-events: auto;
      z-index: 3;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      transition: background-color 0.15s ease;
    }

    .groupColumnResizeHandle::before {
      content: '';
      width: 2px;
      height: 70%;
      border-radius: 2px;
      background: rgba(108, 117, 125, 0.28);
      opacity: 0;
      transition: opacity 0.15s ease, background-color 0.15s ease, box-shadow 0.15s ease;
    }

    .groupColumnResizeHandle:hover::before {
      opacity: 1;
      background: rgba(13, 110, 253, 0.75);
      box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.16);
    }

    .groupColumnResizeHandle.resizing::before {
      opacity: 1;
      background: rgba(13, 110, 253, 0.9);
      box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.22);
    }

    .groupColumnResizeReadout {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(13, 110, 253, 0.94);
      color: #fff;
      font-size: 0.7rem;
      line-height: 1;
      font-weight: 700;
      border-radius: 10px;
      padding: 4px 8px;
      letter-spacing: 0.01em;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(13, 110, 253, 0.35);
      white-space: nowrap;
      z-index: 4;
    }

    /* Active state when dragging groups */
    #app.dragging-group .verticalDropZone {
      pointer-events: auto;
    }

    #app.dragging-group .groupColumnResizeHandle {
      pointer-events: none;
      opacity: 0;
    }

    /* Expanded hit area for easier dropping */
    #app.dragging-group .verticalDropZone::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: -15px;
      right: -15px;
      background: transparent;
      pointer-events: auto;
      z-index: 1;
    }

    #app.dragging-group .verticalDropZone.drag-over-active .verticalDropZoneIndicator {
      width: 10px;
      background: linear-gradient(to right,
        transparent 0%,
        rgba(51, 153, 255, 0.25) 20%,
        rgba(51, 153, 255, 0.25) 80%,
        transparent 100%);
      box-shadow:
        inset 2px 0 0 #3399ff,
        inset -2px 0 0 #3399ff;
    }

    /* Vertical dropzones for link columns */
    .linkVerticalDropZone {
      position: relative;
      width: 6px;
      min-width: 6px;
      padding: 0;
      vertical-align: top;
      pointer-events: none;
      min-height: 50px;
    }

    .linkVerticalDropZoneIndicator {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      background: transparent;
      transition: all 0.2s ease;
      pointer-events: none;
    }

    #app.dragging-link .linkVerticalDropZone {
      pointer-events: auto;
    }

    /* Expanded hit area for easier dropping */
    #app.dragging-link .linkVerticalDropZone::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: -10px;
      right: -10px;
      background: transparent;
      pointer-events: auto;
      z-index: 1;
    }

    #app.dragging-link .linkVerticalDropZone.drag-over-active .linkVerticalDropZoneIndicator {
      width: 100%;
      background: linear-gradient(to right,
        transparent 0%,
        rgba(0, 204, 153, 0.25) 20%,
        rgba(0, 204, 153, 0.25) 80%,
        transparent 100%);
      box-shadow:
        inset 1px 0 0 #00cc99,
        inset -1px 0 0 #00cc99;
    }

    /* Drag and Drop Styles: permanent spacers that replace normal margins */
    .group-drop-zone,
    .linkContainerDragAndDrop {
      display: block !important;
      /* always visible as spacer */
      padding: 0 !important;
      margin: 0 !important;
      border: 0 !important;
      background: transparent;
      color: transparent;
      /* hide any text */
      line-height: 0 !important;
      font-size: 0 !important;
      pointer-events: none;
      /* only active during drag */
      position: relative;
      transition: background 0.15s ease, box-shadow 0.15s ease;
      overflow: hidden;
      box-sizing: border-box !important;
    }

    /* Drop zones act as normal spacing between elements */
    .groupContainerDragAndDrop,
    .group-drop-zone {
      height: 10px !important;
      min-height: 10px !important;
      max-height: 10px !important;
      /* fixed spacing between groups - matches vertical dropzone width */
    }
    
    .linkContainerDragAndDrop,
    .link-drop-zone {
      height: 6px !important;
      min-height: 6px !important;
      max-height: 6px !important;
      /* fixed spacing between links */
    }
    
    /* Enable pointer events only when dragging */
    #app.dragging-group .group-drop-zone,
    #app.dragging-group .groupContainerDragAndDrop,
    #app.dragging-link .linkContainerDragAndDrop {
      pointer-events: auto;
    }

    /* Visual feedback only when actively dragging over the zone - no height change */
    #app.dragging-group .groupContainerDragAndDrop.drag-over-active,
    #app.dragging-group .group-drop-zone.drag-over-active {
      background: linear-gradient(to bottom, 
        transparent, 
        rgba(51, 153, 255, 0.25) 30%, 
        rgba(51, 153, 255, 0.25) 70%, 
        transparent);
      box-shadow: 
        inset 0 2px 0 #3399ff,
        inset 0 -2px 0 #3399ff;
    }

    /* Visual feedback for link drop zones when dragging over - no height change */
    #app.dragging-link .linkContainerDragAndDrop.drag-over-active {
      background: linear-gradient(to bottom, 
        transparent, 
        rgba(0, 204, 153, 0.25) 30%, 
        rgba(0, 204, 153, 0.25) 70%, 
        transparent);
      box-shadow: 
        inset 0 1px 0 #00cc99,
        inset 0 -1px 0 #00cc99;
    }

    /* Expanded hit area for easier dropping - only active when dragging */
    #app.dragging-group .group-drop-zone::before,
    #app.dragging-link .linkContainerDragAndDrop::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: -10px;
      height: calc(100% + 20px);
      /* use height instead of bottom to avoid layout issues */
      background: transparent;
      pointer-events: auto;
      z-index: 2;
    }

    /* Deprecated - these classes are no longer used */

    /* Removed - handled by main dropzone styles above */

    /* .isDragged class deprecated - dropzones are permanent spacers now */

    .drag-over-active {
      border-color: #0288d1 !important;
    }

    /* Deprecated isDragged classes */

    /* Optional: Klasse für die Zone, über der *aktiv* geschwebt wird
    (kannst du behalten oder entfernen, je nachdem, ob du eine zusätzliche Hervorhebung willst) */
    .drag-over-active {
      border-color: #0288d1 !important;
      background-color: transparent;
    }

    /* Remove redundant styles - handled above */

    .group-drag-el {
      /* Style for the item being dragged (optional) */
      opacity: 0.7;
      background-color: #fff3cd;
    }

    .grabbing * {
      cursor: grabbing !important;
    }

    .grabbing {
      cursor: grabbing !important;
    }

    /* Keyword cloud */
    .keyword-badge {
      cursor: pointer;
      user-select: none;
    }

    .mb-keyword-active {
      outline: 2px solid rgba(13, 110, 253, 0.45);
      outline-offset: 1px;
      box-shadow: 0 0 0 1px rgba(13, 110, 253, 0.25) inset;
      opacity: 1 !important;
    }

    .mb-keyword-label {
      gap: 0.35rem;
    }

    .mb-keyword-manage-btn {
      line-height: 1;
      font-size: 0.75rem;
      padding: 0.15rem 0.35rem;
    }

    .mb-keyword-manager-list .list-group-item {
      cursor: pointer;
      user-select: none;
    }

    #keywordManagerModal .mb-keyword-manager-body {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      overflow: hidden;
    }

    #keywordManagerModal .mb-keyword-manager-list {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      margin-bottom: 0 !important;
    }

    #keywordManagerModal .mb-keyword-manager-empty {
      flex: 1 1 auto;
      overflow-y: auto;
    }

    #keywordManagerModal .mb-keyword-manager-editor {
      position: sticky;
      bottom: 0;
      background: var(--bg-secondary, #fff);
      border-top: 1px solid var(--border-color, #dee2e6);
      padding-top: 0.5rem;
      z-index: 1;
    }

    #shortcutManagerModal .mb-shortcut-manager-body {
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      max-height: 70vh;
      overflow-y: auto;
    }

    #shortcutManagerModal .mb-shortcut-manager-section {
      border: 1px solid var(--border-color, #dee2e6);
      border-radius: 0.5rem;
      padding: 0.65rem;
      background: var(--bg-secondary, #fff);
    }

    #shortcutManagerModal .mb-shortcut-manager-section-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    #shortcutManagerModal .mb-shortcut-defined-list {
      max-height: 260px;
      overflow-y: auto;
    }

    #shortcutManagerModal .mb-shortcut-defined-combo {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.82rem;
      letter-spacing: 0.01em;
    }

    #shortcutManagerModal .mb-shortcut-global-card {
      border: 1px solid var(--border-color, #dee2e6);
      border-radius: 0.4rem;
      padding: 0.55rem;
      margin-bottom: 0.6rem;
    }

    #shortcutManagerModal .mb-shortcut-target-tree {
      border: 1px solid var(--border-color, #dee2e6);
      border-radius: 0.45rem;
      padding: 0.5rem;
      max-height: 300px;
      overflow-y: auto;
      background: var(--bg-surface, #fff);
    }

    #shortcutManagerModal .mb-shortcut-target-group {
      border-top: 1px solid var(--border-color, #e9ecef);
      padding-top: 0.45rem;
      margin-top: 0.45rem;
    }

    #shortcutManagerModal .mb-shortcut-target-group:first-child {
      border-top: none;
      padding-top: 0;
      margin-top: 0;
    }

    #shortcutManagerModal .mb-shortcut-target-link-url {
      max-width: 680px;
    }

    /* Keep keyword bar height aligned with left "Manage" label cell */
    .mb-keywords-cloud .input-group {
      align-items: stretch;
    }

    .mb-keywords-cloud .keyword-container {
      padding: 0 0.35rem !important;
      height: auto !important;
      min-height: calc(1.5em + 0.5rem + 2px);
      align-self: stretch;
      display: flex;
      align-items: center;
      overflow-x: auto;
      overflow-y: hidden;
    }

    .mb-keywords-cloud .mb-keyword-row {
      flex-wrap: nowrap !important;
      width: max-content;
    }

    .mb-keywords-cloud .mb-keyword-row .keyword-badge {
      margin-bottom: 0 !important;
    }

    /* Keywords container badges alignment */
    .form-control .keyword-badge {
      position: relative;
      top: 2px;
    }

    /* Ensure badges are visible even without bootstrap color helpers */
    .groupName .keyword-badge,
    h2 .keyword-badge {
      border: 1px solid rgba(0, 0, 0, 0.08);
      font-size: 0.65rem;
      line-height: 0.95rem;
      padding: 0.1rem 0.35rem;
      vertical-align: middle;
      position: relative;
      top: 1px;
    }

    .link-favicon {
      width: 16px;
      height: 16px;
      margin-right: 2px;
      vertical-align: -2px;
      border-radius: 3px;
      /* Ensure base64 favicons display correctly */
      object-fit: contain;
      background-color: transparent;
    }

    .link-favicon-wrap {
      position: relative;
      display: inline-block;
      vertical-align: -2px;
      margin-right: 2px;
    }
    .link-favicon-wrap .link-favicon { margin-right: 0; }
    .link-favicon-dot {
      position: absolute;
      top: 0;
      right: 0;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      border: 1px solid #fff;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.08);
      z-index: 2;
    }
    .link-favicon-dot.src-rule { background-color: #0d6efd; }
    .link-favicon-dot.src-upload { background-color: #6f42c1; }
    .link-favicon-dot.src-extension { background-color: #6c757d; }

    .link-favicon-error {
      display: inline-block;
      width: 16px;
      height: 16px;
      margin-right: 2px;
      vertical-align: -2px;
      font-size: 14px;
      line-height: 16px;
      text-align: center;
      opacity: 0.6;
      cursor: help;
    }

    .mb-group-favicon-wrap {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      margin-right: 6px;
    }

    .mb-group-favicon {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      object-fit: contain;
      background-color: #fff;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.12);
    }

    .mb-group-favicon-placeholder {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px dashed #c8cdd5;
      background: linear-gradient(135deg, #f8f9fa 0%, #f1f3f5 100%);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      color: #adb5bd;
    }

    .mb-group-emoji {
      font-size: 1.1rem;
      line-height: 1;
      margin-right: 6px;
    }

    /* Actions and Visibility */
    .groupActions {
      display: inline-flex;
      align-items: center;
      justify-content: flex-end;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      margin-left: auto;
      pointer-events: all; /* Ensure mouse events work even when invisible */
    }
    
    .groupActions:hover {
      opacity: 1;
    }
    
    .groupActionsVisibleOnMouseOver {
      opacity: 1 !important;
    }
    
    /* Link action container should not reserve width while hidden */
    .linkContainerListItem .groupActions {
      display: none !important;
      margin-left: 0;
    }

    .linkContainerListItem:hover .groupActions,
    .linkContainerListItem:focus-within .groupActions,
    .linkContainerListItem .groupActions.groupActionsVisibleOnMouseOver {
      display: flex !important;
      margin-left: auto;
      opacity: 1;
    }
    
    /* Show group actions when hovering over the group header */
    .groupContainer .card-header:hover .groupActions {
      opacity: 1;
    }

    /* Dark Mode Toggle Button */
    .dark-mode-toggle {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      padding: 5px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.875rem;
      color: var(--text-primary);
      transition: all 0.3s ease;
    }
    
    .dark-mode-toggle:hover {
      background: var(--bg-primary);
      border-color: var(--border-light);
      box-shadow: 0 2px 4px var(--shadow-sm);
    }
    
    .dark-mode-toggle .icon {
      font-size: 1rem;
      transition: transform 0.3s ease;
    }
    
    .dark-mode-toggle:hover .icon {
      transform: rotate(20deg);
    }
    
    /* Options Modal */
    .optionsGroupRow {
      padding: 0;
      margin-top: 15px;
    }

    .optionsGroupSettingContainer {
      margin-bottom: 15px;
      margin-left: 25px;
      margin-right: 25px;
    }

    .optionsGroupSetting {
      width: 250px;
      white-space: normal;
      word-wrap: break-word;
      /* Consistent width for labels with text wrapping */
    }

    /* Limit width for checkbox settings */
    .optionsGroupSettingContainer .input-group:has(input[type="checkbox"]) {
      width: auto;
      display: inline-flex;
      max-width: 400px;
    }
    
    /* Wider color picker settings for better color visibility */
    .optionsGroupSettingContainer .input-group:has(input[type="color"]) {
      width: auto;
      display: inline-flex;
      max-width: 600px;
    }
    
    .optionsGroupSettingContainer input[type="color"] {
      min-width: 100px;
      width: 100px;
    }
    
    /* Consistent color picker design across all dialogs */
    #groupEditModal input[type="color"] {
      min-width: 100px;
      width: 100px;
      height: 38px;
      padding: 0.25rem;
      border: 1px solid var(--input-border);
      border-radius: 0.25rem;
    }

    /* Visual CSS Editor: normalize heights in color property input-group */
    .visual-css-editor .input-group.input-group-sm .input-group-text {
      display: flex;
      align-items: center;
      height: calc(1.5em + 0.5rem + 2px);
      padding-top: 0.25rem;
      padding-bottom: 0.25rem;
    }
    .visual-css-editor .input-group.input-group-sm .form-control,
    .visual-css-editor .input-group.input-group-sm .form-select {
      height: calc(1.5em + 0.5rem + 2px);
      padding-top: 0.25rem;
      padding-bottom: 0.25rem;
    }
    .visual-css-editor .input-group.input-group-sm .form-control-color {
      width: 2rem;
      height: calc(1.5em + 0.5rem + 2px);
      padding: 0;
      border-radius: 0 !important;
    }

    /* Visual CSS Editor: more compact collapsed rule card */
    .visual-css-editor .css-rule-card.collapsed {
      padding-top: 6px !important;
      padding-bottom: 6px !important;
    }
    .visual-css-editor .css-rule-card.collapsed .rule-header {
      margin-bottom: 0 !important;
    }

    /* Visual CSS Editor: compact Design Tokens when collapsed */
    .visual-css-editor .design-tokens-section.collapsed {
      padding-top: 6px !important;
      padding-bottom: 6px !important;
    }
    .visual-css-editor .design-tokens-section.collapsed .design-tokens-header {
      margin-bottom: 0 !important;
    }
    
    /* Role scope badges for sync settings */
    .role-badge {
      display: inline-block;
      padding: 2px 6px;
      margin-left: 8px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      border-radius: 4px;
      vertical-align: middle;
    }
    
    .role-badge.role-all {
      background-color: #3b82f6;
      color: white;
    }
    
    .role-badge.role-owner {
      background-color: #fbbf24;
      color: #78350f;
    }
    
    .role-badge.role-member {
      background-color: #10b981;
      color: white;
    }
    
    .option-row.role-disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    
    .role-info {
      display: inline-block;
      margin-left: 4px;
      color: #6b7280;
      cursor: help;
    }


    /* Context Menus */
    .context-menu {
      display: none;
      position: absolute;
      background-color: white;
      border: 1px solid #ccc;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 9999;
      min-width: 150px;
      /* Ensure minimum width */
      border-radius: 4px;
    }

    .context-menu ul {
      list-style: none;
      padding: 5px 0;
      /* Padding around list items */
      margin: 0;
    }

    .context-menu ul li {
      padding: 8px 15px;
      /* Increased padding */
      cursor: pointer;
      font-size: 0.9em;
    }

    .context-menu ul li:hover {
      background-color: #f0f0f0;
    }

    .context-menu-visible {
      display: block;
    }
    .context-menu .separator {
      border-top: 1px solid #e5e7eb;
      margin: 4px 0;
      padding: 0;
    }
    .context-menu .submenu { position: relative; }
    .context-menu .submenu::after {
      content: '▸';
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: #9aa0a6;
      pointer-events: none;
    }
    .context-menu .submenu.open-left::after { content: '◂'; }
    .context-menu .submenu > .context-submenu {
      list-style: none;
      margin: 0;
      padding: 5px 0;
      position: absolute;
      left: 100%;
      top: 0;
      min-width: 220px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      display: none;
      z-index: 10000;
    }
    .context-menu .submenu.open-left > .context-submenu {
      left: auto;
      right: 100%;
    }
    .context-menu .submenu:hover > .context-submenu,
    .context-menu .submenu:focus-within > .context-submenu,
    .context-menu .submenu.open > .context-submenu { display: block; }
    .context-menu .context-submenu li { padding: 8px 15px; white-space: nowrap; }
    .context-menu .context-submenu.keyword-submenu {
      max-height: min(60vh, 420px);
      overflow-y: auto;
      overflow-x: hidden;
    }
    .context-menu li.disabled {
      color: #9aa0a6;
      cursor: default;
      pointer-events: none;
      background: transparent !important;
    }

    /* Footer */
    .copyrightBar {
      position: fixed;
      bottom: 0;
      left: 0;
      /* Ensure it spans full width */
      width: 100%;
      background-color: #f8f9fa;
      text-align: center;
      border-top: 1px solid #e7e7e7;
      padding: 8px 0;
      /* Add some padding */
      font-size: 0.85em;
      color: #666;
      z-index: 1010;
      /* Ensure it's above context menus if needed */
      /* Calculate total height: padding (16px) + font-size (~14px) + line-height + border (1px) ≈ 35-40px */
      height: auto;
      min-height: 35px;
    }

    /* QR Code Modal */
    #qrCodeDiv {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 300px;
      /* Ensure space for QR code */
    }

    #qrCodeDiv img {
      max-width: 100%;
      /* Ensure QR code image is responsive */
      height: auto;
    }

    .disabled-arrow {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
      /* Verhindert Klick-Events auf dem SVG selbst */
    }
    
    .cursor-pointer {
      cursor: pointer;
    }

    /* Remove after legacy icons are deleted */

    /* Rounded look across UI */
    .btn,
    .form-control,
    .input-group-text,
    .dropdown-menu,
    .modal-content,
    .context-menu,
    .groupContainer,
    .linkContainer,
    .linksTable td {
      border-radius: 8px;
    }

    .badge {
      border-radius: 999px;
    }

    .groupContainer {
      overflow: hidden;
    }

    .input-group .btn {
      border-radius: 8px;
    }

    .input-group .form-control {
      border-top-left-radius: 8px;
      border-bottom-left-radius: 8px;
    }

    .input-group .input-group-text {
      border-radius: 8px;
    }

    /* Hide legacy inline icons if still present */
    .btn-toolbar>svg.svg-button {
      display: none !important;
    }

    .btn-toolbar>.dropdown.ms-2 {
      display: none !important;
    }
    
    /* Info popup styles */
    .info-popup {
      position: fixed;
      background: white;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 10000;
      max-width: 400px;
      max-height: 300px;
      overflow-y: auto;
      font-size: 0.9rem;
      display: none;
    }
    
    .info-popup.show {
      display: block;
    }

    .info-icon-trigger {
      transition: transform 0.2s ease;
    }

    .info-icon-trigger:hover {
      transform: scale(1.1);
    }

    /* Link detail popover */
    .link-detail-popover {
      position: fixed;
      min-width: 260px;
      max-width: 320px;
      background: var(--popover-bg, #ffffff);
      color: var(--text-primary, #1a1a1a);
      border-radius: 14px;
      padding: 16px 18px;
      box-shadow:
        0 18px 45px rgba(15, 23, 42, 0.18),
        0 2px 12px rgba(15, 23, 42, 0.12);
      border: 1px solid rgba(15, 23, 42, 0.06);
      z-index: 8000;
      backdrop-filter: blur(8px);
      transition: opacity 0.18s ease, transform 0.18s ease;
      pointer-events: auto;
    }

    .link-detail-popover__title {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 0 8px 0;
      display: flex;
      align-items: flex-start;
      gap: 6px;
      vertical-align: top;
    }

    .link-detail-popover__title-emoji {
      font-size: 1.2rem;
      line-height: 1;
    }

    .link-detail-popover__url {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9rem;
      color: var(--link-color, #0d6efd);
      text-decoration: none;
      word-break: break-all;
      margin: 6px 0;
    }

    .link-detail-popover__url svg {
      flex-shrink: 0;
      align-items: flex-start;
      width: 14px;
      height: 14px;
    }

    .link-detail-popover__url:hover,
    .link-detail-popover__url:focus {
      text-decoration: underline;
    }

    .link-detail-popover__meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 10px;
      font-size: 0.82rem;
      color: var(--text-secondary, #555);
    }

    .link-detail-popover__row {
      display: flex;
      gap: 8px;
      align-items: flex-start;
    }

    .link-detail-popover__label {
      width: 110px;
      flex-shrink: 0;
      font-weight: 500;
      color: var(--text-muted, #888);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .link-detail-popover__value {
      flex: 1;
      color: var(--text-primary, #1a1a1a);
      word-break: break-word;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .link-detail-popover__value--muted {
      font-size: 0.75rem;
      color: var(--text-muted, #888);
    }

    .link-detail-popover__keywords {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }

    .link-detail-popover__badge {
      padding: 4px 8px;
      background: rgba(13, 110, 253, 0.12);
      border-radius: 999px;
      font-size: 0.75rem;
      color: var(--link-color, #0d6efd);
    }

    .link-detail-popover__favicon {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      object-fit: contain;
      box-shadow: 0 2px 6px rgba(15, 23, 42, 0.18);
      flex-shrink: 0;
      vertical-align: top;
    }

    .favicon-rule-actions .btn {
      width: 32px;
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.25rem;
    }

    @media (max-width: 768px) {
      .link-detail-popover {
        left: 16px !important;
        right: 16px !important;
        width: auto;
      }
    }

    
    /* Generic Options Dialog Styles */
    .options-section {
      margin-bottom: 1rem;
      border: 1px solid #dee2e6;
      border-radius: 0.375rem;
    }
    /* Sync progress (bottom-right) */
    .mb-sync-progress {
      position: fixed;
      right: 16px;
      bottom: 24px;
      z-index: 1050;
      width: 280px;
      background: rgba(33, 37, 41, 0.9);
      border-radius: 8px;
      padding: 10px 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      color: #fff;
    }
    .mb-sync-progress .mb-sync-title { font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    .mb-sync-progress .progress { height: 8px; background: rgba(255,255,255,0.15); }
    .mb-sync-progress .progress-bar { background-color: #0d6efd; }
    
    .options-section-header {
      background-color: #f8f9fa;
      padding: 0.75rem 1rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background-color 0.2s;
    }
    
    .options-section-header:hover {
      background-color: #e9ecef;
    }
    
    .options-section-body {
      padding: 1rem;
      background-color: white;
    }
    
    .option-row {
      margin-bottom: 1rem;
    }

    .option-row:last-child {
      margin-bottom: 0;
    }

    .option-row.mb-edit-field-row {
      position: relative;
    }

    .mb-keyword-suggestions {
      position: absolute;
      top: 75%;
      left: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.12);
      max-height: 200px;
      overflow-y: auto;
      z-index: 2000;
    }

    .mb-keyword-suggestions--overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: auto;
      max-height: 220px;
      z-index: 12050;
    }

    .mb-keyword-quick-field {
      position: relative;
    }

    .mb-keyword-quick-field .mb-keyword-suggestions {
      top: calc(100% - 1px);
    }

    .mb-keyword-suggestion {
      background: transparent;
      border: none;
      text-align: left;
      padding: 6px 10px;
      font-size: 0.85rem;
      cursor: pointer;
      color: inherit;
    }

    .mb-keyword-suggestion + .mb-keyword-suggestion {
      border-top: 1px solid var(--border-color);
    }

    .mb-keyword-suggestion:hover,
    .mb-keyword-suggestion:focus {
      background: rgba(0, 0, 0, 0.05);
      outline: none;
    }
    
    .chevron-icon {
      transition: transform 0.3s;
    }
    
    .collapsed .chevron-icon {
      transform: rotate(-90deg);
    }
    
    .css-sidebar {
      position: fixed;
      top: 0;
      right: -400px;
      width: 400px;
      height: 100vh;
      background-color: var(--bg-primary, #ffffff);
      color: var(--text-primary, #212529);
      box-shadow: -2px 0 5px rgba(0,0,0,0.1);
      transition: right 0.3s ease;
      z-index: 1040;
      display: flex;
      flex-direction: column;
    }

    .css-sidebar.template-dark-active {
      background-color: var(--bg-primary, #1f2428);
      color: var(--text-primary, #f1f3f5);
      box-shadow: -2px 0 12px rgba(0, 0, 0, 0.45);
    }

    /* When sidebar is open, shift the main content */
    body.css-sidebar-open {
      transition: margin-right 0.3s ease;
    }

    body.css-sidebar-open .css-sidebar {
      right: 0;
    }
    
    .css-sidebar-resize-handle {
      position: absolute;
      left: 0;
      top: 0;
      width: 5px;
      height: 100%;
      cursor: ew-resize;
      background: transparent;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .css-sidebar-resize-handle::before {
      content: '';
      width: 2px;
      height: 40px;
      background-color: #adb5bd;
      border-radius: 1px;
    }
    
    .css-sidebar-resize-handle:hover {
      background-color: rgba(0, 123, 255, 0.1);
    }
    
    .css-sidebar-resize-handle:hover::before {
      background-color: #007bff;
      height: 60px;
    }
    
    .css-sidebar-resize-handle.resizing {
      background-color: rgba(0, 123, 255, 0.2);
    }
    
    .css-sidebar-resize-handle.resizing::before {
      background-color: #0056b3;
      height: 80px;
    }
    
    .css-sidebar.resizing {
      transition: none;
    }
    
    /* Removed - now handled by body.css-sidebar-open */
    
    .css-sidebar .sidebar-header {
      padding: 1rem;
      margin: 0.5rem;
      margin-bottom: 0;
      border-bottom: 1px solid var(--border-color, #dee2e6);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 0.25rem 0.25rem 0 0;
      background-color: var(--bg-secondary, #f8f9fa);
    }
    
    .css-sidebar .sidebar-split-container {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 60px);
      padding: 0.5rem;
      padding-top: 0;
      gap: 0.5rem;
      overflow: hidden;
    }
    
    .css-sidebar .sidebar-top-section {
      min-height: 160px;
      overflow: hidden;
      position: relative;
      background-color: var(--bg-secondary, #f8f9fa);
      color: var(--text-primary, #212529);
      border-radius: 0.25rem;
      border: 1px solid var(--border-color, #dee2e6);
    }
    
    .css-sidebar .sidebar-divider {
      height: 8px;
      background-color: var(--bg-tertiary, #e9ecef);
      cursor: ns-resize;
      position: relative;
      user-select: none;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      flex-shrink: 0;
    }
    
    .css-sidebar .sidebar-divider::before {
      content: '';
      width: 40px;
      height: 2px;
      background-color: var(--border-color-strong, #adb5bd);
      border-radius: 1px;
    }
    
    .css-sidebar .sidebar-divider:hover {
      background-color: var(--surface-hover, #dee2e6);
    }
    
    .css-sidebar .sidebar-divider:hover::before {
      background-color: var(--text-muted, #6c757d);
    }
    
    .css-sidebar .sidebar-divider.resizing {
      background-color: var(--surface-active, #ced4da);
    }
    
    .css-sidebar .sidebar-bottom-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 160px;
      padding: 0;
      background-color: var(--bg-primary, #ffffff);
      border-radius: 0.25rem;
      border: 1px solid var(--border-color, #dee2e6);
    }
    
    .css-sidebar .editor-header {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border-color, #dee2e6);
      background-color: var(--bg-secondary, #f8f9fa);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .css-sidebar .editor-content {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
    }

    .css-sidebar.template-dark-active .sidebar-top-section,
    .css-sidebar.template-dark-active .sidebar-bottom-section {
      background-color: var(--bg-primary, #1f2428);
      color: var(--text-primary, #f1f3f5);
      border-color: var(--border-color, #495057);
    }

    .css-sidebar.template-dark-active .editor-header {
      background-color: var(--bg-secondary, #2a2f34);
      border-color: var(--border-color, #495057);
    }

    .css-sidebar.template-dark-active .sidebar-divider {
      background-color: var(--bg-tertiary, #343a40);
    }

    .css-sidebar.template-dark-active .sidebar-divider:hover {
      background-color: var(--surface-hover, #3f464d);
    }

    .css-sidebar .mb-css-property-editor .options-section {
      margin-bottom: 0;
      border-color: var(--border-color, #dee2e6);
    }

    .css-sidebar .mb-css-property-editor .options-section + .options-section {
      margin-top: 0.5rem;
    }

    .css-sidebar .mb-css-property-editor .options-section-header {
      background-color: var(--bg-secondary, #f8f9fa);
      color: var(--text-primary, #212529);
      border-bottom: 1px solid var(--border-color, #dee2e6);
    }

    .css-sidebar .mb-css-property-editor .options-section-header:hover {
      background-color: var(--surface-hover, #e9ecef);
    }

    .css-sidebar .mb-css-property-editor .options-section-body {
      background-color: var(--bg-primary, #ffffff);
      color: var(--text-primary, #212529);
    }

    .visual-css-editor .property-item.property-editor-active {
      border: 1px solid var(--accent-color, #0d6efd);
      border-radius: 0.25rem;
      padding: 0.4rem;
      background: rgba(13, 110, 253, 0.06);
    }

    .css-sidebar.template-dark-active .mb-css-property-editor .options-section-header {
      background-color: var(--bg-secondary, #2a2f34);
      color: var(--text-primary, #f1f3f5);
      border-color: var(--border-color, #495057);
    }

    .css-sidebar.template-dark-active .mb-css-property-editor .options-section-header:hover {
      background-color: var(--surface-hover, #3f464d);
    }

    .css-sidebar.template-dark-active .mb-css-property-editor .options-section-body {
      background-color: var(--bg-primary, #1f2428);
      color: var(--text-primary, #f1f3f5);
    }

    .css-sidebar.template-dark-active .mb-css-property-editor .text-muted {
      color: var(--text-muted, #adb5bd) !important;
    }
    
    .css-sidebar .sidebar-content {
      padding: 0.5rem;
    }
    
    /* Feature Overview Sidebar */
    .feature-sidebar {
      position: fixed;
      top: 0;
      right: -450px;
      width: 450px;
      height: 100vh;
      background-color: #ffffff;
      box-shadow: -2px 0 5px rgba(0,0,0,0.1);
      transition: right 0.3s ease;
      z-index: 1040;
      display: flex;
      flex-direction: column;
    }
    
    .feature-sidebar.sidebar-open {
      right: 0;
    }
    
    .feature-sidebar .sidebar-header {
      padding: 15px 20px;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #f8f9fa;
    }

    /* Toast Notification Styles */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 350px;
    }

    .toast-notification {
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      padding: 0;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      min-width: 300px;
    }

    .toast-notification.toast-show {
      opacity: 1;
      transform: translateX(0);
    }

    .toast-notification.toast-hide {
      opacity: 0;
      transform: translateX(100%);
    }

    .toast-content {
      padding: 12px 40px 12px 16px;
    }

    .toast-title {
      font-weight: 600;
      margin-bottom: 4px;
      color: #212529;
      font-size: 14px;
    }

    .toast-body {
      color: #6c757d;
      font-size: 13px;
      line-height: 1.4;
    }

    .toast-close {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      font-size: 24px;
      line-height: 1;
      color: #6c757d;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .toast-close:hover {
      opacity: 1;
    }

    .toast-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .toast-progress-fill {
      height: 100%;
      width: 100%;
      background: currentColor;
      transition: width linear;
    }

    /* Toast type variations */
    .toast-success {
      border-left: 4px solid #28a745;
    }

    .toast-success .toast-progress-fill {
      background: #28a745;
    }

    .toast-error {
      border-left: 4px solid #dc3545;
    }

    .toast-error .toast-progress-fill {
      background: #dc3545;
    }

    .toast-warning {
      border-left: 4px solid #ffc107;
    }

    .toast-warning .toast-progress-fill {
      background: #ffc107;
    }

    .toast-info {
      border-left: 4px solid #17a2b8;
    }

    .toast-info .toast-progress-fill {
      background: #17a2b8;
    }

    /* Dark mode support for toasts */
    body.dark-mode .toast-notification {
      background: #2d3748;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    body.dark-mode .toast-title {
      color: #f7fafc;
    }

    body.dark-mode .toast-body {
      color: #a0aec0;
    }

    body.dark-mode .toast-close {
      color: #a0aec0;
    }

    body.dark-mode .toast-progress {
      background: rgba(255, 255, 255, 0.1);
    }

    .feature-sidebar .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    
    .feature-section {
      margin-bottom: 25px;
    }
    
    .feature-section-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .feature-list {
      list-style: none;
      padding-left: 0;
      margin: 0;
    }
    
    .feature-list li {
      margin-bottom: 10px;
      padding-left: 20px;
      position: relative;
    }
    
    .feature-list li::before {
      content: "▸";
      position: absolute;
      left: 0;
      color: var(--bs-primary);
    }
    
    .feature-list li strong {
      color: var(--bs-dark);
    }
    
    .feature-list.small {
      font-size: 0.9rem;
    }
    
    .text-purple {
      color: #6f42c1;
    }
    
    /* Online Status Indicators */
    .online-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-left: 0.5rem;
      position: relative;
    }
    
    .online-indicator.online {
      background-color: #28a745;
      box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.2);
    }
    
    .online-indicator.offline {
      background-color: #6c757d;
    }
    
    .online-indicator.checking {
      background-color: #ffc107;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .contact-row {
      position: relative;
    }
    
    .contact-row.offline {
      opacity: 0.6;
    }
    
    .contact-status-text {
      font-size: 0.85rem;
      margin-left: 0.5rem;
    }
    
    .contact-status-text.online {
      color: #28a745;
    }
    
    .contact-status-text.offline {
      color: #6c757d;
    }

    .title-bar {
      padding: 0px 8px 0px 8px;
    }
    
    .toolbar {
      padding: 0px 8px 0px 8px;
    }

    .keywords-cloud {
      padding: 0px 8px 0px 8px;
    }

    /* Make mainContainer vertically scrollable */
    .mainContainer {
      height: calc(100vh - 200px); /* Adjust based on header/toolbar height */
      overflow-y: auto;
      overflow-x: hidden;
    }

    .mb-local-lock-overlay {
      position: fixed;
      inset: 0;
      z-index: 20000;
      background: rgba(15, 23, 42, 0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .mb-local-lock-card {
      width: min(460px, 100%);
      background: #ffffff;
      border-radius: 12px;
      padding: 1rem;
      border: 1px solid rgba(15, 23, 42, 0.15);
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.35);
    }

    body.dark-mode .mb-local-lock-card {
      background: #1f2937;
      color: #f3f4f6;
      border-color: rgba(255, 255, 255, 0.15);
    }
  </style>
  <style id="user-custom-css"></style>
</head>

<body>
  <div id="app"
    :class="['container-fluid', 'app', 'mb-app', {'dragging-group': dragState === 'group', 'dragging-link': dragState === 'link'}]"
    @click.self="hideMenus">
    <div v-if="localSecurity.locked" class="mb-local-lock-overlay">
      <div class="mb-local-lock-card">
        <h5 class="mb-2">{{ getTranslation('options.security.unlockTitle') || 'Unlock local data' }}</h5>
        <p class="text-muted small mb-2">{{ getTranslation('options.security.unlockDescription') || 'Enter your password to unlock local data.' }}</p>
        <p v-if="localSecurity.lockReason === 'timeout'" class="text-warning small mb-2">
          {{ getTranslation('options.security.lockedByTimeout') || 'Session expired. Data has been locked again.' }}
        </p>
        <label class="form-label mb-1">{{ getTranslation('options.security.unlockPassword') || 'Password' }}</label>
        <input
          ref="localUnlockPasswordInput"
          v-model="localSecurity.unlockPassword"
          type="password"
          class="form-control mb-2"
          autocomplete="current-password"
          :disabled="localSecurity.unlockBusy"
          @keyup.enter="submitLocalSecurityUnlock">
        <div v-if="localSecurity.unlockError" class="alert alert-danger py-2 px-3 small mb-2">
          {{ localSecurity.unlockError }}
        </div>
        <button type="button"
          class="btn btn-primary w-100"
          :disabled="localSecurity.unlockBusy || !localSecurity.unlockPassword"
          @click="submitLocalSecurityUnlock">
          {{ getTranslation('options.security.unlockButton') || 'Unlock' }}
        </button>
      </div>
    </div>
    <!-- Dark Mode Toggle -->
    <!-- <button class="dark-mode-toggle" @click="toggleDarkMode" :title="isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'">
      <svg v-if="isDarkMode" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
        <path d="M12 8a4 4 0 1 1-8 0 4 4 0 0 1 8 0zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
      </svg>
      <svg v-else xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
        <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
      </svg>
    </button> -->
    
    <div class="title-bar mb-titlebar">
      <h1 class="text-start mb-titlebar__title">
        <!-- Placeholder favicon -->
        {{ title }}
      </h1>
    </div>

    <div class="container-fluid toolbar mb-toolbar">
      <div class="btn-toolbar" role="toolbar" aria-label="Toolbar">
        <div class="d-flex align-items-center w-100" style="gap: 0.25rem;">
          <button @click="addGroup" type="button" class="btn btn-sm btn-success mb-btn mb-btn--add-group text-nowrap" style="border-radius: 8px;">
            {{ getTranslation('addGroup') }}
          </button>
          
          <!-- Options & Find duplicates group -->
          <div class="btn-group btn-group-sm mb-tools" role="group" aria-label="Options" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--options" :title="getTranslation('options')"
              @click="showOptionsDialog">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-gear-fill" viewBox="0 0 16 16">
                <path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--favicon-rules" :title="getTranslation('options.links.faviconRules.manage') || 'Favicon rules'"
              @click="openFaviconRulesModal">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-image" viewBox="0 0 16 16">
                <path d="M6.002 5.5a1.5 1.5 0 1 1-3.002 0 1.5 1.5 0 0 1 3.002 0"/>
                <path d="M1 2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2zm0 1h14a1 1 0 0 1 1 1v5.5l-3.146-3.147a.5.5 0 0 0-.708 0L8 10 5.854 7.854a.5.5 0 0 0-.708 0L0 13V4a1 1 0 0 1 1-1"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--custom-css" :title="getTranslation('css.custom.open') || 'Custom CSS'"
              @click="openCssSidebar">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M6.5 0a.5.5 0 0 1 .5.5V2h2V.5a.5.5 0 0 1 1 0V2h.5A2.5 2.5 0 0 1 13 4.5V5h.5a.5.5 0 0 1 0 1H13v2h.5a.5.5 0 0 1 0 1H13v.5A2.5 2.5 0 0 1 10.5 12H10v1.5a.5.5 0 0 1-1 0V12H7v1.5a.5.5 0 0 1-1 0V12h-.5A2.5 2.5 0 0 1 3 9.5V9h-.5a.5.5 0 0 1 0-1H3V6h-.5a.5.5 0 0 1 0-1H3v-.5A2.5 2.5 0 0 1 5.5 2H6V.5a.5.5 0 0 1 .5-.5ZM4 6v3.5A1.5 1.5 0 0 0 5.5 11h5A1.5 1.5 0 0 0 12 9.5V6H4Z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--find-duplicates" :title="getTranslation('duplicates.find')"
              @click="findAndResolveDuplicates">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-binoculars-fill" viewBox="0 0 16 16">
                <path d="M4.5 1A1.5 1.5 0 0 0 3 2.5V3h4v-.5A1.5 1.5 0 0 0 5.5 1zM7 4v1h2V4h4v.882a.5.5 0 0 0 .276.447l.895.447A1.5 1.5 0 0 1 15 7.118V13H9v-1.5a.5.5 0 0 1 .146-.354l.854-.853V9.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v.793l.854.853A.5.5 0 0 1 7 11.5V13H1V7.118a1.5 1.5 0 0 1 .83-1.342l.894-.447A.5.5 0 0 0 3 4.882V4zM1 14v.5A1.5 1.5 0 0 0 2.5 16h3A1.5 1.5 0 0 0 7 14.5V14zm8 0v.5a1.5 1.5 0 0 0 1.5 1.5h3a1.5 1.5 0 0 0 1.5-1.5V14zm4-11H9v-.5A1.5 1.5 0 0 1 10.5 1h1A1.5 1.5 0 0 1 13 2.5z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--shortcuts" :title="getTranslation('shortcuts.manage') || 'Shortcut Manager'"
              @click="openShortcutManagerDialog">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-keyboard-fill" viewBox="0 0 16 16">
                <path d="M0 5a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2zm1 0v6a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H2a1 1 0 0 0-1 1m2 1h1v1H3zm2 0h1v1H5zm2 0h1v1H7zm2 0h1v1H9zm2 0h1v1h-1zM3 8h1v1H3zm2 0h1v1H5zm2 0h1v1H7zm2 0h1v1H9zm2 0h1v1h-1zM3 10h10v1H3z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--global-placeholders" :title="getTranslation('placeholders.global.manage') || 'Manage global placeholders'"
              @click="openGlobalPlaceholderDialog">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M6.5 3.5a.5.5 0 0 1 0 1H4v7h2.5a.5.5 0 0 1 0 1H3.5a.5.5 0 0 1-.5-.5v-8a.5.5 0 0 1 .5-.5zM12.5 3a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H9.5a.5.5 0 0 1 0-1H12v-7H9.5a.5.5 0 0 1 0-1z"/>
              </svg>
            </button>
            <button v-if="extensionAvailable" type="button" class="btn btn-outline-secondary mb-btn mb-btn--clear-ext-cache" :title="getTranslation('extension.clearCache') || 'Extension Cache leeren'"
              @click="clearExtensionCache">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
              </svg>
            </button>
          </div>

          <!-- CardDAV Sync group (only when extension available and enabled) -->
          <div class="btn-group btn-group-sm" role="group" aria-label="Sync" style="margin-left: 0.25rem;"
               v-if="extensionAvailable && data.options?.sync?.backend">
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--sync-now"
                    :title="getTranslation('carddav.syncNow')"
                    @click="syncNowGeneric">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-repeat" viewBox="0 0 16 16">
                <path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41m-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9"/>
                <path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5 5 0 0 0 8 3M3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9z"/>
              </svg>
            </button>
          </div>

          <!-- Contacts group -->
          <div class="btn-group btn-group-sm position-relative" role="group" aria-label="Contacts" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--contacts" title="Contacts & Quick-Connect" @click="openContactsDialog" data-bs-toggle="modal" data-bs-target="#contactsModal">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3Zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/>
              </svg>
            </button>
            <!--
            <button type="button" class="btn btn-outline-secondary" 
              :title="syncAllCooldown > 0 ? `Sync All (wait ${syncAllCooldown}s)` : 'Sync All Groups'" 
              @click="syncAllGroups"
              :disabled="syncAllCooldown > 0 || isSyncingAll">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                <circle v-if="isSyncingAll" cx="8" cy="8" r="2" fill="none" stroke="currentColor" stroke-width="1">
                  <animateTransform attributeName="transform" type="rotate" from="0 8 8" to="360 8 8" dur="1s" repeatCount="indefinite"/>
                </circle>
              </svg>
            </button>
          -->
            <!-- Countdown badge outside button but inside btn-group -->
             <!--
            <span v-if="syncAllCooldown > 0" 
                  class="position-absolute badge rounded-pill bg-danger"
                  style="font-size: 0.65em; z-index: 1050; top: -8px; right: -8px;">
              {{ syncAllCooldown }}
            </span>
          -->
          </div>
          
          <!-- Open all & Close all group -->
          <div class="btn-group btn-group-sm" role="group" aria-label="Expand Collapse" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('groups.openAll')"
              @click="expandAllGroups">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                viewBox="0 0 16 16">
                <path fill-rule="evenodd"
                  d="M1.646 3.646a.5.5 0 0 1 .708 0L8 9.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708Z" />
                <path fill-rule="evenodd"
                  d="M1.646 7.646a.5.5 0 0 1 .708 0L8 13.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708Z" />
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('groups.closeAll')"
              @click="collapseAllGroups">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                viewBox="0 0 16 16">
                <path fill-rule="evenodd"
                  d="M14.354 12.354a.5.5 0 0 1-.708 0L8 6.707l-5.646 5.647a.5.5 0 0 1-.708-.708l6-6a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708Z" />
                <path fill-rule="evenodd"
                  d="M14.354 8.354a.5.5 0 0 1-.708 0L8 2.707l-5.646 5.647a.5.5 0 1 1-.708-.708l6-6a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708Z" />
              </svg>
            </button>
            <button v-if="isManualGroupColumnWidthEnabled()"
              type="button"
              class="btn btn-outline-secondary"
              :title="getTranslation('toolbar.equalizeGroupColumns') || 'Equalize group column widths'"
              @click="equalizeGroupColumnWidths">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <rect x="1.5" y="2" width="3" height="12" rx="0.75"></rect>
                <rect x="6.5" y="2" width="3" height="12" rx="0.75"></rect>
                <rect x="11.5" y="2" width="3" height="12" rx="0.75"></rect>
              </svg>
            </button>
          </div>
          
          <!-- Import & Export group -->
          <div class="btn-group btn-group-sm" role="group" aria-label="Import Export" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('exportToFile')"
              @click="exportAndDownload">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-download" viewBox="0 0 16 16">
                <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/>
                <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('import')" @click="openPasteModal">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-upload" viewBox="0 0 16 16">
                <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/>
                <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708z"/>
              </svg>
            </button>
          </div>
          
          <!-- Bookmarklet group -->
          <div class="btn-group btn-group-sm" role="group" aria-label="Bookmarklet" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary"
              :title="getTranslation('bookmarklet.addCurrentTab')" @click="showBookmarkletHelp">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bookmark-check-fill" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M2 15.5V2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v13.5a.5.5 0 0 1-.74.439L8 13.069l-5.26 2.87A.5.5 0 0 1 2 15.5m8.854-9.646a.5.5 0 0 0-.708-.708L7.5 7.793 6.354 6.646a.5.5 0 1 0-.708.708l1.5 1.5a.5.5 0 0 0 .708 0z"/>
              </svg>
            </button>
          </div>

          <!-- Snapshots dropdown as a grouped item -->
          <div class="btn-group btn-group-sm mb-snapshots-dropdown" role="group" aria-label="Snapshots" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('undo')" @click="undo">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('redo')" @click="redo">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/>
                <path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/>
              </svg>
            </button>
            <button class="btn btn-outline-secondary dropdown-toggle mb-snapshots-btn" type="button" data-bs-toggle="dropdown"
              aria-expanded="false">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-plus-fill me-1" viewBox="0 0 16 16">
                <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5z"/>
                <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5zm4.5 6V9H10a.5.5 0 0 1 0 1H8.5v1.5a.5.5 0 0 1-1 0V10H6a.5.5 0 0 1 0-1h1.5V7.5a.5.5 0 0 1 1 0"/>
              </svg>
              {{ getTranslation('snapshots.title') }}
            </button>
            <ul class="dropdown-menu mb-snapshots-menu">
              <li><a class="dropdown-item" href="#" @click.prevent="saveSnapshot">{{
                  getTranslation('snapshots.save') }}</a></li>
              <li>
                <hr class="dropdown-divider">
              </li>
              <li v-if="!data.snapshots || !data.snapshots.length" class="dropdown-item text-muted">{{
                getTranslation('snapshots.none') }}</li>
              <li v-for="s in (data.snapshots || [])" :key="'snap-'+s.id" class="dropdown-item">
                <div class="d-flex align-items-center justify-content-between">
                  <a href="#" @click.prevent="restoreSnapshot(s.id)">{{ formatSnapshotLabel(s) }}</a>
                  <button class="btn btn-xs btn-link text-danger ms-2"
                    @click.stop.prevent="deleteSnapshot(s.id)">×</button>
                </div>
              </li>
            </ul>
          </div>

          <!-- Search group -->
          <div class="input-group input-group-sm align-items-stretch flex-grow-1 mb-toolbar__search" style="margin-left: 0.25rem;">
            <span class="input-group-text" id="search-addon">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-search me-1" viewBox="0 0 16 16">
                <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/>
              </svg>
              <span>
              {{ getTranslation('search') }}
              </span>
            </span>
            <button class="btn btn-outline-secondary" type="button" @click="onClearClick"
              :title="getTranslation('clear')">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path
                  d="M2.5 2.5a.7.7 0 0 1 .99 0L8 7.01l4.51-4.51a.7.7 0 1 1 .99.99L8.99 8l4.51 4.51a.7.7 0 0 1-.99.99L8 8.99l-4.51 4.51a.7.7 0 1 1-.99-.99L7.01 8 2.5 3.49a.7.7 0 0 1 0-.99Z" />
              </svg>
            </button>
            <input type="text" class="form-control" v-model="filterText" :aria-label="getTranslation('search')"
              aria-describedby="search-addon" id="searchFilter">
            
            <!-- Storage indicator (show used only) -->
            <div class="ms-2 me-2 d-flex align-items-center text-muted small mb-toolbar__storage" :title="getStorageTooltip()" style="min-width: auto;">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-database-fill me-1" viewBox="0 0 16 16">
                <path d="M3.904 1.777C4.978 1.289 6.427 1 8 1s3.022.289 4.096.777C13.125 2.245 14 2.993 14 4s-.875 1.755-1.904 2.223C11.022 6.711 9.573 7 8 7s-3.022-.289-4.096-.777C2.875 5.755 2 5.007 2 4s.875-1.755 1.904-2.223Z"/>
                <path d="M2 6.161V7c0 1.007.875 1.755 1.904 2.223C4.978 9.71 6.427 10 8 10s3.022-.289 4.096-.777C13.125 8.755 14 8.007 14 7v-.839c-.457.432-1.004.751-1.49.972C11.278 7.693 9.682 8 8 8s-3.278-.307-4.51-.867c-.486-.22-1.033-.54-1.49-.972Z"/>
                <path d="M2 9.161V10c0 1.007.875 1.755 1.904 2.223C4.978 12.711 6.427 13 8 13s3.022-.289 4.096-.777C13.125 11.755 14 11.007 14 10v-.839c-.457.432-1.004.751-1.49.972-1.232.56-2.828.867-4.51.867s-3.278-.307-4.51-.867c-.486-.22-1.033-.54-1.49-.972Z"/>
                <path d="M2 12.161V13c0 1.007.875 1.755 1.904 2.223C4.978 15.711 6.427 16 8 16s3.022-.289 4.096-.777C13.125 14.755 14 14.007 14 13v-.839c-.457.432-1.004.751-1.49.972-1.232.56-2.828.867-4.51.867s-3.278-.307-4.51-.867c-.486-.22-1.033-.54-1.49-.972Z"/>
              </svg>
              <span>{{ formatStorageSize(storageUsed) }}</span>
            </div>
            
            <!-- Help/Feature Overview Button (moved to right end) -->
            <button type="button" class="btn btn-sm btn-outline-secondary mb-btn mb-btn--features ms-2" :title="getTranslation('features.open') || 'Hilfe / Help'"
              @click="openFeatureSidebar">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.93-9.412-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2"/>
              </svg>
            </button>
          </div>              
        </div>
      </div>
    </div>

    <!-- Keywords Cloud -->
    <div class="container-fluid keywords-cloud mb-keywords-cloud">
      <div class="input-group input-group-sm">
        <span class="input-group-text mb-keyword-label">
          <span>{{ getTranslation('group.keywords') || 'Keywords' }}</span>
          <button
            type="button"
            class="btn btn-outline-secondary btn-sm mb-keyword-manage-btn"
            :title="getTranslation('keywords.manage') || 'Manage keywords'"
            @click="openKeywordManagerDialog">
            {{ getTranslation('keywords.manage') || 'Manage' }}
          </button>
        </span>
        <div class="form-control p-0 keyword-container">
          <div class="d-flex align-items-center mb-keyword-row">
            <span v-for="kw in displayedKeywords" :key="'kw-'+kw" role="button" 
              :class="['badge','me-1','mb-1','keyword-badge','mb-keyword', keywordClass(kw), { 'mb-keyword-active': isKeywordFilterActive(kw) }]"
              :data-keyword="keywordSlug(kw)"
              :style="getKeywordGradientStyle(kw)"
              @click="onKeywordClick(kw)"><span class="mb-keyword-text">{{ kw }}</span></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Groups and Links Content Container -->
    <div class="container-fluid m-0 p-0 mainContainer mb-groups-links-container">
      <table class="groupsTable">
        <tr>
          <!-- Vertikale Dropzone vor der ersten Spalte -->
          <td class="verticalDropZone"
              @drop.stop.prevent="handleDropToNewColumn($event, -1)"
              @dragover.prevent
              @dragenter.prevent="dropManager.handleDragEnterVerticalZone($event)"
              @dragleave="dropManager.handleDragLeaveVerticalZone($event)">
            <div class="verticalDropZoneIndicator"></div>
          </td>

          <template v-for="(colIndex, groupColumnIndex) in getGroupColumns()" :key="'groupColumn-' + groupColumnIndex">
            <td class="groupCell"
                :data-column-index="colIndex"
                :style="getGroupColumnCellStyle(colIndex)"
                :class="{ 'group-cell--resizing': isGroupColumnResizing && (groupColumnResizeState.leftColumn === colIndex || groupColumnResizeState.rightColumn === colIndex) }">

            <div v-if="getGroupsByColumn(colIndex).length === 0"
              :class="['groupContainerDragAndDrop', 'group-drop-zone']"
              @drop.stop.prevent="dropManager.onDrop($event, data.groups, null, 0, colIndex, 'group'); saveData()"
              @dragover.prevent @dragenter.prevent="dropManager.handleDragEnterZone($event)"
              @dragleave="dropManager.handleDragLeaveZone($event)"> {{ getTranslation('group.dropAfter') }}
            </div>

            <template v-for="(group, groupIndex) in getGroupsByColumn(colIndex)" :key="'group-template-' + group.uuid">
              <div :key="'group-drop-before-' + group.uuid"
                :class="['groupContainerDragAndDrop', 'group-drop-zone']"
                @drop.stop.prevent="dropManager.onDrop($event, data.groups, null, groupIndex, colIndex, 'group'); saveData()"
                @dragover.prevent @dragenter.prevent="dropManager.handleDragEnterZone($event)"
                @dragleave="dropManager.handleDragLeaveZone($event)">
                {{ getTranslation('group.dropAfter') }}
              </div>

              <div :key="'group-' + group.uuid" :class="['groupContainer', 'mb-group', cssClassFromUuid('group', group.uuid), { 'mb-group--resizing': isGroupHeightResizing && groupHeightResizeState.groupUuid === group.uuid }]"
                :data-uuid="group.uuid"
                :data-group-id="group.id"
                @mouseover="group.isMouseOver = true"
                @mouseleave="group.isMouseOver = false" @dragover.prevent="handleGroupDragOver(group)"
                @dragenter.prevent="handleGroupDragEnter(group)" @dragleave="handleGroupDragLeave(group)"
                @drop.stop.prevent="handleLinkDrop($event, group, getLinksByColumn(group.links, (getLinkColumns(group.links)[0] ?? 0)).length, (getLinkColumns(group.links)[0] ?? 0))">

                <div class="container-fluid groupContainerHeader p-0 mb-group__header" 
                  draggable="true"
                  :data-drag-id="'group-' + group.uuid"
                  @mouseover="group.isMouseOver = true; prepareForDrag($event, $event.currentTarget)"
                  @mouseleave="group.isMouseOver = false"
                  @mousedown="prepareForDrag($event, $event.currentTarget)"
                  @dragstart="dropManager.startDrag($event, data.groups, group, 'group')" 
                  @dragend="handleDragEnd($event)"
                  style="cursor: grab;">
                  <div class="row align-items-center g-0">
                    <div class="col">
                      <div class="d-flex align-items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none"
                          class="collapseIcon flex-shrink-0" viewBox="0 0 24 24"
                          data-bs-toggle="collapse" :href="'#collapseGroup-' + group.uuid" role="button" tabindex="0"
                          @keydown="onKeyActivate($event, () => toggleGroupCollapse(group))"
                          :aria-expanded="!group.collapsed" :aria-controls="'#collapseGroup-' + group.uuid"
                          @click.prevent="toggleGroupCollapse(group)">
                          <path v-if="group.collapsed && group.searchCollapsed"
                            stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                            d="M9 6l6 6-6 6" />
                          <path v-else
                            stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                            d="M6 9l6 6 6-6" />
                          <title>{{ getTranslation('group.toggleGroupCollapse') }}</title>
                        </svg>
                        <!-- Drag Handle Icon für Gruppen-Drag & Drop (div für stabilere Drag Events) -->
                        <div class="groupDragHandle flex-shrink-0 me-1" :draggable="'true'"
                          @dragstart="dropManager.startDrag($event, data.groups, group, 'group')"
                          @dragend="handleDragEnd()" @mousedown="prepareForDrag($event, $event.currentTarget); $event.stopPropagation()"
                          @click="$event.stopPropagation()"
                          style="cursor: grab; display: inline-flex; align-items: center; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; padding: 2px; min-width: 24px; min-height: 24px; justify-content: center;">
                          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor"
                            class="bi bi-grip-vertical" viewBox="0 0 16 16" style="pointer-events: none;">
                            <title>Drag to move group</title>
                            <path
                              d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0m3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0M7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0m3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0M7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0m3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0m-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0m3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0m-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0m3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0" />
                          </svg>
                        </div>
                        <h2 v-if="!group.editing" class="groupName mb-group__name mb-0 d-flex align-items-center"
                          @dblclick="startEditing(group)"
                          @mouseover="group.isMouseOver = true"
                          @mouseleave="group.isMouseOver = false">
                          <span class="flex-grow-1 d-flex align-items-center groupTitle mb-group__title">
                            <span v-if="group.favicon" class="mb-group-favicon-wrap" :title="faviconSourceTooltip(group)">
                              <img :src="group.favicon" alt="" class="mb-group-favicon">
                            </span>
                            <span v-else-if="group.emoji" class="mb-group-emoji">{{ group.emoji }}</span>
                            <span class="text-truncate" v-html="sanitizeHtml(group.name || '')"></span>
                            <!-- Shared group icon -->
                            <svg v-if="group.shared" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" 
                              class="bi bi-share-fill text-primary ms-2" viewBox="0 0 16 16" style="vertical-align: middle;">
                              <title>{{ getTranslation('group.shared') }}</title>
                              <path d="M11 2.5a2.5 2.5 0 1 1 .603 1.628l-6.718 3.12a2.5 2.5 0 0 1 0 1.504l6.718 3.12a2.5 2.5 0 1 1-.488.876l-6.718-3.12a2.5 2.5 0 1 1 0-3.256l6.718-3.12A2.5 2.5 0 0 1 11 2.5"/>
                            </svg>
                            <!-- Link count pill -->
                            <span :class="['groupLinkCount', 'mb-linkcount-badge', { 'empty': getGroupLinkCount(group) === 0 }]"
                              :data-group-uuid="group.uuid"
                              :data-group-name="keywordSlug(group.name)"
                              :data-link-count="getGroupLinkCount(group)">
                              {{ getGroupLinkCount(group) }}
                            </span>
                          </span>
                          <span class="ms-2 d-flex align-items-center mb-group__badges">
                            <span v-for="kw in groupKeywordsArray(group)" :key="'gkw-'+group.uuid+'-'+kw"
                              :class="['badge','keyword-badge','mb-group__keyword-badge', keywordClass(kw)]"
                              :data-group-uuid="group.uuid"
                              :data-group-name="keywordSlug(group.name)"
                              :data-keyword="keywordSlug(kw)"
                              @click.stop="onKeywordClick(kw)" role="button">{{ kw }}</span>
                            <span v-if="shouldShowGroupKeywordQuickAddBadge(group)"
                              class="badge mb-keyword-add-badge ms-1"
                              role="button"
                              tabindex="0"
                              :title="getTranslation('menu.keyword.new') || 'New keyword'"
                              @keydown.stop="onKeyActivate($event, () => openKeywordQuickDialogForGroup(group))"
                              @click.stop="openKeywordQuickDialogForGroup(group)">+</span>
                          </span>
                        </h2>
                        <input v-else v-model="group.name" type="text" class="form-control form-control-sm"
                          aria-label="GroupName" @blur="saveEditing(group)" @keyup.enter="saveEditing(group)"
                          @keyup.esc="cancelEditing(group)" v-focus="group.editing">
                      </div>
                    </div>
                    <div
                      :class="['col-auto', 'text-end', 'ps-2', 'groupActions', 'mb-group__actions', {'groupActionsVisibleOnMouseOver': group.isMouseOver}]" 
                      style="margin-left: auto;">
                      <!-- Add link button (dialog mode) -->
                      <svg v-if="data.options?.buttons?.showAddLink" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                        :class="['bi bi-node-plus-fill fw-bold actionIcon ms-2 me-1', canAdd(group) ? 'text-success' : 'text-muted']"
                        :style="{ cursor: canAdd(group) ? 'pointer' : 'not-allowed', opacity: canAdd(group) ? 1 : 0.5 }"
                        viewBox="0 0 16 16"
                        role="button" tabindex="0"
                        @keydown="canAdd(group) ? onKeyActivate($event, () => openAddLinkDialog(group)) : null"
                        @click="canAdd(group) ? openAddLinkDialog(group) : null"
                        :title="canAdd(group) ? getTranslation('group.addLink') : getTranslation('error.perm.add')">
                        <path d="M11 13a5 5 0 1 0-4.975-5.5H4A1.5 1.5 0 0 0 2.5 6h-1A1.5 1.5 0 0 0 0 7.5v1A1.5 1.5 0 0 0 1.5 10h1A1.5 1.5 0 0 0 4 8.5h2.025A5 5 0 0 0 11 13m.5-7.5v2h2a.5.5 0 0 1 0 1h-2v2a.5.5 0 0 1-1 0v-2h-2a.5.5 0 0 1 0-1h2v-2a.5.5 0 0 1 1 0"/>
                      </svg>
                      <!-- Delete group button -->
                      <svg v-if="data.options?.buttons?.showDeleteGroup" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                        :class="['bi bi-trash-fill fw-bold actionIcon ms-1 me-1', isOwnerOfGroup(group) ? 'text-danger' : 'text-muted']"
                        :style="{ cursor: isOwnerOfGroup(group) ? 'pointer' : 'not-allowed', opacity: isOwnerOfGroup(group) ? 1 : 0.5 }"
                        viewBox="0 0 16 16"
                        role="button" tabindex="0"
                        @keydown.stop="isOwnerOfGroup(group) ? onKeyActivate($event, () => delGroup(group)) : null"
                        @click.stop="isOwnerOfGroup(group) ? delGroup(group) : null"
                        :title="isOwnerOfGroup(group) ? getTranslation('group.deleteGroup') : (group.shared ? getTranslation('menu.group.leaveGroup') : getTranslation('error.perm.delete'))">
                        <path d="M2.5 1a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1H3v9a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V4h.5a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H10a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1zm3 4a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5M8 5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7A.5.5 0 0 1 8 5m3 .5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 1 0"/>
                      </svg>
                      <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor"
                        class="bi bi-three-dots-vertical svg-button actionIcon mb-group-menu-btn me-2" viewBox="0 0 16 16" 
                        role="button" tabindex="0" @keydown.stop="onKeyActivate($event, () => showGroupMenu($event, group))"
                        @click.stop="showGroupMenu($event, group)">
                        <path
                          d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0" />
                      </svg>
                    </div>
                  </div>
                </div>
                <div :class="['collapse', 'linkContainer', 'mb-group__body', 'mb-links-container', {'show': !group.collapsed}]"
                  :id="'collapseGroup-' + group.uuid"
                  :style="group.collapsed ? null : { height: getGroupBodyHeight(group) + 'px' }">
                  <!-- Collapsible info section -->
                  <div v-if="group.infoHtml" class="group-info-section mb-group-info-section">
                    <div class="d-flex align-items-center px-1 py-0 mb-group-info-header" 
                         role="button"
                         @click="toggleGroupInfo(group)">
                      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" 
                           class="bi bi-info-circle me-1 text-info" viewBox="0 0 16 16">
                        <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                        <path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
                      </svg>
                      <span class="text-info mb-group-info-label">{{ getTranslation('group.info.toggle') || 'Information' }}</span>
                      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" 
                           class="bi ms-auto text-info" viewBox="0 0 16 16">
                        <path v-if="!group.infoExpanded" fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                        <path v-else fill-rule="evenodd" d="M7.646 4.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1-.708.708L8 5.707l-5.646 5.647a.5.5 0 0 1-.708-.708l6-6z"/>
                      </svg>
                    </div>
                    <div v-show="group.infoExpanded" class="px-2 py-1 mb-1 mb-group-info-content" 
                         v-html="group.infoHtml"></div>
                  </div>
                  <table class="linksTable mb-links">
                    <tr>
                      <!-- Vertikale Dropzone vor der ersten Link-Spalte -->
                      <td class="linkVerticalDropZone"
                          @drop.stop.prevent="handleLinkDropToNewColumn($event, group, -1)"
                          @dragover.prevent
                          @dragenter.prevent="dropManager.handleDragEnterVerticalZone($event)"
                          @dragleave="dropManager.handleDragLeaveVerticalZone($event)">
                        <div class="linkVerticalDropZoneIndicator"></div>
                      </td>

                      <template v-for="(linkColIndex, linkColumnIndex) in getLinkColumns(group.links)">
                        <td :key="'linkColumn-' + linkColumnIndex" class="linkCell">

                        <div v-if="getLinksByColumn(group.links, linkColIndex).length === 0"
                          :class="['linkContainerDragAndDrop', 'link-drop-zone']"
                          @drop.stop.prevent="handleLinkDrop($event, group, 0, linkColIndex)" @dragover.prevent
                          @dragenter.prevent="dropManager.handleDragEnterZone($event)"
                          @dragleave="dropManager.handleDragLeaveZone($event)">
                          {{ getTranslation('group.link.dropAfter') }}
                        </div>

                        <template v-for="(link, linkIndex) in getLinksByColumn(group.links, linkColIndex)">
                          <div :key="'link-drop-before-' + link.uuid"
                            :class="['linkContainerDragAndDrop', 'link-drop-zone']"
                            @drop.stop.prevent="handleLinkDrop($event, group, linkIndex, linkColIndex)"
                            @dragover.prevent @dragenter.prevent="dropManager.handleDragEnterZone($event)"
                            @dragleave="dropManager.handleDragLeaveZone($event)">
                            {{ getTranslation('group.link.dropAfter') }}
                          </div>

                          <div :key="'link-' + link.uuid" :class="['linkContainerListItem', 'mb-link', cssClassFromUuid('link', link.uuid), { 'mb-link-separator-row': isSeparatorLink(link), 'mb-link-note-row': isNoteLink(link) }]"
                            :data-uuid="link.uuid"
                            :data-link-id="link.id"
                            :data-drag-id="'link-' + link.uuid"
                            @mouseover="link.isMouseOver = true; prepareForDrag($event, $event.currentTarget); if (shouldShowLinkPopover()) { cancelHideLinkPopover(); showLinkPopover($event, link); }" 
                            @mouseleave="link.isMouseOver = false; setLinkKeywordQuickAddBadgeHover(link, false); if (shouldShowLinkPopover()) queueHideLinkPopover()"
                            @focusin="if (shouldShowLinkPopover()) { cancelHideLinkPopover(); showLinkPopover($event, link); }"
                            @focusout="if (shouldShowLinkPopover()) queueHideLinkPopover()"
                            @dblclick="onLinkRowDblClick(link)"
                            :draggable="!link.editing"
                            @mousedown="prepareForDrag($event, $event.currentTarget)"
                            @dragstart="hideLinkPopover(); dropManager.startDrag($event, group.links, link, 'link')"
                            @dragend="handleDragEnd($event)" 
                            @dragover.prevent @dragenter.prevent
>
                                <div class="linkText mb-link__url">
                                  <template v-if="!link.editing">
                                    <template v-if="isSeparatorLink(link)">
                                      <div class="mb-link-separator">
                                        <span v-if="(link.text || '').trim()" class="mb-link-separator__label" v-html="sanitizeInlineNoAnchor(link.text || '')"></span>
                                      </div>
                                    </template>
                                    <template v-else-if="isNoteLink(link)">
                                      <div class="mb-link-note">
                                        <div class="mb-link-note__header">
                                          <button type="button"
                                            class="mb-link-note__toggle"
                                            :title="isNoteCollapsed(link) ? (getTranslation('note.expand') || 'Expand note') : (getTranslation('note.collapse') || 'Collapse note')"
                                            @mousedown.stop
                                            @click.stop="toggleNoteCollapsed(link)">
                                            <span class="mb-link-note__chevron">{{ isNoteCollapsed(link) ? '▸' : '▾' }}</span>
                                          </button>
                                          <span class="mb-link-note__title" v-html="sanitizeInlineNoAnchor(getEffectiveLinkText(link) || '')"></span>
                                        </div>
                                        <div v-if="!isNoteCollapsed(link) && getEffectiveLinkInfoHtml(link)"
                                          class="mb-link-note__body"
                                          v-html="sanitizeHtml(getEffectiveLinkInfoHtml(link) || '')"></div>
                                      </div>
                                      <span v-if="data.options?.links?.showLinkBadges && (getEffectiveLinkKeywords(link) || shouldShowLinkKeywordQuickAddBadge(group, link))"
                                        class="margin-left ms-3 mb-link__badges">
                                        <span class="mb-link__badge-list">
                                          <span v-for="kw in parseKeywords(getEffectiveLinkKeywords(link))"
                                            :key="'lkw-' + link.uuid + '-' + kw"
                                            :class="['badge','keyword-badge','mb-link__keyword-badge', keywordClass(kw)]"
                                            :data-group-uuid="group.uuid"
                                            :data-group-name="keywordSlug(group.name)"
                                            :data-link-uuid="link.uuid"
                                            :data-link-text="keywordSlug(getEffectiveLinkText(link))"
                                            :data-keyword="keywordSlug(kw)"
                                            @click.stop="onKeywordClick(kw)" role="button">{{ kw }}</span>
                                        </span>
                                        <span v-if="shouldShowLinkKeywordQuickAddBadge(group, link)"
                                          class="badge mb-keyword-add-badge"
                                          role="button"
                                          tabindex="0"
                                          :title="getTranslation('menu.keyword.new') || 'New keyword'"
                                          @mouseenter.stop="setLinkKeywordQuickAddBadgeHover(link, true)"
                                          @mouseleave.stop="setLinkKeywordQuickAddBadgeHover(link, false)"
                                          @keydown.stop="onKeyActivate($event, () => openKeywordQuickDialogForLink(group, link))"
                                          @click.stop="openKeywordQuickDialogForLink(group, link)">+</span>
                                      </span>
                                    </template>
                                    <template v-else>
                                      <span
                                        :class="[{'linkTextCategory': !getEffectiveLinkUrl(link)}, 'text-truncate']" style="min-width: 0; overflow: hidden;">
                                        <a v-if="getEffectiveLinkUrl(link)" :href="getEffectiveLinkUrl(link)" :title="getEffectiveLinkUrl(link)"
                                          :target="data.options?.links?.openInNewTab ? '_blank' : null"
                                          :rel="data.options?.links?.openInNewTab ? 'noopener noreferrer' : null"
                                          class="text-decoration-none linkanchor mb-link__anchor" draggable="false"
                                          @click.stop>
                                          <img
                                            v-if="getEffectiveLinkFavicon(link)"
                                            :src="getEffectiveLinkFavicon(link)" alt="" class="link-favicon mb-link__icon" />
                                          <span
                                            v-else-if="data.options?.links?.autoFetchFavicon && getEffectiveLinkFaviconError(link)"
                                            class="link-favicon-error mb-link__icon" title="Favicon konnte nicht geladen werden (Extension erforderlich)">⚠️</span>
                                          <span class="mb-link-text-with-marker">
                                            <span v-html="sanitizeInlineNoAnchor(getEffectiveLinkText(link) || '')"></span>
                                            <span v-if="isReferenceLink(link) && data.options?.links?.showReferenceMarker !== false"
                                              class="mb-ref-marker"
                                              :title="getReferenceMarkerTitle(link)">*</span>
                                          </span>
                                        </a>
                                        <span v-else>
                                          <span class="mb-link-text-with-marker">
                                            <span v-html="sanitizeHtml(getEffectiveLinkText(link) || '')"></span>
                                            <span v-if="isReferenceLink(link) && data.options?.links?.showReferenceMarker !== false"
                                              class="mb-ref-marker"
                                              :title="getReferenceMarkerTitle(link)">*</span>
                                          </span>
                                        </span>
                                      </span>
                                      <!-- URL preview on hover - moved before badges -->
                                      <span v-if="getEffectiveLinkUrl(link)" class="link-url-preview">{{ getEffectiveLinkUrl(link) }}</span>
                                      <!-- Link keyword badges - moved outside text-truncate to stay visible -->
                                      <span v-if="data.options?.links?.showLinkBadges && (getEffectiveLinkKeywords(link) || shouldShowLinkKeywordQuickAddBadge(group, link))"
                                        class="margin-left ms-3 mb-link__badges">
                                        <span class="mb-link__badge-list">
                                          <span v-for="kw in parseKeywords(getEffectiveLinkKeywords(link))"
                                            :key="'lkw-' + link.uuid + '-' + kw"
                                            :class="['badge','keyword-badge','mb-link__keyword-badge', keywordClass(kw)]"
                                            :data-group-uuid="group.uuid"
                                            :data-group-name="keywordSlug(group.name)"
                                            :data-link-uuid="link.uuid"
                                            :data-link-text="keywordSlug(getEffectiveLinkText(link))"
                                            :data-keyword="keywordSlug(kw)"
                                            @click.stop="onKeywordClick(kw)" role="button">{{ kw }}</span>
                                        </span>
                                        <span v-if="shouldShowLinkKeywordQuickAddBadge(group, link)"
                                          class="badge mb-keyword-add-badge"
                                          role="button"
                                          tabindex="0"
                                          :title="getTranslation('menu.keyword.new') || 'New keyword'"
                                          @mouseenter.stop="setLinkKeywordQuickAddBadgeHover(link, true)"
                                          @mouseleave.stop="setLinkKeywordQuickAddBadgeHover(link, false)"
                                          @keydown.stop="onKeyActivate($event, () => openKeywordQuickDialogForLink(group, link))"
                                          @click.stop="openKeywordQuickDialogForLink(group, link)">+</span>
                                      </span>
                                    </template>
                                  </template>
                                  <input v-else v-model="link.text" type="text" ref="linkTextInput"
                                    class="form-control form-control-sm flex-grow-1" aria-label="LinkText"
                                    @blur="saveEditing(link)" @keyup.enter="saveEditing(link)"
                                    @keyup.esc="cancelEditing(link)" v-focus="link.editing">
                                </div>
                              <div
                                :class="['groupActions', 'mb-link__actions', {'groupActionsVisibleOnMouseOver': link.isMouseOver && !link.editing}]" style="display: flex; align-items: center; gap: 2px; flex-shrink: 0;">
                                <!-- Info button - shows HTML popup on hover -->
                                <svg v-if="!isSeparatorLink(link) && !isNoteLink(link) && getEffectiveLinkInfoHtml(link)" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                  class="bi bi-info-circle-fill text-info actionIcon" viewBox="0 0 16 16"
                                  style="cursor: help;"
                                  @mouseover="showInfoPopup($event, getEffectiveLinkInfoHtml(link))"
                                  @mouseleave="hideInfoPopup()">
                                  <title>{{ getTranslation('link.info') || 'Info' }}</title>
                                  <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.93-9.412-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2"/>
                                </svg>

                                <!-- Copy URL button -->
                                <svg v-if="getEffectiveLinkUrl(link) && data.options?.buttons?.showCopyUrl" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                  class="bi bi-clipboard actionIcon" viewBox="0 0 16 16" role="button"
                                  tabindex="0" @keydown.stop="onKeyActivate($event, () => copyLinkToClipboard(link))"
                                  @click.stop="copyLinkToClipboard(link)">
                                  <title>{{ getTranslation('link.copyUrl') || 'Copy URL' }}</title>
                                  <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
                                  <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
                                </svg>

                                <!-- QR code button -->
                                <svg v-if="getEffectiveLinkUrl(link) && data.options?.buttons?.showQrCode" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                  class="bi bi-qr-code actionIcon" viewBox="0 0 16 16" role="button"
                                  tabindex="0" @keydown.stop="onKeyActivate($event, () => showQrCodeModal(getEffectiveLinkUrl(link)))"
                                  @click.stop="showQrCodeModal(getEffectiveLinkUrl(link))">
                                  <title>{{ getTranslation('link.qrCode') || 'Generate QR Code' }}</title>
                                  <path d="M2 2h2v2H2z"/>
                                  <path d="M6 0v6H0V0zM5 1H1v4h4zM4 12H2v2h2z"/>
                                  <path d="M6 10v6H0v-6zm-5 1v4h4v-4zm11-9h2v2h-2z"/>
                                  <path d="M10 0v6h6V0zm5 1v4h-4V1zM8 1V0h1v2H8v2H7V1zm0 5V4h1v2zM6 8V7h1V6h1v2h1V7h5v1h-4v1H7V8zm0 0v1H2V8H1v1H0V7h3v1zm10 1h-1V7h1zm-1 0h-1v2h2v-1h-1zm-4 0h2v1h-1v1h-1zm2 3v-1h-1v1h-1v1H9v1h3v-2zm0 0h3v1h-2v1h-1zm-4-1v1h1v-2H7v1z"/>
                                  <path d="M7 12h1v3h4v1H7zm9 2v2h-3v-1h2v-1z"/>
                                </svg>
                                
                                <!-- Delete link button -->
                                <svg v-if="data.options?.buttons?.showDeleteLink" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                  :class="['bi bi-trash-fill svg-button fw-bold actionIcon', canDelete(group) ? 'text-danger' : 'text-muted']"
                                  :style="{ cursor: canDelete(group) ? 'pointer' : 'not-allowed', opacity: canDelete(group) ? 1 : 0.5 }"
                                  viewBox="0 0 16 16"
                                  role="button" tabindex="0"
                                  @keydown.stop="canDelete(group) ? onKeyActivate($event, () => deleteLink(link)) : null"
                                  @click.stop="canDelete(group) ? deleteLink(link) : null">
                                  <title>{{ canDelete(group) ? (isSeparatorLink(link) ? (getTranslation('menu.link.deleteSeparator') || 'Delete separator') : (isNoteLink(link) ? (getTranslation('menu.link.deleteNote') || 'Delete note') : (isReferenceLink(link) ? (getTranslation('menu.link.deleteRefLink') || 'Delete ref link') : getTranslation('menu.link.deleteLink')))) : getTranslation('error.perm.delete') }}</title>
                                  <path d="M2.5 1a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1H3v9a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V4h.5a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H10a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1zm3 4a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5M8 5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7A.5.5 0 0 1 8 5m3 .5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 1 0"/>
                                </svg>

                                <!-- Context menu button -->
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" 
                                  class="bi bi-three-dots-vertical svg-button actionIconLink mb-link-menu-btn" viewBox="0 0 16 16"
                                  @click.stop="showLinkMenu($event, group, link)">
                                  <path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0"/>
                                </svg>
                              </div>
                          </div>
                        </template>
                        <div v-if="getLinksByColumn(group.links, linkColIndex).length > 0"
                          :class="['linkContainerDragAndDrop', 'link-drop-zone']"
                          @drop.stop.prevent="handleLinkDrop($event, group, getLinksByColumn(group.links, linkColIndex).length, linkColIndex)"
                          @dragover.prevent @dragenter.prevent="dropManager.handleDragEnterZone($event)"
                          @dragleave="dropManager.handleDragLeaveZone($event)">
                          {{ getTranslation('group.link.dropAfter') }}
                        </div>
                      </td>

                        <!-- Vertikale Dropzone nach jeder Link-Spalte -->
                        <td :key="'linkVerticalDropZone-' + linkColumnIndex"
                            class="linkVerticalDropZone"
                            @drop.stop.prevent="handleLinkDropToNewColumn($event, group, linkColIndex + 1)"
                            @dragover.prevent
                            @dragenter.prevent="dropManager.handleDragEnterVerticalZone($event)"
                            @dragleave="dropManager.handleDragLeaveVerticalZone($event)">
                          <div class="linkVerticalDropZoneIndicator"></div>
                        </td>
                      </template>
                    </tr>
                  </table>

                  <!-- Show more/less button for progressive loading (full width at bottom) -->
                  <div v-if="shouldShowExpandButton(group)"
                    class="mb-progressive-btn-wrapper">
                    <button
                      @click="toggleGroupExpansion(group)"
                      class="btn btn-sm w-100 mb-progressive-btn">
                      <span v-if="!group.linksExpanded">
                        {{ getTranslation('group.showMore') || 'Show more' }}
                      </span>
                      <span v-else>
                        {{ getTranslation('group.showLess') || 'Show less' }}
                      </span>
                    </button>
                  </div>



                  <div v-if="!data.options?.links?.addViaDialog"
                    class="input-group input-group-sm addLinkContainer mt-2">
                    <input v-model="group.newLinkText" type="text" class="form-control"
                      :placeholder="getTranslation('group.link.linkText')"
                      :aria-label="getTranslation('group.link.linkText')" :aria-describedby="'groupNewLink' + group.uuid"
                      @keyup.enter="addLink(group)">
                    <input v-model="group.newLinkUrl" type="text" class="form-control"
                      :placeholder="getTranslation('group.link.linkUrl')"
                      :aria-label="getTranslation('group.link.linkUrl')" :aria-describedby="'groupNewLink' + group.uuid"
                      @keyup.enter="addLink(group)">
                    <button @click="addLink(group)" :id="'groupNewLink' + group.uuid" type="button"
                      class="btn btn-sm btn-success">{{ getTranslation('group.link.add') }}</button>
                  </div>
                </div>
                <div v-if="!group.collapsed && canManuallyResizeGroupHeight(group)"
                  :class="['mb-group-resize-handle', { 'resizing': isGroupHeightResizing && groupHeightResizeState.groupUuid === group.uuid }]"
                  role="separator"
                  aria-orientation="horizontal"
                  :title="getTranslation('group.resizeHeight') || 'Drag to resize group height. Double-click to auto-fit this group.'"
                  @mousedown.stop.prevent="startGroupHeightResize($event, group)"
                  @dblclick.stop.prevent="autoFitGroupHeight(group)">
                  <span v-if="isGroupHeightResizing && groupHeightResizeState.groupUuid === group.uuid" class="mb-group-resize-readout">
                    {{ getGroupBodyHeight(group) }}px
                  </span>
                </div>
              </div>
            </template>
            <div v-if="getGroupsByColumn(colIndex).length > 0"
              :class="['groupContainerDragAndDrop', 'group-drop-zone']"
              @drop.stop.prevent="dropManager.onDrop($event, data.groups, null, getGroupsByColumn(colIndex).length, colIndex, 'group'); saveData()"
              @dragover.prevent @dragenter.prevent="dropManager.handleDragEnterZone($event)"
              @dragleave="dropManager.handleDragLeaveZone($event)">
              {{ getTranslation('group.dropAfter') }}
            </div>
    </div>
    </td>

    <!-- Vertikale Dropzone nach jeder Spalte -->
    <td class="verticalDropZone"
        @drop.stop.prevent="handleDropToNewColumn($event, colIndex + 1)"
        @dragover.prevent
        @dragenter.prevent="dropManager.handleDragEnterVerticalZone($event)"
        @dragleave="dropManager.handleDragLeaveVerticalZone($event)">
      <div class="verticalDropZoneIndicator"></div>
      <div v-if="groupColumnIndex < getGroupColumns().length - 1 && isManualGroupColumnWidthEnabled()"
           :class="['groupColumnResizeHandle', { 'resizing': isGroupColumnResizing && groupColumnResizeState.leftColumn === colIndex }]"
           role="separator"
           aria-orientation="vertical"
           :title="getTranslation('group.resizeWidth') || 'Drag to resize group column width'"
           @mousedown.stop.prevent="startGroupColumnResize($event, colIndex, getGroupColumns()[groupColumnIndex + 1])">
        <span v-if="isGroupColumnResizing && groupColumnResizeState.leftColumn === colIndex" class="groupColumnResizeReadout">
          {{ getGroupColumnWidthLabel(colIndex) }}
        </span>
      </div>
    </td>
    </template>
    </tr>
    </table>
    </div>
    <!-- End of Groups and Links Content Container -->

  <div id="groupMenu" class="context-menu mb-context-menu" :style="contextMenuStyle"
    :class="{ 'context-menu-visible': isGroupMenuVisible }">
    <ul v-if="contextGroup" class="mb-context-menu-list">
      <li @click="showGroupEditModal(contextGroup); hideMenus()">{{ getTranslation('menu.group.editGroup') }}</li>
      <li @click="duplicateGroup(contextGroup); hideMenus()">{{ getTranslation('menu.group.duplicate') }}</li>
      <li @click="openAddSeparatorDialog(contextGroup); hideMenus()">{{ getTranslation('menu.group.addSeparator') || 'Add separator…' }}</li>
      <li @click="openAddNoteDialog(contextGroup); hideMenus()">{{ getTranslation('menu.group.addNote') || 'Add note…' }}</li>
      <li class="submenu" tabindex="0">
        {{ getTranslation('menu.keywords') || 'Keywords' }}
        <ul class="context-submenu mb-context-submenu keyword-submenu">
          <li @click="openKeywordQuickDialogForGroup(contextGroup); hideMenus()">
            {{ getTranslation('menu.keyword.new') || 'New keyword' }}
          </li>
          <li class="separator mb-context-menu-separator"></li>
          <li v-if="getAssignedKeywordsForGroup(contextGroup).length === 0" class="disabled">
            {{ getTranslation('menu.keyword.noneAssigned') || 'No assigned keywords' }}
          </li>
          <li v-for="kw in getAssignedKeywordsForGroup(contextGroup)" :key="'group-menu-remove-kw-' + kw"
              @click="removeKeywordFromGroup(contextGroup, kw); hideMenus()">
            {{ (getTranslation('menu.keyword.remove') || 'Remove') + ': ' + kw }}
          </li>
          <li class="separator mb-context-menu-separator"></li>
          <li v-if="getAvailableKeywordsForGroup(contextGroup).length === 0" class="disabled">
            {{ getTranslation('menu.keyword.noneAvailable') || 'No remaining keywords' }}
          </li>
          <li v-for="kw in getAvailableKeywordsForGroup(contextGroup)" :key="'group-menu-add-kw-' + kw"
              @click="addKeywordToGroup(contextGroup, kw); hideMenus()">
            {{ (getTranslation('menu.keyword.add') || 'Add') + ': ' + kw }}
          </li>
        </ul>
      </li>
      <li v-if="shouldShowGroupSharingSection(contextGroup)" class="separator mb-context-menu-separator"></li>
      <li v-if="hasNtfyUrl() && hasConnectedContacts()" @click="shareGroup(contextGroup); hideMenus()">{{ getTranslation('menu.group.sendGroup') }}</li>
      <li v-if="hasNtfyUrl() && hasConnectedContacts() && (!contextGroup?.shared || isOwnerOfGroup(contextGroup))" @click="inviteMembers(contextGroup); hideMenus()">{{ getTranslation('menu.group.inviteMembers') }}</li>
      <li v-if="hasNtfyUrl() && contextGroup?.shared && isOwnerOfGroup(contextGroup)" @click="openOwnerTransferDialog(contextGroup); hideMenus()">{{ getTranslation('menu.group.transferOwnership') || 'Transfer ownership…' }}</li>
      <li v-if="hasNtfyUrl() && hasConnectedContacts()" @click="openMembersModal(contextGroup); hideMenus()">{{ getTranslation('menu.group.members') }}</li>
      <li v-if="shouldShowGroupSharingSection(contextGroup)" class="separator mb-context-menu-separator"></li>
      <li class="submenu" tabindex="0">
        {{ getTranslation('menu.group.sort') || 'Sort links' }}
        <ul class="context-submenu mb-context-submenu">
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'within-columns', direction: 'asc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.withinColumns') || 'Within columns (A→Z)' }}
          </li>
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'preserve-counts', direction: 'asc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.preserveCounts') || 'Global A→Z, preserve column sizes' }}
          </li>
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'rebalance-columns', direction: 'asc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.rebalance') || 'Global A→Z, rebalance columns' }}
          </li>
          <li class="separator mb-context-menu-separator"></li>
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'within-columns', direction: 'desc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.withinColumnsDesc') || 'Within columns (Z→A)' }}
          </li>
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'preserve-counts', direction: 'desc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.preserveCountsDesc') || 'Global Z→A, preserve column sizes' }}
          </li>
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'rebalance-columns', direction: 'desc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.rebalanceDesc') || 'Global Z→A, rebalance columns' }}
          </li>
        </ul>
      </li>
      <li class="separator mb-context-menu-separator"></li>
      <li @click="inspectGroupJSON(contextGroup); hideMenus()">{{ getTranslation('menu.group.inspectJSON') || 'Inspect JSON' }}</li>
      <li class="separator mb-context-menu-separator"></li>
      <li v-if="cssSidebarVisible" class="submenu" tabindex="0">
        {{ getTranslation('menu.group.copyForCss') || 'Copy for CSS' }}
        <ul class="context-submenu mb-context-submenu">
          <li @click="copyGroupCssClass(contextGroup); hideMenus()">{{ getTranslation('menu.group.copyCssClass') || 'Copy CSS class' }}</li>
          <li @click="copyGroupUuid(contextGroup); hideMenus()">{{ getTranslation('menu.group.copyUuid') || 'Copy UUID' }}</li>
          <li @click="copyGroupUuid(contextGroup, {shiftKey: true}); hideMenus()">{{ getTranslation('menu.group.copyCssSelector') || 'Copy CSS selector [data-group-uuid]' }}</li>
        </ul>
      </li>
      <li v-if="cssSidebarVisible" class="separator mb-context-menu-separator"></li>
      <li v-if="contextGroup?.shared && !isOwnerOfGroup(contextGroup)" @click="delGroup(contextGroup); hideMenus()">{{ getTranslation('menu.group.leaveGroup') || 'Leave group' }}</li>
      <li v-if="isOwnerOfGroup(contextGroup)" @click="delGroup(contextGroup); hideMenus()">{{ getTranslation('group.deleteGroup') }}</li>
    </ul>
  </div>
  
  <!-- Visual CSS Editor Sidebar -->
  <div v-if="cssSidebarVisible"
       class="css-sidebar mb-css-sidebar visual-css-editor-sidebar sidebar-open"
       :class="{
         'resizing': isCssSidebarWidthResizing,
         'template-dark-active': selectedVisualTemplate === 'dark-mode'
       }"
       :style="{ width: cssSidebarWidth + 'px' }">
    <!-- Resize Handle -->
    <div class="css-sidebar-resize-handle" :class="{ 'resizing': isCssSidebarWidthResizing }" @mousedown="startCssSidebarWidthResize"></div>
    <div class="sidebar-header mb-css-sidebar-header">
      <h5 class="mb-css-sidebar-title">{{ getTranslation('css.visual.title') || 'Visual CSS Editor' }}</h5>
      <button type="button" class="btn-close mb-css-sidebar-close" @click="closeCssSidebar()" aria-label="Close"></button>
    </div>
    <div ref="cssSidebarSplitContainer" class="sidebar-split-container mb-css-sidebar-container">
      <div class="sidebar-top-section mb-css-sidebar-top" :style="{ height: cssSidebarTopHeight + 'px' }">
        <!-- Visual CSS Rules Editor -->
        <div class="visual-css-editor" style="height: 100%; overflow-y: auto; padding: 15px;">

        <!-- Template Selection -->
        <div class="template-section mb-3">
          <h6 class="mb-2">{{ getTranslation('css.visual.templates') || 'CSS Vorlagen' }}</h6>
          <select v-model="selectedVisualTemplate"
                  @change="loadVisualTemplate"
                  class="form-select form-select-sm">
            <option :value="null">{{ getTranslation('css.visual.selectTemplate') || '-- Vorlage wählen --' }}</option>
            <optgroup :label="getTranslation('css.visual.defaultTemplates') || 'Standard-Vorlagen'">
              <option value="dark-mode">Dark Mode</option>
              <option value="minimal">Minimal</option>
              <option value="colorful">Colorful</option>
            </optgroup>
          </select>
        </div>

        <!-- CSS Rules List -->
      <div class="css-rules-container">
        <h6 class="mb-3">{{ getTranslation('css.visual.rules') || 'CSS Regeln' }}</h6>

        <!-- Design Tokens -->
        <div class="mb-3 p-2 border rounded design-tokens-section" :class="{ 'collapsed': designTokensCollapsed }">
          <div class="d-flex align-items-center justify-content-between mb-2 design-tokens-header">
            <div class="d-flex align-items-center gap-2">
              <button @click="toggleDesignTokensCollapse"
                      class="btn btn-sm btn-link p-0"
                      :title="getTranslation('css.visual.toggleCollapse') || 'Ein-/Ausklappen'"
                      style="width: 20px;">
                <span v-if="!designTokensCollapsed">▼</span>
                <span v-else>▶</span>
              </button>
              <strong class="mb-0">{{ getTranslation('css.visual.designTokens') || 'Design Tokens' }}</strong>
            </div>
            <button class="btn btn-sm btn-outline-primary" @click="addDesignToken">+
              {{ getTranslation('css.visual.addToken') || 'Token' }}</button>
          </div>
          <div v-show="!designTokensCollapsed">
            <div v-if="designTokens.length === 0" class="text-muted small mb-2">
              {{ getTranslation('css.visual.noTokens') || 'Noch keine Tokens. Füge welche hinzu (z. B. brand-primary (ohne --), #3b82f6)' }}
            </div>
            <div class="input-group input-group-sm mb-2" v-for="(t, ti) in designTokens" :key="'tok-'+ti">
              <span class="input-group-text">{{ getTranslation('css.visual.tokenName') || 'Name' }}</span>
              <input class="form-control"
                     :value="t.name"
                     @input="onTokenNameInput(t, $event)"
                     placeholder="token-name"
                     autocomplete="off"
                     spellcheck="false">
              <span class="input-group-text">{{ getTranslation('css.visual.tokenValue') || 'Wert' }}</span>
              <input class="form-control"
                     :class="{ 'is-invalid': !isTokenValueValid(t.value) }"
                     :value="t.value"
                     @input="onTokenValueInput(t, $event)"
                     placeholder="#rrggbb oder Wert"
                     autocomplete="off"
                     spellcheck="false">
              <span class="input-group-text p-0">
                <input type="color"
                       :value="getValidHexColor(t.value)"
                       @input="t.value = $event.target.value; saveDesignTokens()"
                       class="form-control form-control-color border-0"
                       style="width: 2rem; padding: 0;">
              </span>
              <button class="btn btn-outline-danger" @click="removeDesignToken(ti)">×</button>
            </div>
            <div v-for="(t, ti) in designTokens" :key="'tokhint-'+ti"
                 v-if="!isTokenValueValid(t.value)"
                 class="invalid-feedback d-block small mt-1">
              {{ getTokenValidationHint(t.value) }}
            </div>
            <div class="small text-muted">
              {{ getTranslation('css.visual.tokensHint') || 'Tokens per Dropdown neben den Properties einsetzen (var(--token)).' }}
            </div>
          </div>
        </div>

          <!-- Rule Sets Management -->
          <div class="rule-sets-section mb-3">
            <div class="d-flex align-items-center gap-2 mb-2">
              <label class="form-label small mb-0 text-nowrap">{{ getTranslation('css.visual.ruleSets') || 'Regel-Sätze' }}:</label>
              <select v-model="selectedRuleSetName"
                      @change="if(selectedRuleSetName) loadRuleSet(selectedRuleSetName)"
                      class="form-select form-select-sm flex-grow-1">
                <option :value="null">{{ getTranslation('css.visual.selectRuleSet') || '-- Wählen --' }}</option>
                <option v-for="(ruleSet, name) in customRuleSets"
                        :key="name"
                        :value="name">
                  {{ name }}
                </option>
              </select>
              <button @click="saveRuleSet"
                      class="btn btn-sm btn-outline-primary px-2"
                      :title="getTranslation('css.visual.saveCurrentRules') || 'Speichern'">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v7.293l2.646-2.647a.5.5 0 0 1 .708.708l-3.5 3.5a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L7.5 9.293V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1H2z"/>
                </svg>
              </button>
              <button @click="if(selectedRuleSetName) deleteRuleSet(selectedRuleSetName)"
                      :disabled="!selectedRuleSetName"
                      class="btn btn-sm btn-outline-danger px-2"
                      :title="getTranslation('css.visual.deleteRuleSet') || 'Löschen'">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                  <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                </svg>
              </button>
            </div>
          </div>

          <!-- Collapse/Expand All Buttons -->
          <div class="d-flex gap-2 mb-2 align-items-center">
            <button @click="expandAllRules()"
                    class="btn btn-sm btn-outline-secondary"
                    :title="getTranslation('css.visual.expandAll') || 'Alle aufklappen'">
              ▼
            </button>
            <button @click="collapseAllRules()"
                    class="btn btn-sm btn-outline-secondary"
                    :title="getTranslation('css.visual.collapseAll') || 'Alle zuklappen'">
              ▶
            </button>
            <input
              v-model="rulesFilterQuery"
              type="text"
              class="form-control form-control-sm flex-grow-1"
              style="min-width: 0;"
              :placeholder="getTranslation('css.visual.searchRules') || 'Rules durchsuchen…'"
            >
            
          </div>

          <!-- Each CSS Rule -->
          <div v-for="(rule, index) in visualCssRules"
               :key="rule.id"
               class="css-rule-card mb-3 p-3 border rounded"
               :class="{ 'opacity-50': !rule.enabled, 'collapsed': isRuleCollapsed(rule) }"
               v-show="matchesRuleSearch(rule)">

            <!-- Rule Header -->
            <div class="rule-header d-flex justify-content-between align-items-center mb-2">
              <div class="d-flex align-items-center flex-grow-1">
                <button @click="toggleRuleCollapse(rule)"
                        class="btn btn-sm btn-link p-0 me-2"
                        :title="getTranslation('css.visual.toggleCollapse') || 'Ein-/Ausklappen'"
                        style="width: 20px;">
                  <span v-if="!isRuleCollapsed(rule)">▼</span>
                  <span v-else>▶</span>
                </button>
                <div v-if="editingRuleId !== rule.id"
                     @dblclick="startEditingRuleName(rule)"
                     class="rule-number fw-bold"
                     style="cursor: pointer;"
                     :title="getTranslation('css.visual.doubleClickToEdit') || 'Doppelklick zum Bearbeiten'">
                  {{ rule.name || `${getTranslation('css.visual.rule') || 'Regel'} ${index + 1}` }}
                </div>
                <input v-else
                       v-model="editingRuleName"
                       @blur="saveRuleName(rule)"
                       @keyup.enter="saveRuleName(rule)"
                       @keyup.esc="cancelEditingRuleName()"
                       class="form-control form-control-sm"
                       style="max-width: 200px;"
                       type="text"
                       ref="ruleNameInput">
                <span v-if="!getRuleSelector(rule).base"
                      class="badge bg-warning text-dark ms-2"
                      :title="getTranslation('css.visual.selectElement') || '-- Element wählen --'">
                  {{ getTranslation('css.visual.selectElementShort') || 'Element wählen' }}
                </span>
              </div>
              <div class="rule-actions btn-group btn-group-sm">
                <button @click="startElementPicker(rule)"
                        class="btn btn-outline-secondary"
                        :class="{ active: elementPickerActive && currentPickerRule && currentPickerRule.id === rule.id }"
                        :title="getTranslation('css.visual.pickElement') || 'Element wählen'">🎯</button>
                <button @click="moveCssRuleUp(index)"
                        class="btn btn-outline-secondary"
                        :disabled="index === 0"
                        :title="getTranslation('css.visual.moveUp') || 'Nach oben'">▲</button>
                <button @click="moveCssRuleDown(index)"
                        class="btn btn-outline-secondary"
                        :disabled="index === visualCssRules.length - 1"
                        :title="getTranslation('css.visual.moveDown') || 'Nach unten'">▼</button>
                <button @click="toggleCssRule(rule)"
                        class="btn btn-outline-secondary"
                        :title="rule.enabled ? getTranslation('css.visual.deactivate') : getTranslation('css.visual.activate')">
                  {{ rule.enabled ? '👁️' : '👁️‍🗨️' }}
                </button>
                <button @click="duplicateCssRule(rule)"
                        class="btn btn-outline-secondary"
                        :title="getTranslation('css.visual.duplicate') || 'Duplizieren'">📋</button>
                <button @click="deleteCssRule(rule)"
                        class="btn btn-outline-danger"
                        :title="getTranslation('css.visual.delete') || 'Löschen'">×</button>
              </div>
            </div>

            <!-- Rule Content (Collapsible) -->
            <div v-show="!isRuleCollapsed(rule)">
              <!-- Selector Dropdowns -->
              <div class="selector-section mb-3">
              <!-- Base Selector -->
              <div class="selector-row mb-2 d-flex align-items-center">
                <label class="form-label small mb-0 me-2" style="min-width: 60px;">{{ getTranslation('css.visual.element') || 'Element' }}:</label>
                <select v-model="rule.selector.base"
                        @change="updateRuleBase(rule, $event)"
                        :ref="'baseSelector-' + rule.id"
                        class="form-select form-select-sm flex-grow-1">
                  <option value="">{{ getTranslation('css.visual.selectElement') || '-- Element wählen --' }}</option>
                  <optgroup :label="getTranslation('css.visual.appLevel') || 'App-Ebene'">
                    <option value="app">App Container</option>
                    <option value="header">Header</option>
                    <option value="toolbar">Toolbar</option>
                    <option value="footer">Footer</option>
                    <option value="groups-links-container">Groups & Links Container</option>
                  </optgroup>
                  <optgroup :label="getTranslation('css.visual.uiPrimitives') || 'UI Primitives'">
                    <option value="body">Body</option>
                    <option value="modal">Modal Container</option>
                    <option value="modal-header">Modal Header</option>
                    <option value="modal-body">Modal Body</option>
                    <option value="modal-footer">Modal Footer</option>
                    <option value="css-sidebar">CSS Sidebar</option>
                    <option value="feature-sidebar">Feature Sidebar</option>
                    <option value="sidebar-header">Sidebar Header</option>
                    <option value="sidebar-top-section">Sidebar Top Section</option>
                    <option value="sidebar-bottom-section">Sidebar Bottom Section</option>
                    <option value="sidebar-divider">Sidebar Divider</option>
                    <option value="card">Card</option>
                    <option value="card-header">Card Header</option>
                    <option value="list-group-item">List Item</option>
                    <option value="table">Table</option>
                    <option value="table-header">Table Header Cells</option>
                    <option value="table-cell">Table Cells</option>
                    <option value="form-control">Textbox / Input</option>
                    <option value="form-select">Select Box</option>
                    <option value="input-group-text">Input Prefix / Label</option>
                    <option value="form-check-input">Checkbox / Radio</option>
                    <option value="dropdown-menu">Dropdown Menu</option>
                    <option value="dropdown-item">Dropdown Item</option>
                    <option value="context-menu">Context Menu</option>
                    <option value="context-menu-item">Context Menu Item</option>
                    <option value="alert-info">Info Alert</option>
                    <option value="alert-warning">Warning Alert</option>
                    <option value="surface-panel">Surface Panel</option>
                    <option value="muted-text">Muted Text</option>
                  </optgroup>
                  <optgroup :label="getTranslation('css.visual.groupLevel') || 'Gruppen-Ebene'">
                    <option value="groups">{{ getTranslation('css.visual.allGroups') || 'Alle Gruppen' }}</option>
                    <option value="group-header">{{ getTranslation('css.visual.groupHeader') || 'Gruppen Header' }}</option>
                    <option value="group-title">{{ getTranslation('css.visual.groupTitle') || 'Gruppen Titel' }}</option>
                    <option value="group-body">{{ getTranslation('css.visual.groupContent') || 'Gruppen Inhalt' }}</option>
                    <option value="vertical-dropzone">Gruppen-Spalten Dropzone (vertikal)</option>
                    <option value="group-horizontal-dropzone">Gruppen Dropzone (horizontal)</option>
                  </optgroup>
                  <optgroup :label="getTranslation('css.visual.linkLevel') || 'Link-Ebene'">
                    <option value="links">{{ getTranslation('css.visual.allLinks') || 'Alle Links' }}</option>
                    <option value="separators">{{ getTranslation('css.visual.allSeparators') || 'Alle Trenner' }}</option>
                    <option value="notes">{{ getTranslation('css.visual.allNotes') || 'Alle Notizen' }}</option>
                    <option value="link-hover">{{ getTranslation('css.visual.linkHover') || 'Link (Hover)' }}</option>
                    <option value="link-anchor">{{ getTranslation('css.visual.linkAnchor') || 'Link Anchor' }}</option>
                    <option value="link-url">{{ getTranslation('css.visual.linkUrl') || 'Link URL' }}</option>
                    <option value="link-icon">{{ getTranslation('css.visual.linkIcon') || 'Link Icon' }}</option>
                    <option value="link-vertical-dropzone">Link-Spalten Dropzone (vertikal)</option>
                    <option value="link-horizontal-dropzone">Link Dropzone (horizontal)</option>
                  </optgroup>
                  <optgroup :label="getTranslation('css.visual.popoverLevel') || 'Link-Popover'">
                    <option value="link-popover">{{ getTranslation('css.visual.linkPopover') || 'Popover Container' }}</option>
                    <option value="link-popover-title">{{ getTranslation('css.visual.linkPopoverTitle') || 'Popover Titelzeile' }}</option>
                    <option value="link-popover-url">{{ getTranslation('css.visual.linkPopoverUrl') || 'Popover URL' }}</option>
                    <option value="link-popover-meta">{{ getTranslation('css.visual.linkPopoverMeta') || 'Popover Metadaten' }}</option>
                    <option value="link-popover-row">{{ getTranslation('css.visual.linkPopoverRow') || 'Popover Zeile' }}</option>
                    <option value="link-popover-label">{{ getTranslation('css.visual.linkPopoverLabel') || 'Popover Label' }}</option>
                    <option value="link-popover-value">{{ getTranslation('css.visual.linkPopoverValue') || 'Popover Wert' }}</option>
                    <option value="link-popover-value-muted">{{ getTranslation('css.visual.linkPopoverValueMuted') || 'Popover Wert (relativ)' }}</option>
                    <option value="link-popover-keywords">{{ getTranslation('css.visual.linkPopoverKeywords') || 'Popover Keywords' }}</option>
                    <option value="link-popover-badge">{{ getTranslation('css.visual.linkPopoverBadge') || 'Popover Keyword Badge' }}</option>
                    <option value="link-popover-favicon">{{ getTranslation('css.visual.linkPopoverFavicon') || 'Popover Favicon' }}</option>
                  </optgroup>
                  <optgroup :label="getTranslation('css.visual.keywords') || 'Keywords'">
                    <option value="keywords">{{ getTranslation('css.visual.allKeywords') || 'Alle Keywords (Keyword-Bar)' }}</option>
                    <option value="keywords-selected">{{ getTranslation('css.visual.selectedKeywords') || 'Selected Keywords (Keyword Bar)' }}</option>
                    <option value="keyword-selected-text">{{ getTranslation('css.visual.selectedKeywordText') || 'Selected Keyword Text' }}</option>
                    <option value="keywords-hierarchical">{{ getTranslation('css.visual.keywordsHierarchical') || 'Keywords (Hierarchisch)' }}</option>
                    <option value="keyword-by-name">{{ getTranslation('css.visual.keywordByName') || 'Keyword nach Name' }}</option>
                    <option value="keyword-suggestions">{{ getTranslation('css.visual.keywordSuggestions') || 'Keyword Suggestions List' }}</option>
                    <option value="keyword-suggestion-item">{{ getTranslation('css.visual.keywordSuggestionItem') || 'Keyword Suggestion Item' }}</option>
                  </optgroup>
                </select>
              </div>

              <!-- Pseudo State Selector -->
              <div v-if="getRuleSelector(rule).base"
                   class="selector-row mb-2 d-flex align-items-center">
                <label class="form-label small mb-0 me-2" style="min-width: 60px;">{{ getTranslation('css.visual.state') || 'Zustand' }}:</label>
                <div class="d-flex align-items-center flex-wrap gap-3">
                  <div class="form-check form-switch mb-0">
                    <input :id="'hover-state-' + rule.id"
                           class="form-check-input"
                           type="checkbox"
                           :checked="getRuleSelector(rule).base === 'link-hover' ? true : !!getRuleSelector(rule).hover"
                           :disabled="getRuleSelector(rule).base === 'link-hover'"
                           @change="updateRuleHover(rule, $event)">
                    <label class="form-check-label small"
                           :for="'hover-state-' + rule.id">
                      {{ getTranslation('css.visual.hoverState') || 'Hover (:hover)' }}
                    </label>
                  </div>
                  <div class="form-check form-switch mb-0">
                    <input :id="'drag-over-state-' + rule.id"
                           class="form-check-input"
                           type="checkbox"
                           :checked="!!getRuleSelector(rule).dragOver"
                           @change="updateRuleDragOver(rule, $event)">
                    <label class="form-check-label small"
                           :for="'drag-over-state-' + rule.id">
                      {{ getTranslation('css.visual.dragOverState') || 'Drag Over (.drag-over-active)' }}
                    </label>
                  </div>
                </div>
              </div>

              <!-- Group Selector (conditional) -->
              <div v-if="canSelectGroup(rule)"
                   class="selector-row mb-2 d-flex align-items-center">
                <label class="form-label small mb-0 me-2" style="min-width: 60px;">{{ getTranslation('css.visual.group') || 'Gruppe' }}:</label>
                <select :value="getRuleSelector(rule).groupId"
                        @change="updateRuleGroupId(rule, $event)"
                        class="form-select form-select-sm flex-grow-1">
                  <option :value="null">{{ getTranslation('css.visual.selectGroup') || '-- Alle Gruppen --' }}</option>
                  <option v-for="group in data.groups"
                          :key="group.id || group.uuid"
                          :value="group.id || group.uuid">
                    {{ group.name }}
                  </option>
                </select>
              </div>

              <!-- Link Selector (conditional) -->
              <div v-if="canSelectLink(rule)"
                   class="selector-row mb-2 d-flex align-items-center">
                <label class="form-label small mb-0 me-2" style="min-width: 60px;">
                  {{ getRuleSelector(rule).base === 'separators'
                    ? (getTranslation('css.visual.separatorShort') || 'Sep.')
                    : (getRuleSelector(rule).base === 'notes'
                      ? (getTranslation('css.visual.noteShort') || 'Note')
                      : (getTranslation('css.visual.link') || 'Link')) }}:
                </label>
                <select :value="getRuleSelector(rule).linkId"
                        @change="updateRuleLinkId(rule, $event)"
                        class="form-select form-select-sm flex-grow-1">
                  <option :value="null">
                    {{ getRuleSelector(rule).base === 'separators'
                      ? (getTranslation('css.visual.selectSeparator') || '-- Alle Trenner --')
                      : (getRuleSelector(rule).base === 'notes'
                        ? (getTranslation('css.visual.selectNote') || '-- Alle Notizen --')
                        : (getTranslation('css.visual.selectLink') || '-- Alle Links --')) }}
                  </option>
                  <option v-for="link in getLinksForRule(rule)"
                          :key="link.id || link.uuid"
                          :value="link.id || link.uuid">
                    {{ getCssRuleLinkLabel(link) }}
                  </option>
                </select>
              </div>

              <!-- Keyword Selector (for keyword selectors) -->
              <div v-if="getRuleSelector(rule).base === 'keyword-by-name' ||
                         getRuleSelector(rule).base === 'keywords-hierarchical'"
                   class="selector-row mb-2 d-flex align-items-center">
                <label class="form-label small mb-0 me-2" style="min-width: 60px;">{{ getTranslation('css.visual.keyword') || 'Keyword' }}:</label>
                <select :value="getRuleSelector(rule).keywordSlug || ''"
                        @change="updateRuleKeywordSlug(rule, $event)"
                        class="form-select form-select-sm flex-grow-1">
                  <option value="">-- Alle Keywords --</option>
                  <option v-for="kw in getKeywordsForRule(rule)"
                          :key="keywordSlug(kw)"
                          :value="keywordSlug(kw)">
                    {{ kw }}
                  </option>
                </select>
              </div>
            </div>

            <!-- CSS Properties -->
            <div class="properties-section">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <label class="form-label small mb-0">{{ getTranslation('css.visual.properties') || 'CSS Eigenschaften' }}:</label>
                <button v-if="Object.keys(rule.properties).length > 0 || rule.customCss"
                        @click="clearRuleProperties(rule)"
                        class="btn btn-sm btn-outline-danger px-2"
                        :title="getTranslation('css.visual.clearPropertiesTitle') || 'Alle Eigenschaften dieser Regel löschen'">
                  <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M2.5 1a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1H3v9a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V4h.5a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H10a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1H2.5zm3 4a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5zM8 5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7A.5.5 0 0 1 8 5zm3 .5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 1 0z"/>
                  </svg>
                  {{ getTranslation('css.visual.clearProperties') || 'Eigenschaften löschen' }}
                </button>
              </div>
              <div class="properties-grid">
                <!-- Existing Properties as Bootstrap 5 Input Groups -->
                <div v-for="(value, prop) in rule.properties"
                     :key="prop"
                     class="property-item mb-2"
                     :class="{
                       'opacity-50': isPropertyDisabled(rule, prop),
                       'property-editor-active': isCssPropertyEditorTarget(rule, prop)
                     }">
                  <!-- Custom CSS (multiline) with delete button -->
                  <div v-if="prop === 'custom'">
                    <div class="d-flex justify-content-between align-items-center mb-1">
                      <label class="form-label small mb-0">{{ formatPropertyName(prop) }}</label>
                      <button type="button" @click="removeProperty(rule, 'custom')"
                              class="btn btn-sm btn-outline-danger px-2">×</button>
                    </div>
                    <textarea
                      :id="'prop-' + rule.id + '-' + prop"
                      v-model="rule.properties[prop]"
                      @input="saveVisualCss"
                      class="form-control form-control-sm"
                      style="height: 84px; font-family: monospace; font-size: 12px;"
                      :placeholder="getTranslation('css.visual.customPropertiesHint') || 'z.B. display: flex;\njustify-content: center;'">
                    </textarea>
                  </div>

                  <!-- Color property: text + color picker + token + important + remove in one input-group -->
                  <div v-else-if="isColorProperty(prop)">
                    <div class="input-group input-group-sm">
                      <span class="input-group-text">{{ formatPropertyName(prop) }}</span>
                      <input
                        :id="'prop-' + rule.id + '-' + prop"
                        type="text"
                        v-model="rule.properties[prop]"
                        @input="saveVisualCss"
                        @blur="validateProperty(rule, prop)"
                        class="form-control"
                        :class="{ 'is-invalid': !isPropertyValid(rule, prop) }"
                        :placeholder="getTranslation('css.visual.valuePlaceholder') || 'Wert eingeben (z. B. #ff0000, rgb(), var(--...))'">
                      <button type="button"
                              class="btn btn-outline-secondary"
                              @click.stop="openCssPropertyEditor(rule, prop)"
                              :title="getTranslation('css.visual.openFormatEditor') || 'Open property format editor'">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492zm-4.796 3.246a4.796 4.796 0 1 1 9.592 0 4.796 4.796 0 0 1-9.592 0z"/>
                          <path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a1.873 1.873 0 0 1-2.547 1.136l-.29-.15c-1.64-.85-3.433.943-2.582 2.582l.15.29a1.873 1.873 0 0 1-1.136 2.547l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a1.873 1.873 0 0 1 1.136 2.547l-.15.29c-.851 1.64.943 3.434 2.582 2.582l.29-.15a1.873 1.873 0 0 1 2.547 1.136l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a1.873 1.873 0 0 1 2.547-1.136l.29.15c1.64.852 3.433-.943 2.582-2.582l-.15-.29a1.873 1.873 0 0 1 1.136-2.547l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a1.873 1.873 0 0 1-1.136-2.547l.15-.29c.851-1.64-.943-3.433-2.582-2.582l-.29.15a1.873 1.873 0 0 1-2.547-1.136l-.094-.319z"/>
                        </svg>
                      </button>
                      <span class="input-group-text p-0">
                        <input type="color"
                               :value="getValidHexColor(rule.properties[prop])"
                               @input="onColorPickerChange(rule, prop, $event)"
                               class="form-control form-control-color border-0"
                               style="width: 2rem; padding: 0;">
                      </span>
                      <select class="form-select" style="max-width: 170px;"
                              @change="applyTokenToProperty(rule, prop, $event.target.value)">
                        <option value="">{{ getTranslation('css.visual.tokensSelect') || '-- Token wählen --' }}</option>
                        <option v-for="t in designTokens" :value="t.name">{{ t.name }}</option>
                      </select>
                      <span class="input-group-text">
                        <input type="checkbox"
                               :id="'important-' + rule.id + '-' + prop"
                               class="form-check-input mt-0"
                               :checked="getPropertyImportant(rule, prop)"
                               @change="togglePropertyImportant(rule, prop)"
                               :title="getTranslation('css.visual.importantHint') || 'Override other styles with !important'">
                      </span>
                      <button @click="togglePropertyDisabled(rule, prop)"
                              class="btn btn-outline-secondary"
                              :title="isPropertyDisabled(rule, prop) ? (getTranslation('css.visual.activateProperty') || 'Aktivieren') : (getTranslation('css.visual.deactivateProperty') || 'Deaktivieren')">
                        {{ isPropertyDisabled(rule, prop) ? '👁️‍🗨️' : '👁️' }}
                      </button>
                      <button @click="removeProperty(rule, prop)"
                              class="btn btn-outline-danger">×</button>
                    </div>
                    <div v-if="!isPropertyValid(rule, prop)"
                         class="invalid-feedback d-block small mt-1">
                      {{ getPropertyValidationHint(rule, prop) }}
                    </div>
                  </div>

                  <!-- Default text property -->
                  <div v-else class="input-group input-group-sm">
                    <span class="input-group-text">{{ formatPropertyName(prop) }}</span>
                    <input
                      :id="'prop-' + rule.id + '-' + prop"
                      type="text"
                      v-model="rule.properties[prop]"
                      @input="saveVisualCss"
                      @blur="validateProperty(rule, prop)"
                      class="form-control"
                      :class="{ 'is-invalid': !isPropertyValid(rule, prop) }"
                      :placeholder="getTranslation('css.visual.valuePlaceholder') || 'Wert eingeben'">
                    <button type="button"
                            class="btn btn-outline-secondary"
                            @click.stop="openCssPropertyEditor(rule, prop)"
                            :title="getTranslation('css.visual.openFormatEditor') || 'Open property format editor'">
                      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492zm-4.796 3.246a4.796 4.796 0 1 1 9.592 0 4.796 4.796 0 0 1-9.592 0z"/>
                        <path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a1.873 1.873 0 0 1-2.547 1.136l-.29-.15c-1.64-.85-3.433.943-2.582 2.582l.15.29a1.873 1.873 0 0 1-1.136 2.547l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a1.873 1.873 0 0 1 1.136 2.547l-.15.29c-.851 1.64.943 3.434 2.582 2.582l.29-.15a1.873 1.873 0 0 1 2.547 1.136l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a1.873 1.873 0 0 1 2.547-1.136l.29.15c1.64.852 3.433-.943 2.582-2.582l-.15-.29a1.873 1.873 0 0 1 1.136-2.547l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a1.873 1.873 0 0 1-1.136-2.547l.15-.29c.851-1.64-.943-3.433-2.582-2.582l-.29.15a1.873 1.873 0 0 1-2.547-1.136l-.094-.319z"/>
                      </svg>
                    </button>
                    <select class="form-select" style="max-width: 170px;"
                            @change="applyTokenToProperty(rule, prop, $event.target.value)">
                      <option value="">{{ getTranslation('css.visual.tokensSelect') || '-- Token wählen --' }}</option>
                      <option v-for="t in designTokens" :value="t.name">{{ t.name }}</option>
                    </select>
                    <span class="input-group-text">
                      <input type="checkbox"
                             :id="'important-' + rule.id + '-' + prop"
                             class="form-check-input mt-0"
                             :checked="getPropertyImportant(rule, prop)"
                             @change="togglePropertyImportant(rule, prop)"
                             :title="getTranslation('css.visual.importantHint') || 'Override other styles with !important'">
                    </span>
                    <button @click="togglePropertyDisabled(rule, prop)"
                            class="btn btn-outline-secondary"
                            :title="isPropertyDisabled(rule, prop) ? (getTranslation('css.visual.activateProperty') || 'Aktivieren') : (getTranslation('css.visual.deactivateProperty') || 'Deaktivieren')">
                      {{ isPropertyDisabled(rule, prop) ? '👁️‍🗨️' : '👁️' }}
                    </button>
                    <button @click="removeProperty(rule, prop)"
                            class="btn btn-outline-danger">×</button>
                  </div>
                  <div v-if="prop !== 'custom' && !isColorProperty(prop) && !isPropertyValid(rule, prop)"
                       class="invalid-feedback d-block small mt-1">
                    {{ getPropertyValidationHint(rule, prop) }}
                  </div>
                </div>

                <!-- Add New Property -->
                <div class="property-add">
                  <select @change.stop="addPropertyToRule(rule, $event)"
                          class="form-select form-select-sm">
                    <option value="">{{ getTranslation('css.visual.addProperty') || '+ Eigenschaft hinzufügen...' }}</option>
                    <option value="custom" :disabled="isPropertyInRule(rule, 'custom')">{{ getTranslation('css.visual.customCss') || 'Custom CSS' }}</option>
                    <optgroup :label="getTranslation('css.visual.colors') || 'Farben'">
                      <option value="background" :disabled="isPropertyInRule(rule, 'background')">{{ getTranslation('css.background') || 'Hintergrund' }}</option>
                      <option value="background-color" :disabled="isPropertyInRule(rule, 'background-color')">{{ getTranslation('css.backgroundColor') || 'Hintergrundfarbe' }}</option>
                      <option value="color" :disabled="isPropertyInRule(rule, 'color')">{{ getTranslation('css.textColor') || 'Textfarbe' }}</option>
                      <option value="border-color" :disabled="isPropertyInRule(rule, 'border-color')">{{ getTranslation('css.borderColor') || 'Rahmenfarbe' }}</option>
                    </optgroup>
                    <optgroup :label="getTranslation('css.visual.borders') || 'Rahmen (Border)'">
                      <option value="border" :disabled="isPropertyInRule(rule, 'border')">{{ getTranslation('css.border') || 'Rahmen' }} ({{ getTranslation('css.visual.complete') || 'komplett' }})</option>
                      <option value="border-width" :disabled="isPropertyInRule(rule, 'border-width')">{{ getTranslation('css.borderWidth') || 'Rahmenbreite' }}</option>
                      <option value="border-style" :disabled="isPropertyInRule(rule, 'border-style')">{{ getTranslation('css.borderStyle') || 'Rahmenstil' }}</option>
                      <option value="border-radius" :disabled="isPropertyInRule(rule, 'border-radius')">{{ getTranslation('css.borderRadius') || 'Eckenradius' }}</option>
                      <option value="border-top">{{ getTranslation('css.border') || 'Rahmen' }} {{ getTranslation('css.top') || 'oben' }}</option>
                      <option value="border-right">{{ getTranslation('css.border') || 'Rahmen' }} {{ getTranslation('css.right') || 'rechts' }}</option>
                      <option value="border-bottom">{{ getTranslation('css.border') || 'Rahmen' }} {{ getTranslation('css.bottom') || 'unten' }}</option>
                      <option value="border-left">{{ getTranslation('css.border') || 'Rahmen' }} {{ getTranslation('css.left') || 'links' }}</option>
                      <option value="border-top-width">{{ getTranslation('css.borderWidth') || 'Rahmenbreite' }} {{ getTranslation('css.top') || 'oben' }}</option>
                      <option value="border-right-width">{{ getTranslation('css.borderWidth') || 'Rahmenbreite' }} {{ getTranslation('css.right') || 'rechts' }}</option>
                      <option value="border-bottom-width">{{ getTranslation('css.borderWidth') || 'Rahmenbreite' }} {{ getTranslation('css.bottom') || 'unten' }}</option>
                      <option value="border-left-width">{{ getTranslation('css.borderWidth') || 'Rahmenbreite' }} {{ getTranslation('css.left') || 'links' }}</option>
                      <option value="border-top-style">{{ getTranslation('css.borderStyle') || 'Rahmenstil' }} {{ getTranslation('css.top') || 'oben' }}</option>
                      <option value="border-right-style">{{ getTranslation('css.borderStyle') || 'Rahmenstil' }} {{ getTranslation('css.right') || 'rechts' }}</option>
                      <option value="border-bottom-style">{{ getTranslation('css.borderStyle') || 'Rahmenstil' }} {{ getTranslation('css.bottom') || 'unten' }}</option>
                      <option value="border-left-style">{{ getTranslation('css.borderStyle') || 'Rahmenstil' }} {{ getTranslation('css.left') || 'links' }}</option>
                      <option value="border-top-color">{{ getTranslation('css.borderColor') || 'Rahmenfarbe' }} {{ getTranslation('css.top') || 'oben' }}</option>
                      <option value="border-right-color">{{ getTranslation('css.borderColor') || 'Rahmenfarbe' }} {{ getTranslation('css.right') || 'rechts' }}</option>
                      <option value="border-bottom-color">{{ getTranslation('css.borderColor') || 'Rahmenfarbe' }} {{ getTranslation('css.bottom') || 'unten' }}</option>
                      <option value="border-left-color">{{ getTranslation('css.borderColor') || 'Rahmenfarbe' }} {{ getTranslation('css.left') || 'links' }}</option>
                      <option value="border-top-left-radius">{{ getTranslation('css.borderRadius') || 'Eckenradius' }} {{ getTranslation('css.topLeft') || 'oben links' }}</option>
                      <option value="border-top-right-radius">{{ getTranslation('css.borderRadius') || 'Eckenradius' }} {{ getTranslation('css.topRight') || 'oben rechts' }}</option>
                      <option value="border-bottom-left-radius">{{ getTranslation('css.borderRadius') || 'Eckenradius' }} {{ getTranslation('css.bottomLeft') || 'unten links' }}</option>
                      <option value="border-bottom-right-radius">{{ getTranslation('css.borderRadius') || 'Eckenradius' }} {{ getTranslation('css.bottomRight') || 'unten rechts' }}</option>
                      <option value="outline">{{ getTranslation('css.outline') || 'Umrisslinie' }}</option>
                      <option value="outline-width">{{ getTranslation('css.outlineWidth') || 'Umrissbreite' }}</option>
                      <option value="outline-style">{{ getTranslation('css.outlineStyle') || 'Umrissstil' }}</option>
                      <option value="outline-color">{{ getTranslation('css.outlineColor') || 'Umrissfarbe' }}</option>
                      <option value="outline-offset">{{ getTranslation('css.outlineOffset') || 'Umrissabstand' }}</option>
                    </optgroup>
                    <optgroup :label="getTranslation('css.visual.sizes') || 'Größen'">
                      <option value="font-size">{{ getTranslation('css.fontSize') || 'Schriftgröße' }}</option>
                      <option value="padding">{{ getTranslation('css.padding') || 'Innenabstand' }}</option>
                      <option value="margin">{{ getTranslation('css.margin') || 'Außenabstand' }}</option>
                      <option value="width">{{ getTranslation('css.width') || 'Breite' }}</option>
                      <option value="height">{{ getTranslation('css.height') || 'Höhe' }}</option>
                    </optgroup>
                    <optgroup :label="getTranslation('css.visual.effects') || 'Effekte'">
                      <option value="box-shadow">{{ getTranslation('css.boxShadow') || 'Schatten' }}</option>
                      <option value="opacity">{{ getTranslation('css.opacity') || 'Transparenz' }}</option>
                    </optgroup>
                    <optgroup :label="getTranslation('css.visual.typography') || 'Text'">
                      <option value="font-family">{{ getTranslation('css.fontFamily') || 'Schriftfamilie' }}</option>
                      <option value="font-weight">{{ getTranslation('css.fontWeight') || 'Schriftstärke' }}</option>
                      <option value="text-decoration">{{ getTranslation('css.textDecoration') || 'Textdekoration' }}</option>
                      <option value="text-align">{{ getTranslation('css.textAlign') || 'Textausrichtung' }}</option>
                    </optgroup>
                  </select>
                </div>

                <!-- Apply preset to rule -->
                <div class="property-add mt-2">
                  <select @change="applyPresetToRule(rule, $event)" class="form-select form-select-sm">
                    <option value="">{{ getTranslation('css.visual.applyPreset') || 'Preset anwenden…' }}</option>
                    <option v-for="p in cssPresets" :value="p.id">{{ p.name }}</option>
                  </select>
                </div>

                
              </div>
            </div>

            
            </div> <!-- End of collapsible content -->
          </div>

          <!-- Add New Rule and Clear All Buttons -->
          <div class="d-flex gap-2 mb-3">
            <button @click="addNewCssRule" class="btn btn-success flex-grow-1">
              + {{ getTranslation('css.visual.addRule') || 'Neue CSS Regel hinzufügen' }}
            </button>
            <button @click="clearAllCssSettings"
                    class="btn btn-outline-danger"
                    :title="getTranslation('css.visual.clearAllTooltip') || 'Alle CSS Einstellungen löschen'">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828l6.879-6.879zm2.121.707a1 1 0 0 0-1.414 0L4.16 7.547l5.293 5.293 4.633-4.633a1 1 0 0 0 0-1.414l-3.879-3.879zM8.746 13.547 3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293l.16-.16z"/>
              </svg>
              {{ getTranslation('css.visual.clearAll') || 'Alles löschen' }}
            </button>
          </div>
        </div>

        

        <!-- Migration Notice (if old CSS exists) -->
          <div v-if="showMigrationNotice" class="alert alert-info mt-3">
            {{ getTranslation('css.visual.migrationNotice') || 'Hinweis: Ihr bisheriges Custom CSS wurde importiert. Sie können es oben als "Legacy CSS" Regel bearbeiten oder löschen.' }}
          </div>
        </div>
      </div>

      <div class="sidebar-divider mb-css-sidebar-divider"
           :class="{ 'resizing': isCssSidebarResizing }"
           @mousedown="startCssSidebarResize"></div>

      <div class="sidebar-bottom-section mb-css-property-editor">
        <div class="editor-header mb-css-property-editor-header">
          <div>
            <strong>{{ getTranslation('css.visual.formatEditor') || 'Property Format Editor' }}</strong>
            <div class="small text-muted" v-if="cssPropertyEditor.property && cssPropertyEditorRule">
              {{ formatPropertyName(cssPropertyEditor.property) }}
              <span class="mx-1">·</span>
              {{ cssPropertyEditorRule.name || ((getTranslation('css.visual.rule') || 'Rule') + ' ' + ((visualCssRules.indexOf(cssPropertyEditorRule) || 0) + 1)) }}
            </div>
          </div>
          <button type="button"
                  class="btn btn-sm btn-outline-secondary"
                  :disabled="!cssPropertyEditor.property"
                  @click="clearCssPropertyEditorSelection"
                  :title="getTranslation('close') || 'Close'">
            ×
          </button>
        </div>
        <div class="editor-content mb-css-property-editor-content">
          <div v-if="!cssPropertyEditor.property || !cssPropertyEditorRule" class="text-muted small">
            {{ getTranslation('css.visual.formatEditorNoSelection') || 'Select a property with the gear button next to "Enter value...".' }}
          </div>
          <div v-else>
            <div class="options-section mb-edit-section mb-2">
              <div class="options-section-header mb-edit-section-header"
                   :class="{ collapsed: !isCssPropertyEditorSectionExpanded('basic') }"
                   @click="toggleCssPropertyEditorSection('basic')">
                <span>{{ getTranslation('css.visual.formatEditorBasic') || 'Basic' }}</span>
                <svg class="chevron-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                </svg>
              </div>
              <div v-show="isCssPropertyEditorSectionExpanded('basic')" class="options-section-body mb-edit-section-body">
                <div class="small mb-1"><strong>{{ getTranslation('css.visual.formatEditorProperty') || 'Property' }}:</strong> <code>{{ cssPropertyEditor.property }}</code></div>
                <div class="small mb-1"><strong>{{ getTranslation('css.visual.formatEditorType') || 'Type' }}:</strong> {{ getCssPropertySchema(cssPropertyEditor.property).kind }}</div>
                <div class="small mb-0"><strong>{{ getTranslation('css.visual.formatEditorPreview') || 'Preview' }}:</strong> <code>{{ getCssPropertyEditorPreviewValue() || '—' }}</code></div>
              </div>
            </div>

            <div class="options-section mb-edit-section mb-2">
              <div class="options-section-header mb-edit-section-header"
                   :class="{ collapsed: !isCssPropertyEditorSectionExpanded('value') }"
                   @click="toggleCssPropertyEditorSection('value')">
                <span>{{ getTranslation('css.visual.formatEditorValue') || 'Value Builder' }}</span>
                <svg class="chevron-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                </svg>
              </div>
              <div v-show="isCssPropertyEditorSectionExpanded('value')" class="options-section-body mb-edit-section-body">
                <div v-if="cssPropertyEditor.useRawValue" class="small text-muted">
                  {{ getTranslation('css.visual.formatEditorRawEnabled') || 'Raw mode enabled. Disable it to use guided controls.' }}
                </div>

                <div v-else-if="getCssPropertySchema(cssPropertyEditor.property).kind === 'color'" class="row g-2">
                  <div class="col-5">
                    <label class="form-label small mb-1">{{ getTranslation('css.visual.color') || 'Color' }}</label>
                    <input type="color" class="form-control form-control-color"
                           :value="cssPropertyEditor.model.color"
                           @input="onCssPropertyEditorColorInput($event.target.value)">
                  </div>
                  <div class="col-7">
                    <label class="form-label small mb-1">{{ getTranslation('css.visual.alpha') || 'Alpha' }}</label>
                    <input type="range" min="0" max="1" step="0.01" class="form-range"
                           v-model.number="cssPropertyEditor.model.alpha"
                           @input="onCssPropertyEditorModelChange">
                  </div>
                  <div class="col-12" v-if="(designTokens || []).length > 0">
                    <label class="form-label small mb-1">{{ getTranslation('css.visual.tokensSelect') || '-- Select Token --' }}</label>
                    <select class="form-select form-select-sm"
                            v-model="cssPropertyEditor.model.tokenName"
                            @change="onCssPropertyEditorTokenChange">
                      <option value="">{{ getTranslation('css.visual.none') || 'None' }}</option>
                      <option v-for="t in designTokens" :key="'editor-token-' + t.name" :value="t.name">{{ t.name }}</option>
                    </select>
                  </div>
                </div>

                <div v-else-if="getCssPropertySchema(cssPropertyEditor.property).kind === 'font-family'" class="row g-2">
                  <div class="col-12">
                    <label class="form-label small mb-1">{{ getTranslation('css.fontFamily') || 'Font Family' }}</label>
                    <select class="form-select form-select-sm"
                            v-model="cssPropertyEditor.model.fontFamily"
                            @change="onCssPropertyEditorModelChange">
                      <option value="">{{ getTranslation('css.visual.fontFamilyCustom') || '-- Custom value --' }}</option>
                      <option v-for="font in cssPropertyEditorFonts" :key="'font-opt-' + font.value" :value="font.value">{{ font.label }}</option>
                    </select>
                  </div>
                  <div class="col-12">
                    <input type="text"
                           class="form-control form-control-sm"
                           v-model="cssPropertyEditor.model.fontFamilyCustom"
                           @input="onCssPropertyEditorModelChange"
                           :placeholder="getTranslation('css.visual.fontFamilyCustom') || 'Custom font-family value'">
                  </div>
                </div>

                <div v-else-if="getCssPropertySchema(cssPropertyEditor.property).kind === 'enum'" class="row g-2">
                  <div class="col-12">
                    <label class="form-label small mb-1">{{ getTranslation('css.visual.value') || 'Value' }}</label>
                    <select class="form-select form-select-sm"
                            v-model="cssPropertyEditor.model.enumValue"
                            @change="onCssPropertyEditorModelChange">
                      <option v-for="opt in getCssPropertySchema(cssPropertyEditor.property).options || []"
                              :key="'enum-opt-' + opt"
                              :value="opt">{{ opt }}</option>
                    </select>
                  </div>
                </div>

                <div v-else-if="getCssPropertySchema(cssPropertyEditor.property).kind === 'number'" class="row g-2">
                  <div class="col-12">
                    <label class="form-label small mb-1">{{ getTranslation('css.visual.value') || 'Value' }}</label>
                    <input type="range"
                           class="form-range"
                           :min="getCssPropertySchema(cssPropertyEditor.property).min"
                           :max="getCssPropertySchema(cssPropertyEditor.property).max"
                           :step="getCssPropertySchema(cssPropertyEditor.property).step || 1"
                           v-model.number="cssPropertyEditor.model.numberValue"
                           @input="onCssPropertyEditorModelChange">
                    <input type="number"
                           class="form-control form-control-sm"
                           :min="getCssPropertySchema(cssPropertyEditor.property).min"
                           :max="getCssPropertySchema(cssPropertyEditor.property).max"
                           :step="getCssPropertySchema(cssPropertyEditor.property).step || 1"
                           v-model.number="cssPropertyEditor.model.numberValue"
                           @input="onCssPropertyEditorModelChange">
                  </div>
                </div>

                <div v-else-if="getCssPropertySchema(cssPropertyEditor.property).kind === 'length'" class="row g-2">
                  <div class="col-5">
                    <label class="form-label small mb-1">{{ getTranslation('css.visual.value') || 'Value' }}</label>
                    <input type="number"
                           class="form-control form-control-sm"
                           :step="getCssPropertySchema(cssPropertyEditor.property).step || 1"
                           v-model.number="cssPropertyEditor.model.lengthValue"
                           @input="onCssPropertyEditorModelChange">
                  </div>
                  <div class="col-3">
                    <label class="form-label small mb-1">{{ getTranslation('css.unit') || 'Unit' }}</label>
                    <select class="form-select form-select-sm"
                            v-model="cssPropertyEditor.model.lengthUnit"
                            @change="onCssPropertyEditorModelChange">
                      <option v-for="unit in getCssPropertySchema(cssPropertyEditor.property).units || []" :key="'len-unit-' + unit" :value="unit">{{ unit }}</option>
                    </select>
                  </div>
                  <div class="col-4" v-if="(getCssPropertySchema(cssPropertyEditor.property).keywords || []).length > 0">
                    <label class="form-label small mb-1">{{ getTranslation('css.visual.keyword') || 'Keyword' }}</label>
                    <select class="form-select form-select-sm"
                            v-model="cssPropertyEditor.model.lengthKeyword"
                            @change="onCssPropertyEditorModelChange">
                      <option value="">{{ getTranslation('css.visual.none') || 'None' }}</option>
                      <option v-for="kw in getCssPropertySchema(cssPropertyEditor.property).keywords || []" :key="'len-kw-' + kw" :value="kw">{{ kw }}</option>
                    </select>
                  </div>
                </div>

                <div v-else-if="getCssPropertySchema(cssPropertyEditor.property).kind === 'spacing'" class="row g-2">
                  <div class="col-12 d-flex align-items-center justify-content-between">
                    <label class="form-label small mb-0">{{ getTranslation('css.spacing') || 'Spacing' }}</label>
                    <div class="form-check form-switch">
                      <input class="form-check-input"
                             type="checkbox"
                             :id="'css-property-editor-link-' + cssPropertyEditor.property"
                             v-model="cssPropertyEditor.model.spacingLinked"
                             @change="onCssPropertyEditorSpacingLinked">
                      <label class="form-check-label small" :for="'css-property-editor-link-' + cssPropertyEditor.property">
                        {{ getTranslation('css.visual.linkValues') || 'Link values' }}
                      </label>
                    </div>
                  </div>
                  <div class="col-12" v-if="cssPropertyEditor.model.spacingLinked">
                    <div class="input-group input-group-sm">
                      <input type="number" class="form-control"
                             v-model.number="cssPropertyEditor.model.spacing.top.value"
                             @input="onCssPropertyEditorSpacingInput('top')">
                      <select class="form-select"
                              v-model="cssPropertyEditor.model.spacing.top.unit"
                              @change="onCssPropertyEditorSpacingInput('top')">
                        <option v-for="unit in getCssPropertySchema(cssPropertyEditor.property).units || []" :key="'sp-unit-all-' + unit" :value="unit">{{ unit }}</option>
                      </select>
                    </div>
                  </div>
                  <template v-else>
                    <div class="col-6" v-for="side in ['top', 'right', 'bottom', 'left']" :key="'spacing-side-' + side">
                      <label class="form-label small mb-1 text-capitalize">{{ side }}</label>
                      <div class="input-group input-group-sm">
                        <input type="number" class="form-control"
                               v-model.number="cssPropertyEditor.model.spacing[side].value"
                               @input="onCssPropertyEditorModelChange">
                        <select class="form-select"
                                v-model="cssPropertyEditor.model.spacing[side].unit"
                                @change="onCssPropertyEditorModelChange">
                          <option v-for="unit in getCssPropertySchema(cssPropertyEditor.property).units || []" :key="'sp-unit-' + side + '-' + unit" :value="unit">{{ unit }}</option>
                        </select>
                      </div>
                    </div>
                  </template>
                </div>

                <div v-else-if="getCssPropertySchema(cssPropertyEditor.property).kind === 'border'" class="row g-2">
                  <div class="col-4">
                    <label class="form-label small mb-1">{{ getTranslation('css.borderWidth') || 'Border Width' }}</label>
                    <input type="number" class="form-control form-control-sm"
                           :step="0.1"
                           v-model.number="cssPropertyEditor.model.border.width"
                           @input="onCssPropertyEditorModelChange">
                  </div>
                  <div class="col-3">
                    <label class="form-label small mb-1">{{ getTranslation('css.unit') || 'Unit' }}</label>
                    <select class="form-select form-select-sm"
                            v-model="cssPropertyEditor.model.border.unit"
                            @change="onCssPropertyEditorModelChange">
                      <option v-for="unit in ['px', 'rem', 'em']" :key="'bd-unit-' + unit" :value="unit">{{ unit }}</option>
                    </select>
                  </div>
                  <div class="col-5">
                    <label class="form-label small mb-1">{{ getTranslation('css.borderStyle') || 'Border Style' }}</label>
                    <select class="form-select form-select-sm"
                            v-model="cssPropertyEditor.model.border.style"
                            @change="onCssPropertyEditorModelChange">
                      <option v-for="styleOpt in getCssEnumOptions('border-style')" :key="'bd-style-' + styleOpt" :value="styleOpt">{{ styleOpt }}</option>
                    </select>
                  </div>
                  <div class="col-12">
                    <label class="form-label small mb-1">{{ getTranslation('css.borderColor') || 'Border Color' }}</label>
                    <div class="d-flex align-items-center gap-2">
                      <input type="color" class="form-control form-control-color"
                             :value="cssPropertyEditor.model.border.color"
                             @input="onCssPropertyEditorBorderColorInput($event.target.value)">
                      <input type="range" min="0" max="1" step="0.01" class="form-range flex-grow-1"
                             v-model.number="cssPropertyEditor.model.border.alpha"
                             @input="onCssPropertyEditorModelChange">
                    </div>
                  </div>
                </div>

                <div v-else-if="getCssPropertySchema(cssPropertyEditor.property).kind === 'shadow'" class="row g-2">
                  <div class="col-6">
                    <label class="form-label small mb-1">X</label>
                    <input type="number" class="form-control form-control-sm" v-model.number="cssPropertyEditor.model.shadow.offsetX" @input="onCssPropertyEditorModelChange">
                  </div>
                  <div class="col-6">
                    <label class="form-label small mb-1">Y</label>
                    <input type="number" class="form-control form-control-sm" v-model.number="cssPropertyEditor.model.shadow.offsetY" @input="onCssPropertyEditorModelChange">
                  </div>
                  <div class="col-6">
                    <label class="form-label small mb-1">{{ getTranslation('css.blur') || 'Blur' }}</label>
                    <input type="number" class="form-control form-control-sm" v-model.number="cssPropertyEditor.model.shadow.blur" @input="onCssPropertyEditorModelChange">
                  </div>
                  <div class="col-6">
                    <label class="form-label small mb-1">{{ getTranslation('css.spread') || 'Spread' }}</label>
                    <input type="number" class="form-control form-control-sm" v-model.number="cssPropertyEditor.model.shadow.spread" @input="onCssPropertyEditorModelChange">
                  </div>
                  <div class="col-12 d-flex align-items-center gap-2">
                    <input type="color" class="form-control form-control-color"
                           :value="cssPropertyEditor.model.shadow.color"
                           @input="onCssPropertyEditorShadowColorInput($event.target.value)">
                    <input type="range" min="0" max="1" step="0.01" class="form-range flex-grow-1"
                           v-model.number="cssPropertyEditor.model.shadow.alpha"
                           @input="onCssPropertyEditorModelChange">
                    <div class="form-check mb-0">
                      <input class="form-check-input" type="checkbox" :id="'shadow-inset-' + cssPropertyEditor.property"
                             v-model="cssPropertyEditor.model.shadow.inset"
                             @change="onCssPropertyEditorModelChange">
                      <label class="form-check-label small" :for="'shadow-inset-' + cssPropertyEditor.property">inset</label>
                    </div>
                  </div>
                </div>

                <div v-else class="small text-muted">
                  {{ getTranslation('css.visual.formatEditorRawOnly') || 'This property uses raw mode only.' }}
                </div>
              </div>
            </div>

            <div class="options-section mb-edit-section">
              <div class="options-section-header mb-edit-section-header"
                   :class="{ collapsed: !isCssPropertyEditorSectionExpanded('advanced') }"
                   @click="toggleCssPropertyEditorSection('advanced')">
                <span>{{ getTranslation('css.visual.formatEditorAdvanced') || 'Advanced' }}</span>
                <svg class="chevron-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                </svg>
              </div>
              <div v-show="isCssPropertyEditorSectionExpanded('advanced')" class="options-section-body mb-edit-section-body">
                <div class="form-check form-switch mb-2">
                  <input class="form-check-input"
                         type="checkbox"
                         :id="'css-property-editor-raw-' + cssPropertyEditor.property"
                         v-model="cssPropertyEditor.useRawValue"
                         @change="onCssPropertyEditorRawModeToggle">
                  <label class="form-check-label small" :for="'css-property-editor-raw-' + cssPropertyEditor.property">
                    {{ getTranslation('css.visual.formatEditorUseRaw') || 'Edit as raw CSS value' }}
                  </label>
                </div>
                <div class="mb-2">
                  <label class="form-label small mb-1">{{ getTranslation('css.visual.value') || 'Value' }}</label>
                  <input type="text"
                         class="form-control form-control-sm"
                         :class="{ 'is-invalid': !isCssPropertyEditorDraftValid() }"
                         v-model="cssPropertyEditor.rawValue"
                         @input="onCssPropertyEditorRawInput"
                         :placeholder="getTranslation('css.visual.valuePlaceholder') || 'Enter value (e.g., #ff0000, rgb(), var(--...))'">
                  <div v-if="!isCssPropertyEditorDraftValid()" class="invalid-feedback d-block">
                    {{ getCssPropertyEditorValidationHint() }}
                  </div>
                </div>
                <div class="form-check form-switch mb-3">
                  <input class="form-check-input"
                         type="checkbox"
                         :id="'css-property-editor-important-' + cssPropertyEditor.property"
                         v-model="cssPropertyEditor.important"
                         @change="onCssPropertyEditorImportantToggle">
                  <label class="form-check-label small" :for="'css-property-editor-important-' + cssPropertyEditor.property">
                    !important
                  </label>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Sync Progress (bottom-right) -->
  <div v-if="syncInProgress" class="mb-sync-progress" role="status" aria-live="polite">
    <div class="mb-sync-title">{{ syncProgressText || (getTranslation('sync.progress') || 'Sync in progress…') }}</div>
    <div class="progress">
      <div class="progress-bar" role="progressbar" :style="{ width: Math.max(0, Math.min(100, syncProgress)) + '%' }" :aria-valuenow="Math.round(syncProgress)" aria-valuemin="0" aria-valuemax="100"></div>
    </div>
    <div class="text-end mt-1" style="font-size: 11px; opacity: .8;">{{ Math.round(syncProgress) }}%</div>
  </div>

  <!-- Feature Overview Sidebar -->
  <div v-if="featureSidebarVisible" class="feature-sidebar mb-feature-sidebar" 
       :class="{ 'sidebar-open': featureSidebarVisible }" 
       :style="{ width: '450px', right: featureSidebarVisible ? 0 : '-450px' }">
    <div class="sidebar-header mb-feature-sidebar-header">
      <h5 class="mb-feature-sidebar-title">🚀 Feature Overview / Hilfe</h5>
      <button type="button" class="btn-close mb-feature-sidebar-close" @click="featureSidebarVisible=false" aria-label="Close"></button>
    </div>
    
    <!-- Language Tabs -->
    <ul class="nav nav-tabs px-3 pt-2" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link" :class="{'active': helpLanguageTab === 'de'}" 
                @click="helpLanguageTab = 'de'" type="button">
          🇩🇪 Deutsch
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" :class="{'active': helpLanguageTab === 'en'}" 
                @click="helpLanguageTab = 'en'" type="button">
          🇬🇧 English
        </button>
      </li>
    </ul>
    
    <div class="sidebar-content mb-feature-sidebar-content" style="height: calc(100% - 110px); overflow-y: auto; padding: 20px;">
      
      <!-- German Content -->
      <div v-if="helpLanguageTab === 'de'">
        <!-- Kernfunktionen -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-primary mb-3">
            <i class="bi bi-star-fill"></i> Kernfunktionen
          </h6>
          <ul class="feature-list">
            <li><strong>Gruppen & Links:</strong> Erstellen Sie beliebig viele Gruppen, klappen Sie diese ein oder aus und verteilen Sie Links in mehreren Spalten pro Gruppe, damit auch große Sammlungen übersichtlich bleiben.</li>
            <li><strong>Drag & Drop:</strong> Ziehen Sie Gruppen an neue Positionen sowie Links innerhalb einer Spalte, in andere Spalten oder direkt in andere Gruppen. Visuelle Drop-Zonen zeigen die Einfügeposition.</li>
            <li><strong>Suche & Filter:</strong> Die Volltextsuche berücksichtigt u. a. Gruppentitel, Linktitel, URL und Keywords. Über die Keyword-Cloud können mehrere Keyword-Filter parallel aktiviert werden.</li>
            <li><strong>Import/Export:</strong> Import aus Datei, URL oder Zwischenablage. Unterstützte Formate: JSON, CSV und HTML (inkl. Netscape-Bookmarks). Vor dem Import gibt es eine selektierbare Vorschau.</li>
            <li><strong>Bookmarklet:</strong> Über den Bookmarklet-Dialog legen Sie einen Schnellzugriff in der Browserleiste an, um aktuelle Seiten mit URL/Titel direkt in MyBookmarks zu übernehmen.</li>
          </ul>
        </div>
        
        <!-- Zusammenarbeit & Sync -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-success mb-3">
            <i class="bi bi-people-fill"></i> Zusammenarbeit & Sync
          </h6>
          <ul class="feature-list">
            <li><strong>Teilen per ntfy:</strong> Senden Sie einzelne Links oder komplette Gruppen aus dem Kontextmenü an ausgewählte Kontakte; eingehende Inhalte können direkt übernommen werden.</li>
            <li><strong>Kontakte & Quick-Connect:</strong> Kontakte werden zentral verwaltet, inklusive Online-Status. Neue Kontakte lassen sich mit dem Quick-Connect-Dialog per 6-stelligem Code koppeln.</li>
            <li><strong>Mitgliederverwaltung:</strong> Besitzer geteilter Gruppen können Mitglieder einladen, Rollen und Rechte (Add/Edit/Delete) anpassen, Mitglieder entfernen und Eigentum übertragen.</li>
            <li><strong>Event-Log:</strong> Änderungen werden mit Zeitstempel und Autor nachvollziehbar protokolliert. Das hilft bei Konflikten, Prüfung von Änderungen und Wiederherstellungsfällen.</li>
            <li><strong>Optionaler Backend-Sync:</strong> Zusätzlich zur Kontaktfreigabe kann ein Sync mit CardDAV oder Nextcloud Bookmarks aktiviert werden (Browser-Extension erforderlich).</li>
          </ul>
        </div>
        
        <!-- Anpassung -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-warning mb-3">
            <i class="bi bi-palette-fill"></i> Anpassung
          </h6>
          <ul class="feature-list">
            <li><strong>CSS-Sidebar:</strong> Der visuelle CSS-Editor unterstützt Regelsets, Selektoren, Eigenschaften, Design-Tokens und Live-Vorschau, sodass UI-Anpassungen ohne externen Build-Prozess möglich sind.</li>
            <li><strong>Formatierung:</strong> Definieren Sie Standard- und Einzelstile für Gruppen, Gruppentitel, Links, Badges, Keyword-Chips und weitere Elemente auf Gruppen- oder Link-Ebene.</li>
            <li><strong>Favicon-Regeln:</strong> Legen Sie Regeln auf Basis von Domain/URL-Mustern fest, laden Sie eigene Favicons hoch und steuern Sie, welche Icon-Quelle bevorzugt verwendet wird.</li>
            <li><strong>Link-Darstellung:</strong> Konfigurieren Sie Link-Badges, Link-Popover, Standard-URL-Präfix und Verhalten beim Öffnen (z. B. in neuem Tab) passend zu Ihrem Workflow.</li>
            <li><strong>Button-Optionen:</strong> Blenden Sie Add/Delete/Copy/QR-Aktionen gezielt ein oder aus, um die Oberfläche für unterschiedliche Nutzerrollen oder Fokus-Workflows zu vereinfachen.</li>
          </ul>
        </div>
        
        <!-- Werkzeuge -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-info mb-3">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-gear-fill me-1" viewBox="0 0 16 16">
              <path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/>
            </svg> Werkzeuge
          </h6>
          <ul class="feature-list">
            <li><strong>Duplikat-Finder:</strong> Erkennt doppelte URLs gruppenübergreifend, zeigt alle Fundstellen an und erlaubt das selektive Entfernen einzelner Duplikate.</li>
            <li><strong>Snapshots:</strong> Speichern Sie manuelle Sicherungspunkte über die Toolbar, stellen Sie frühere Zustände wieder her oder löschen Sie nicht mehr benötigte Snapshots.</li>
            <li><strong>Undo/Redo:</strong> Bearbeitungsschritte können über die Toolbar gezielt zurückgenommen oder wiederhergestellt werden, um Änderungen sicher auszuprobieren.</li>
            <li><strong>JSON-Inspektor:</strong> Über das Gruppen-Kontextmenü lassen sich Rohdaten der Gruppe inklusive Event-Log- und Snapshot-Bereichen detailliert prüfen.</li>
            <li><strong>QR & Copy:</strong> Für Links stehen schnelle Aktionen zum URL-Kopieren (inkl. Formatvorlage) und zur QR-Code-Erzeugung für Mobile/Sharing zur Verfügung.</li>
            <li><strong>Keyword-Manager:</strong> Keywords können global umbenannt oder entfernt werden; Änderungen werden konsistent auf Gruppen und Links angewendet.</li>
            <li><strong>Shortcut-Manager:</strong> Zeigt alle Link-Shortcuts und erlaubt globale Shortcuts, bei denen Gruppen und einzelne Links per Treeview ausgewählt werden, um komplette Seiten-Sets per Tastenkombination zu öffnen. Zusätzlich können Gruppen eigene Shortcuts erhalten; im Gruppen-/Link-Dialog werden Konflikte und Überschneidungen mit globalen sowie Gruppen-Shortcuts direkt angezeigt.</li>
          </ul>
        </div>
        
        <!-- Tastatur -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-secondary mb-3">
            <i class="bi bi-keyboard-fill"></i> Tastatur
          </h6>
          <ul class="feature-list small">
            <li><kbd>Esc</kbd> - Schließt geöffnete Menüs/Dialoge und beendet aktive Inline-Bearbeitungen ohne Übernahme.</li>
            <li><kbd>Enter</kbd> - Speichert Inline-Bearbeitungen von Gruppen- oder Linkfeldern direkt aus dem Eingabefeld.</li>
            <li><kbd>Enter</kbd>/<kbd>Leertaste</kbd> - Löst fokussierte Icon-Aktionen aus (z. B. Kopieren, QR-Code, Löschen) für bessere Tastaturbedienung.</li>
            <li>Optional: Ist <em>Search as you type</em> aktiviert, fokussiert die erste normale Taste automatisch das Suchfeld, wenn kein Eingabefeld aktiv ist.</li>
          </ul>
        </div>
        
        <!-- Hinweise -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-purple mb-3">
            <i class="bi bi-lightbulb-fill"></i> Hinweise
          </h6>
          <ul class="feature-list small">
            <li>Einige Funktionen sind nur mit Browser-Extension verfügbar, z. B. Browser-Bookmark-Import, Extension-Cache leeren und optionaler Backend-Sync.</li>
            <li>Daten werden lokal gespeichert (inkl. Einstellungen/Kontakte). Für Backup und Gerätewechsel sollten regelmäßig Exporte erstellt werden.</li>
            <li>Rechtsklick auf Gruppen oder Links öffnet Kontextmenüs mit erweiterten Aktionen wie Teilen, Sortieren, Inspektion und Keyword-Verwaltung.</li>
            <li>Für geteilte Gruppen werden eine gültige ntfy-Konfiguration, eine lokale Identität und passende Kontakte benötigt.</li>
            <li>Die Import-Vorschau erlaubt es, Gruppen und einzelne Links vor dem Import gezielt auszuwählen oder abzuwählen.</li>
          </ul>
        </div>
      </div>
      
      <!-- English Content -->
      <div v-if="helpLanguageTab === 'en'">
        <!-- Core Features -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-primary mb-3">
            <i class="bi bi-star-fill"></i> Core Features
          </h6>
          <ul class="feature-list">
            <li><strong>Groups & Links:</strong> Create as many groups as needed, collapse/expand them, and distribute links across multiple columns to keep large collections readable.</li>
            <li><strong>Drag & Drop:</strong> Reorder groups and move links within a column, between columns, or across groups. Visual drop zones indicate the exact insertion point.</li>
            <li><strong>Search & Filters:</strong> Full-text search covers group titles, link titles, URLs, and keywords. Keyword cloud filters can be combined for precise narrowing.</li>
            <li><strong>Import/Export:</strong> Import from file, URL, or clipboard with support for JSON/CSV/HTML (including Netscape bookmarks), plus a selectable preview before applying.</li>
            <li><strong>Bookmarklet:</strong> Create a browser-bar shortcut that captures the current page (title + URL) and sends it back into MyBookmarks quickly.</li>
          </ul>
        </div>
        
        <!-- Collaboration & Sync -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-success mb-3">
            <i class="bi bi-people-fill"></i> Collaboration & Sync
          </h6>
          <ul class="feature-list">
            <li><strong>ntfy Sharing:</strong> Send single links or full groups to selected contacts from context menus; incoming shared data can be accepted directly.</li>
            <li><strong>Contacts & Quick-Connect:</strong> Manage contacts in one place, see online status, and pair new contacts via the Quick-Connect 6-digit code workflow.</li>
            <li><strong>Member Management:</strong> Group owners can invite members, change Add/Edit/Delete permissions, remove members, and transfer ownership.</li>
            <li><strong>Event Log:</strong> Changes are traceable with timestamps and authors, helping with conflict resolution and auditability.</li>
            <li><strong>Optional Backend Sync:</strong> Beyond contact sharing, you can enable sync with CardDAV or Nextcloud Bookmarks (requires browser extension).</li>
          </ul>
        </div>
        
        <!-- Customization Features -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-warning mb-3">
            <i class="bi bi-palette-fill"></i> Customization
          </h6>
          <ul class="feature-list">
            <li><strong>CSS Sidebar:</strong> The visual CSS editor supports rule sets, selectors, properties, design tokens, and live preview without needing an external build step.</li>
            <li><strong>Formatting:</strong> Configure default and per-item styling for groups, titles, links, badges, keyword chips, and other UI elements.</li>
            <li><strong>Favicon Rules:</strong> Define host/URL-based icon rules, upload custom favicons, and control source priority for icon selection.</li>
            <li><strong>Link Display:</strong> Tune link badges, metadata popovers, default URL prefix behavior, and link opening behavior (e.g., new tab).</li>
            <li><strong>Button Options:</strong> Enable or disable Add/Delete/Copy/QR actions by area to keep the interface aligned with your workflow.</li>
          </ul>
        </div>
        
        <!-- Power Tools -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-info mb-3">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-gear-fill me-1" viewBox="0 0 16 16">
              <path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/>
            </svg> Power Tools
          </h6>
          <ul class="feature-list">
            <li><strong>Duplicate Finder:</strong> Scans across groups for duplicate URLs, lists all matches, and lets you remove selected duplicates safely.</li>
            <li><strong>Snapshots:</strong> Save manual restore points from the toolbar, restore previous states, and delete obsolete snapshots.</li>
            <li><strong>Undo/Redo:</strong> Step backward or forward through edit history using dedicated toolbar actions.</li>
            <li><strong>JSON Inspector:</strong> Open structured raw group data (including event-log and snapshot sections) from the group context menu.</li>
            <li><strong>QR & Copy:</strong> Each link supports quick URL copy (with configurable copy format) and QR generation for mobile sharing.</li>
            <li><strong>Keyword Manager:</strong> Rename or remove keywords globally and apply those changes consistently to groups and links.</li>
            <li><strong>Shortcut Manager:</strong> Shows all link shortcuts and lets you build global shortcuts by selecting groups and links in a tree view to launch full page sets at once. Groups can also have their own shortcuts, and the group/link edit dialogs now show overlap and conflict hints with global and group-level shortcuts.</li>
          </ul>
        </div>
        
        <!-- Keyboard -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-secondary mb-3">
            <i class="bi bi-keyboard-fill"></i> Keyboard
          </h6>
          <ul class="feature-list small">
            <li><kbd>Esc</kbd> - Closes menus/dialogs and cancels active inline edits without applying changes.</li>
            <li><kbd>Enter</kbd> - Saves inline edits in group and link input fields.</li>
            <li><kbd>Enter</kbd>/<kbd>Space</kbd> - Activates focused icon actions (for example Copy, QR, or Delete) for keyboard accessibility.</li>
            <li>Optional: when <em>Search as you type</em> is enabled, the first regular keypress auto-focuses the search field if no input is active.</li>
          </ul>
        </div>
        
        <!-- Notes -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-purple mb-3">
            <i class="bi bi-lightbulb-fill"></i> Notes
          </h6>
          <ul class="feature-list small">
            <li>Some capabilities appear only when the browser extension is available, such as browser-bookmark import, extension-cache clearing, and optional backend sync.</li>
            <li>Data is stored locally (including settings and contacts), so regular exports are strongly recommended for backup and migration.</li>
            <li>Right-click on groups or links to access advanced context actions like sharing, sorting, inspection, and keyword management.</li>
            <li>Shared-group workflows require a valid ntfy setup, a local identity, and properly configured contacts.</li>
            <li>The import preview lets you include or exclude groups and individual links before committing the import.</li>
          </ul>
        </div>
      </div>
      
    </div>
  </div>
  
  <!-- Invitation Dialog (replaces Inbox Modal) -->
  <div class="modal fade" id="invitationModal" tabindex="-1" aria-labelledby="invitationModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="invitationModalLabel">
            <span v-if="invitationDialog.type === 'group'">{{ getTranslation('invitation.groupTitle') || 'Einladung zur geteilten Gruppe' }}</span>
            <span v-else-if="invitationDialog.type === 'link' && invitationDialog.groupName">{{ getTranslation('share.groupTitle') || 'Gruppe erhalten' }}</span>
            <span v-else-if="invitationDialog.type === 'link'">{{ getTranslation('share.linkTitle') || 'Links erhalten' }}</span>
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" @click="rejectInvitation()"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <p>
              <strong>{{ getTranslation('invitation.from') || 'Von' }}:</strong> 
              {{ invitationDialog.fromName }}
            </p>
            <div v-if="invitationDialog.type === 'group'">
              <p>
                <strong>{{ getTranslation('invitation.groupName') || 'Gruppenname' }}:</strong> 
                {{ invitationDialog.groupName }}
              </p>
              <p v-if="invitationDialog.linkCount > 0">
                <strong>{{ getTranslation('invitation.linkCount') || 'Anzahl Links' }}:</strong> 
                {{ invitationDialog.linkCount }}
              </p>
            </div>
            <div v-else-if="invitationDialog.type === 'link'">
              <p v-if="invitationDialog.groupName">
                <strong>{{ getTranslation('invitation.groupName') || 'Gruppenname' }}:</strong> 
                {{ invitationDialog.groupName }}
              </p>
              <p v-if="invitationDialog.linkCount > 0">
                <strong>{{ getTranslation('invitation.linkCount') || 'Anzahl Links' }}:</strong> 
                {{ invitationDialog.linkCount }}
              </p>
              <div v-if="invitationDialog.preview.length > 0">
                <p><strong>{{ getTranslation('invitation.linksToAdd') || 'Zu hinzufügende Links' }}:</strong></p>
                <div class="border rounded p-2" style="max-height: 200px; overflow-y: auto;">
                  <div v-for="(link, idx) in invitationDialog.preview" :key="idx" class="mb-1">
                    <small>• {{ link.text || link.url }}</small>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="alert alert-info" role="alert">
            <span v-if="invitationDialog.type === 'group'">
              {{ getTranslation('invitation.groupDescription') || 'Möchten Sie diese geteilte Gruppe hinzufügen? Sie können dann Links mit anderen Mitgliedern der Gruppe teilen.' }}
            </span>
            <span v-else-if="invitationDialog.type === 'link'">
              <span v-if="invitationDialog.groupName">
                {{ getTranslation('share.groupDescription') || 'Möchten Sie diese Gruppe mit allen Links hinzufügen?' }}
              </span>
              <span v-else>
                {{ getTranslation('share.linkDescription') || 'Möchten Sie diese Links hinzufügen?' }}
              </span>
            </span>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" @click="rejectInvitation()">
            <span v-if="invitationDialog.type === 'group'">{{ getTranslation('invitation.reject') || 'Ablehnen' }}</span>
            <span v-else>{{ getTranslation('share.cancel') || 'Abbrechen' }}</span>
          </button>
          <button type="button" class="btn btn-primary" @click="acceptInvitation()">
            <span v-if="invitationDialog.type === 'group'">{{ getTranslation('invitation.accept') || 'Annehmen' }}</span>
            <span v-else>{{ getTranslation('share.add') || 'Hinzufügen' }}</span>
          </button>
        </div>
      </div>
    </div>
  </div>


  <!-- Contacts & Quick-Connect Modal -->
  <div class="modal fade" id="contactsModal" tabindex="-1" aria-labelledby="contactsModalLabel" aria-hidden="true" v-show="contactsDialog.visible">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="contactsModalLabel">{{ getTranslation('dialog.contacts.title') || 'Contacts' }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" @click="closeContactsDialog()"></button>
        </div>
        <div class="modal-body">
          <!-- Tab Navigation -->
          <ul class="nav nav-tabs mb-3" role="tablist">
            <li class="nav-item" role="presentation">
              <button class="nav-link" :class="{'active': contactsDialog.tab === 'contacts'}" 
                      @click="contactsDialog.tab = 'contacts'" type="button">
                {{ getTranslation('dialog.contacts.tabTitle') || 'Contacts' }}
              </button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" :class="{'active': contactsDialog.tab === 'quickconnect'}" 
                      @click="contactsDialog.tab = 'quickconnect'" type="button">
                {{ getTranslation('dialog.quickconnect.tabTitle') || 'Quick-Connect' }}
              </button>
            </li>
          </ul>
          
          <!-- Contacts Tab -->
          <div v-if="contactsDialog.tab === 'contacts'">
            <div v-if="!data.contacts || data.contacts.length===0" class="text-muted">{{ getTranslation('dialog.contacts.empty') }}</div>
            <table class="table table-sm" v-else>
              <thead>
                <tr>
                  <th>{{ getTranslation('dialog.contacts.name') }}</th>
                  <th>{{ getTranslation('dialog.contacts.status') || 'Status' }}</th>
                  <th>{{ getTranslation('dialog.contacts.uuid') }}</th>
                  <th>{{ getTranslation('dialog.contacts.actions') }}</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="c in data.contacts" :key="c.uuid" :class="{ 'contact-row': true, 'offline': !isContactOnline(c.uuid) }">
                  <td>{{ c.name || '(no name)' }}</td>
                  <td>
                    <span :class="getContactStatusClass(c.uuid)"></span>
                    <span :class="getContactStatusTextClass(c.uuid)">
                      {{ getContactStatusText(c.uuid) }}
                    </span>
                  </td>
                  <td class="text-monospace" :title="c.uuid">…{{ c.uuid.slice(-5) }}</td>
                  <td>
                    <button class="btn btn-sm btn-outline-primary me-1" 
                            :disabled="!isContactOnline(c.uuid)"
                            @click="sendTestToContact(c)"
                            :title="!isContactOnline(c.uuid) ? getTranslation('dialog.contacts.offlineTooltip') || 'Contact is offline' : ''">
                      {{ getTranslation('dialog.contacts.sendTest') }}
                    </button>
                    <button class="btn btn-sm btn-outline-danger" @click="confirmRemoveContact(c)">
                      {{ getTranslation('dialog.contacts.remove') }}
                    </button>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          
          <!-- Quick-Connect Tab -->
          <div v-if="contactsDialog.tab === 'quickconnect'">
            <div class="row mb-3">
              <div class="col-6">
                <div class="card" :class="qcDialog.mode==='receive' ? 'border-primary border-2' : 'border-secondary'" 
                     @click="qcDialog.mode='receive'" style="cursor: pointer;">
                  <div class="card-body text-center p-2">
                    <h6 class="card-title mb-1">
                      <span class="badge" :class="qcDialog.mode==='receive' ? 'bg-primary' : 'bg-secondary'">
                        {{ getTranslation('qc.receive') || 'RECEIVE' }}
                      </span>
                    </h6>
                    <small class="text-muted">{{ getTranslation('qc.receive.desc') || 'Show code' }}</small>
                  </div>
                </div>
              </div>
              <div class="col-6">
                <div class="card" :class="qcDialog.mode==='send' ? 'border-primary border-2' : 'border-secondary'" 
                     @click="qcDialog.mode='send'" style="cursor: pointer;">
                  <div class="card-body text-center p-2">
                    <h6 class="card-title mb-1">
                      <span class="badge" :class="qcDialog.mode==='send' ? 'bg-primary' : 'bg-secondary'">
                        {{ getTranslation('qc.send') || 'SEND' }}
                      </span>
                    </h6>
                    <small class="text-muted">{{ getTranslation('qc.send.desc') || 'Enter code' }}</small>
                  </div>
                </div>
              </div>
            </div>
            
            <div v-if="qcDialog.mode==='receive'" class="text-center">
              <p class="text-muted mb-2">{{ getTranslation('qc.receive.instruction') || 'Share this code:' }}</p>
              <div class="mb-3">
                <input type="text" class="form-control form-control-lg text-center font-monospace fw-bold" 
                       :value="qcDialog.code || '------'" readonly 
                       style="letter-spacing: 0.2em; font-size: 1.5rem;">
              </div>
              <button class="btn btn-success me-2" @click="qcStartReceive" v-if="!qcDialog.code">
                {{ getTranslation('qc.generate') || 'Generate Code' }}
              </button>
              <button class="btn btn-danger" @click="qcCancel" v-else>
                {{ getTranslation('qc.stop') || 'Stop' }}
              </button>
            </div>
            
            <div v-else class="text-center">
              <p class="text-muted mb-2">{{ getTranslation('qc.send.instruction') || 'Enter the code:' }}</p>
              <div class="mb-3">
                <input type="text" class="form-control form-control-lg text-center font-monospace fw-bold" 
                       v-model="qcDialog.code" placeholder="abc123" maxlength="6"
                       style="letter-spacing: 0.2em; font-size: 1.5rem;">
              </div>
              <button class="btn btn-primary me-2" @click="qcStartSend" :disabled="!qcDialog.code || qcDialog.code.length !== 6">
                {{ getTranslation('qc.connect') || 'Connect' }}
              </button>
              <button class="btn btn-secondary" @click="qcCancel">
                {{ getTranslation('qc.cancel') || 'Cancel' }}
              </button>
            </div>
            
            <hr class="my-3">
            <div class="border rounded p-2 bg-light mb-surface-panel mb-qc-status-panel" style="height: 120px; overflow: auto;" id="qcStatusBox">
              <small>
                <div v-for="s in qcDialog.status" :key="s.t" class="text-muted">
                  {{ formatMessageTime(s.t) }} — {{ s.m }}
                </div>
              </small>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" @click="closeContactsDialog()">{{ getTranslation('dialog.close') || 'Close' }}</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Share Modal -->
  <div class="modal fade" id="shareModal" tabindex="-1" aria-labelledby="shareModalLabel" aria-hidden="true" v-show="shareDialog.visible">
    <div class="modal-dialog modal-md modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="shareModalLabel">
            <span v-if="shareDialog.mode === 'link'">{{ getTranslation('dialog.send.linkTitle') || 'Send Link' }}</span>
            <span v-else-if="shareDialog.mode === 'group'">{{ getTranslation('dialog.send.groupTitle') || 'Send Group' }}</span>
            <span v-else-if="shareDialog.mode === 'invite-group'">{{ getTranslation('dialog.invite.title') || 'Invite Members' }}</span>
            <span v-else-if="shareDialog.mode === 'owner-transfer'">{{ getTranslation('dialog.transfer.title') || 'Transfer Ownership' }}</span>
            <span v-else>{{ getTranslation('dialog.share.title') || 'Share' }}</span>
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" @click="shareDialog.visible=false"></button>
        </div>
        <div class="modal-body">
          <template v-if="shareDialog.mode === 'owner-transfer'">
            <div class="mb-3">{{ getTranslation('dialog.transfer.select') || 'Select new owner:' }}</div>
            <div class="form-check" v-for="c in (data.contacts||[]).filter(ct=> (shareDialog.group?.members||[]).some(m=>m.uuid===ct.uuid) && ct.uuid!==data.identity?.uuid)" :key="'sc-'+c.uuid" 
                 :class="{ 'contact-row': true, 'offline': !isContactOnline(c.uuid) }">
              <input class="form-check-input" type="checkbox" :id="'sc-'+c.uuid" v-model="shareDialog.selectedContacts[c.uuid]" :disabled="!isContactOnline(c.uuid)">
              <label class="form-check-label" :for="'sc-'+c.uuid">
                {{ c.name || '(no name)' }} 
                <span class="text-monospace text-muted">…{{ c.uuid.slice(-5) }}</span>
                <span :class="getContactStatusClass(c.uuid)"></span>
                <span :class="getContactStatusTextClass(c.uuid)" v-if="!isContactOnline(c.uuid)">
                  ({{ getContactStatusText(c.uuid) }})
                </span>
              </label>
            </div>
            <div v-if="!(data.contacts||[]).some(ct=> (shareDialog.group?.members||[]).some(m=>m.uuid===ct.uuid) && ct.uuid!==data.identity?.uuid)" class="text-muted">
              {{ getTranslation('dialog.transfer.noCandidates') || 'No eligible members found.' }}
            </div>
          </template>
          <template v-else>
            <div class="mb-3">{{ getTranslation('dialog.send.selectContacts') || 'Select contacts to send to:' }}</div>
            <div class="form-check" v-for="c in data.contacts" :key="'sc-'+c.uuid" 
                 :class="{ 'contact-row': true, 'offline': !isContactOnline(c.uuid) }">
              <input class="form-check-input" type="checkbox" 
                     :id="'sc-'+c.uuid" 
                     v-model="shareDialog.selectedContacts[c.uuid]"
                     :disabled="!isContactOnline(c.uuid)">
              <label class="form-check-label" :for="'sc-'+c.uuid">
                {{ c.name || '(no name)' }} 
                <span class="text-monospace text-muted">…{{ c.uuid.slice(-5) }}</span>
                <span :class="getContactStatusClass(c.uuid)"></span>
                <span :class="getContactStatusTextClass(c.uuid)" v-if="!isContactOnline(c.uuid)">
                  ({{ getContactStatusText(c.uuid) }})
                </span>
              </label>
            </div>
            <div v-if="!data.contacts || data.contacts.length === 0" class="text-muted">
              {{ getTranslation('dialog.send.noContacts') || 'No contacts available. Add contacts first.' }}
            </div>
          </template>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" @click="confirmShare">
            <span v-if="shareDialog.mode === 'owner-transfer'">{{ getTranslation('dialog.transfer.transfer') || 'Transfer' }}</span>
            <span v-else>{{ getTranslation('dialog.send.send') || 'Send' }}</span>
          </button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" @click="shareDialog.visible=false">{{ getTranslation('dialog.send.cancel') || 'Cancel' }}</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Members Modal -->
  <div class="modal fade" id="membersModal" tabindex="-1" aria-labelledby="membersModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="membersModalLabel">{{ getTranslation('members.title') }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" v-if="editGroup">
          <div v-if="Array.isArray(editGroup.members) && editGroup.members.length">
            <div class="border rounded p-2 mb-2" v-for="m in editGroup.members" :key="'mem-'+m.uuid">
              <div class="d-flex align-items-center justify-content-between">
                <div class="d-flex align-items-center">
                  <div v-if="isOwnerOfGroup(editGroup) && m.role !== 'owner'" class="form-check me-3">
                    <input class="form-check-input" type="checkbox" :id="'mem-'+m.uuid" :checked="(editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='allow'" @change="toggleMemberInbound(m)">
                    <label class="form-check-label" :for="'mem-'+m.uuid">
                      <strong>{{ m.name || m.uuid }}</strong>
                    </label>
                  </div>
                  <div v-else>
                    <strong>{{ m.name || m.uuid }}</strong>
                  </div>
                  <span class="badge bg-secondary ms-2 me-2">{{ m.role||'member' }}</span>
                  <span v-if="isOwnerOfGroup(editGroup) && m.role !== 'owner'" class="badge" :class="{
                    'bg-success': (editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='allow',
                    'bg-danger': (editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='deny',
                    'bg-secondary': (editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='unset'
                  }">
                    {{ (editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='allow' ? getTranslation('members.filter.allow') : (editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='deny' ? getTranslation('members.filter.deny') : getTranslation('members.filter.unset') }}
                  </span>
                </div>
                <button v-if="isOwnerOfGroup(editGroup)" class="btn btn-sm btn-outline-danger" :disabled="m.role==='owner' || m.uuid===data.identity.uuid" @click="confirmRemoveMember(m)">{{ getTranslation('members.remove') }}</button>
              </div>
              <div v-if="isOwnerOfGroup(editGroup)" class="mt-2 d-flex align-items-center">
                <small class="text-muted me-2">Permissions:</small>
                <div class="form-check form-check-inline">
                  <input class="form-check-input" type="checkbox" :id="'perm-add-'+m.uuid"
                         :checked="(m.role==='owner') ? true : !!m.canAdd"
                         :disabled="m.role==='owner'"
                         @change="toggleMemberPerm(m, 'canAdd')">
                  <label class="form-check-label" :for="'perm-add-'+m.uuid">{{ getTranslation('members.perm.add') }}</label>
                </div>
                <div class="form-check form-check-inline">
                  <input class="form-check-input" type="checkbox" :id="'perm-edit-'+m.uuid"
                         :checked="(m.role==='owner') ? true : !!m.canEdit"
                         :disabled="m.role==='owner'"
                         @change="toggleMemberPerm(m, 'canEdit')">
                  <label class="form-check-label" :for="'perm-edit-'+m.uuid">{{ getTranslation('members.perm.edit') }}</label>
                </div>
                <div class="form-check form-check-inline">
                  <input class="form-check-input" type="checkbox" :id="'perm-del-'+m.uuid"
                         :checked="(m.role==='owner') ? true : !!m.canDelete"
                         :disabled="m.role==='owner'"
                         @change="toggleMemberPerm(m, 'canDelete')">
                  <label class="form-check-label" :for="'perm-del-'+m.uuid">{{ getTranslation('members.perm.delete') }}</label>
                </div>
              </div>
            </div>
          </div>
          <div v-else class="text-muted">{{ getTranslation('members.noRoster') }}</div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Removed from Group Modal -->
  <div class="modal fade" id="removedFromGroupModal" tabindex="-1" aria-labelledby="removedFromGroupModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header bg-warning">
          <h5 class="modal-title" id="removedFromGroupModalLabel">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-exclamation-triangle me-2" viewBox="0 0 16 16">
              <path d="M7.938 2.016A.13.13 0 0 1 8.002 2a.13.13 0 0 1 .063.016.146.146 0 0 1 .054.057l6.857 11.667c.036.06.035.124.002.183a.163.163 0 0 1-.054.06.116.116 0 0 1-.066.017H1.146a.115.115 0 0 1-.066-.017.163.163 0 0 1-.054-.06.176.176 0 0 1 .002-.183L7.884 2.073a.147.147 0 0 1 .054-.057zm1.044-.45a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566z"/>
              <path d="M7.002 12a1 1 0 1 1 2 0 1 1 0 0 1-2 0zM7.1 5.995a.905.905 0 1 1 1.8 0l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995z"/>
            </svg>
            {{ getTranslation('removedFromGroup.title') || 'Group Membership Removed' }}
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="alert alert-warning" role="alert">
            <p class="mb-2">
              {{ getTranslation('removedFromGroup.message') || 'You have been removed from the following group while you were offline:' }}
            </p>
            <div class="card">
              <div class="card-body">
                <h6 class="card-title">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-folder-x me-2" viewBox="0 0 16 16">
                    <path d="M.54 3.87.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3h3.982a2 2 0 0 1 1.992 2.181L15.546 8H14.54l.265-2.91A1 1 0 0 0 13.81 4H9.828a3 3 0 0 1-2.122-.879l-.827-.828A1 1 0 0 0 6.172 2H2.5a1 1 0 0 0-1 .981l.006.04z"/>
                    <path d="M1 7v9a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7H1zm5.646 5.646a.5.5 0 0 0 .708.708L8 12.707l.646.647a.5.5 0 0 0 .708-.708L8.707 12l.647-.646a.5.5 0 0 0-.708-.708L8 11.293l-.646-.647a.5.5 0 0 0-.708.708l.647.646-.647.646z"/>
                  </svg>
                  {{ removedGroupInfo.groupName }}
                </h6>
                <p class="card-text mb-1">
                  <small class="text-muted">
                    <strong>{{ getTranslation('removedFromGroup.owner') || 'Group Owner:' }}</strong> {{ removedGroupInfo.ownerName }}
                  </small>
                </p>
                <p class="card-text">
                  <small class="text-muted">
                    <strong>{{ getTranslation('removedFromGroup.removedAt') || 'Removed:' }}</strong> {{ formatDate(removedGroupInfo.removedAt) }}
                  </small>
                </p>
              </div>
            </div>
            <p class="mt-3 mb-0">
              <small>{{ getTranslation('removedFromGroup.explanation') || 'The group will be removed from your list. If you need access again, please contact the group owner.' }}</small>
            </p>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" data-bs-dismiss="modal" @click="acknowledgeGroupRemoval">
            {{ getTranslation('removedFromGroup.acknowledge') || 'I Understand' }}
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="linkMenu" class="context-menu mb-context-menu" :style="contextMenuStyle"
    :class="{ 'context-menu-visible': isLinkMenuVisible }">
    <ul v-if="contextLink" class="mb-context-menu-list">
      <li @click="canEdit(contextGroup) ? showLinkEditModal(contextLink) : null" 
          :class="{ 'disabled': !canEdit(contextGroup) }"
          :title="!canEdit(contextGroup) ? getTranslation('error.perm.edit') : ''">
        {{ isSeparatorLink(contextLink) ? (getTranslation('menu.link.editSeparator') || 'Edit separator') : (isNoteLink(contextLink) ? (getTranslation('menu.link.editNote') || 'Edit note') : (isReferenceLink(contextLink) ? (getTranslation('menu.link.editRefLink') || 'Edit ref link') : getTranslation('menu.link.editLink'))) }}
        <span v-if="!canEdit(contextGroup)" class="text-muted"> ({{ getTranslation('permission.denied') || 'No permission' }})</span>
      </li>
      <li @click="(!isReferenceLink(contextLink) && !isSeparatorLink(contextLink) && !isNoteLink(contextLink)) ? createReferenceLinkFromContext(contextGroup, contextLink) : null"
          :class="{ 'disabled': isReferenceLink(contextLink) || isSeparatorLink(contextLink) || isNoteLink(contextLink) }"
          :title="(isReferenceLink(contextLink) || isSeparatorLink(contextLink) || isNoteLink(contextLink)) ? (getTranslation('link.ref.createFromRefDisabled') || 'Create ref link is only available for original URL links.') : ''">
        {{ getTranslation('menu.link.createRefLink') || 'Create ref link…' }}
      </li>
      <li v-if="isReferenceLink(contextLink)" @click="editOriginalLinkFromReference(contextLink)">
        {{ getTranslation('menu.link.editOriginalLink') || 'Edit original link…' }}
      </li>
      <li v-if="hasNtfyUrl() && hasConnectedContacts() && getEffectiveLinkUrl(contextLink)" class="separator mb-context-menu-separator"></li>
      <li v-if="hasNtfyUrl() && hasConnectedContacts() && getEffectiveLinkUrl(contextLink)" @click="shareResolvedLink(contextLink)">{{ getTranslation('menu.link.sendLink') }}</li>
      <li class="separator mb-context-menu-separator" v-if="getEffectiveLinkUrl(contextLink)"></li>
      <li @click="showQrCodeModal(getEffectiveLinkUrl(contextLink))" v-if="getEffectiveLinkUrl(contextLink)">{{ getTranslation('menu.link.createQrCode') }}</li>
      <li v-if="!isSeparatorLink(contextLink)" class="separator mb-context-menu-separator"></li>
      <li v-if="!isSeparatorLink(contextLink)" class="submenu" tabindex="0">
        {{ getTranslation('menu.keywords') || 'Keywords' }}
        <ul class="context-submenu mb-context-submenu keyword-submenu">
          <li @click="canEdit(contextGroup) ? (openKeywordQuickDialogForLink(contextGroup, contextLink), hideMenus()) : null"
              :class="{ 'disabled': !canEdit(contextGroup) }">
            {{ getTranslation('menu.keyword.new') || 'New keyword' }}
          </li>
          <li class="separator mb-context-menu-separator"></li>
          <li v-if="getAssignedKeywordsForLink(contextLink).length === 0" class="disabled">
            {{ getTranslation('menu.keyword.noneAssigned') || 'No assigned keywords' }}
          </li>
          <li v-for="kw in getAssignedKeywordsForLink(contextLink)" :key="'link-menu-remove-kw-' + kw"
              :class="{ 'disabled': !canEdit(contextGroup) }"
              @click="canEdit(contextGroup) ? (removeKeywordFromLink(contextGroup, contextLink, kw), hideMenus()) : null">
            {{ (getTranslation('menu.keyword.remove') || 'Remove') + ': ' + kw }}
          </li>
          <li class="separator mb-context-menu-separator"></li>
          <li v-if="getAvailableKeywordsForLink(contextLink).length === 0" class="disabled">
            {{ getTranslation('menu.keyword.noneAvailable') || 'No remaining keywords' }}
          </li>
          <li v-for="kw in getAvailableKeywordsForLink(contextLink)" :key="'link-menu-add-kw-' + kw"
              :class="{ 'disabled': !canEdit(contextGroup) }"
              @click="canEdit(contextGroup) ? (addKeywordToLink(contextGroup, contextLink, kw), hideMenus()) : null">
            {{ (getTranslation('menu.keyword.add') || 'Add') + ': ' + kw }}
          </li>
        </ul>
      </li>
      <li v-if="!isSeparatorLink(contextLink)" class="separator mb-context-menu-separator"></li>
      <li v-if="cssSidebarVisible" class="submenu" tabindex="0">
        {{ getTranslation('menu.link.copyForCss') || 'Copy for CSS' }}
        <ul class="context-submenu mb-context-submenu">
          <li @click="copyLinkCssClass(contextLink); hideMenus()">{{ getTranslation('menu.link.copyCssClass') || 'Copy CSS class' }}</li>
          <li @click="copyLinkUuid(contextLink); hideMenus()">{{ getTranslation('menu.link.copyUuid') || 'Copy UUID' }}</li>
          <li @click="copyLinkUuid(contextLink, {shiftKey: true}); hideMenus()">{{ getTranslation('menu.link.copyCssSelector') || 'Copy CSS selector [data-link-uuid]' }}</li>
        </ul>
      </li>
      <li v-if="cssSidebarVisible" class="separator mb-context-menu-separator"></li>
      <li @click="canDelete(contextGroup) ? (deleteLink(contextLink), hideMenus()) : null" 
          :class="{ 'disabled': !canDelete(contextGroup) }"
          :title="!canDelete(contextGroup) ? getTranslation('error.perm.delete') : ''">
        {{ isSeparatorLink(contextLink) ? (getTranslation('menu.link.deleteSeparator') || 'Delete separator') : (isNoteLink(contextLink) ? (getTranslation('menu.link.deleteNote') || 'Delete note') : (isReferenceLink(contextLink) ? (getTranslation('menu.link.deleteRefLink') || 'Delete ref link') : getTranslation('menu.link.deleteLink'))) }}
        <span v-if="!canDelete(contextGroup)" class="text-muted"> ({{ getTranslation('permission.denied') || 'No permission' }})</span>
      </li>
    </ul>
  </div>

  <div class="modal fade" id="referenceAliasModal" tabindex="-1" aria-labelledby="referenceAliasModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content mb-modal mb-ref-alias-modal">
        <div class="modal-header">
          <h5 class="modal-title mb-edit-modal-title" id="referenceAliasModalLabel">
            {{ getTranslation('link.ref.editDialog.title') || 'Edit reference link text' }}
          </h5>
          <button type="button" class="btn-close" aria-label="Close" @click="cancelReferenceAliasDialog"></button>
        </div>
        <div class="modal-body mb-edit-modal-body">
          <form v-if="refAliasEditData" class="mb-edit-form" @submit.prevent="saveReferenceAliasDialog">
            <div class="options-section mb-edit-section">
              <div
                class="options-section-header mb-edit-section-header"
                :class="{ collapsed: !isRefAliasSectionExpanded('basic') }"
                @click="toggleRefAliasSection('basic')">
                <span>{{ getTranslation('link.basic') || 'Basic Settings' }}</span>
                <svg class="chevron-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                </svg>
              </div>
              <div v-show="isRefAliasSectionExpanded('basic')" class="options-section-body mb-edit-section-body">
                <div class="small text-muted mb-2 mb-ref-alias-source-line">
                  <strong>{{ getTranslation('link.ref.editDialog.original') || 'Original link' }}:</strong>
                  <span>{{ refAliasEditData.sourceTitle || (getTranslation('link.ref.missing') || 'Reference link (original missing)') }}</span>
                </div>
                <div class="small text-muted mb-2">
                  <strong>{{ getTranslation('link.ref.editDialog.originalUrl') || 'Original URL template' }}:</strong>
                  <code>{{ refAliasEditData.sourceUrlTemplate || '-' }}</code>
                </div>
                <div v-if="refAliasEditData.sourceMissing" class="small mb-edit-field-help mb-ref-alias-warning mb-2">
                  {{ getTranslation('link.ref.editDialog.sourceMissingHint') || 'The original link could not be found. You can still set a local reference text.' }}
                </div>
                <div class="option-row mb-edit-field-row">
                  <label class="form-label mb-edit-field-label" for="referenceAliasInput">
                    {{ getTranslation('link.ref.editDialog.aliasLabel') || 'Reference text' }}
                  </label>
                  <input
                    id="referenceAliasInput"
                    ref="refAliasInput"
                    v-model="refAliasEditData.aliasText"
                    type="text"
                    class="form-control mb-edit-text-input"
                    :placeholder="getTranslation('link.ref.editDialog.aliasPlaceholder') || 'Leave empty to use the original link text'"
                    autocomplete="off">
                  <div class="form-text mb-edit-field-help">
                    {{ getTranslation('link.ref.editDialog.help') || 'Only this reference text is changed. URL and metadata stay linked to the original link.' }}
                  </div>
                </div>
              </div>
            </div>

            <div class="options-section mb-edit-section">
              <div
                class="options-section-header mb-edit-section-header"
                :class="{ collapsed: !isRefAliasSectionExpanded('keywords') }"
                @click="toggleRefAliasSection('keywords')">
                <span>{{ getTranslation('menu.keywords') || 'Keywords' }}</span>
                <svg class="chevron-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                </svg>
              </div>
              <div v-show="isRefAliasSectionExpanded('keywords')" class="options-section-body mb-edit-section-body">
                <div class="option-row mb-edit-field-row">
                  <div class="form-check">
                    <input
                      id="referenceInheritKeywordsInput"
                      v-model="refAliasEditData.inheritSourceKeywords"
                      class="form-check-input"
                      type="checkbox">
                    <label class="form-check-label mb-edit-field-label" for="referenceInheritKeywordsInput">
                      {{ getTranslation('link.ref.editDialog.inheritKeywords') || 'Use original link keywords' }}
                    </label>
                  </div>
                </div>
                <div class="option-row mb-edit-field-row">
                  <div class="small text-muted mb-2 mb-ref-alias-source-keywords">
                    <strong>{{ getTranslation('link.ref.editDialog.originalKeywords') || 'Original keywords' }}:</strong>
                    <span>{{ refAliasEditData.sourceKeywordsLabel || (getTranslation('link.ref.editDialog.none') || 'None') }}</span>
                  </div>
                  <label class="form-label mb-edit-field-label" for="referenceKeywordsInput">
                    {{ getTranslation('link.ref.editDialog.localKeywordsLabel') || 'Additional reference keywords' }}
                  </label>
                  <input
                    id="referenceKeywordsInput"
                    v-model="refAliasEditData.localKeywords"
                    type="text"
                    class="form-control mb-edit-text-input"
                    :placeholder="getTranslation('link.ref.editDialog.localKeywordsPlaceholder') || 'keyword1, keyword2'"
                    autocomplete="off">
                  <div class="form-text mb-edit-field-help">
                    {{ getTranslation('link.ref.editDialog.localKeywordsHelp') || 'These keywords belong only to this reference link.' }}
                  </div>
                </div>
              </div>
            </div>

            <div class="options-section mb-edit-section">
              <div
                class="options-section-header mb-edit-section-header"
                :class="{ collapsed: !isRefAliasSectionExpanded('placeholders') }"
                @click="toggleRefAliasSection('placeholders')">
                <span>{{ getTranslation('link.ref.editDialog.placeholders') || 'Placeholders' }}</span>
                <svg class="chevron-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                </svg>
              </div>
              <div v-show="isRefAliasSectionExpanded('placeholders')" class="options-section-body mb-edit-section-body">
                <div class="option-row mb-edit-field-row">
                  <div v-if="(refAliasEditData.placeholderRows || []).length === 0" class="small text-muted">
                    {{ getTranslation('placeholders.noneInUrl') || 'No placeholders found in URL template.' }}
                  </div>
                  <div v-else class="table-responsive">
                    <table class="table table-sm align-middle mb-placeholder-table">
                      <thead>
                        <tr>
                          <th style="width: 35%;">{{ getTranslation('placeholders.name') || 'Name' }}</th>
                          <th style="width: 45%;">{{ getTranslation('placeholders.value') || 'Value' }}</th>
                          <th style="width: 20%;">{{ getTranslation('placeholders.encode') || 'Encode' }}</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr v-for="(row, idx) in refAliasEditData.placeholderRows" :key="'ref-plh-' + idx + '-' + row.name">
                          <td><code>{{ row.name }}</code></td>
                          <td>
                            <input
                              v-model="row.value"
                              type="text"
                              class="form-control form-control-sm"
                              :placeholder="getTranslation('placeholders.valuePlaceholder') || 'Enter value'"
                              autocomplete="off">
                            <div v-if="isReferenceAliasInheritedPlaceholder(row)" class="form-text mb-0">
                              <span>{{ getTranslation('placeholders.inheritedValue') || 'Inherited value' }}: <code>{{ getReferenceAliasInheritedPlaceholderValue(row) || '—' }}</code></span>
                              <button
                                v-if="canRestoreReferenceAliasPlaceholder(row)"
                                type="button"
                                class="btn btn-link btn-sm p-0 ms-2 align-baseline"
                                @click="restoreReferenceAliasPlaceholder(idx)">
                                {{ getTranslation('placeholders.restoreInherited') || 'Restore inherited' }}
                              </button>
                            </div>
                          </td>
                          <td>
                            <div class="form-check">
                              <input
                                class="form-check-input"
                                type="checkbox"
                                :id="'ref-placeholder-encode-' + idx"
                                v-model="row.encode">
                              <label class="form-check-label small" :for="'ref-placeholder-encode-' + idx">
                                {{ getTranslation('placeholders.encodeLabel') || 'URL-encode' }}
                              </label>
                            </div>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <div class="form-text mb-edit-field-help">
                    <strong>{{ getTranslation('placeholders.preview') || 'Preview' }}:</strong>
                    <code>{{ previewReferenceAliasResolvedUrl() || '-' }}</code>
                  </div>
                  <div v-if="getReferenceAliasUnresolvedPlaceholders().length" class="form-text text-warning">
                    {{ (getTranslation('placeholders.unresolvedHint') || 'Unresolved placeholders') + ': ' + getReferenceAliasUnresolvedPlaceholders().join(', ') }}
                  </div>
                </div>
              </div>
            </div>
          </form>
        </div>
        <div class="modal-footer mb-edit-modal-footer">
          <button type="button" class="btn btn-primary mb-edit-save-btn" @click="saveReferenceAliasDialog">
            {{ getTranslation('save') || 'Save' }}
          </button>
          <button type="button" class="btn btn-secondary mb-edit-cancel-btn" @click="cancelReferenceAliasDialog">
            {{ getTranslation('cancel') || 'Cancel' }}
          </button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="keywordManagerModal" tabindex="-1" aria-labelledby="keywordManagerModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="keywordManagerModalLabel">
            {{ getTranslation('keywords.dialog.title') || 'Manage Keywords' }}
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body mb-keyword-manager-body">
          <div v-if="allKeywords.length === 0" class="text-muted mb-keyword-manager-empty">
            {{ getTranslation('keywords.dialog.empty') || 'No keywords available' }}
          </div>
          <div v-else class="list-group mb-3 mb-keyword-manager-list">
            <button
              v-for="kw in allKeywords"
              :key="'keyword-manager-' + kw"
              type="button"
              class="list-group-item list-group-item-action"
              :class="{ active: keywordManager.selected === kw }"
              @click="selectManagedKeyword(kw)">
              {{ kw }}
            </button>
          </div>
          <div class="mb-keyword-manager-editor">
            <label class="form-label small mb-1">{{ getTranslation('keywords.dialog.newName') || 'New name' }}</label>
            <input
              type="text"
              class="form-control form-control-sm"
              v-model="keywordManager.newName"
              :placeholder="getTranslation('keywords.dialog.newName') || 'New name'"
              :disabled="!keywordManager.selected"
            >
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-outline-danger me-auto"
            :disabled="!keywordManager.selected"
            @click="deleteManagedKeyword">
            {{ getTranslation('keywords.dialog.delete') || 'Delete' }}
          </button>
          <button type="button" class="btn btn-primary"
            :disabled="!keywordManager.selected"
            @click="renameManagedKeyword">
            {{ getTranslation('keywords.dialog.rename') || 'Rename' }}
          </button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
            {{ getTranslation('dialog.close') || 'Close' }}
          </button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="keywordQuickAddModal" tabindex="-1" aria-labelledby="keywordQuickAddModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="keywordQuickAddModalLabel">
            {{ keywordQuickDialog.mode === 'group'
              ? (getTranslation('keywords.quick.title.group') || 'Add group keyword')
              : (getTranslation('keywords.quick.title.link') || 'Add link keyword') }}
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" @click="resetKeywordQuickDialog"></button>
        </div>
        <div class="modal-body">
          <label class="form-label small mb-1">{{ getTranslation('keywords.quick.inputLabel') || 'Keyword' }}</label>
          <div class="mb-keyword-quick-field">
            <input
              ref="keywordQuickInput"
              type="text"
              class="form-control form-control-sm"
              v-model="keywordQuickDialog.value"
              :placeholder="getTranslation('keywords.quick.placeholder') || 'Enter keyword'"
              @focus="updateQuickKeywordContext($event)"
              @keyup="updateQuickKeywordContext($event)"
              @click="updateQuickKeywordContext($event)"
              @blur="clearQuickKeywordContext"
              @keydown.tab="handleQuickKeywordTab($event)"
              @keydown.enter.prevent="submitKeywordQuickDialog"
            >
          </div>
          <div class="form-text">{{ getTranslation('keywords.quick.help') || 'Separate multiple keywords with comma or semicolon.' }}</div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" @click="submitKeywordQuickDialog">
            {{ getTranslation('keywords.quick.add') || 'Add' }}
          </button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" @click="resetKeywordQuickDialog">
            {{ getTranslation('dialog.close') || 'Close' }}
          </button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="shortcutManagerModal" tabindex="-1" aria-labelledby="shortcutManagerModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="shortcutManagerModalLabel">
            {{ getTranslation('shortcuts.manager.title') || 'Shortcut Manager' }}
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body mb-shortcut-manager-body">
          <div class="alert alert-warning py-2 px-3 small mb-2" role="alert">
            {{ getTranslation('shortcuts.manager.popupBlockerHint') || 'Browsers may block opening many tabs at once. If that happens, allow pop-ups for this site or trigger the shortcut/action again.' }}
          </div>
          <div class="mb-shortcut-manager-section">
            <div class="mb-shortcut-manager-section-title">
              {{ getTranslation('shortcuts.manager.linkAssignments') || 'Defined link shortcuts' }}
            </div>
            <div class="input-group input-group-sm mb-2">
              <span class="input-group-text">{{ getTranslation('search') || 'Search' }}</span>
              <input
                type="text"
                class="form-control"
                v-model="shortcutManager.linkFilter"
                :placeholder="getTranslation('shortcuts.manager.filterPlaceholder') || 'Filter by shortcut, group, title or URL'"
              >
              <button class="btn btn-outline-secondary" type="button" @click="shortcutManager.linkFilter = ''">
                {{ getTranslation('clear') || 'Clear' }}
              </button>
            </div>
            <div v-if="shortcutManagerLinkGroups.length === 0" class="text-muted small">
              {{ getTranslation('shortcuts.manager.noneDefined') || 'No link shortcuts defined yet.' }}
            </div>
            <div v-else class="list-group mb-shortcut-defined-list">
              <div
                v-for="group in shortcutManagerLinkGroups"
                :key="'shortcut-links-' + group.combo"
                class="list-group-item">
                <div class="d-flex align-items-start justify-content-between gap-2">
                  <div>
                    <span class="badge bg-secondary mb-shortcut-defined-combo">{{ group.combo }}</span>
                    <span class="ms-2 small text-muted">
                      {{ group.itemCount }} {{ getTranslation('shortcuts.manager.linksCount') || 'links' }},
                      {{ group.validUrlCount }} {{ getTranslation('shortcuts.manager.urlsCount') || 'valid URLs' }}
                    </span>
                  </div>
                  <button
                    type="button"
                    class="btn btn-sm btn-outline-secondary"
                    :disabled="group.validUrlCount === 0"
                    @click="openUrlsFromShortcutGroup(group)">
                    {{ getTranslation('shortcuts.manager.openNow') || 'Open now' }}
                  </button>
                </div>
                <div class="mt-2 small">
                  <div
                    v-for="item in group.items"
                    :key="'shortcut-item-' + group.combo + '-' + item.linkUuid"
                    class="d-flex align-items-center justify-content-between gap-2 py-1 border-top">
                    <div class="text-truncate">
                      <strong>{{ item.groupName || '-' }}</strong>:
                      {{ item.linkText || item.url || '-' }}
                      <span v-if="item.url" class="text-muted"> ({{ item.url }})</span>
                    </div>
                    <button
                      type="button"
                      class="btn btn-sm btn-link text-decoration-none p-0"
                      @click="showLinkEditModal(item.linkRef)">
                      {{ getTranslation('shortcuts.manager.editLink') || 'Edit' }}
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="mb-shortcut-manager-section">
            <div class="mb-shortcut-manager-section-title">
              {{ getTranslation('shortcuts.manager.globalTitle') || 'Global shortcuts (open multiple pages)' }}
            </div>
            <p class="small text-muted mb-2">
              {{ getTranslation('shortcuts.manager.globalHelp') || 'Select groups and links from your bookmark tree. Selected items will be opened by shortcut.' }}
            </p>
            <div v-if="shortcutManager.globalDrafts.length === 0" class="text-muted small mb-2">
              {{ getTranslation('shortcuts.manager.globalEmpty') || 'No global shortcuts configured.' }}
            </div>
            <div
              v-for="(draft, draftIndex) in shortcutManager.globalDrafts"
              :key="'shortcut-global-draft-' + draft.id"
              class="mb-shortcut-global-card">
              <div class="row g-2 align-items-end">
                <div class="col-md-3">
                  <label class="form-label small mb-1">{{ getTranslation('shortcuts.manager.globalCombo') || 'Shortcut' }}</label>
                  <div class="input-group input-group-sm">
                    <input
                      type="text"
                      class="form-control mb-edit-shortcut-input"
                      :value="draft.combo"
                      :placeholder="getTranslation('link.shortcut.placeholder') || 'Focus and press keys'"
                      readonly
                      @focus="$event.target.select()"
                      @keydown="captureShortcutManagerDraft(draftIndex, $event)"
                    >
                    <button
                      type="button"
                      class="btn btn-outline-secondary"
                      @click="clearShortcutManagerDraft(draftIndex)">
                      {{ getTranslation('clear') || 'Clear' }}
                    </button>
                  </div>
                </div>
                <div class="col-md-6">
                  <label class="form-label small mb-1">{{ getTranslation('shortcuts.manager.globalName') || 'Name' }}</label>
                  <input
                    type="text"
                    class="form-control form-control-sm"
                    v-model="draft.name"
                    :placeholder="getTranslation('shortcuts.manager.globalNamePlaceholder') || 'Optional label (e.g. Morning Start)'"
                  >
                </div>
                <div class="col-md-3 d-flex justify-content-end">
                  <button type="button" class="btn btn-sm btn-outline-danger" @click="removeGlobalShortcutDraft(draftIndex)">
                    {{ getTranslation('shortcuts.manager.remove') || 'Remove' }}
                  </button>
                </div>
              </div>
              <div class="mt-2">
                <label class="form-label small mb-1">{{ getTranslation('shortcuts.manager.globalTargets') || 'Select groups and links' }}</label>
                <div class="d-flex gap-1 mb-2">
                  <button type="button" class="btn btn-sm btn-outline-primary" @click="selectAllShortcutTargetsForDraft(draftIndex)">
                    {{ getTranslation('export.selectAll') || 'Select All' }}
                  </button>
                  <button type="button" class="btn btn-sm btn-outline-secondary" @click="clearShortcutTargetsForDraft(draftIndex)">
                    {{ getTranslation('export.deselectAll') || 'Deselect All' }}
                  </button>
                </div>
                <div v-if="shortcutManagerTargetGroups.length === 0" class="text-muted small">
                  {{ getTranslation('shortcuts.manager.globalNoLinks') || 'No groups/links available.' }}
                </div>
                <div v-else class="mb-shortcut-target-tree">
                  <div
                    v-for="group in shortcutManagerTargetGroups"
                    :key="'shortcut-target-group-' + draft.id + '-' + group.groupId"
                    class="mb-shortcut-target-group">
                    <div class="form-check">
                      <input
                        class="form-check-input"
                        type="checkbox"
                        :id="'shortcut-target-group-' + draft.id + '-' + group.groupId"
                        :checked="isShortcutDraftGroupSelected(draft, group.groupId)"
                        :disabled="group.selectableLinkCount === 0"
                        @change="toggleShortcutDraftGroup(draftIndex, group.groupId, $event.target.checked)"
                      >
                      <label class="form-check-label fw-semibold" :for="'shortcut-target-group-' + draft.id + '-' + group.groupId">
                        {{ group.groupName || '-' }}
                        <span class="text-muted small">({{ getShortcutDraftGroupSelectedCount(draft, group.groupId) }}/{{ group.selectableLinkCount }})</span>
                      </label>
                    </div>
                    <div class="ms-4 mt-1" v-if="group.links.length > 0">
                      <div
                        v-for="link in group.links"
                        :key="'shortcut-target-link-' + draft.id + '-' + group.groupId + '-' + link.linkId"
                        class="form-check form-check-sm">
                        <input
                          class="form-check-input"
                          type="checkbox"
                          :id="'shortcut-target-link-' + draft.id + '-' + group.groupId + '-' + link.linkId"
                          :checked="isShortcutDraftLinkSelected(draft, group.groupId, link.linkId)"
                          :disabled="!link.validUrl || isShortcutDraftGroupSelected(draft, group.groupId)"
                          @change="toggleShortcutDraftLink(draftIndex, group.groupId, link.linkId, $event.target.checked)"
                        >
                        <label class="form-check-label small" :for="'shortcut-target-link-' + draft.id + '-' + group.groupId + '-' + link.linkId">
                          {{ link.linkText || '-' }}
                          <span class="text-muted d-block small text-truncate mb-shortcut-target-link-url">{{ link.rawUrl || '-' }}</span>
                          <span v-if="!link.validUrl" class="text-warning small">
                            {{ getTranslation('shortcuts.manager.invalidLinkUrl') || 'Invalid URL; cannot be opened via shortcut.' }}
                          </span>
                        </label>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="form-text">
                  {{ getShortcutManagerDraftStatsText(draft) }}
                </div>
              </div>
            </div>
            <button type="button" class="btn btn-sm btn-outline-primary" @click="addGlobalShortcutDraft">
              {{ getTranslation('shortcuts.manager.addGlobal') || 'Add global shortcut' }}
            </button>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" @click="saveShortcutManagerDialog">
            {{ getTranslation('save') || 'Save' }}
          </button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
            {{ getTranslation('dialog.close') || 'Close' }}
          </button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="globalPlaceholdersModal" tabindex="-1" aria-labelledby="globalPlaceholdersModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="globalPlaceholdersModalLabel">
            {{ getTranslation('placeholders.global.title') || 'Global placeholders' }}
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p class="small text-muted mb-2">{{ getTranslation('placeholders.global.help') || 'Global placeholders are available for all links.' }}</p>
          <div class="table-responsive">
            <table class="table table-sm align-middle mb-placeholder-table">
              <thead>
                <tr>
                  <th style="width: 30%;">{{ getTranslation('placeholders.name') || 'Name' }}</th>
                  <th style="width: 40%;">{{ getTranslation('placeholders.value') || 'Value' }}</th>
                  <th style="width: 20%;">{{ getTranslation('placeholders.encode') || 'Encode' }}</th>
                  <th style="width: 10%;">{{ getTranslation('delete') || 'Delete' }}</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="(row, idx) in globalPlaceholderRows" :key="'global-placeholder-' + idx">
                  <td><input v-model="row.name" type="text" class="form-control form-control-sm" placeholder="PLACEHOLDER"></td>
                  <td><input v-model="row.value" type="text" class="form-control form-control-sm" :placeholder="getTranslation('placeholders.valuePlaceholder') || 'Enter value'"></td>
                  <td>
                    <div class="form-check">
                      <input class="form-check-input" type="checkbox" :id="'global-placeholder-encode-' + idx" v-model="row.encode">
                      <label class="form-check-label small" :for="'global-placeholder-encode-' + idx">
                        {{ getTranslation('placeholders.encodeLabel') || 'URL-encode' }}
                      </label>
                    </div>
                  </td>
                  <td>
                    <button type="button" class="btn btn-sm btn-outline-danger" @click="removeGlobalPlaceholderRow(idx)">×</button>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <button type="button" class="btn btn-sm btn-outline-primary" @click="addGlobalPlaceholderRow">
            {{ getTranslation('placeholders.add') || 'Add placeholder' }}
          </button>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" @click="saveGlobalPlaceholderDialog">{{ getTranslation('save') || 'Save' }}</button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{{ getTranslation('dialog.close') || 'Close' }}</button>
        </div>
      </div>
    </div>
  </div>

  <div id="options">
  </div>

  <div id="qrCode">
    <div class="modal fade" id="qrCodeModal" tabindex="-1" aria-labelledby="qrCodeModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content mb-modal">
          <div class="modal-header">
            <h5 class="modal-title" id="qrCodeModalLabel">QR code</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body text-center">
            <div id="qrCodeDiv"></div>
            <p class="mt-3 qrCodeUrl">{{ qrCodeUrl }}</p>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Bookmarklet Modal -->
  <div id="bookmarklet">
    <div class="modal fade" id="bookmarkletModal" tabindex="-1" aria-labelledby="bookmarkletModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content mb-modal">
          <div class="modal-header">
            <h5 class="modal-title" id="bookmarkletModalLabel">{{ getTranslation('bookmarklet.helpTitle') }}</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <p class="mb-2">{{ getTranslation('bookmarklet.instructions') }}</p>
            <p class="mb-2"><a :href="bookmarkletHref" draggable="true" class="btn btn-sm btn-primary">{{ getTranslation('bookmarklet.dragThis') }}</a></p>
            <div class="input-group input-group-sm">
              <span class="input-group-text mb-bookmarklet-prefix">JS</span>
              <input type="text" class="form-control" :value="bookmarkletHref" readonly onclick="this.select()">
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- JSON Inspector Modal -->
  <div class="modal fade" id="jsonInspectorModal" tabindex="-1" aria-labelledby="jsonInspectorModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-centered modal-dialog-scrollable">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="jsonInspectorModalLabel">
            {{ getTranslation('json.inspector.title') || 'Group JSON Inspector' }}
            <span v-if="inspectedGroup" class="text-muted ms-2">- {{ inspectedGroup.name }}</span>
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div v-if="inspectedGroup">
            <!-- Tabs -->
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#json-tab" type="button" role="tab">
                  JSON
                </button>
              </li>
              <li class="nav-item" role="presentation" v-if="inspectedGroup.eventLog && inspectedGroup.eventLog.length > 0">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#eventlog-tab" type="button" role="tab">
                  Event Log ({{ inspectedGroup.eventLog.length }})
                </button>
              </li>
              <li class="nav-item" role="presentation" v-if="inspectedGroup.snapshot">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#snapshot-tab" type="button" role="tab">
                  Snapshot
                </button>
              </li>
            </ul>
            
            <!-- Tab Content -->
            <div class="tab-content mt-3">
              <!-- JSON Tab -->
              <div class="tab-pane fade show active" id="json-tab" role="tabpanel">
                <!-- Copy button and info -->
                <div class="d-flex justify-content-between align-items-center mb-3">
                  <div class="text-muted">
                    <small>
                      {{ getTranslation('json.inspector.info') || 'Complete JSON representation of the group object' }}
                    </small>
                  </div>
                  <button type="button" class="btn btn-sm btn-outline-primary" @click="copyGroupJSON">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16">
                      <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
                      <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
                    </svg>
                    {{ getTranslation('json.inspector.copy') || 'Copy JSON' }}
                  </button>
                </div>
                
                <!-- JSON display -->
                <pre class="bg-light p-3 rounded mb-surface-panel mb-json-inspector-code" style="max-height: 50vh; overflow-y: auto; font-size: 0.875rem;">{{ inspectedGroupJSON }}</pre>
                
                <!-- Statistics -->
                <div class="mt-3 p-3 bg-light rounded mb-surface-panel mb-json-inspector-stats">
                  <h6>{{ getTranslation('json.inspector.stats') || 'Statistics' }}</h6>
                  <div class="row">
                    <div class="col-md-6">
                      <ul class="list-unstyled mb-0">
                        <li><strong>Links:</strong> {{ inspectedGroup.links ? inspectedGroup.links.length : 0 }}</li>
                        <li><strong>Members:</strong> {{ inspectedGroup.members ? inspectedGroup.members.length : 0 }}</li>
                        <li><strong>Shared:</strong> {{ inspectedGroup.shared ? 'Yes' : 'No' }}</li>
                        <li><strong>Version:</strong> {{ inspectedGroup.version || CONSTS.VERSION_FALLBACK }}</li>
                      </ul>
                    </div>
                    <div class="col-md-6">
                      <ul class="list-unstyled mb-0">
                        <li><strong>Has Event Log:</strong> {{ inspectedGroup.eventLog ? 'Yes' : 'No' }}</li>
                        <li v-if="inspectedGroup.eventLog"><strong>Events:</strong> {{ inspectedGroup.eventLog.length }}</li>
                        <li v-if="inspectedGroup.snapshot"><strong>Has Snapshot:</strong> Yes</li>
                        <li><strong>Size:</strong> {{ formatBytes(inspectedGroupJSON.length) }}</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Event Log Tab -->
              <div class="tab-pane fade" id="eventlog-tab" role="tabpanel" v-if="inspectedGroup.eventLog">
                <div class="table-responsive">
                  <table class="table table-sm table-hover">
                    <thead>
                      <tr>
                        <th>{{ getTranslation('eventlog.time') || 'Time' }}</th>
                        <th>{{ getTranslation('eventlog.type') || 'Type' }}</th>
                        <th>{{ getTranslation('eventlog.author') || 'Author' }}</th>
                        <th>{{ getTranslation('eventlog.details') || 'Details' }}</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr v-for="event in getSortedEventLog(inspectedGroup.eventLog)" :key="event.eventId">
                        <td class="text-nowrap">{{ formatEventTime(event.timestamp) }}</td>
                        <td>
                          <span class="badge" :class="getEventTypeBadgeClass(event.operation?.type || event.type)">
                            {{ event.operation?.type || event.type || 'unknown' }}
                          </span>
                        </td>
                        <td>{{ getAuthorName(event.author || event.authorId) }}</td>
                        <td>
                          <div v-if="(event.operation?.type || event.type) === 'link-edit' && ((event.operation && Object.keys(event.operation.data || {}).length > 1) || (!event.operation && event.data?.changes && Object.keys(event.data.changes).length > 1))">
                            <details>
                              <summary class="cursor-pointer">
                                <small class="text-muted">{{ Object.keys(event.operation?.data || event.data?.changes || {}).length }} {{ getTranslation('eventlog.changes') || 'changes' }}</small>
                              </summary>
                              <div class="mt-1">
                                <small class="text-muted" v-html="getEventDetailsFormatted(event)"></small>
                              </div>
                            </details>
                          </div>
                          <div v-else>
                            <small class="text-muted" v-html="getEventDetailsFormatted(event)"></small>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              
              <!-- Snapshot Tab -->
              <div class="tab-pane fade" id="snapshot-tab" role="tabpanel" v-if="inspectedGroup.snapshot">
                <div class="p-3 bg-light rounded mb-surface-panel mb-json-inspector-snapshot">
                  <h6>{{ getTranslation('snapshot.info') || 'Snapshot Information' }}</h6>
                  <ul class="list-unstyled">
                    <li><strong>{{ getTranslation('snapshot.created') || 'Created' }}:</strong> {{ formatEventTime(inspectedGroup.snapshot.timestamp) }}</li>
                    <li><strong>{{ getTranslation('snapshot.eventId') || 'Event ID' }}:</strong> <code>{{ inspectedGroup.snapshot.eventId || 'N/A' }}</code></li>
                    <li><strong>{{ getTranslation('snapshot.links') || 'Links in snapshot' }}:</strong> {{ inspectedGroup.snapshot.data?.links?.length || 0 }}</li>
                    <li><strong>{{ getTranslation('snapshot.members') || 'Members in snapshot' }}:</strong> {{ inspectedGroup.snapshot.data?.members?.length || 0 }}</li>
                    <li><strong>{{ getTranslation('snapshot.version') || 'Version' }}:</strong> {{ inspectedGroup.snapshot.data?.version || CONSTS.VERSION_FALLBACK }}</li>
                  </ul>
                  
                  <h6 class="mt-3">{{ getTranslation('snapshot.vectorClock') || 'Vector Clock' }}</h6>
                  <div class="table-responsive">
                    <table class="table table-sm" v-if="inspectedGroup.snapshot.vectorClock && Object.keys(inspectedGroup.snapshot.vectorClock).length > 0">
                      <thead>
                        <tr>
                          <th>{{ getTranslation('snapshot.member') || 'Member' }}</th>
                          <th>{{ getTranslation('snapshot.eventCount') || 'Event Count' }}</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr v-for="(count, memberId) in inspectedGroup.snapshot.vectorClock" :key="memberId">
                          <td>{{ getAuthorName(memberId) }}</td>
                          <td>{{ count }}</td>
                        </tr>
                      </tbody>
                    </table>
                    <p v-else class="text-muted">{{ getTranslation('snapshot.noVectorClock') || 'No vector clock data' }}</p>
                  </div>
                  
                  <details class="mt-3">
                    <summary class="cursor-pointer">{{ getTranslation('snapshot.showData') || 'Show snapshot data' }}</summary>
                    <pre class="bg-white p-2 mt-2 rounded mb-surface-panel mb-json-inspector-snapshot-data" style="max-height: 30vh; overflow-y: auto; font-size: 0.875rem;">{{ JSON.stringify(inspectedGroup.snapshot.data, null, 2) }}</pre>
                  </details>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{{ getTranslation('close') || 'Close' }}</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Paste from Clipboard Modal -->
  <div id="pasteClipboard">
    <div class="modal fade" id="pasteClipboardModal" tabindex="-1" aria-labelledby="pasteClipboardModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content mb-modal">
          <div class="modal-header">
            <h5 class="modal-title" id="pasteClipboardModalLabel">{{ getTranslation('clipboard.modalTitle') || 'Import Links' }}</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" @click="resetImportDialog"></button>
          </div>
          <div class="modal-body">
            <p class="mb-2">{{ getTranslation('clipboard.instructions') || 'Import from file or paste JSON, CSV, or HTML bookmarks:' }}</p>
            
            <!-- File upload section -->
            <div class="options-section mb-edit-section">
              <div
                class="options-section-header mb-edit-section-header"
                :class="{ collapsed: !isImportDialogSectionExpanded('file') }"
                @click="toggleImportDialogSection('file')">
                <span>{{ getTranslation('import.fromFile') || 'Import from file:' }}</span>
                <svg class="chevron-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                </svg>
              </div>
              <div v-show="isImportDialogSectionExpanded('file')" class="options-section-body mb-edit-section-body">
                <input type="file" class="form-control form-control-sm"
                  accept=".json,.csv,.html,.htm"
                  @change="handleFileUpload"
                  ref="fileInput">
              </div>
            </div>

            <!-- URL import section -->
            <div class="options-section mb-edit-section">
              <div
                class="options-section-header mb-edit-section-header"
                :class="{ collapsed: !isImportDialogSectionExpanded('url') }"
                @click="toggleImportDialogSection('url')">
                <span>{{ getTranslation('import.fromUrl') || 'Import from URL:' }}</span>
                <svg class="chevron-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                </svg>
              </div>
              <div v-show="isImportDialogSectionExpanded('url')" class="options-section-body mb-edit-section-body">
                <div class="mb-2">
                  <div class="input-group">
                    <input type="url" class="form-control form-control-sm"
                      v-model="importUrl"
                      :placeholder="getTranslation('import.urlPlaceholder') || 'https://example.com/bookmarks.json'"
                      @keyup.enter="fetchFromUrl">
                    <button type="button" class="btn btn-sm btn-outline-secondary"
                      @click="fetchFromUrl"
                      :disabled="!importUrl || fetchingUrl">
                      <span v-if="fetchingUrl">{{ getTranslation('import.fetching') || 'Fetching...' }}</span>
                      <span v-else>{{ getTranslation('import.fetch') || 'Fetch' }}</span>
                    </button>
                  </div>
                  <div v-if="urlFetchError" class="text-danger small mt-1">{{ urlFetchError }}</div>
                </div>

                <div v-if="extensionAvailable" class="text-center my-2">
                  <small class="text-muted">{{ getTranslation('import.or') || '— OR —' }}</small>
                </div>

                <!-- Browser bookmarks option (if extension available) -->
                <div v-if="extensionAvailable">
                  <button type="button" class="btn btn-sm btn-outline-primary"
                    @click="fetchBrowserBookmarks"
                    :disabled="fetchingBrowserBookmarks">
                    <span v-if="fetchingBrowserBookmarks">
                      <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                      {{ getTranslation('import.fetchingBookmarks') || 'Loading bookmarks...' }}
                    </span>
                    <span v-else>
                      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bookmark-star me-1" viewBox="0 0 16 16">
                        <path d="M7.84 4.1a.178.178 0 0 1 .32 0l.634 1.285a.178.178 0 0 0 .134.098l1.42.206c.145.021.204.2.098.303L9.42 6.993a.178.178 0 0 0-.051.158l.242 1.414a.178.178 0 0 1-.258.187l-1.27-.668a.178.178 0 0 0-.165 0l-1.27.668a.178.178 0 0 1-.257-.187l.242-1.414a.178.178 0 0 0-.05-.158l-1.03-1.001a.178.178 0 0 1 .098-.303l1.42-.206a.178.178 0 0 0 .134-.098L7.84 4.1z"/>
                        <path d="M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v13.5a.5.5 0 0 1-.777.416L8 13.101l-5.223 2.815A.5.5 0 0 1 2 15.5V2zm2-1a1 1 0 0 0-1 1v12.566l4.723-2.482a.5.5 0 0 1 .554 0L13 14.566V2a1 1 0 0 0-1-1H4z"/>
                      </svg>
                      {{ getTranslation('import.browserBookmarks') || 'Import Browser Bookmarks' }}
                    </span>
                  </button>
                  <div v-if="browserBookmarksInfo" class="text-muted small mt-1">
                    {{ browserBookmarksInfo }}
                  </div>
                </div>
              </div>
            </div>

            <!-- Clipboard section -->
            <div class="options-section mb-edit-section">
              <div
                class="options-section-header mb-edit-section-header"
                :class="{ collapsed: !isImportDialogSectionExpanded('clipboard') }"
                @click="toggleImportDialogSection('clipboard')">
                <span>{{ getTranslation('import.fromClipboard') || 'Paste from clipboard:' }}</span>
                <svg class="chevron-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                </svg>
              </div>
              <div v-show="isImportDialogSectionExpanded('clipboard')" class="options-section-body mb-edit-section-body">
                <div class="mb-2">
                  <button type="button" class="btn btn-sm btn-outline-secondary" @click="readFromClipboard">{{ getTranslation('clipboard.read') || 'Read from Clipboard' }}</button>
                </div>
                <div class="mb-3">
                  <textarea class="form-control" rows="5" v-model="pasteContent" @input="parsePastedContent" :placeholder="getTranslation('clipboard.placeholder') || 'Paste your data here...'"></textarea>
                </div>
                <div class="mb-0">
                  <label class="form-label">{{ getTranslation('import.csvSeparator') || 'CSV separator (optional):' }}</label>
                  <input type="text" class="form-control form-control-sm"
                    v-model="importCsvSeparator"
                    maxlength="8"
                    @input="parsePastedContent"
                    :placeholder="getTranslation('import.csvSeparator.placeholder') || 'Auto-detect (e.g. ; or ,)'">
                  <div class="form-text">{{ getTranslation('import.csvSeparator.help') || 'Leave empty for automatic detection. Use \\t for tab.' }}</div>
                </div>
                <div class="text-muted small mt-2" v-if="pasteHint">{{ pasteHint }}</div>
              </div>
            </div>
            
            <!-- Format detection -->
            <div v-if="detectedFormat" class="alert alert-info py-2">
              <small>{{ getTranslation('clipboard.detectedFormat') || 'Detected format:' }} <strong>{{ detectedFormat }}</strong></small>
            </div>
            
            <!-- Warning for full export -->
            <div v-if="isFullExport" class="alert alert-warning py-2">
              <strong>{{ getTranslation('import.fullExportWarning.title') || 'Warning!' }}</strong>
              {{ getTranslation('import.fullExportWarning.message') || 'This is a full database export. It should only be imported into an EMPTY database to avoid conflicts. All existing data will be replaced.' }}
            </div>
            
            <!-- New group title input (only show when not doing full import) -->
            <div v-if="parsedLinks && parsedLinks.length > 0 && !isFullExport" class="mb-3">
              <label class="form-label">{{ getTranslation('import.newGroupTitle') || 'New group title:' }}</label>
              <input type="text" class="form-control form-control-sm" 
                v-model="importGroupTitle" 
                :placeholder="getDefaultImportGroupTitle()"
                @keypress.enter.prevent="importSelected">
            </div>
            
            <!-- Preview section -->
            <div v-if="parsedLinks && parsedLinks.length > 0" class="border rounded p-2 mb-surface-panel mb-import-preview-panel" style="max-height: 300px; overflow-y: auto;">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="mb-0">{{ getTranslation('clipboard.preview') || 'Preview' }} ({{ parsedLinks.filter(l => l.selected).length }}/{{ parsedLinks.length }})</h6>
                <div>
                  <button type="button" class="btn btn-sm btn-outline-primary me-1" @click="selectAllLinks">{{ getTranslation('clipboard.selectAll') || 'Select All' }}</button>
                  <button type="button" class="btn btn-sm btn-outline-secondary" @click="deselectAllLinks">{{ getTranslation('clipboard.deselectAll') || 'Deselect All' }}</button>
                </div>
              </div>
              
              <!-- Group by existing groups if available -->
              <div v-if="getImportGroups().length > 0" class="mb-2">
                <div class="alert alert-info py-2">
                  <small>{{ getTranslation('import.groupsFound') || 'Found links from the following groups:' }}</small>
                  <div class="mt-1">
                    <span v-for="groupName in getImportGroups()" :key="groupName" 
                          class="badge bg-secondary me-1">{{ groupName }}</span>
                  </div>
                  <small class="d-block mt-2">{{ getTranslation('import.groupsWillBeCreated') || 'These groups will be created automatically if they don\'t exist.' }}</small>
                </div>
              </div>
              
              <div class="list-group list-group-flush">
                <!-- Group links by groupName -->
                <template v-for="groupName in getUniqueGroupNames()">
                  <!-- Group header with checkbox and toggle -->
                  <div v-if="groupName" :key="'group-' + groupName"
                       class="list-group-item py-2 bg-light mb-surface-panel mb-import-group-header">
                    <div class="d-flex align-items-center">
                      <!-- Group checkbox -->
                      <input type="checkbox"
                             class="form-check-input me-2"
                             :checked="isGroupSelected(groupName)"
                             @change="toggleGroupSelection(groupName)"
                             :id="'import-group-' + groupName">

                      <!-- Toggle button -->
                      <button type="button"
                              class="btn btn-sm btn-link p-0 me-2 text-decoration-none"
                              @click="toggleImportGroupCollapse(groupName)"
                              :aria-expanded="!isImportGroupCollapsed(groupName)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                          <path v-if="isImportGroupCollapsed(groupName)" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                          <path v-else d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                        </svg>
                      </button>

                      <!-- Group name and count -->
                      <strong class="text-primary flex-grow-1">
                        📁 {{ getGroupDisplayName(groupName) }}
                        <span class="text-muted small">({{ getLinksForGroup(groupName).length }})</span>
                      </strong>
                    </div>
                    <!-- Full path display for browser bookmarks -->
                    <div v-if="getGroupFullPath(groupName)" class="ms-4 mt-1">
                      <small class="text-muted">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-folder-fill me-1" viewBox="0 0 16 16">
                          <path d="M9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.825a2 2 0 0 1-1.991-1.819l-.637-7a1.99 1.99 0 0 1 .342-1.31L.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3zm-8.322.12C1.72 3.042 1.95 3 2.19 3h5.396l-.707-.707A1 1 0 0 0 6.172 2H2.5a1 1 0 0 0-1 .981l.006.139z"/>
                        </svg>
                        {{ getGroupFullPath(groupName) }}
                      </small>
                    </div>
                  </div>

                  <!-- Collapsible links in this group -->
                  <div v-show="!isImportGroupCollapsed(groupName)">
                    <label v-for="(link, index) in getLinksForGroup(groupName)"
                           :key="'link-' + groupName + '-' + index"
                           class="list-group-item py-1"
                           :style="groupName ? 'padding-left: 3rem;' : ''">
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" v-model="link.selected"
                               :id="'import-link-' + parsedLinks.indexOf(link)">
                        <div class="ms-2">
                          <div class="d-flex align-items-center">
                            <div class="fw-bold small">{{ link.text || link.url }}</div>
                          </div>
                          <div class="text-muted small text-truncate" style="max-width: 100%;">{{ link.url }}</div>
                          <div v-if="link.keywords && link.keywords.length" class="small">
                            <span v-for="kw in parseKeywords(link.keywords)"
                              :key="kw" class="badge me-1 mb-import-keyword-badge" style="background-color: #e9ecef; color: #212529;">{{ kw }}</span>
                          </div>
                        </div>
                      </div>
                    </label>
                  </div>
                </template>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" @click="confirmPasteAdd" :disabled="!parsedLinks || parsedLinks.filter(l => l.selected).length === 0">
              {{ getTranslation('clipboard.import') || 'Import Selected' }} 
              <span v-if="parsedLinks && parsedLinks.filter(l => l.selected).length > 0">({{ parsedLinks.filter(l => l.selected).length }})</span>
            </button>
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" @click="resetImportDialog">{{ getTranslation('clipboard.cancel') || 'Cancel' }}</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Export Dialog -->
  <div id="exportDialog">
    <div class="modal fade" id="exportModal" tabindex="-1" aria-labelledby="exportModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content mb-modal">
          <div class="modal-header">
            <h5 class="modal-title" id="exportModalLabel">{{ getTranslation('export.title') || 'Export Bookmarks' }}</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div v-if="exportFormat !== 'json'">
              <p class="mb-3">{{ getTranslation('export.selectItems') || 'Select groups and links to export:' }}</p>
              <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="mb-0">{{ getTranslation('export.groups') || 'Groups' }}</h6>
                <div>
                  <button type="button" class="btn btn-sm btn-outline-primary me-1" @click="selectAllExportGroups">
                    {{ getTranslation('export.selectAll') || 'Select All' }}
                  </button>
                  <button type="button" class="btn btn-sm btn-outline-secondary" @click="deselectAllExportGroups">
                    {{ getTranslation('export.deselectAll') || 'Deselect All' }}
                  </button>
                </div>
              </div>
              <div class="border rounded p-2 mb-surface-panel mb-export-selection-panel" style="max-height: 400px; overflow-y: auto;">
                <div v-for="(group, gIndex) in exportSelection" :key="'export-g-' + gIndex" class="mb-3">
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" v-model="group.selected" 
                      @change="onExportGroupChange(gIndex)" :id="'export-group-' + gIndex">
                    <label class="form-check-label fw-bold" :for="'export-group-' + gIndex">
                      {{ group.name || 'Untitled Group' }}
                      <span class="text-muted small">({{ group.links.filter(l => l.selected).length }}/{{ group.links.length }})</span>
                    </label>
                  </div>
                  <div class="ms-4 mt-1" v-if="group.links && group.links.length > 0">
                    <div v-for="(link, lIndex) in group.links" :key="'export-l-' + gIndex + '-' + lIndex" 
                      class="form-check form-check-sm">
                      <input class="form-check-input" type="checkbox" v-model="link.selected" 
                        @change="onExportLinkChange(gIndex)" :id="'export-link-' + gIndex + '-' + lIndex">
                      <label class="form-check-label small" :for="'export-link-' + gIndex + '-' + lIndex">
                        {{ link.text || link.url }}
                        <span class="text-muted d-block small text-truncate" style="max-width: 500px;">{{ link.url }}</span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div v-else>
              <p class="mb-2 fw-bold">Full JSON (Preview)</p>
              <textarea class="form-control" rows="12" readonly :value="getFullJsonPreview()"></textarea>
            </div>

            <div class="mt-3">
              <label class="form-label">{{ getTranslation('export.format') || 'Export Format:' }}</label>
              <select class="form-select form-select-sm" v-model="exportFormat">
                <option value="json">JSON (Full)</option>
                <option value="json-array">JSON Array (Links only)</option>
                <option value="csv">CSV</option>
                <option value="html">HTML Bookmarks</option>
              </select>
            </div>
          </div>
          <div class="modal-footer">
            <span v-if="exportFormat !== 'json'" class="me-auto text-muted">
              {{ getExportSelectionCount() }} {{ getTranslation('export.selected') || 'selected' }}
            </span>
            <button type="button" class="btn btn-primary" @click="confirmExport" 
              :disabled="exportFormat !== 'json' && !hasExportSelection()">
              {{ getTranslation('export.export') || 'Export' }}
            </button>
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
              {{ getTranslation('export.cancel') || 'Cancel' }}
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  
  <!-- Unified Generic Edit Dialog -->
  <div class="modal fade" id="genericEditModal" tabindex="-1" aria-labelledby="genericEditModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <div class="d-flex align-items-center flex-grow-1">
            <!-- Favicon display for link & group edit dialog -->
            <div v-if="genericEditData && ['link','group'].includes(genericEditConfig.type) && !isGenericSeparatorEditMode()" class="me-3 mb-edit-favicon-preview">
              <div v-if="genericEditData.faviconLoading"
                class="link-edit-favicon-loading"
                style="width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">
                <div class="spinner-border spinner-border-sm text-primary" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
              </div>
              <span v-else-if="genericEditData.favicon && !genericEditData.faviconError" class="link-favicon-wrap" :title="faviconSourceTooltip(genericEditData)">
                <img
                  :src="genericEditData.favicon"
                  alt="Favicon"
                  class="link-edit-favicon"
                  style="width: 32px; height: 32px; object-fit: contain; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                <span v-if="genericEditData.faviconSource" class="link-favicon-dot" :class="faviconSourceClass(genericEditData)"></span>
              </span>
              <span v-else-if="genericEditData.emoji"
                class="link-edit-emoji"
                style="font-size: 32px; display: inline-block; width: 32px; height: 32px; line-height: 32px; text-align: center;">
                {{ genericEditData.emoji }}
              </span>
              <span v-else-if="genericEditData.faviconError"
                class="link-edit-favicon-error"
                style="font-size: 24px; display: inline-block; width: 32px; height: 32px; line-height: 32px; text-align: center; opacity: 0.5;"
                :title="getTranslation('favicon.loadError') || 'Favicon konnte nicht geladen werden'">
                ⚠️
              </span>
              <span v-else
                class="link-edit-favicon-placeholder"
                style="display: inline-block; width: 32px; height: 32px; background: #f0f0f0; border-radius: 4px; border: 1px dashed #ccc;">
              </span>
            </div>
            <h5 class="modal-title mb-edit-modal-title mb-0" id="genericEditModalLabel">{{ genericEditConfig.title }}</h5>
          </div>
          <div v-if="genericEditData && ['link','group'].includes(genericEditConfig.type) && !isGenericSeparatorEditMode()" class="mb-edit-favicon-actions">
            <button type="button" class="btn btn-sm btn-outline-secondary" @click="$refs.faviconFile && $refs.faviconFile.click()">
              {{ getFaviconText('upload') }}
            </button>
            <button type="button" class="btn btn-sm btn-outline-danger" @click="clearEditedFavicon" :disabled="!genericEditData.favicon && !genericEditData.faviconError">
              {{ getFaviconText('remove') }}
            </button>
            <input ref="faviconFile" type="file" accept="image/*" class="d-none" @change="onFaviconFileSelected">
          </div>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body mb-edit-modal-body">
          <form @submit.prevent="saveGenericEditDialog" v-if="genericEditData" class="mb-edit-form">
            <!-- Filter Input -->
            <div class="mb-3 mb-edit-filter-container">
              <div class="input-group mb-edit-filter-group">
                <span class="input-group-text">
                  <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                  </svg>
                </span>
                <input 
                  type="text" 
                  class="form-control mb-edit-filter-input" 
                  v-model="genericFilterText"
                  placeholder="Filter settings..."
                >
                <button class="btn btn-outline-secondary" type="button" @click="genericFilterText = ''" 
                  v-if="genericFilterText">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M2.5 2.5a.7.7 0 0 1 .99 0L8 7.01l4.51-4.51a.7.7 0 1 1 .99.99L8.99 8l4.51 4.51a.7.7 0 0 1-.99.99L8 8.99l-4.51 4.51a.7.7 0 1 1-.99-.99L7.01 8 2.5 3.49a.7.7 0 0 1 0-.99Z"/>
                  </svg>
                </button>
              </div>
            </div>
            
            <!-- Generic Edit Sections -->
            <div v-for="(section, sectionKey) in getFilteredGenericSettings()" :key="sectionKey" v-if="hasVisibleGenericSectionFields(sectionKey, section)" class="options-section mb-edit-section">
              <div 
                class="options-section-header mb-edit-section-header"
                :class="{ collapsed: !isGenericSectionExpanded(sectionKey) }"
                @click="toggleGenericSection(sectionKey)"
              >
                <span>{{ getTranslation(section.translateKey) || sectionKey }}</span>
                <svg class="chevron-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                </svg>
              </div>
              
              <div v-show="isGenericSectionExpanded(sectionKey)" class="options-section-body mb-edit-section-body">
                <div v-for="(field, fieldKey) in section.fields" :key="fieldKey" v-if="shouldShowGenericField(sectionKey, fieldKey, field)"
                     :class="['option-row mb-edit-field-row', field.rowClass || '', { 'role-disabled': isFieldDisabled(sectionKey, fieldKey) }]">
                  
                  <!-- Text Field -->
                  <div v-if="field.type === 'text'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                      <span v-if="field.roleScope" :class="['role-badge mb-edit-role-badge', 'role-' + field.roleScope]">
                        {{ getRoleScopeBadgeText(field.roleScope) }}
                      </span>
                    </label>
                    <input 
                      type="text" 
                      class="form-control form-control-sm mb-edit-text-input"
                      :data-section="sectionKey"
                      :data-field="fieldKey"
                      :value="getGenericFieldValue(sectionKey, fieldKey)"
                      @input="onGenericTextInput(sectionKey, fieldKey, $event)"
                      @focus="maybeUpdateKeywordContext(sectionKey, fieldKey, $event)"
                      @keyup="maybeUpdateKeywordContext(sectionKey, fieldKey, $event)"
                      @click="maybeUpdateKeywordContext(sectionKey, fieldKey, $event)"
                      @blur="clearKeywordContext(sectionKey, fieldKey)"
                      @keydown.tab="handleKeywordTab(sectionKey, fieldKey, $event)"
                      :placeholder="field.placeholder"
                      :disabled="isFieldDisabled(sectionKey, fieldKey)"
                    >
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>
                  
                  <!-- URL Field -->
                  <div v-else-if="field.type === 'url'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                      <span v-if="field.roleScope" :class="['role-badge', 'role-' + field.roleScope]">
                        {{ getRoleScopeBadgeText(field.roleScope) }}
                      </span>
                    </label>
                    <input 
                      type="url" 
                      class="form-control form-control-sm mb-edit-url-input"
                      :data-autofocus="field.autofocus ? 'true' : null"
                      :data-field="fieldKey"
                      :value="getGenericFieldValue(sectionKey, fieldKey)"
                      @input="setGenericFieldValue(sectionKey, fieldKey, $event.target.value)"
                      :placeholder="field.placeholder"
                      :disabled="isFieldDisabled(sectionKey, fieldKey)"
                    >
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>

                  <!-- Shortcut Field -->
                  <div v-else-if="field.type === 'shortcut'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                      <span v-if="field.roleScope" :class="['role-badge', 'role-' + field.roleScope]">
                        {{ getRoleScopeBadgeText(field.roleScope) }}
                      </span>
                    </label>
                    <div class="input-group input-group-sm">
                      <input
                        type="text"
                        class="form-control mb-edit-shortcut-input"
                        :value="getGenericFieldValue(sectionKey, fieldKey)"
                        :placeholder="getTranslation(field.placeholder) || field.placeholder"
                        :disabled="isFieldDisabled(sectionKey, fieldKey)"
                        readonly
                        @focus="$event.target.select()"
                        @keydown="captureShortcutField(sectionKey, fieldKey, $event)"
                      >
                      <button
                        type="button"
                        class="btn btn-outline-secondary"
                        :disabled="isFieldDisabled(sectionKey, fieldKey)"
                        @click="clearShortcutField(sectionKey, fieldKey)"
                      >
                        {{ getTranslation('clear') || 'Clear' }}
                      </button>
                    </div>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                    <div
                      v-for="notice in getGenericShortcutNoticeItems(sectionKey, fieldKey)"
                      :key="'shortcut-notice-' + sectionKey + '-' + fieldKey + '-' + notice.key"
                      class="form-text mb-edit-field-help"
                      :class="notice.className || ''">
                      {{ notice.text }}
                    </div>
                  </div>
                  
                  <!-- Number Field -->
                  <div v-else-if="field.type === 'number'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                      <span v-if="field.roleScope" :class="['role-badge', 'role-' + field.roleScope]">
                        {{ getRoleScopeBadgeText(field.roleScope) }}
                      </span>
                    </label>
                    <div class="input-group input-group-sm">
                      <input 
                        type="number" 
                        class="form-control mb-edit-number-input"
                        :value="getGenericFieldValue(sectionKey, fieldKey)"
                        @input="setGenericFieldValue(sectionKey, fieldKey, Number($event.target.value))"
                        :min="field.min"
                        :max="field.max"
                        :step="field.step"
                        :disabled="isFieldDisabled(sectionKey, fieldKey)"
                      >
                      <span v-if="field.suffix" class="input-group-text">{{ getTranslation(field.suffix) || field.suffix }}</span>
                    </div>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>
                  
                  <!-- Checkbox Field -->
                  <div v-else-if="field.type === 'checkbox'">
                    <div class="form-check">
                      <input 
                        type="checkbox" 
                        class="form-check-input mb-edit-checkbox"
                        :id="field.id"
                        :checked="getGenericFieldValue(sectionKey, fieldKey)"
                        @change="setGenericFieldValue(sectionKey, fieldKey, $event.target.checked)"
                      >
                      <label class="form-check-label mb-edit-checkbox-label" :for="field.id">
                        {{ getTranslation(field.translateKey) || fieldKey }}
                        <span v-if="field.roleScope" :class="['role-badge', 'role-' + field.roleScope]">
                          {{ getRoleScopeBadgeText(field.roleScope) }}
                        </span>
                      </label>
                    </div>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>
                  
                  <!-- Select Field -->
                  <div v-else-if="field.type === 'select'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                      <span v-if="field.roleScope" :class="['role-badge', 'role-' + field.roleScope]">
                        {{ getRoleScopeBadgeText(field.roleScope) }}
                      </span>
                    </label>
                    <select 
                      class="form-select form-select-sm mb-edit-select"
                      :value="getGenericFieldValue(sectionKey, fieldKey)"
                      @change="setGenericFieldValue(sectionKey, fieldKey, $event.target.value)"
                    >
                      <option v-for="(optLabel, optValue) in field.values" :key="optValue" :value="optValue">
                        {{ getTranslation(optLabel) || optLabel }}
                      </option>
                    </select>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>
                  
                  <!-- Textarea Field -->
                  <div v-else-if="field.type === 'textarea'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                      <span v-if="field.roleScope" :class="['role-badge', 'role-' + field.roleScope]">
                        {{ getRoleScopeBadgeText(field.roleScope) }}
                      </span>
                    </label>
                    <textarea
                      class="form-control form-control-sm"
                      :value="getGenericFieldValue(sectionKey, fieldKey)"
                      @input="setGenericFieldValue(sectionKey, fieldKey, $event.target.value)"
                      :placeholder="getTranslation(field.placeholder) || field.placeholder"
                      :rows="field.rows || 3"
                    ></textarea>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>

                  <!-- Placeholder Table Field -->
                  <div v-else-if="field.type === 'placeholders'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                    </label>
                    <div v-if="field.scope === 'link'" class="small text-muted mb-2">
                      <strong>{{ getTranslation('placeholders.urlTemplate') || 'URL template' }}:</strong>
                      <code>{{ getGenericLinkPlaceholderTemplate() || '-' }}</code>
                    </div>
                    <div v-if="field.scope === 'link' && getGenericPlaceholderRows(fieldKey).length === 0" class="small text-muted mb-2">
                      {{ getTranslation('placeholders.noneInUrl') || 'No placeholders found in URL template.' }}
                    </div>
                    <div v-else class="table-responsive">
                      <table class="table table-sm align-middle mb-placeholder-table">
                        <thead>
                          <tr>
                            <th style="width: 30%;">{{ getTranslation('placeholders.name') || 'Name' }}</th>
                            <th style="width: 40%;">{{ getTranslation('placeholders.value') || 'Value' }}</th>
                            <th style="width: 20%;">{{ getTranslation('placeholders.encode') || 'Encode' }}</th>
                            <th style="width: 10%;">{{ getTranslation('delete') || 'Delete' }}</th>
                          </tr>
                        </thead>
                        <tbody>
                          <tr v-for="(row, idx) in getGenericPlaceholderRows(fieldKey)" :key="'generic-placeholder-' + fieldKey + '-' + idx">
                            <td>
                              <code v-if="isGenericInheritedPlaceholderRow(row, fieldKey, idx)">{{ row.name }}</code>
                              <input v-else v-model="row.name" type="text" class="form-control form-control-sm" placeholder="PLACEHOLDER">
                            </td>
                            <td>
                              <input v-model="row.value" type="text" class="form-control form-control-sm" :placeholder="getTranslation('placeholders.valuePlaceholder') || 'Enter value'">
                              <div v-if="isGenericInheritedPlaceholderRow(row, fieldKey, idx)" class="form-text mb-0">
                                <span>{{ getTranslation('placeholders.inheritedValue') || 'Inherited value' }}: <code>{{ getGenericInheritedPlaceholderValue(row, fieldKey, idx) || '—' }}</code></span>
                                <button
                                  v-if="canRestoreGenericInheritedPlaceholderRow(row, fieldKey, idx)"
                                  type="button"
                                  class="btn btn-link btn-sm p-0 ms-2 align-baseline"
                                  @click="restoreGenericInheritedPlaceholderRow(fieldKey, idx)">
                                  {{ getTranslation('placeholders.restoreInherited') || 'Restore inherited' }}
                                </button>
                              </div>
                            </td>
                            <td>
                              <div class="form-check">
                                <input class="form-check-input" type="checkbox" :id="'generic-placeholder-encode-' + fieldKey + '-' + idx" v-model="row.encode">
                                <label class="form-check-label small" :for="'generic-placeholder-encode-' + fieldKey + '-' + idx">
                                  {{ getTranslation('placeholders.encodeLabel') || 'URL-encode' }}
                                </label>
                              </div>
                            </td>
                            <td>
                              <button
                                type="button"
                                class="btn btn-sm btn-outline-danger"
                                :disabled="isGenericInheritedPlaceholderRow(row, fieldKey, idx)"
                                :title="isGenericInheritedPlaceholderRow(row, fieldKey, idx) ? (getTranslation('placeholders.inheritedLocked') || 'Inherited placeholders cannot be deleted.') : ''"
                                @click="removeGenericPlaceholderRow(fieldKey, idx)">×</button>
                            </td>
                          </tr>
                        </tbody>
                      </table>
                    </div>
                    <button type="button" class="btn btn-sm btn-outline-primary" @click="addGenericPlaceholderRow(fieldKey)">
                      {{ getTranslation('placeholders.add') || 'Add placeholder' }}
                    </button>
                    <div v-if="field.scope === 'link'" class="form-text mt-2">
                      <strong>{{ getTranslation('placeholders.preview') || 'Preview' }}:</strong>
                      <code>{{ previewGenericLinkPlaceholderUrl() || '-' }}</code>
                    </div>
                    <div v-if="field.scope === 'link' && getGenericLinkPlaceholderUnresolved().length" class="form-text text-warning">
                      {{ (getTranslation('placeholders.unresolvedHint') || 'Unresolved placeholders') + ': ' + getGenericLinkPlaceholderUnresolved().join(', ') }}
                    </div>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>

                  <!-- Action/Button Field -->
                  <div v-else-if="field.type === 'action'">
                    <label v-if="!field.hideLabel" class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                    </label>
                    <div class="d-flex align-items-center justify-content-end">
                      <button type="button" :class="['btn btn-sm', field.buttonClass || 'btn-warning']" @click="handleGenericAction(sectionKey, fieldKey)">
                        {{ getTranslation(field.buttonLabel) || getTranslation(field.translateKey) || 'Run' }}
                      </button>
                    </div>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>

                  <!-- Multiple Actions in one row -->
                  <div v-else-if="field.type === 'actions'">
                    <div class="d-flex justify-content-end gap-2">
                      <button v-for="(action, idx) in field.actions" :key="idx"
                              type="button"
                              :class="['btn btn-sm', action.buttonClass || 'btn-outline-secondary']"
                              @click="handleGenericAction(sectionKey, action.key)">
                        {{ getTranslation(action.buttonLabel) || getTranslation(action.translateKey) || 'Run' }}
                      </button>
                    </div>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>

                </div>
              </div>
            </div>
          </form>
        </div>
        <div class="modal-footer mb-edit-modal-footer">
          <button v-if="genericEditConfig.type === 'options'" type="button" class="btn btn-danger me-auto mb-edit-reset-btn" @click="resetDataFromOptions">
            {{ getTranslation('eraseDatabase') }}
          </button>
          <button type="button" class="btn btn-primary mb-edit-save-btn" @click="saveGenericEditDialog">{{ getTranslation('save') || 'Save' }}</button>
          <button type="button" class="btn btn-secondary mb-edit-cancel-btn" data-bs-dismiss="modal">{{ getTranslation('cancel') || 'Cancel' }}</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="localSecurityPasswordModal" tabindex="-1" aria-labelledby="localSecurityPasswordModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="localSecurityPasswordModalLabel">{{ getTranslation('options.security.passwordDialog.title') || 'Set encryption password' }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" @click="cancelLocalSecurityPasswordDialog"></button>
        </div>
        <div class="modal-body">
          <p class="text-muted small">{{ getTranslation('options.security.passwordDialog.help') || 'Set a password to protect local data.' }}</p>
          <div class="mb-2">
            <label class="form-label mb-1">{{ getTranslation('options.security.passwordDialog.password') || 'Password' }}</label>
            <input v-model="localSecurityPasswordDialog.password"
              ref="localSecurityPasswordInput"
              type="password"
              autocomplete="new-password"
              class="form-control">
          </div>
          <div class="mb-2">
            <label class="form-label mb-1">{{ getTranslation('options.security.passwordDialog.confirm') || 'Confirm password' }}</label>
            <input v-model="localSecurityPasswordDialog.confirmPassword"
              type="password"
              autocomplete="new-password"
              class="form-control"
              @keyup.enter="submitLocalSecurityPasswordDialog">
          </div>
          <div v-if="localSecurityPasswordDialog.error" class="alert alert-danger py-2 px-3 small mb-0">
            {{ localSecurityPasswordDialog.error }}
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" @click="submitLocalSecurityPasswordDialog">
            {{ getTranslation('options.security.passwordDialog.submit') || 'Apply password' }}
          </button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" @click="cancelLocalSecurityPasswordDialog">
            {{ getTranslation('cancel') || 'Cancel' }}
          </button>
        </div>
      </div>
    </div>
  </div>

  <div
    v-if="shouldShowKeywordSuggestions && keywordSuggestionStyle && keywordSuggestionField"
    class="mb-keyword-suggestions mb-keyword-suggestions--overlay"
    :style="keywordSuggestionStyle"
  >
    <button
      v-for="item in keywordSuggestionList"
      :key="item.value"
      type="button"
      class="mb-keyword-suggestion"
      @mousedown.prevent="applyKeywordSuggestion(keywordSuggestionField.section, keywordSuggestionField.field, item)"
      @click.prevent="applyKeywordSuggestion(keywordSuggestionField.section, keywordSuggestionField.field, item)"
    >
      {{ item.label }}
    </button>
  </div>

  <div
    v-if="shouldShowQuickKeywordSuggestions && quickKeywordSuggestionStyle"
    class="mb-keyword-suggestions mb-keyword-suggestions--overlay"
    :style="quickKeywordSuggestionStyle"
  >
    <button
      v-for="item in quickKeywordSuggestionList"
      :key="'quick-kw-overlay-' + item.value"
      type="button"
      class="mb-keyword-suggestion"
      @mousedown.prevent="applyQuickKeywordSuggestion(item)"
      @click.prevent="applyQuickKeywordSuggestion(item)"
    >
      {{ item.label }}
    </button>
  </div>

  <!-- NC Folder Picker Modal -->
  <div class="modal fade" id="ncFolderPickerModal" tabindex="-1" aria-labelledby="ncFolderPickerLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="ncFolderPickerLabel">{{ getTranslation('bookmarks.pickFolder') }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="d-flex mb-2">
            <button class="btn btn-sm btn-outline-secondary ms-auto" @click="loadNcFolders">{{ getTranslation('bookmarks.refresh') }}</button>
          </div>
          <div v-if="ncFoldersLoading" class="text-center py-3">Loading…</div>
          <div v-else>
            <div class="list-group">
              <label v-for="f in ncFolders" :key="'f-'+f.id" class="list-group-item d-flex align-items-center" style="cursor: pointer;">
                <input class="form-check-input me-2" type="radio" name="ncFolder" :value="f.id" v-model="ncFolderSelected">
                <span class="flex-grow-1">{{ f.title || ('ID '+f.id) }}</span>
                <small class="text-muted">#{{ f.id }}</small>
              </label>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" :disabled="!ncFolderSelected" @click="applyNcFolderSelection">{{ getTranslation('bookmarks.select') }}</button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{{ getTranslation('cancel') || 'Cancel' }}</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Favicon Rules Modal -->
  <div class="modal fade" id="faviconRulesModal" tabindex="-1" aria-labelledby="faviconRulesLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-centered modal-dialog-scrollable">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="faviconRulesLabel">{{ getTranslation('favicon.rules.title') || 'Favicon Rules' }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="d-flex align-items-center justify-content-between mb-2">
            <div class="d-flex align-items-center gap-2 flex-wrap">
              <label class="form-label mb-0 me-2">{{ getTranslation('favicon.rules.test') || 'Test URL' }}</label>
              <input class="form-control form-control-sm" style="min-width: 320px;" v-model="faviconRulesTestUrl" placeholder="https://example.com/path">
              <div v-if="faviconRulesTestUrl" class="d-flex align-items-center gap-2">
                <span class="badge bg-secondary">{{ getTranslation('favicon.rules.matchPreview') || 'Matched rule preview' }}</span>
                <img :src="findRuleIconForUrl(faviconRulesTestUrl) || ''" v-if="findRuleIconForUrl(faviconRulesTestUrl)" style="width: 20px; height: 20px; object-fit: contain; border-radius: 3px;">
              </div>
            </div>
            <div class="d-flex align-items-center gap-2">
              <button type="button" class="btn btn-sm btn-outline-primary" @click="addFaviconRule">+ {{ getTranslation('favicon.rules.add') || 'Add rule' }}</button>
              <button type="button" class="btn btn-sm btn-outline-secondary" @click="restoreDefaultFaviconRules">{{ getTranslation('favicon.rules.restoreDefaults') || 'Restore defaults' }}</button>
              <button
                type="button"
                class="btn btn-sm btn-outline-secondary"
                :title="getTranslation('favicon.rules.export') || 'Export rules'"
                :aria-label="getTranslation('favicon.rules.export') || 'Export rules'"
                @click="exportFaviconRules"
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.6a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-2.6a.5.5 0 0 1 1 0v2.6A1.5 1.5 0 0 1 14.5 15h-13A1.5 1.5 0 0 1 0 13v-2.6a.5.5 0 0 1 .5-.5Z"/>
                  <path d="M7.646 11.354a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 9.293V1.5a.5.5 0 0 0-1 0v7.793L5.354 7.646a.5.5 0 1 0-.708.708Z"/>
                </svg>
              </button>
              <button
                type="button"
                class="btn btn-sm btn-outline-secondary"
                :title="getTranslation('favicon.rules.import') || 'Import rules'"
                :aria-label="getTranslation('favicon.rules.import') || 'Import rules'"
                @click="$refs.faviconRulesImport && $refs.faviconRulesImport.click()"
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.6a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-2.6a.5.5 0 0 1 1 0v2.6A1.5 1.5 0 0 1 14.5 15h-13A1.5 1.5 0 0 1 0 13v-2.6a.5.5 0 0 1 .5-.5Z"/>
                  <path d="M8.354 4.646a.5.5 0 0 0-.708 0l-3 3a.5.5 0 0 0 .708.708L7.5 6.707V14.5a.5.5 0 0 0 1 0V6.707l2.146 2.147a.5.5 0 0 0 .708-.708Z"/>
                </svg>
              </button>
              <input ref="faviconRulesImport" type="file" class="d-none" accept="application/json" @change="onImportFaviconRules">
            </div>
          </div>

          <div class="table-responsive">
            <table class="table table-sm align-middle">
              <thead>
                <tr>
                  <th style="width: 70px;">{{ getTranslation('favicon.rules.enabled') || 'Enabled' }}</th>
                  <th style="width: 140px;">{{ getTranslation('favicon.rules.type') || 'Type' }}</th>
                  <th>{{ getTranslation('favicon.rules.pattern') || 'Pattern' }}</th>
                  <th style="width: 110px;">{{ getTranslation('favicon.rules.icon') || 'Icon' }}</th>
                  <th style="width: 220px;">{{ getTranslation('favicon.rules.comment') || 'Comment' }}</th>
                  <th style="width: 200px;"></th>
                </tr>
              </thead>
              <tbody>
                <tr v-if="!faviconRulesWorking.length">
                  <td colspan="6" class="text-center text-muted py-3">{{ getTranslation('favicon.rules.none') || 'No favicon rules yet.' }}</td>
                </tr>
                <tr v-for="(r, ri) in faviconRulesWorking" :key="r.id || ri">
                  <td>
                    <input type="checkbox" class="form-check-input" v-model="r.enabled">
                  </td>
                  <td>
                    <select class="form-select form-select-sm" v-model="r.patternType">
                      <option value="domain">{{ getTranslation('favicon.rules.domain') || 'Domain' }}</option>
                      <option value="prefix">{{ getTranslation('favicon.rules.prefix') || 'URL prefix' }}</option>
                      <option value="regex">{{ getTranslation('favicon.rules.regex') || 'Regex' }}</option>
                    </select>
                  </td>
                  <td>
                    <input class="form-control form-control-sm" v-model="r.pattern" placeholder="e.g. example.com or https://example.com/path">
                  </td>
                  <td>
                    <img v-if="r.iconDataUrl" :src="r.iconDataUrl" style="width: 20px; height: 20px; object-fit: contain; border-radius: 3px;">
                  </td>
                  <td>
                    <input class="form-control form-control-sm" v-model="r.comment" :placeholder="getTranslation('favicon.rules.commentPlaceholder') || 'Optional comment'">
                  </td>
                  <td>
                    <div class="d-flex gap-1 justify-content-end favicon-rule-actions">
                      <button
                        type="button"
                        class="btn btn-sm btn-outline-secondary"
                        :title="getTranslation('favicon.rules.autofetch') || 'Auto-fetch'"
                        :aria-label="getTranslation('favicon.rules.autofetch') || 'Auto-fetch'"
                        @click="autoFetchRuleIcon(r)"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 1.874 5.293 4.311C14.758 4.687 16 6.137 16 7.891 16 9.918 14.355 11.5 12.438 11.5H9.5a.5.5 0 0 1 0-1h2.938C13.94 10.5 15 9.463 15 7.891c0-1.528-1.226-2.637-2.443-2.637h-.5l-.049-.498C12.012 2.826 10.211 1 8 1a4.53 4.53 0 0 0-3.594 1.64l-.342.406-.525-.111C2.784 2.79 2 3.604 2 4.63c0 .65.26 1.216.682 1.59l.356.315-.27.43A3.063 3.063 0 0 0 3.062 11H6.5a.5.5 0 0 1 0 1H3.062c-2.086 0-3.384-2.286-2.288-4.238a2.724 2.724 0 0 1-.532-1.636c0-1.6 1.157-2.862 2.637-3.101A5.53 5.53 0 0 1 4.406 1.342Z"/>
                          <path d="M7.5 5.5a.5.5 0 0 1 1 0v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 0 1 .708-.708L7.5 9.293z"/>
                          <path d="M3.5 15a.5.5 0 0 1 0-1H12a.5.5 0 0 1 0 1H3.5Z"/>
                        </svg>
                      </button>
                      <button
                        type="button"
                        class="btn btn-sm btn-outline-secondary"
                        :title="getTranslation('favicon.rules.upload') || 'Upload'"
                        :aria-label="getTranslation('favicon.rules.upload') || 'Upload'"
                        @click="openFaviconRuleFile(ri)"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.6a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-2.6a.5.5 0 0 1 1 0v2.6A1.5 1.5 0 0 1 14.5 15h-13A1.5 1.5 0 0 1 0 13v-2.6a.5.5 0 0 1 .5-.5Z"/>
                          <path d="m7.646 11.354-3-3a.5.5 0 0 1 .708-.708L7.5 9.793V1.5a.5.5 0 0 1 1 0v8.293l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0Z"/>
                        </svg>
                      </button>
                      <input type="file" class="d-none" ref="frFile" accept="image/*" @change="onFaviconRuleFileSelected(ri, $event)">
                      <button
                        type="button"
                        class="btn btn-sm btn-outline-danger"
                        :title="getTranslation('favicon.rules.delete') || 'Delete'"
                        :aria-label="getTranslation('favicon.rules.delete') || 'Delete'"
                        @click="deleteFaviconRule(ri)"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5Zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5Zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6Z"/>
                          <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1ZM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118Z"/>
                        </svg>
                      </button>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" @click="saveFaviconRules">{{ getTranslation('save') || 'Save' }}</button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{{ getTranslation('cancel') || 'Cancel' }}</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Duplicates Result Dialog -->
  <div class="modal fade" id="duplicatesModal" tabindex="-1" aria-labelledby="duplicatesModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered modal-dialog-scrollable">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="duplicatesModalLabel">{{ getTranslation('duplicates.title') || 'Duplicate Links Found' }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div v-if="Object.keys(duplicatesFound).length === 0" class="text-center py-4">
            <p class="text-muted">{{ getTranslation('duplicates.none') }}</p>
          </div>
          <div v-else>
            <p class="mb-3">{{ getTranslation('duplicates.description') || 'The following links appear in multiple groups:' }}</p>
            
            <!-- Duplicates list -->
            <div v-for="(duplicateGroup, url) in duplicatesFound" :key="url" class="card mb-3">
              <div class="card-header">
                <div class="d-flex align-items-center justify-content-between">
                  <div class="text-truncate" style="max-width: 70%;">
                    <strong>{{ duplicateGroup[0].link.text }}</strong>
                    <br>
                    <small class="text-muted text-truncate d-block">{{ url }}</small>
                  </div>
                  <span class="badge bg-warning text-dark">
                    {{ duplicateGroup.length }} {{ getTranslation('duplicates.copies') || 'copies' }}
                  </span>
                </div>
              </div>
              <div class="card-body">
                <div class="list-group list-group-flush">
                  <div v-for="(item, index) in duplicateGroup" :key="index" 
                       class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                      <span class="badge">
                        {{ item.group.name }}
                      </span>
                      <span v-if="!item.selected" class="badge bg-success ms-2">
                        {{ getTranslation('duplicates.keep') || 'Keep' }}
                      </span>
                      <span v-else class="badge bg-danger ms-2">
                        {{ getTranslation('duplicates.remove') || 'Remove' }}
                      </span>
                    </div>
                    <div class="form-check">
                      <input class="form-check-input" type="checkbox" 
                             :id="'dup-' + url + '-' + index"
                             :checked="item.selected"
                             @change="toggleDuplicateSelection(url, index)">
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="alert alert-info">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-info-circle me-2" viewBox="0 0 16 16">
                <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                <path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
              </svg>
              {{ getTranslation('duplicates.info') || 'Unchecked items will be kept, checked items will be removed.' }}
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
            {{ getTranslation('cancel') || 'Cancel' }}
          </button>
          <button type="button" class="btn btn-danger" @click="removeDuplicates" 
                  :disabled="Object.keys(duplicatesFound).length === 0">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash me-2" viewBox="0 0 16 16">
              <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
              <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
            </svg>
            {{ getTranslation('duplicates.removeSelected') || 'Remove Selected Duplicates' }}
          </button>
        </div>
      </div>
    </div>
  </div>

  
  <!-- Info popup for HTML content -->
  <div id="infoPopup" class="info-popup" v-html="infoPopupContent"></div>

  <!-- Link detail popover -->
  <div v-if="linkPopover.visible"
       class="link-detail-popover"
       :style="linkPopover.style"
       @mouseenter="cancelHideLinkPopover()"
       @mouseleave="hideLinkPopover()">
    <div class="link-detail-popover__title">
      <img v-if="linkPopover.favicon" :src="linkPopover.favicon" alt="" class="link-detail-popover__favicon">
      <span v-if="linkPopover.emoji" class="link-detail-popover__title-emoji">{{ linkPopover.emoji }}</span>
      <span v-html="linkPopover.titleHtml"></span>
    </div>

    <a v-if="linkPopover.url"
       :href="linkPopover.url"
       class="link-detail-popover__url"
       target="_blank"
       rel="noopener noreferrer">
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
        <path d="M6.354 11.354a.5.5 0 0 0 .707-.708L4.707 8l2.354-2.646a.5.5 0 1 0-.707-.708l-2.5 2.812a.5.5 0 0 0 0 .696z"/>
        <path d="M9.5 11a.5.5 0 0 0 0-1H3.707l2.147-2.417a.5.5 0 1 0-.708-.706l-3 3.375a.5.5 0 0 0 0 .706l3 3.375a.5.5 0 0 0 .708-.706L3.707 11z"/>
        <path d="M12.5 3a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-.5a.5.5 0 0 0-1 0V12a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7a2 2 0 0 0-2 2v.5a.5.5 0 0 0 1 0V4a1 1 0 0 1 1-1z"/>
      </svg>
      <span>{{ linkPopover.displayUrl }}</span>
    </a>

    <div v-else class="link-detail-popover__meta">
      <div class="link-detail-popover__row">
        <span class="link-detail-popover__label">{{ getTranslation('link.popover.url') || 'URL' }}</span>
        <span class="link-detail-popover__value text-muted">{{ getTranslation('link.popover.noUrl') || 'No URL available' }}</span>
      </div>
    </div>

    <div class="link-detail-popover__meta">
      <div class="link-detail-popover__row">
        <span class="link-detail-popover__label">{{ getTranslation('link.popover.created') || 'Created' }}</span>
        <span class="link-detail-popover__value">
          <span>{{ linkPopover.createdAt.full }}</span>
          <span v-if="linkPopover.createdAt.relative" class="link-detail-popover__value--muted">({{ linkPopover.createdAt.relative }})</span>
        </span>
      </div>
      <div class="link-detail-popover__row">
        <span class="link-detail-popover__label">{{ getTranslation('link.popover.updated') || 'Updated' }}</span>
        <span class="link-detail-popover__value">
          <span>{{ linkPopover.updatedAt.full }}</span>
          <span v-if="linkPopover.updatedAt.relative" class="link-detail-popover__value--muted">({{ linkPopover.updatedAt.relative }})</span>
        </span>
      </div>
      <div v-if="linkPopover.rawUrlInput" class="link-detail-popover__row">
        <span class="link-detail-popover__label">{{ getTranslation('link.popover.originalUrl') || 'Original Input' }}</span>
        <span class="link-detail-popover__value">{{ linkPopover.rawUrlInput }}</span>
      </div>
      <div v-if="linkPopover.uuid" class="link-detail-popover__row">
        <span class="link-detail-popover__label">UUID</span>
        <span class="link-detail-popover__value">{{ linkPopover.uuid }}</span>
      </div>
    </div>

    <div v-if="linkPopover.keywords && linkPopover.keywords.length" class="link-detail-popover__keywords">
      <span v-for="kw in linkPopover.keywords"
            :key="'link-popover-kw-' + kw"
            class="link-detail-popover__badge">{{ kw }}</span>
    </div>
  </div>
  
  <!-- Conflict Resolution Notifications -->
  <transition name="fade">
    <div v-if="false && showConflictNotification" class="conflict-notification">
      <div class="conflict-notification-title">
        {{ getTranslation('sync.conflictResolved') || 'Sync Conflict Resolved' }}
      </div>
      <div class="conflict-notification-text">
        {{ conflictNotificationText }}
      </div>
    </div>
  </transition>
  
  </div> <!-- /#app -->

  <footer id="footer" class="copyrightBar mb-footer">
    <span>&copy; 2024-2026 <a href="mailto:mybookmarks@msging.de">Jörg Pannbacker</a> | <a href="https://github.com/akdk7/mybookmarks" target="_blank">Github</a> | <a href="https://raw.githubusercontent.com/akdk7/mybookmarks/refs/heads/main/LICENSE" target="_blank">Licensed under MIT License</a> | Version: {{ version }}</span>
  </footer>
  <script>
    // Should be placed inside the <script type="module"> where 'app' is defined,
    // or defined separately and imported if using a module system.
    // Innerhalb deines <script type="module">

    // Debug logging utility (runtime-controlled via options)
    let DEBUG_ENABLED = false; // Default: off

    function setDebugEnabled(enabled) {
      DEBUG_ENABLED = !!enabled;
    }
    
    function debugLog(level, ...args) {
      if (!DEBUG_ENABLED) return;
      
      const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
      const prefix = `[${timestamp}] [${level.toUpperCase()}]`;
      
      switch(level) {
        case 'log':
          console.log(prefix, ...args);
          break;
        case 'warn':
          console.warn(prefix, ...args);
          break;
        case 'error':
          console.error(prefix, ...args);
          break;
        default:
          console.log(prefix, ...args);
      }
    }

    // Centralized constants used across features
const CONSTS = {
  MINUTE_MS: 60000,
      BACKOFF_MAX_MS: 30000,
      // Keep small to avoid ntfy turning messages into attachments over SSE
      NTFY_CHUNK_SIZE: 2000,
      MAX_CONCURRENT_TRANSFERS: 32,
      MAX_TRANSFER_SIZE: 8 * 1024 * 1024, // 8 MB safety cap for chunked transfers

      // Progressive Loading & Display
      PROGRESSIVE_LOADING_THRESHOLD: 100, // Default number of links to show initially
      EXPANDED_LINK_LIMIT: 500, // Number of links to show when expanded
      PAGE_SIZE: 200, // Default page size for pagination
      INITIAL_LIMIT: 200, // Initial display limit
      GROUP_BODY_HEIGHT_DEFAULT: 360, // Default fixed group body height in px
      GROUP_BODY_HEIGHT_MIN: 45, // Minimum group body height in px
      GROUP_COLUMN_WIDTH_MIN: 180, // Minimum width for group columns in px

      // Event Log
      EVENT_LOG_MAX_EVENTS: 500, // Maximum events to keep in log
      EVENT_LOG_SNAPSHOT_INTERVAL: 50, // Create snapshot every N events

      // Sharing & Sync
      QUICK_CODE_TTL_SEC: 180, // Quick share code expiration (3 minutes)
      CONTACT_ONLINE_TIMEOUT_SEC: 30, // Contact online status timeout
      DEFAULT_NTFY_TTL: undefined, // Default NTFY message TTL

      // UI Delays & Timeouts
      HOVER_EXPAND_DELAY_MS: 1000, // Delay before expanding on hover
      FOCUS_DELAY_SHORT_MS: 300, // Short focus delay
      FOCUS_DELAY_MEDIUM_MS: 500, // Medium focus delay
      FOCUS_DELAY_LONG_MS: 700, // Long focus delay
      UI_UPDATE_DELAY_MS: 100, // General UI update delay
      NETWORK_DELAY_MS: 200, // Network operation delay

      // Storage Keys
      STORAGE_KEY_LINKS: 'links',
      STORAGE_KEY_DARK_MODE: 'darkMode',
      STORAGE_KEY_CUSTOM_COLORS: 'customColors',
      STORAGE_KEY_SIDEBAR_HEIGHT: 'sidebarTopHeight',
      STORAGE_KEY_CSS_SIDEBAR_WIDTH: 'cssSidebarWidth',
      STORAGE_KEY_CSS_SIDEBAR_HEIGHT: 'cssSidebarTopHeight',

      // Defaults
      VERSION_FALLBACK: 0, // Default version for unversioned data
      DEFAULT_GROUP_COLUMNS: 1, // Default number of columns in a group
      DEFAULT_STORAGE_WARNING_MB: 4, // Show warning at 4MB localStorage usage
      MAX_STORAGE_MB: 5, // Maximum localStorage size (browser limit)

  DEFAULT_URL_PREFIX: 'https://'
};

const DEFAULT_FAVICON_RULES = Object.freeze([
  {
    id: 'preset-google',
    enabled: true,
    patternType: 'regex',
    pattern: '(?:www\\.)?google\\.',
    iconDataUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsSAAALEgHS3X78AAAE3ElEQVRYhc2XW2xUVRSGv30uU9rTMhUaCuVixQSMpLYmPIhYwAcTIyKFROI1KQmkxBgj8UEf5MEYiSYmPvhAfCASY02MUaFEHjSRQYtGNDAqIhKxQJVeodPLMJ2Zc/by4cz91tZ4+5Od2Wf2Xuv/z9lrr722EhFmiTagA9gEbCwz5wQQAg4D4Vl5FZGZWqeIhGXuCKdsK/qvNNgsIqG/QFyIUMrXnAR0iEjkbyBPI5LyWcSlpDgGOoG3S67XV71wshd+CMPwEAiAAShoXIy0tsL6dtS6u8qt+E7gUO4fhQI6gI+LzM6ehjf2w9AQJC1QgCi/KRMwQZmIYSLKRBYvwXj2KVTLmlIituEHaZGAZvzIDeZN/+BVOPwhTAX850QgS44CZWWaoBDTRgzbd77lfoxdTxYKGMffUZfA/35pHCoif+8F+Pxdvx/wSr1NPpSR/3z2HERvFM4KkrMMaYtOCvf2p8/A5W5ouAHz4+AkoDoJpguGB6QEpT6GAKJUVsstKzBe2QdOTSmpG1OcmSUIA62Z4eEeCD0BV+pgnoahOhhwwBCwVsL23bCuHZxaf340Cl9/g+5+H0YjcOvKSuRpfA+0KRFpA87kDX2xCgYHIWpDNOALmLLhju2w4/kscSGiUeTIMdTWzTORp3GnhR/5WYwdhUA/NBhQKzDtQZUHddvhkZcru3Mc1GMPz4Y4jQ4LP7dnETkK8wywACVgu2DUwQOvzcXxbLHJojD4pnuz/WoBF1j2KATyN0ga310p41pAkc0xCqEpqFhcr3JnbbSK7OJ9oAyUpcAEAsDSLWVfYXd3OQGFGVaxpx262vP/Ldi4KelCZk+LoWDeirICykKpbEs/l0CRABGd7aeMhNLGcxJTxk/xFxAN4uJpl6R4TIuLG79U0b+gEbxU06TSUqpVRlEMEGhGJy4zJRpLmVzXHtWRIzTUbSjpoOueNInK++35EQbGZ+THwi+jMjtB17bjXesDDKLaT7f9I+9Q37QPy6wvcrCnXeWQ+5ichu5v08IkM7725iLzEwZ+DZeB1G9lVAv9nseg1vziac7EJ/nk1z0zv04KB89EGXVjRO0pkkYCVyVJGgnWFsdyyCDnbAaw6zsYtldwUQtXtTCshUEx+HL0Mw5e2MuUO1mR/MBPf7A//DvjNcNMVI8QC0zhGR4PtZQM5MMlD6OJiRDHz91LRBTjYtAnDtd1DWPikAi0squ5i/sa1hO0nIynnoGLvHn+Ar0DMQKx5VhuNbZbg5MIYno2x3fXsTSYJyJzGEGJMizUt5fjVw8wLjaXJciEOEyKw5DXSJwASapI6lpqzflEkh6SDEJ8CYiJii3HdB0CroMdX0BXy0Je2lAUPzuBQ7kVUYiCtNx9oYuPhnoYkIV4YjGmb2JSGnBReFKFxsbVVSgE8Rz09BJQGuJNWLEmPMOlrXYZJ7fdXkh+gtQZlJsHOvHLpQweX/UWmxp3ABCXQHZAzEzXUG6mr6yJTN+1x3lw+SKObV5dSD6e4vJtZlOUnoqc5rmfX+e32AQxCSIYCCag0NryT01dhXjVSHIBtbKUF29bx9OrVxW6ggpFaRqdlCnLj42c4uhImN6x8/RPXwMUIgYKYb5Zz93BNrY0ruHBRS0E7apSLorK8v/8YvK/vZr9a5fTUjFQDv/I9fxPxUx0d1WRkbMAAAAASUVORK5CYII=',
    comment: 'Standard-Favicon Google'
  },
  {
    id: 'preset-youtube',
    enabled: true,
    patternType: 'domain',
    pattern: 'youtube.com',
    iconDataUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAACklpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAAEiJnVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/stRzjPAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAJcEhZcwAACxMAAAsTAQCanBgAAAGvSURBVFiF7de/jwxhAMbxzzu5OO5uSYSN36GQSzRyt9GJRqFhV+EPEJQKlWhUEqIQ0YqcQqJxxQURjYLa7EUi5Cj8KBQbDXvWnmJHMTMKIbGzmx3FPcnkfTOZ532+xfvOPBOSJFGmolLTVwH+B4CQTxK1cRzFLHajigoms3FD9nzA+r+s9xUJetm8jW/Z2MJ7NPEwiFd+ASRq+7GQBY9CH9AI4hchUVuHN9gxovBcHzEd4XgJ4bAL9QgHSgjPdTDCvhIB9kbY3pelupHTDaKhnOCtETb1ZZlYy62LPL/DodlBAaoRpgpZZ6Z5epN7V9mzrSjAVHGAXCcO83qeK2epTPTrrgznVTy+hgsnebvAqXpf+6P0b8HYUFZZ+cH1u1yeo93pG2DZIPtg/gnnb/DuUxF3uzjA4hLnrvGsWSQ41/IYPmPLP1s6Xc5c4vYDer1BwqEVErXHODLoSgX1KMKrksLhZYS4RIBmXkiWsHPE4WkhCeLvOCbta6MMrwdx9/dS2sCMtBtulpbPyezKS2kkLal/Ul5KE3yRHvFOdr8l7YKLuB/EXQirv2arAGUD/ASKFWPTtIUJ1AAAAABJRU5ErkJggg==',
    comment: 'Standard-Favicon Youtube'
  },
  {
    id: 'preset-github',
    enabled: true,
    patternType: 'domain',
    pattern: 'github.com',
    iconDataUrl: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNiAwQzcuMTYgMCAwIDcuMTYgMCAxNkMwIDIzLjA4IDQuNTggMjkuMDYgMTAuOTQgMzEuMThDMTEuNzQgMzEuMzIgMTIuMDQgMzAuODQgMTIuMDQgMzAuNDJDMTIuMDQgMzAuMDQgMTIuMDIgMjguNzggMTIuMDIgMjcuNDRDOCAyOC4xOCA2Ljk2IDI2LjQ2IDYuNjQgMjUuNTZDNi40NiAyNS4xIDUuNjggMjMuNjggNSAyMy4zQzQuNDQgMjMgMy42NCAyMi4yNiA0Ljk4IDIyLjI0QzYuMjQgMjIuMjIgNy4xNCAyMy40IDcuNDQgMjMuODhDOC44OCAyNi4zIDExLjE4IDI1LjYyIDEyLjEgMjUuMkMxMi4yNCAyNC4xNiAxMi42NiAyMy40NiAxMy4xMiAyMy4wNkM5LjU2IDIyLjY2IDUuODQgMjEuMjggNS44NCAxNS4xNkM1Ljg0IDEzLjQyIDYuNDYgMTEuOTggNy40OCAxMC44NkM3LjMyIDEwLjQ2IDYuNzYgOC44MiA3LjY0IDYuNjJDNy42NCA2LjYyIDguOTggNi4yIDEyLjA0IDguMjZDMTMuMzIgNy45IDE0LjY4IDcuNzIgMTYuMDQgNy43MkMxNy40IDcuNzIgMTguNzYgNy45IDIwLjA0IDguMjZDMjMuMSA2LjE4IDI0LjQ0IDYuNjIgMjQuNDQgNi42MkMyNS4zMiA4LjgyIDI0Ljc2IDEwLjQ2IDI0LjYgMTAuODZDMjUuNjIgMTEuOTggMjYuMjQgMTMuNCAyNi4yNCAxNS4xNkMyNi4yNCAyMS4zIDIyLjUgMjIuNjYgMTguOTQgMjMuMDZDMTkuNTIgMjMuNTYgMjAuMDIgMjQuNTIgMjAuMDIgMjYuMDJDMjAuMDIgMjguMTYgMjAgMjkuODggMjAgMzAuNDJDMjAgMzAuODQgMjAuMyAzMS4zNCAyMS4xIDMxLjE4QzI3LjQyIDI5LjA2IDMyIDIzLjA2IDMyIDE2QzMyIDcuMTYgMjQuODQgMCAxNiAwVjBaIiBmaWxsPSIjMjQyOTJFIi8+Cjwvc3ZnPgo=',
    comment: 'Standard-Favicon Github'
  },
  {
    id: 'preset-wikipedia',
    enabled: true,
    patternType: 'domain',
    pattern: 'wikipedia.org',
    iconDataUrl: 'data:image/svg+xml;base64,AAABAAMAMDAQAAEABABoBgAANgAAACAgEAABAAQA6AIAAJ4GAAAQEBAAAQAEACgBAACGCQAAKAAAADAAAABgAAAAAQAEAAAAAAAABgAAAAAAAAAAAAAQAAAAAAAAAAEBAQAXFxcAMDAwAEdHRwBYWFgAZ2dnAHZ2dgCHh4cAlZWVAKmpqQC3t7cAx8fHANfX1wDo6OgA/v7+AAAAAAD////+7u7u7u7u7u7u7u7u7u7u7u///////+7u7u7u7u7u7u7u7u7u7u7u7u7u/////u7u7u7u7u7u7u7u7u7u7u7u7u7u7///7u7u7u7u7u7u7u7u7u7u7u7u7u7u7v/+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u/+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u/+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u/u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7sa+7u7u7u1b7u7u7u7u7u7u7u7u7u7u7p9u7u7u7ugG7u7u7u7u7u7u7u7u7u7u7TAa7u7u7tQBzu7u7u7u7u7u7u7u7u7u6wAF7u7u7pAAju7u7u7u7u7u7u7u7u7u1AAAru7u7U//Le7u7u7u7u7u7u7u7u7uz/8RPe7u6gAB+e7u7u7u7u7u7u7u7u7ubw94Ce7u1QAIIu7u7u7u7u7u7u7u7u7tH/G+Mt7usAAtcL7u7u7u7u7u7u7u7u7n8ATun47uQACO0T7u7u7u7u7u7u7u7u7hDxnu4x3sAPLO5Qzu7u7u7u7u7u7u7u6P/z7u6wXk/wfu7ATu7u7u7u7u7u7u7u4QAY7u7kCQADzu7kDO7u7u7u7u7u7u7uoA8u7u7sAAAG7u7r9e7u7u7u7u7u7u7uIPB+7u7uUAAs7u7uMd7u7u7u7u7u7u7rEAHe7u7uQABu7u7un37u7u7u7u7u7u7kAAXu7u7sAPHe7u7u4S3u7u7u7u7u7u7BAA3u7u7k8AHO7u7u6Aju7u7u7u7u7u5g/07u7u7B8BBe7u7u7RLu7u7u7u7u7u0v/87u7u5QAGQa7u7u7nCe7u7u7u7u7ugAA+7u7uwQ8dsE7u7u7rBO7u7u7u7u7tP/++7u7uYAB+5Qnu7u7tQa7u7u7u7u7pH/Lu7u7sLwHe6xPe7u7ur27u7u7u7u7V//ru7u7mAAju7n+e7u7u0yvu7u7u7u6h8C3u7u6yAB3u7rEs7u7u6Pfu7u7u7u1AAE7u7u5g/27u7tQG3u7u6QHO7u7u7tbwAB3u7ukfAH7u7sIAju7u5wA97u7utiAAAAF76lAA/wWeyDAA84zqUAABfO7uMiNERDIm4iNERDIrkiNEQybiI0RDJO7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u/+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u/+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u//7u7u7u7u7u7u7u7u7u7u7u7u7u7u7v///u7u7u7u7u7u7u7u7u7u7u7u7u7u7////+7u7u7u7u7u7u7u7u7u7u7u7u7u///////+7u7u7u7u7u7u7u7u7u7u7u/////+AAAAAH8AAPAAAAAADwAA4AAAAAAHAADAAAAAAAMAAIAAAAAAAQAAgAAAAAABAACAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAABAACAAAAAAAEAAIAAAAAAAQAAwAAAAAADAADgAAAAAAcAAPAAAAAADwAA/gAAAAB/AAAoAAAAIAAAAEAAAAABAAQAAAAAAIACAAAAAAAAAAAAABAAAAAAAAAAAQEBABYWFgAnJycANTU1AEdHRwBZWVkAZWVlAHh4eACIiIgAmZmZAK6urgDMzMwA19fXAOnp6QD+/v4AAAAAAP//7u7u7u7u7u7u7u7u////7u7u7u7u7u7u7u7u7u7//u7u7u7u7u7u7u7u7u7u7/7u7u7u7u7u7u7u7u7u7u/u7u7u7u7u7u7u7u7u7u7u7u7u7u7X3u7u7I7u7u7u7u7u7u7uYF7u7uIK7u7u7u7u7u7u7QAM7u6vBO7u7u7u7u7u7ucABe7uMA/O7u7u7u7u7u7R8q/O6gCEbu7u7u7u7u7ukAnibuTx6g3u7u7u7u7u7hAe6gzP+O4Y7u7u7u7u7urwju4mXx7uge7u7u7u7u7jAd7uoACO7tCe7u7u7u7uoPfu7uEB3u7mPu7u7u7u7k8N7u7QBu7u6wru7u7u7uwAXu7ufwbu7u407u7u7u7lAM7u7RBQzu7ur87u7u7u0ATu7ucA0l7u7uFu7u7u7n/67u7RB+oL7u7nHe7u7u0fPu7ucA3uJO7u7Qju7u7o/67u7Q9u7q+u7u5R3u7u0Q/e7ub/vu7PLO7uX13u4w//Be4v/xnoH/+ekv//Xu7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7+7u7u7u7u7u7u7u7u7u7v/u7u7u7u7u7u7u7u7u7u7//u7u7u7u7u7u7u7u7u7v///+7u7u7u7u7u7u7u7v//8AAAD8AAAAOAAAABgAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAGAAAABwAAAA/AAAA8oAAAAEAAAACAAAAABAAQAAAAAAMAAAAAAAAAAAAAAABAAAAAAAAAAAQEBABcXFwAnJycAOzs7AElJSQBpaWkAeXl5AIaGhgCVlZUApqamALOzswDMzMwA2dnZAObm5gD+/v4AAAAAAP/u7u7u7u7//u7u7u7u7u/u7uzu7t7u7u7u4Y7lTu7u7u6QTtA77u7u7iaoctXu7u7qDOQZ5d7u7uRO5R7rbu7uv77iLu5O7u5D7pGn7pju7QrtKOTe4+6z+OT40z2RTO7u7u7u7u7u7u7u7u7u7u7+7u7u7u7u7//u7u7u7u7/wAMAD4ABAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAQAPwAMADw==',
    comment: 'Standard-Favicon Wikipedia'
  },
  {
    id: 'preset-amazon',
    enabled: true,
    patternType: 'regex',
    pattern: '(?:www\\.)?amazon\\.',
    iconDataUrl: 'data:image/svg+xml;base64,AAABAAQAMDAAAAEAIACoJQAARgAAACAgAAABACAAqBAAAO4lAAAYGAAAAQAgAIgJAACWNgAAEBAAAAEAIABoBAAAHkAAACgAAAAwAAAAYAAAAAEAIAAAAAAAgCUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///0X///+Z////zP////P////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////w////zP///5P///8/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8k////wP//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////t////x4AAAAAAAAAAAAAAAAAAAAAAAAAAP///0L////z///////////////////////////////////////////////////////////////////////////X7///u+T//5DV//+R1f//csr//1C+//+Cz///kdX//5/Z///L6v//8vr//////////////////////////////////////////////////////////////////////////////////////+3///85AAAAAAAAAAAAAAAA////Lf////D///////////////////////////////////////////////////////////////+85f//csr//xOt//8AqP//AKj//wCn//8Ap///AKf+/wCn//8AqP//AKf//wCn//8Ap///AKj//z64//+Q1f//2PD////////////////////////////////////////////////////////////////////////////q////JAAAAAAAAAAA////zP/////////////////////////////////////////////////////y+v//kNX//xOs//8Ap///AKf//wCo//8Ap///AKf//wCo//8AqP//AKf//wCn/v8Ap///AKj//wCn//8AqP//AKf//wCn//8Ap///AKf//z64//+u4P//////////////////////////////////////////////////////////////////////vQAAAAD///9R////////////////////////////////////////////////8vr//5HV//8TrP//AKj//wCo//8AqP//AKj//wCo//8Ap///AKf//wCn//8AqP//AKf//wCo//8AqP//AKj//wCn//8Ap/7/AKf//wCo//8AqP//AKf//wCo//8Ap///KbL//67g////////////////////////5fT//////////////////////////////////////0L///+l//////////////////////////////////////////+75P//E63//wCn//8Ap///AKf//wCn/v8AqP//AKf//wCo//8psv//UL///4LQ//+R1f//kNX//5DV//+Q1f//kNX//5HV//9hw///UL7//wCo//8Ap/7/AKj//wCn//8Ap///AKj//wCn//9Qvv//5vX/////////////Ub///5DV/////////////////////////////////5b////q////////////////////////////////8vr//3LK//8AqP//AKf//wCn//8AqP//AKj//1C///+R1f//y+r////////////////////////////////////////////////////////////////////////Y7///rd///3LJ//8Trf//AKf+/wCn//8AqP//E63//7zl////////n9r//wCo///l9P///////////////////////////9v////////////////////////////////Y7///Prj//wCn//8Ap///AKf+/1C+//+t3///8vr/////////////////////////////////////////////////////////////////////////////////////////////////////////////vOX//3LK//8Ap///AKf//wCo//+t3///2O///wCn//9zyv////////////////////////////n//////////////////////////9jw//8Trf//AKf//wCn//9yyf//5fT////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////y+v//kNX//xOt//9hw////////xOt//8Trf//////////////////////////////////////////////////u+T//xOt//8AqP//csn//+X0/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1G///8Ap///5vX////////////////////////////////////////Y7///AKj//1C+///l9f///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9jv//8Ap///Ub///2HD//+Q1f//csr//wCn//8Ap///y+r////////////////////////////////////////Y8P//ruD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////L6v//YsP//wCn//8Ap///AKj//wCo//8Ap///2PD///////////////////////////////////////////////////////////////////////////////////////////////////Pz8/+ioqL/VlZU/x0dG/8FBQT/BQUD/x0dHP9WVlX/hoaE/9jY2P////////////////////////////////++vr7/VlZV/6Kiov/////////////////////////////////K6f//yun//8rq///l9P//////////////////////////////////////////////////////////////////////////////////////////////////oqKi/x0dHP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/wUFBP9WVlT/5ubm/////////////////7Cwr/8FBQT/BQUE/wUFBP92dnb///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+GhoX/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wQEA/8FBQT/BQUD/wUFA/8FBQT/HR0c/7Cwr///////2dnZ/wUFBP8FBQT/BQUE/wUFBP8FBQT/Z2dm//Ly8v///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////729vf8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQP/BQUD/wUFBP8FBQT/BQUE/wUFBP+ioqL/MjIw/wUFBP8FBQT/BQUD/wUFA/8FBQT/BQUE/0REQ//y8vL//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////zExMP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8dHRv/////////////////////////////////////////////////////////////////////////////////////////////////////////////////2dnZ/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8dHRz/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQP/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8yMjD/////////////////////////////////////////////////////////////////////////////////////////////////////////////////lJST/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/HR0c/8zMzP///////////8zMzP8xMTD/BQUE/wUFBP8FBQT/BQUD/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP/MzMz/////////////////////////////////////////////////////////////////////////////////////////////////////////////////hoaF/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/zMzM///////////////////////y8vL/HR0c/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/4aGhP//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VlZV/wUFBP8EBAP/BQUD/wUFA/8FBQT/BQUE/wUFBP9FRUT/////////////////////////////////sLCv/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/+Xl5f//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////ZmZl/wUFA/8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP9VVVT//////////////////////////////////////zExMP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZV////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////lJST/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP9WVlX//////////////////////////////////////3Z2dv8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZV////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////sbGw/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8dHRz//////////////////////////////////////5SUk/8FBQP/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQT/VlZU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8vLy/wUFA/8FBQP/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQT/oqKi/////////////////////////////////5SUk/8FBQP/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQP/VlZV/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////3Z2dv8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/HR0c/729vf///////////////////////////83Nzf8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZV/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+bm5v8dHRz/BQUD/wUFA/8FBQT/BQUE/wUFBP8EBAP/BQUE/wUFBP9WVlX/vb29//Pz8////////////83Nzf8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/VlZV//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////++vr7/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZU/0REQ/8FBQT/BQUE/wUFBP8FBQP/BQUE/wUFBP8FBQT/VVVU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////zMzM/x0dG/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQP/VVVU//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Ly8v92dnb/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZV////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////5ubm/6Kiov9VVVT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/VlZV/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9nZ2f/MzMz/lJST/5SUk/9WVlT/VlZV/zExMP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZV/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8zMzP8FBQP/BQUE/wUFA/8FBQT/BAQD/wUFBP8FBQT/VlZV////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8/Pz/8zMzP/MzMz/lJST/5SUk//Z2dn//////////////////////////////////////76+vv8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/VlZV/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////5WVk/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP9nZ2b//////////////////////////////////////5SUk/8FBQT/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQT/dnZ2/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1ZWVP8FBQT/BQUE/wUFBP8FBQT/BQUD/wUFA/8dHRz/8/Pz/////////////////////////////////3Z2dv8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/lJST/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////6Ghof8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/dnZ2////////////////////////////2dnZ/x0dHP8FBQT/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/lJST/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+bm5v8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/BAQD/zExMP+xsbD/zMzM/8zMzP+UlJP/HR0c/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/zMzM//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////92dnb/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8dHRv///////////////////////////////////////////////////////////////////////////n////t///////////////////////////////////////////////////////////m5ub/Hh4c/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wQEA/8FBQP/BQUD/wUFBP+UlJP//////////////////////////////////////////////////////////////////////////97///+o////////////////////////////////////////////////////////////////2dnZ/x0dG/8FBQT/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/0VFRP/z8/P//////////////////////////////////////////////////////////////////////////5b///9U/////////////////////////////////////////////////////////////////////9nZ2f8xMTD/BQUE/wUFBP8FBQP/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VVVU//Ly8v///////////////////////////////////////////////////////////////////////////////0L///8D////z///////////////////////////////////////////////////////////////////////////lZWU/zExMP8FBQT/BQUD/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/BQUD/zExMP+xsbD/////////////////////////////////////////////////////////////////////////////////////wwAAAAAAAAAA////MP////b////////////////////////////////////////////////////////////////////////////////Z2dn/lJST/1ZWVf9WVlX/BAQD/wUFBP8FBQT/RUVD/1ZWVf+UlJP/zMzM///////////////////////////////////////////////////////////////////////////////////////////w////JwAAAAAAAAAAAAAAAP///0v////z//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////D///8/AAAAAAAAAAAAAAAAAAAAAAAAAAD///8t////yf//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////w////yQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///0v///+f////z///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////zP///5n///9FAAAAAAAAAAAAAAAAAAAAAAAAAAD4AAAAAB8AAOAAAAAABwAAwAAAAAADAACAAAAAAAEAAIAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAgAAAAAABAADAAAAAAAMAAOAAAAAABwAA+AAAAAAfAAAoAAAAIAAAAEAAAAABACAAAAAAAIAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////Uf///5/////S///////////////////////////////////////////////////////////////////////////////////////////////////////////////P////nP///0gAAAAAAAAAAAAAAAAAAAAA////GP///7H//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////6X///8SAAAAAP///wb////P////////////////////////////////////////////////5fX//67g//+R1f//UL7//1C+//9Rv///YsT//5DU//+85f//8vr//////////////////////////////////////////////////////8P///8D////df//////////////////////////////////////////ruD//z24//8AqP//AKf//wCo//8Ap///AKj//wCo//8Ap/7/AKf//wCn//8AqP//csr//8vq/////////////////////////////////////////////////2b////S////////////////////////////////y+r//ymy//8Ap///AKj//wCo//8Ap///AKf//wCn//8Ap///AKj//wCn//8Ap///AKj//wCo//8AqP//AKj//1C////Y8P///////8rq///Y7///////////////////////w/////z/////////////////////8vr//3LJ//8AqP//AKf//wCn/v9ixP//kNT//8vq///y+v////////////////////////L6///L6v//n9r//2LE//8Trf//AKf//wCo//+u4P//vOX//z65///////////////////////w//////////////////////L6//8+uP//AKf//1C+//+t3///8/r///////////////////////////////////////////////////////////////////////+85f//UL7//wCo///Y7///AKf//8rp///////////////////////////////////Y7///E63//1C+///L6v////////////////////////////////////////////////////////////////////////////////////////P7///L6v//5fT///L6//8ps///kNT//////////////////////////////////5DU//+t3///////////////////////////////////////////////////////////////////////////////////////////////////5fX//1C+//8AqP//AKf//wCn//+Q1f//////////////////////////////////////////////////////////////////8vLy/5SUk/9FRUT/BQUE/wQEA/8yMjD/Z2dm/8zMzP////////////////+GhoX/Z2dm//Lz8////////////+X0///L6v//yun///L6//////////////////////////////////////////////////////////////Ly8v9FRUT/BQUE/wUFBP8FBQT/BQUE/wQEA/8FBQT/BQUD/3Z2dv/z8/P/dnZ2/wUFBP8FBQP/MTEw/9nZ2f//////////////////////////////////////////////////////////////////////////////////////VlZV/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/zIyMP8FBQT/BQUE/wUFBP8FBQT/HR0c/9nZ2f///////////////////////////////////////////////////////////////////////////+bm5v8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8xMTD/HR0c/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/lJST////////////////////////////////////////////////////////////////////////////vb29/wUFBP8EBAP/BQUE/wUFBP8FBQT/dnZ2////////////oqKi/wUFBP8EBAP/BQUE/wUFBP8FBQP/BQUE/zIyMf/y8vL///////////////////////////////////////////////////////////////////////////+UlJP/BQUE/wUFBP8FBQT/BQUE/wUFBP/y8vL/////////////////Z2dm/wUFBP8FBQT/BQUE/wUFBP8FBQT/sbGw/////////////////////////////////////////////////////////////////////////////////7GxsP8FBQT/BQUD/wUFBP8FBQT/BQUD//////////////////////+9vb3/BQUE/wUFBP8FBQT/BQUE/wUFBP/m5ub/////////////////////////////////////////////////////////////////////////////////2dnZ/wUFBP8FBQT/BQUE/wUFBP8FBQT/zMzM/////////////////+bm5v8FBQT/BQUE/wUFA/8FBQT/BQUD////////////////////////////////////////////////////////////////////////////////////////////MTEw/wUFBP8FBQT/BQUE/wUFBP9FRUT/5eXl/////////////////wUFBP8FBQT/BQUE/wUFBP8FBQT////////////////////////////////////////////////////////////////////////////////////////////MzMz/BQUE/wUFA/8FBQT/BQUD/wUFBP8FBQT/dnZ2/5SUk/+9vb3/BQUE/wUFBP8FBQT/BQUE/wUFA/////////////////////////////////////////////////////////////////////////////////////////////////+wsK//HR0c/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE///////////////////////////////////////////////////////////////////////////////////////////////////////m5ub/hoaF/zIyMP8FBQT/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQP//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+bm5v/MzMz/lJST/5SUk/9WVlX/BQUE/wQEA/8FBQT/BQUE/wUFA//////////////////////////////////////////////////////////////////////////////////////////////////y8vL/zMzM/8zMzP/Nzc3///////////////////////////8FBQT/BQUE/wUFBP8FBQT/BQUD////////////////////////////////////////////////////////////////////////////////////////////Z2dm/wUFBP8FBQT/BQUE/wUFBP/y8vL/////////////////2dnZ/wUFA/8FBQP/BQUD/wUFBP8FBQT///////////////////////////////////////////////////////////////////////////////////////////9mZmX/BQUE/wUFBP8FBQT/BQUE/3Z2dv////////////////92dnb/BQUE/wUFBP8FBQT/BQUE/wUFBP///////////////////////////////////////////////////////////////////////////////////////////7CwsP8FBQT/BQUE/wUFBP8FBQT/BQUE/zIyMP9WVlX/RUVE/wUFBP8FBQT/BQUE/wUFBP8FBQT/RUVD/////////////////////////////////////////////////////////////////////////////////////////////////1ZWVf8FBQT/BQUE/wUFBP8EBAP/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP+wsK/////////////////////////////////////////////////2////2///////////////////////////////////////////8vLy/0VFRP8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/dnZ2/////////////////////////////////////////////////////8z///9+/////////////////////////////////////////////////////7Cwr/9FRUT/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/RUVE/7Cwr///////////////////////////////////////////////////////////b////wz////b///////////////////////////////////////////////////////////y8vL/zMzM/8zMzP/MzMz/zc3N/+bm5v///////////////////////////////////////////////////////////////9L///8GAAAAAP///yf////b///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////S////HgAAAAAAAAAAAAAAAP///wz///94////2P/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////S////cv///wkAAAAAAAAAAOAAAAeAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAHAAAADKAAAABgAAAAwAAAAAQAgAAAAAABgCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8G////hP///9v/////////////////////////////////////////////////////////////////////////////////////////2////4T///8GAAAAAP///wz////P///////////////////////////y+v//vOX//5DV//+C0P//YsT//5DU//+u4P//5fT////////////////////////////////////////////G////Cf///4T/////////////////////8vr//3LK//8Trf//AKj//wCn//8Ap///AKf+/wCo//8AqP//AKf//1C+///K6v//////////////////////////////////////e////9v///////////////+u4P//E6z//wCn//8AqP//AKf//wCo//8Ap///AKf//wCo//8AqP//AKf//wCo//8Ap///kNX/////////////kdX//9jw////////////z/////D//////////4LP//8Ap///AKf//wCo//8qs///csr//5DV///K6f//y+r//8rq///L6v//n9n//3LK//8TrP//AKf//5/a////////kNX//1C+////////////7f////D/////kdX//wCo//8AqP//csn//9jw///////////////////////////////////////////////////y+v//n9r//4LQ////////yun//wCn///l9P//////8P////DK6v//AKf//1C+///l9P//////////////////////////////////////////////////////////////////////////////////yun//wCn//+85f//////8P////Aps///kNX///////////////////////////////////////////////////////////////////////+g2v//KrP//2LE//+Q1P//csr//wCn//+R1f//////8P////C75P////////////////////////////+xsbD/VlZV/1VVVP9WVlX/oaGh//Ly8v/y8vL/dnZ2/7Cwr///////vOT//2HD//8Ap///AKj//wCn/v+85f//////8P////D//////////////////////////4aGhf8EBAP/BQUD/wUFBP8EBAP/BQUD/0VFRP9nZ2b/BQUE/wUFBP92dnb/////////////////2O///+b1////////////8P////D/////////////////////8vLy/wUFBP8FBQT/BQUE/wUFA/9EREP/HR0b/wUFBP8FBQT/BQUD/wUFBP8FBQT/////////////////////////////////////8P////D/////////////////////zMzM/wUFBP8FBQT/BQUE/3Z2dv//////8vLy/x0dHP8FBQT/BQUE/wUFBP+UlJP/////////////////////////////////////8P////D/////////////////////zc3N/wUFBP8FBQT/BQUE/5SUk////////////4aGhf8FBQT/BQUE/wUFBP/MzMz/////////////////////////////////////8P////D//////////////////////////x0dG/8FBQT/BQUE/0VFQ//z8/P//////76+vv8FBQT/BQUE/wUFBP/Nzc3/////////////////////////////////////8P////D//////////////////////////7CwsP8FBQP/BQUE/wUFBP8dHRv/dnZ2/3Z2dv8FBQP/BQUE/wUFBP/MzMz/////////////////////////////////////8P////D///////////////////////////////++vr7/MTEw/wUFBP8FBQP/BQUD/wUFBP8FBQT/BQUE/wUFBP/MzMz/////////////////////////////////////8P////D//////////////////////////////////////////+Xl5f/MzMz/lJST/3Z2dv8FBQT/BQUE/wUFBP/MzMz/////////////////////////////////////8P////D//////////////////////////4aGhf9WVlX/HR0b/729vf///////////7Cwr/8FBQP/BQUE/wUFBP/MzMz/////////////////////////////////////8P////D//////////////////////////2ZmZf8FBQT/BQUE/x0dHP++vr7/zMzM/0VFRP8FBQT/BQUE/wUFBP/y8vL/////////////////////////////////////8P////D//////////////////////////8zMzP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUD/1ZWVP/29vb/////////////////////////////////////7f///9X///////////////////////////////+wsK//HR0c/wUFBP8FBQT/BQUE/wUFBP8FBQT/MTEw/9vb2//6+vr/////////////////////////////////////z////3v/////////////////////////////////////8vLy/76+vv+UlJP/lJST/5SUk/++vr7/////////////////////////////////////////////////////df///wn////D//////////////////////////////////////////////////////////////////////////////////////////////////////////////+9////BgAAAAD///8D////df///9L/////////////////////////////////////////////////////////////////////////////////////////z////3X///8DAAAAAIAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAABACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8G////lv////b/////////////////////////////////////////////////////////9v///5b///8G////iv/////////////////////Y7///n9r//5DV//+Q1P//vOT/////////////////////////////////iv///+f//////////8vq//9Qvv//AKj//wCn//8Ap///AKf+/wCn//8ps///u+T////////y+v//8vr//////+f////w/////67g//8AqP//AKj//z24//+C0P//kNX//5DU//+R1f//UL7//wCn//+u4P//vOX//4LQ///////w////8Lzl//8AqP//csn//+bz///////////////////////////////////l9P//rd///9jv//8Trf//////8P////Aqs///2O//////////////////////////////////////////////Ur7//3LK//+C0P//AKf///////D////w5vX/////////////zMzM/x0dG/8FBQT/HR0b/5SUk/9WVlT/RUVD/+fu8/+i2P7/csr//3LK///////w////8P///////////////zExMP8FBQT/BQUE/0VFRP8FBQP/BQUE/wUFBP+UlJP/////////////////////8P////D///////////////8FBQT/BQUE/4aGhP//////ZmZl/wUFBP8FBQT/8vLy//////////////////////D////w////////////////VlZV/wUFBP8yMjD/5ubm/5SUk/8FBQT/BQUE///////////////////////////w////8P///////////////9nZ2f8yMjD/BQUE/wUFBP8FBQT/BQUE/wUFBP//////////////////////////8P////D////////////////m5ub/zMzM/729vf+wsK//VlZV/wUFBP8FBQT///////////////////////////D////w////////////////Z2dm/wUFBP9FRUT/2NjY/2dnZv8FBQT/HR0c///////////////////////////w////5////////////////8zMzP8FBQP/BQUE/wUFBP8FBQT/BQUE/3Z2dv//////////////////////////5////4f/////////////////////2dnZ/3Z2dv9VVVT/VlZV/6Kiov///////////////////////////////4r///8G////jf///+T/////////////////////////////////////////////////////////5P///43///8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==',
    comment: 'Standard-Favicon Amazon'
  },
  {
    id: 'preset-http-default',
    enabled: true,
    patternType: 'regex',
    pattern: '^https?:\\/\\/',
    iconDataUrl: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iNiIgZmlsbD0iI2Y4ZmFmYyIvPjxjaXJjbGUgY3g9IjE2IiBjeT0iMTYiIHI9IjkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzY0NzQ4YiIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTTcgMTZoMThNMTYgN2MzIDMgNC41IDYgNC41IDlzLTEuNSA2LTQuNSA5Yy0zLTMtNC41LTYtNC41LTlzMS41LTYgNC41LTl6IiBmaWxsPSJub25lIiBzdHJva2U9IiM2NDc0OGIiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+',
    comment: 'Standard-Favicon HTTP(S)'
  }
]);

function getDefaultFaviconRules() {
  const baseTs = Date.now();
  return DEFAULT_FAVICON_RULES.map((rule, index) => Object.assign({}, rule, { createdAt: baseTs + index }));
}

    /**
     * HTMLBookmarkParser - Generic HTML structure parser for bookmark imports
     * Detects and extracts bookmarks from various HTML structures:
     * - Netscape bookmark format (DL/DT/DD)
     * - Nested lists (UL/OL with LI)
     * - Heading hierarchies (H1-H6 with following content)
     * - Definition lists
     * - Article/Section structures
     * - Table-based layouts
     */
    class HTMLBookmarkParser {
      constructor(options = {}) {
        this.options = {
          // Group detection settings
          minLinksForGroup: options.minLinksForGroup || 2,
          maxGroupDepth: options.maxGroupDepth || 5,
          inferGroupNames: options.inferGroupNames !== false,

          // Link extraction settings
          extractMetadata: options.extractMetadata !== false,
          extractKeywords: options.extractKeywords !== false,
          followRedirects: options.followRedirects || false,

          // Pattern priorities (higher = preferred)
          patternPriorities: {
            netscape: 100,    // Standard bookmark format
            headings: 90,     // H1-H6 hierarchies
            nestedLists: 80,  // UL/OL structures
            definitions: 70,  // DL/DT/DD (non-Netscape)
            sections: 60,     // article/section/nav
            tables: 50,       // Table-based layouts
            divGroups: 40,    // Grouped DIVs
            generic: 30       // Fallback patterns
          },
          ...options
        };
      }

      /**
       * Main parsing method - detects format and extracts bookmarks
       * @param {string} html - HTML content to parse
       * @returns {Array} Array of group objects with links
       */
      parse(html) {
        const doc = this.createDocument(html);
        if (!doc) return [];

        // Try patterns in priority order
        const patterns = this.getDetectionPatterns();

        for (const pattern of patterns) {
          const result = pattern.detector(doc);
          if (result && result.confidence > 0.5) {
            debugLog('log', `[HTMLBookmarkParser] Using pattern: ${pattern.name} (confidence: ${result.confidence})`);
            return pattern.extractor(doc, result.context);
          }
        }

        // Fallback: extract all links as single group
        return this.extractGenericLinks(doc);
      }

      /**
       * Create DOM document from HTML string
       */
      createDocument(html) {
        try {
          const parser = new DOMParser();
          return parser.parseFromString(html, 'text/html');
        } catch (e) {
          debugLog('error', '[HTMLBookmarkParser] Failed to parse HTML:', e);
          return null;
        }
      }

      /**
       * Get detection patterns sorted by priority
       */
      getDetectionPatterns() {
        return [
          {
            name: 'Netscape Bookmarks',
            priority: this.options.patternPriorities.netscape,
            detector: (doc) => this.detectNetscapeFormat(doc),
            extractor: (doc) => this.extractNetscapeBookmarks(doc)
          },
          {
            name: 'Heading Hierarchy',
            priority: this.options.patternPriorities.headings,
            detector: (doc) => this.detectHeadingStructure(doc),
            extractor: (doc, ctx) => this.extractHeadingGroups(doc, ctx)
          },
          {
            name: 'Nested Lists',
            priority: this.options.patternPriorities.nestedLists,
            detector: (doc) => this.detectNestedLists(doc),
            extractor: (doc, ctx) => this.extractListGroups(doc, ctx)
          },
          {
            name: 'Definition Lists',
            priority: this.options.patternPriorities.definitions,
            detector: (doc) => this.detectDefinitionLists(doc),
            extractor: (doc, ctx) => this.extractDefinitionGroups(doc, ctx)
          },
          {
            name: 'Section Structure',
            priority: this.options.patternPriorities.sections,
            detector: (doc) => this.detectSectionStructure(doc),
            extractor: (doc, ctx) => this.extractSectionGroups(doc, ctx)
          },
          {
            name: 'Table Layout',
            priority: this.options.patternPriorities.tables,
            detector: (doc) => this.detectTableStructure(doc),
            extractor: (doc, ctx) => this.extractTableGroups(doc, ctx)
          }
        ].sort((a, b) => b.priority - a.priority);
      }

      /**
       * Detect Netscape bookmark format
       */
      detectNetscapeFormat(doc) {
        const hasDL = doc.querySelector('DL');
        const hasDT = doc.querySelector('DT');
        const hasH3inDT = doc.querySelector('DT > H3');
        const hasBookmarkMeta = doc.querySelector('META[HTTP-EQUIV*="Content-Type"]');

        const confidence =
          (hasDL ? 0.3 : 0) +
          (hasDT ? 0.3 : 0) +
          (hasH3inDT ? 0.3 : 0) +
          (hasBookmarkMeta ? 0.1 : 0);

        return { confidence, context: { hasDL, hasDT, hasH3inDT } };
      }

      /**
       * Extract Netscape bookmarks (existing implementation)
       */
      extractNetscapeBookmarks(doc) {
        const result = [];

        const walkDL = (dl, currentGroupName = null) => {
          const groupLinks = [];
          const groups = [];
          const nodes = Array.from(dl.children || []);

          for (let i = 0; i < nodes.length; i++) {
            const el = nodes[i];
            if (el.tagName === 'DT') {
              const a = el.querySelector('a');
              const h3 = el.querySelector('h3');

              if (a) {
                groupLinks.push(this.extractLinkData(a));
              } else if (h3) {
                const name = h3.textContent || 'Folder';
                let next = el.nextElementSibling;
                while (next && next.tagName !== 'DL') next = next.nextElementSibling;

                if (next && next.tagName === 'DL') {
                  const sub = walkDL(next, name);
                  groups.push(...sub);
                } else {
                  groups.push({ name, links: [] });
                }
              }
            }
          }

          if (currentGroupName) {
            groups.unshift({ name: currentGroupName, links: groupLinks });
          } else if (groupLinks.length) {
            groups.unshift({ name: 'Imported', links: groupLinks });
          }

          return groups;
        };

        const topDL = doc.querySelector('dl');
        return topDL ? walkDL(topDL) : [];
      }

      /**
       * Detect heading-based structure (H1-H6)
       */
      detectHeadingStructure(doc) {
        const headings = doc.querySelectorAll('h1, h2, h3, h4, h5, h6');
        const links = doc.querySelectorAll('a[href]');

        if (headings.length === 0 || links.length === 0) {
          return { confidence: 0 };
        }

        // Check if headings have links following them
        let headingsWithLinks = 0;
        headings.forEach(heading => {
          const nextElements = this.getNextSiblings(heading, 5);
          const hasLinks = nextElements.some(el =>
            el.querySelector && el.querySelector('a[href]')
          );
          if (hasLinks) headingsWithLinks++;
        });

        const confidence = headingsWithLinks / headings.length;
        return {
          confidence,
          context: { headings, headingsWithLinks }
        };
      }

      /**
       * Extract groups based on heading hierarchy
       */
      extractHeadingGroups(doc, context) {
        const groups = [];
        const headings = doc.querySelectorAll('h1, h2, h3, h4, h5, h6');

        headings.forEach(heading => {
          const level = parseInt(heading.tagName.charAt(1));
          const groupName = heading.textContent.trim();
          const links = [];

          // Collect links until next heading of same or higher level
          let current = heading.nextElementSibling;
          while (current) {
            // Stop at next heading of same or higher importance
            if (/^H[1-6]$/.test(current.tagName)) {
              const currentLevel = parseInt(current.tagName.charAt(1));
              if (currentLevel <= level) break;
            }

            // Extract links from current element
            const anchors = current.querySelectorAll('a[href]');
            anchors.forEach(a => links.push(this.extractLinkData(a)));

            current = current.nextElementSibling;
          }

          if (links.length >= this.options.minLinksForGroup) {
            groups.push({ name: groupName, links });
          }
        });

        return groups;
      }

      /**
       * Detect nested list structure
       */
      detectNestedLists(doc) {
        const lists = doc.querySelectorAll('ul, ol');
        const nestedLists = Array.from(lists).filter(list =>
          list.querySelector('ul, ol') || // Has nested lists
          list.parentElement.closest('ul, ol') // Is nested itself
        );

        const linksInLists = Array.from(lists).reduce((count, list) =>
          count + list.querySelectorAll('a[href]').length, 0
        );

        const totalLinks = doc.querySelectorAll('a[href]').length;

        if (lists.length === 0 || totalLinks === 0) {
          return { confidence: 0 };
        }

        const confidence = (linksInLists / totalLinks) *
                          (nestedLists.length > 0 ? 1.2 : 0.8);

        return {
          confidence: Math.min(confidence, 1),
          context: { lists, nestedLists }
        };
      }

      /**
       * Extract groups from list structures
       */
      extractListGroups(doc, context) {
        const groups = [];
        const processedLists = new Set();

        const extractList = (list, groupName = null) => {
          if (processedLists.has(list)) return null;
          processedLists.add(list);

          const group = {
            name: groupName || this.inferGroupName(list) || 'List Group',
            links: []
          };

          Array.from(list.children).forEach(li => {
            if (li.tagName !== 'LI') return;

            // Check for nested list (subgroup)
            const nestedList = li.querySelector('ul, ol');
            if (nestedList) {
              // Extract text before nested list as subgroup name
              const textNode = Array.from(li.childNodes).find(
                node => node.nodeType === Node.TEXT_NODE && node.textContent.trim()
              );
              const subgroupName = textNode ? textNode.textContent.trim() : null;

              const subgroup = extractList(nestedList, subgroupName);
              if (subgroup && subgroup.links.length >= this.options.minLinksForGroup) {
                groups.push(subgroup);
              }
            }

            // Extract links from this item
            const anchors = Array.from(li.querySelectorAll('a[href]')).filter(
              a => !nestedList || !nestedList.contains(a)
            );
            anchors.forEach(a => group.links.push(this.extractLinkData(a)));
          });

          return group;
        };

        // Process top-level lists
        const topLists = Array.from(doc.querySelectorAll('ul, ol')).filter(
          list => !list.parentElement.closest('ul, ol')
        );

        topLists.forEach(list => {
          const group = extractList(list);
          if (group && group.links.length >= this.options.minLinksForGroup) {
            groups.push(group);
          }
        });

        return groups;
      }

      /**
       * Detect section-based structure (article, section, nav)
       */
      detectSectionStructure(doc) {
        const sections = doc.querySelectorAll('article, section, nav, aside');
        const linksInSections = Array.from(sections).reduce((count, section) =>
          count + section.querySelectorAll('a[href]').length, 0
        );

        const totalLinks = doc.querySelectorAll('a[href]').length;

        if (sections.length === 0 || totalLinks === 0) {
          return { confidence: 0 };
        }

        const confidence = (linksInSections / totalLinks) * 0.9;
        return {
          confidence,
          context: { sections }
        };
      }

      /**
       * Extract groups from section elements
       */
      extractSectionGroups(doc, context) {
        const groups = [];
        const sections = doc.querySelectorAll('article, section, nav, aside');

        sections.forEach(section => {
          const groupName = this.inferGroupName(section) || 'Section';
          const links = Array.from(section.querySelectorAll('a[href]'))
            .map(a => this.extractLinkData(a));

          if (links.length >= this.options.minLinksForGroup) {
            groups.push({ name: groupName, links });
          }
        });

        return groups;
      }

      /**
       * Detect definition list structure
       */
      detectDefinitionLists(doc) {
        const dlElements = doc.querySelectorAll('dl');
        const hasNonNetscapeDL = Array.from(dlElements).some(dl =>
          !dl.querySelector('dt > h3') && dl.querySelector('dt') && dl.querySelector('dd')
        );

        if (!hasNonNetscapeDL) {
          return { confidence: 0 };
        }

        const confidence = 0.7;
        return { confidence, context: { dlElements } };
      }

      /**
       * Extract groups from definition lists
       */
      extractDefinitionGroups(doc, context) {
        const groups = [];
        const dlElements = doc.querySelectorAll('dl');

        dlElements.forEach(dl => {
          let currentGroup = null;

          Array.from(dl.children).forEach(el => {
            if (el.tagName === 'DT') {
              // DT might be a group header
              const links = el.querySelectorAll('a[href]');
              if (links.length === 0) {
                // No links, treat as group name
                if (currentGroup && currentGroup.links.length >= this.options.minLinksForGroup) {
                  groups.push(currentGroup);
                }
                currentGroup = {
                  name: el.textContent.trim(),
                  links: []
                };
              } else {
                // Has links, add to current group
                if (!currentGroup) {
                  currentGroup = { name: 'Definitions', links: [] };
                }
                links.forEach(a => currentGroup.links.push(this.extractLinkData(a)));
              }
            } else if (el.tagName === 'DD' && currentGroup) {
              // DD contains links for the current group
              const links = el.querySelectorAll('a[href]');
              links.forEach(a => currentGroup.links.push(this.extractLinkData(a)));
            }
          });

          if (currentGroup && currentGroup.links.length >= this.options.minLinksForGroup) {
            groups.push(currentGroup);
          }
        });

        return groups;
      }

      /**
       * Detect table-based structure
       */
      detectTableStructure(doc) {
        const tables = doc.querySelectorAll('table');
        const linksInTables = Array.from(tables).reduce((count, table) =>
          count + table.querySelectorAll('a[href]').length, 0
        );

        const totalLinks = doc.querySelectorAll('a[href]').length;

        if (tables.length === 0 || totalLinks === 0) {
          return { confidence: 0 };
        }

        const confidence = (linksInTables / totalLinks) * 0.7;
        return { confidence, context: { tables } };
      }

      /**
       * Extract groups from table structure
       */
      extractTableGroups(doc, context) {
        const groups = [];
        const tables = doc.querySelectorAll('table');

        tables.forEach(table => {
          // Try to detect if table has category rows/columns
          const rows = table.querySelectorAll('tr');
          let currentGroup = null;

          rows.forEach(row => {
            const cells = row.querySelectorAll('td, th');
            const links = row.querySelectorAll('a[href]');

            if (links.length === 0 && cells.length > 0) {
              // Possible category row
              if (currentGroup && currentGroup.links.length >= this.options.minLinksForGroup) {
                groups.push(currentGroup);
              }
              currentGroup = {
                name: row.textContent.trim(),
                links: []
              };
            } else if (links.length > 0) {
              // Row with links
              if (!currentGroup) {
                currentGroup = {
                  name: this.inferGroupName(table) || 'Table Links',
                  links: []
                };
              }
              links.forEach(a => currentGroup.links.push(this.extractLinkData(a)));
            }
          });

          if (currentGroup && currentGroup.links.length >= this.options.minLinksForGroup) {
            groups.push(currentGroup);
          }
        });

        return groups;
      }

      /**
       * Generic link extraction (fallback)
       */
      extractGenericLinks(doc) {
        const links = Array.from(doc.querySelectorAll('a[href]'))
          .map(a => this.extractLinkData(a));

        if (links.length === 0) return [];

        // Try to group by common parent containers
        const groups = this.groupByContainers(doc, links);

        if (groups.length > 1) {
          return groups;
        }

        // Single group with all links
        return [{
          name: this.inferGroupName(doc.body) || 'Imported Links',
          links: links
        }];
      }

      /**
       * Group links by their container elements
       */
      groupByContainers(doc, links) {
        const containerMap = new Map();

        doc.querySelectorAll('a[href]').forEach(anchor => {
          // Find meaningful container
          let container = anchor.parentElement;
          while (container && container !== doc.body) {
            if (this.isMeaningfulContainer(container)) {
              break;
            }
            container = container.parentElement;
          }

          if (!container || container === doc.body) {
            container = doc.body;
          }

          if (!containerMap.has(container)) {
            containerMap.set(container, {
              element: container,
              links: []
            });
          }

          containerMap.get(container).links.push(this.extractLinkData(anchor));
        });

        const groups = [];
        containerMap.forEach(({ element, links }) => {
          if (links.length >= this.options.minLinksForGroup) {
            groups.push({
              name: this.inferGroupName(element) || 'Group',
              links: links
            });
          }
        });

        return groups;
      }

      /**
       * Check if element is a meaningful container
       */
      isMeaningfulContainer(element) {
        const meaningfulTags = ['article', 'section', 'nav', 'aside', 'div', 'ul', 'ol', 'dl'];
        const meaningfulClasses = ['group', 'category', 'section', 'links', 'bookmarks', 'list'];

        if (meaningfulTags.includes(element.tagName.toLowerCase())) {
          // Check for meaningful class or id
          const classList = Array.from(element.classList);
          const hasClass = meaningfulClasses.some(cls =>
            classList.some(c => c.toLowerCase().includes(cls))
          );

          const hasId = element.id && meaningfulClasses.some(cls =>
            element.id.toLowerCase().includes(cls)
          );

          return hasClass || hasId || element.children.length > 2;
        }

        return false;
      }

      /**
       * Extract link data from anchor element
       */
      extractLinkData(anchor) {
        const link = {
          text: anchor.textContent.trim() || anchor.title || 'Link',
          url: anchor.href || anchor.getAttribute('href') || '',
          keywords: ''
        };

        if (this.options.extractMetadata) {
          // Extract title attribute
          if (anchor.title) {
            link.title = anchor.title;
          }

          // Extract favicon if present
          const img = anchor.querySelector('img');
          if (img && img.src) {
            link.favicon = img.src;
          }

          // Extract description from next sibling or parent
          const nextSibling = anchor.nextSibling;
          if (nextSibling && nextSibling.nodeType === Node.TEXT_NODE) {
            const desc = nextSibling.textContent.trim();
            if (desc && desc.length < 200) {
              link.description = desc;
            }
          }
        }

        if (this.options.extractKeywords) {
          // Extract keywords from class, data attributes, or context
          const keywords = [];

          if (anchor.className) {
            keywords.push(...anchor.className.split(/\s+/));
          }

          // Check data attributes
          Array.from(anchor.attributes).forEach(attr => {
            if (attr.name.startsWith('data-')) {
              keywords.push(attr.value);
            }
          });

          // Check parent context
          const parent = anchor.closest('[class*="tag"], [class*="category"], [data-category]');
          if (parent) {
            if (parent.dataset.category) {
              keywords.push(parent.dataset.category);
            }
            if (parent.className) {
              keywords.push(...parent.className.split(/\s+/));
            }
          }

          link.keywords = [...new Set(keywords)]
            .filter(k => k && k.length > 1 && k.length < 50)
            .join(', ');
        }

        return link;
      }

      /**
       * Infer group name from element context
       */
      inferGroupName(element) {
        if (!element || !this.options.inferGroupNames) return null;

        // Try various strategies to find a name

        // 1. Check for heading before or within element
        const heading = element.querySelector('h1, h2, h3, h4, h5, h6') ||
                       this.getPreviousHeading(element);
        if (heading) {
          return heading.textContent.trim();
        }

        // 2. Check for aria-label or title
        if (element.getAttribute('aria-label')) {
          return element.getAttribute('aria-label');
        }
        if (element.title) {
          return element.title;
        }

        // 3. Check for data attributes
        if (element.dataset.title || element.dataset.name) {
          return element.dataset.title || element.dataset.name;
        }

        // 4. Check for id or class that might indicate purpose
        if (element.id) {
          // Convert ID to readable name (bookmarks-list -> Bookmarks List)
          return element.id.replace(/[-_]/g, ' ')
            .replace(/([a-z])([A-Z])/g, '$1 $2')
            .replace(/\b\w/g, c => c.toUpperCase());
        }

        // 5. Check first text node
        const textNode = Array.from(element.childNodes).find(
          node => node.nodeType === Node.TEXT_NODE && node.textContent.trim()
        );
        if (textNode) {
          const text = textNode.textContent.trim();
          if (text.length < 50) {
            return text;
          }
        }

        return null;
      }

      /**
       * Get previous heading sibling
       */
      getPreviousHeading(element) {
        let sibling = element.previousElementSibling;
        while (sibling) {
          if (/^H[1-6]$/.test(sibling.tagName)) {
            return sibling;
          }
          sibling = sibling.previousElementSibling;
        }
        return null;
      }

      /**
       * Get next siblings up to count
       */
      getNextSiblings(element, count = 5) {
        const siblings = [];
        let current = element.nextElementSibling;

        while (current && siblings.length < count) {
          siblings.push(current);
          current = current.nextElementSibling;
        }

        return siblings;
      }
    }

    // Toast Notification System
    class ToastManager {
      constructor() {
        this.container = null;
        this.toasts = [];
        this.init();
      }

      init() {
        // Create container if it doesn't exist
        if (!document.getElementById('toast-container')) {
          this.container = document.createElement('div');
          this.container.id = 'toast-container';
          this.container.className = 'toast-container';
          document.body.appendChild(this.container);
        } else {
          this.container = document.getElementById('toast-container');
        }
      }

      show(title, body = '', type = 'info', duration = 5000) {
        const toast = document.createElement('div');
        toast.className = `toast-notification toast-${type} mb-toast mb-toast-${type}`;

        const toastId = 'toast-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        toast.id = toastId;

        // Toast content
        const content = document.createElement('div');
        content.className = 'toast-content mb-toast-content';

        // Title
        if (title) {
          const titleEl = document.createElement('div');
          titleEl.className = 'toast-title mb-toast-title';
          titleEl.textContent = title;
          content.appendChild(titleEl);
        }

        // Body (supports HTML)
        if (body) {
          const bodyEl = document.createElement('div');
          bodyEl.className = 'toast-body mb-toast-body';
          bodyEl.innerHTML = body;
          content.appendChild(bodyEl);
        }

        toast.appendChild(content);

        // Close button
        const closeBtn = document.createElement('button');
        closeBtn.className = 'toast-close mb-toast-close';
        closeBtn.innerHTML = '×';
        closeBtn.onclick = () => this.remove(toastId);
        toast.appendChild(closeBtn);

        // Progress bar
        const progressBar = document.createElement('div');
        progressBar.className = 'toast-progress mb-toast-progress';
        const progressFill = document.createElement('div');
        progressFill.className = 'toast-progress-fill mb-toast-progress-fill';
        progressBar.appendChild(progressFill);
        toast.appendChild(progressBar);

        // Add to container
        this.container.appendChild(toast);
        this.toasts.push({ id: toastId, element: toast });

        // Trigger animation
        setTimeout(() => {
          toast.classList.add('toast-show');
          progressFill.style.transition = `width ${duration}ms linear`;
          progressFill.style.width = '0%';
        }, 10);

        // Auto remove after duration
        if (duration > 0) {
          setTimeout(() => {
            this.remove(toastId);
          }, duration);
        }

        return toastId;
      }

      remove(toastId) {
        const index = this.toasts.findIndex(t => t.id === toastId);
        if (index > -1) {
          const toast = this.toasts[index];
          toast.element.classList.remove('toast-show');
          toast.element.classList.add('toast-hide');

          setTimeout(() => {
            if (toast.element.parentNode) {
              toast.element.parentNode.removeChild(toast.element);
            }
            this.toasts.splice(index, 1);
          }, 300);
        }
      }

      success(title, body = '', duration = 5000) {
        return this.show(title, body, 'success', duration);
      }

      error(title, body = '', duration = 5000) {
        return this.show(title, body, 'error', duration);
      }

      warning(title, body = '', duration = 5000) {
        return this.show(title, body, 'warning', duration);
      }

      info(title, body = '', duration = 5000) {
        return this.show(title, body, 'info', duration);
      }
    }

    // Create global instance
    const toastManager = new ToastManager();

    // Minimal in-file namespaces to group related helpers
    const MB = {
      Utils: {},
      DnD: {},
      Sync: {},
      EventLog: {},
      UI: {},
      Extension: {},
      CardDAV: {},
      SyncAdapters: {}
    };

    // Enums / Sentinel values for clarity
    const ENUMS = {
      EnvelopeType: {
        GROUP_UPDATE_REQUEST: 'group-update-request',
        GROUP_ROSTER: 'group-roster',
        SYNC_CHUNK: 'sync-chunk',
        SYNC_CHUNKS_DONE: 'sync-chunks-done',
        SYNC_EVENT: 'sync-event',
        EVENT_LOG_ACTIVATION: 'event-log-activation'
      },
      Role: { OWNER: 'owner', MEMBER: 'member' }
    };

    // Message/Envelope builder
    MB.Sync.buildEnvelope = function(app, type, payload = {}, overrides = {}) {
      const from = { uuid: app?.data?.identity?.uuid || '', name: app?.data?.identity?.name || '' };
      const base = { v: 1, type, ts: Date.now(), from, msgId: (Math.random().toString(36).slice(2) + Date.now()) };
      return Object.assign(base, payload || {}, overrides || {});
    };

    // URL helpers
    MB.Utils.isValidHttpUrl = function(str) {
      try { const u = new URL(str); return u.protocol === 'http:' || u.protocol === 'https:'; } catch { return false; }
    };
    MB.Utils.ensureProtocol = function(str) {
      const s = (str || '').trim();
      if (!s) return '';
      // Normalize accidental double http(s):// prefixes
      const m = s.match(/^(https?:\/\/)/i);
      if (m) {
        return s.replace(/^(https?:\/\/)+/i, m[1]);
      }
      if (/^[a-zA-Z]+:\/\//.test(s) || s.startsWith('/')) return s;
      try {
        const appRef = (typeof window !== 'undefined' && window.app) ? window.app : null;
        const hasCustomPrefix = (
          appRef &&
          appRef.data &&
          appRef.data.options &&
          appRef.data.options.links &&
          typeof appRef.data.options.links.defaultUrlPrefix === 'string'
        );
        let pref = hasCustomPrefix
          ? appRef.data.options.links.defaultUrlPrefix
          : CONSTS.DEFAULT_URL_PREFIX;
        pref = (typeof pref === 'string') ? pref.trim() : '';
        if (!pref) return s; // allow empty (no auto prefix)
        // Collapse repeated http(s):// again after concatenation
        const combined = pref + s;
        const mm = combined.match(/^(https?:\/\/)/i);
        if (mm) return combined.replace(/^(https?:\/\/)+/i, mm[1]);
        return combined;
      } catch {
        return CONSTS.DEFAULT_URL_PREFIX ? CONSTS.DEFAULT_URL_PREFIX + s : s;
      }
    };

    // Extension communication wrapper
    MB.Extension.isAvailable = function() {
      return window.MyBookmarksExtension && typeof window.MyBookmarksExtension.isAvailable === 'function';
    };

    MB.Extension.checkAvailability = async function() {
      if (!MB.Extension.isAvailable()) {
        debugLog('warn', 'Extension object not found');
        return false;
      }
      try {
        const available = await window.MyBookmarksExtension.isAvailable();
        debugLog('log', 'Extension availability check:', available);
        return available;
      } catch (e) {
        debugLog('error', 'Extension availability check failed:', e);
        return false;
      }
    };

    MB.Extension.fetchMetadata = async function(url, options = {}) {
      if (!MB.Extension.isAvailable()) {
        throw new Error('Extension not available');
      }

      const normalizedUrl = MB.Utils.ensureProtocol(url);
      if (!MB.Utils.isValidHttpUrl(normalizedUrl)) {
        throw new Error('Invalid URL: ' + url);
      }

      debugLog('log', 'Fetching metadata via extension for:', normalizedUrl, 'Options:', options);

      try {
        const metadata = await window.MyBookmarksExtension.fetchMetadata(normalizedUrl, options);

        if (!metadata || !metadata.success) {
          throw new Error(metadata?.error || 'Failed to fetch metadata');
        }

        // Normalize the response
        return {
          success: true,
          url: normalizedUrl,
          title: metadata.title || '',
          description: metadata.description || '',
          favicon: metadata.favicon || null,
          faviconUrl: metadata.faviconUrl || null,
          ogImage: metadata.ogImage || null,
          keywords: metadata.keywords || [],
          author: metadata.author || '',
          siteName: metadata.siteName || '',
          html: metadata.html || '', // Full HTML content if requested
          links: metadata.links || [] // Extracted links if requested
        };
      } catch (e) {
        debugLog('error', 'Extension fetchMetadata failed:', e);
        throw e;
      }
    };

    MB.Extension.fetchPageContent = async function(url) {
      // Special method for fetching and parsing page content (for import)
      if (!MB.Extension.isAvailable()) {
        throw new Error('Extension not available');
      }

      const normalizedUrl = MB.Utils.ensureProtocol(url);
      if (!MB.Utils.isValidHttpUrl(normalizedUrl)) {
        throw new Error('Invalid URL: ' + url);
      }

      debugLog('log', 'Fetching page content via extension for:', normalizedUrl);

      try {
        // Use the same fetchMetadata but we'll expand it to include HTML content
        const response = await window.MyBookmarksExtension.fetchMetadata(normalizedUrl);

        if (!response || !response.success) {
          throw new Error(response?.error || 'Failed to fetch page content');
        }

        // For now, return what we have - we'll need to enhance the extension
        // to also return the HTML content for parsing
        return {
          success: true,
          url: normalizedUrl,
          title: response.title || '',
          html: response.html || '', // Extension needs to be updated to return this
          links: response.links || [] // Extension needs to extract links
        };
      } catch (e) {
        debugLog('error', 'Extension fetchPageContent failed:', e);
        throw e;
      }
    };

    MB.Extension.getBookmarks = async function() {
      if (!MB.Extension.isAvailable()) {
        throw new Error('Extension not available');
      }

      debugLog('log', 'Fetching browser bookmarks via extension');

      try {
        const bookmarks = await window.MyBookmarksExtension.getBookmarks();

        if (!bookmarks) {
          throw new Error('Failed to fetch bookmarks');
        }

        return bookmarks;
      } catch (e) {
        debugLog('error', 'Extension getBookmarks failed:', e);
        throw e;
      }
    };

    // Set DAV auth for extension header injection
    MB.Extension.setDavAuth = async function(serverUrl, username, password) {
      if (!MB.Extension.isAvailable()) return false;
      try {
        await window.MyBookmarksExtension.setDavAuth({ serverUrl, username, password });
        return true;
      } catch { return false; }
    };

    // ===== CARDDAV HELPERS (transport strictly via extension) =====
    MB.CardDAV.buildBasicAuthHeader = function(username, password) {
      const up = `${username || ''}:${password || ''}`;
      try { return 'Basic ' + btoa(up); } catch { return 'Basic ' + btoa(unescape(encodeURIComponent(up))); }
    };

    MB.CardDAV.joinUrl = function(base, path) {
      if (!base) return path || '';
      if (!path) return base;
      if (/^https?:\/\//i.test(path)) return path;
      const b = base.endsWith('/') ? base.slice(0, -1) : base;
      const p = path.startsWith('/') ? path : ('/' + path);
      return b + p;
    };

    MB.CardDAV.request = async function(req) {
      // req: { method, url, headers, body }
      const { method, url, headers, body } = req || {};
      if (!MB.Extension.isAvailable() || !window.MyBookmarksExtension || typeof window.MyBookmarksExtension.davRequest !== 'function') {
        throw new Error('Extension DAV API not available');
      }
      // Extract creds from Authorization header if present
      let username = undefined, password = undefined;
      try {
        const authHeader = headers && (headers['Authorization'] || headers['authorization']);
        if (authHeader && /^Basic\s+/i.test(authHeader)) {
          const b64 = authHeader.split(/\s+/)[1] || '';
          const up = atob(b64);
          const idx = up.indexOf(':');
          if (idx >= 0) { username = up.slice(0, idx); password = up.slice(idx + 1); }
        }
      } catch {}
      // Send with auth on first try (Nextcloud-friendly)
      let res = await MB.Extension.davRequest({ method, url, headers: headers || {}, body, username, password });
      if (!res) throw new Error('No response from extension');
      return res;
    };

    // Try to resolve /.well-known/carddav to canonical DAV base via redirect
    MB.CardDAV.followWellKnown = async function(serverUrl) {
      const wellKnown = MB.CardDAV.joinUrl(serverUrl, '/.well-known/carddav');
      try {
        const res = await MB.CardDAV.request({ method: 'GET', url: wellKnown, headers: {} });
        // XHR follows redirects; derive final URL from Location header if provided
        const loc = res.headers && (res.headers['location'] || res.headers['content-location']);
        return loc ? MB.CardDAV.joinUrl(serverUrl, loc) : serverUrl;
      } catch { return serverUrl; }
    };

    MB.CardDAV.propfind = async function(url, depth, body, authHeader) {
      const headers = {
        'Depth': String(depth ?? 0),
        'Content-Type': 'application/xml; charset=utf-8',
        'Accept': 'application/xml,text/xml'
      };
      if (authHeader) headers['Authorization'] = authHeader;
      return await MB.CardDAV.request({ method: 'PROPFIND', url, headers, body });
    };

    MB.CardDAV.report = async function(url, body, authHeader, depth = 1) {
      const headers = {
        'Depth': String(depth),
        'Content-Type': 'application/xml; charset=utf-8',
        'Accept': 'application/xml,text/xml'
      };
      if (authHeader) headers['Authorization'] = authHeader;
      return await MB.CardDAV.request({ method: 'REPORT', url, headers, body });
    };

    MB.CardDAV.get = async function(url, authHeader) {
      const headers = {};
      if (authHeader) headers['Authorization'] = authHeader;
      return await MB.CardDAV.request({ method: 'GET', url, headers });
    };

    MB.CardDAV.put = async function(url, body, authHeader, ifMatch, ifNoneMatch) {
      const headers = { 'Content-Type': 'text/vcard; charset=utf-8' };
      if (authHeader) headers['Authorization'] = authHeader;
      if (ifMatch) headers['If-Match'] = ifMatch;
      if (ifNoneMatch) headers['If-None-Match'] = ifNoneMatch;
      return await MB.CardDAV.request({ method: 'PUT', url, headers, body });
    };

    MB.CardDAV.delete = async function(url, authHeader, ifMatch) {
      const headers = {};
      if (authHeader) headers['Authorization'] = authHeader;
      if (ifMatch) headers['If-Match'] = ifMatch;
      return await MB.CardDAV.request({ method: 'DELETE', url, headers });
    };

    MB.CardDAV.escapeText = function(s) {
      return String(s || '')
        .replace(/\\/g, '\\\\')
        .replace(/\n/g, '\\n')
        .replace(/;/g, '\\;')
        .replace(/,/g, '\\,');
    };

    MB.CardDAV.buildVCard = function(model) {
      // model: { uid, fn, url, categories[], note, keywords, meta }
      const lines = [];
      lines.push('BEGIN:VCARD');
      lines.push('VERSION:4.0');
      if (model.uid) lines.push('UID:' + MB.CardDAV.escapeText(model.uid));
      if (model.fn) lines.push('FN:' + MB.CardDAV.escapeText(model.fn));
      if (model.url) lines.push('URL;VALUE=uri:' + MB.CardDAV.escapeText(model.url));
      if (Array.isArray(model.categories) && model.categories.length) {
        const cat = model.categories.map(c => MB.CardDAV.escapeText(c)).join(',');
        lines.push('CATEGORIES:' + cat);
      }
      if (model.keywords) lines.push('X-MB-KEYWORDS:' + MB.CardDAV.escapeText(model.keywords));
      if (model.meta) lines.push('X-MB-META:' + MB.CardDAV.escapeText(JSON.stringify(model.meta)));
      if (model.note) lines.push('NOTE:' + MB.CardDAV.escapeText(model.note));
      lines.push('END:VCARD');
      return lines.join('\r\n');
    };

    // ===== GENERIC SYNC ADAPTER REGISTRY =====
    MB.SyncAdapters._adapters = {};
    MB.SyncAdapters.register = function(key, adapter) { MB.SyncAdapters._adapters[key] = adapter; };
    MB.SyncAdapters.get = function(key) { return MB.SyncAdapters._adapters[key]; };

    // CardDAV adapter (wrap existing CardDAV methods)
    MB.SyncAdapters.register('carddav', {
      name: 'CardDAV',
      async testConnection(app) {
        // Reuse existing test logic
        if (typeof app.testCardDavConnection === 'function') return app.testCardDavConnection();
        // Fallback: minimal PROPFIND 0
        const opts = app.data.options?.carddav||{};
        const serverUrl = (opts.serverUrl||'').trim(); const path=(opts.addressbookPath||'').trim();
        if (!serverUrl||!path) throw new Error('Missing serverUrl or addressbookPath');
        const auth = MB.CardDAV.buildBasicAuthHeader(opts.username||'', opts.password||'');
        const url = MB.CardDAV.joinUrl(serverUrl, path);
        const r = await MB.CardDAV.propfind(url, 0, `<?xml version="1.0"?><D:propfind xmlns:D="DAV:"><D:prop><D:resourcetype/></D:prop></D:propfind>`, auth);
        return { ok: r.ok, status: r.status };
      },
      async syncNow(app) {
        if (typeof app.syncCardDavNow === 'function') return app.syncCardDavNow();
        throw new Error('CardDAV sync not available');
      }
    });

    // Nextcloud Bookmarks adapter (REST) – initial test implementation
    MB.SyncAdapters.register('nc-bookmarks', {
      name: 'Nextcloud Bookmarks',
      async testConnection(app) {
        const bk = app.data.options?.bookmarks||{};
        const serverUrl = (bk.serverUrl||'').trim();
        if (!serverUrl) throw new Error('Missing bookmarks serverUrl');
        // Ensure extension has auth from bookmarks settings
        try { await MB.Extension.setDavAuth(serverUrl, bk.username||'', bk.password||''); } catch {}
        const url = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
        const headers = { 'Accept':'application/json', 'OCS-APIREQUEST':'true', 'X-Requested-With':'XMLHttpRequest' };
        const auth = MB.CardDAV.buildBasicAuthHeader(bk.username||'', bk.password||'');
        headers['Authorization']=auth;
        const res = await MB.Extension.davRequest({ method:'GET', url, headers, username: bk.username||'', password: bk.password||'' });
        return { ok: res.ok, status: res.status };
      },
      async syncNow(app) {
        debugLog('log', '[NC SYNC] syncNow start');
        try { app.syncInProgress = true; app.syncProgress = 5; app.syncProgressText = 'Synchronizing…'; } catch {}
        try { debugLog('log', '[NC-TRACE] Start', { traceId: (typeof TRACE_NC_ID!=='undefined'?TRACE_NC_ID:null), backend: 'nc-bookmarks' }); } catch {}
        const bk = app.data.options?.bookmarks||{};
        const serverUrl = (bk.serverUrl||'').trim();
        if (!serverUrl) throw new Error('Missing bookmarks serverUrl');
        const sessionId = Date.now();
        const forceFetchAll = (typeof window !== 'undefined' && (window.mbForceFetch === true)) || (localStorage.getItem('mbForceFetch') === '1');
        // Robust NC timestamp parser: supports seconds, millis, numeric strings, ISO strings
        const parseNcTs = (v) => {
          if (v === null || v === undefined) return 0;
          if (typeof v === 'number') return v < 1e12 ? Math.floor(v * 1000) : Math.floor(v);
          const s = String(v).trim();
          if (!s) return 0;
          const n = Number(s);
          if (!Number.isNaN(n)) return n < 1e12 ? Math.floor(n * 1000) : Math.floor(n);
          const d = Date.parse(s);
          return Number.isNaN(d) ? 0 : Math.floor(d);
        };
        try { await MB.Extension.setDavAuth(serverUrl, bk.username||'', bk.password||''); } catch {}
        const auth = MB.CardDAV.buildBasicAuthHeader(bk.username||'', bk.password||'');
        const hJson = { 'Accept':'application/json', 'OCS-APIREQUEST':'true', 'X-Requested-With':'XMLHttpRequest', 'Authorization':auth };
        // Process any pending remote deletions FIRST to avoid re-pulling locally deleted items
        try {
          const pending = Array.isArray(app.data.pendingNcDeletes) ? [...app.data.pendingNcDeletes] : [];
          for (const pd of pending) {
            if (!pd?.id) continue;
            const delUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(pd.id)}`);
            let delRes = null; try { delRes = await MB.Extension.davRequest({ method:'DELETE', url: delUrl, headers:hJson, username: bk.username||'', password: bk.password||'' }); } catch { delRes = { ok:false, status:0 }; }
            if (delRes?.ok || delRes?.status === 404) {
              try { app.data.pendingNcDeletes = (app.data.pendingNcDeletes||[]).filter(x => x !== pd); } catch {}
              debugLog('log', '[NC SYNC] Pre-pull delete OK', { id: pd.id, status: delRes?.status||200 });
            } else {
              debugLog('warn', '[NC SYNC] Pre-pull delete failed (will retry later)', { id: pd.id, status: delRes?.status });
            }
          }
          app.saveData();
        } catch {}
        // Helper: robust JSON parse for NC Bookmarks responses (handles OCS/data/items wrappers)
        const parseNcList = (bodyText, label) => {
          let parsed = null;
          try { parsed = JSON.parse(bodyText||'[]'); } catch {}
          if (Array.isArray(parsed)) return parsed;
          const d = parsed && parsed.data ? parsed.data : parsed;
          if (Array.isArray(d)) return d;
          if (d && Array.isArray(d.items)) return d.items;
          if (parsed && Array.isArray(parsed.items)) return parsed.items;
          debugLog('warn', '[NC SYNC] Could not parse list as array', { label, sample: (bodyText||'').slice(0, 200) });
          return [];
        };
        // Unwrap helper for single-object responses: {item:{...}}, {data:{...}}, {status, item}
        const unwrapNc = (obj) => {
          try {
            if (!obj) return obj;
            if (obj && obj.status && obj.item) return obj.item;
            if (obj && obj.data && obj.data.item) return obj.data.item;
            if (obj && obj.item) return obj.item;
            if (obj && obj.data && !obj.id) return obj.data;
            return obj;
          } catch { return obj; }
        };
        // Helper: fetch bookmarks for a folder with multiple fallbacks
        const fetchFolderItems = async (fid) => {
          // Attempt 0: some NC setups require page=0 + deleted=false + sortby
          try {
            const url0 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?limit=1000&page=0&sortby=lastmodified&folder=${encodeURIComponent(fid)}&deleted=false`);
            const res0 = await MB.Extension.davRequest({ method:'GET', url:url0, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res0?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt0 body head', { folderId: fid, head: (res0.bodyText||'').slice(0, 200) }); } catch {}
              const arr0 = parseNcList(res0.bodyText, 'attempt0-folder-page0');
              if (arr0.length) return arr0;
            } else { try { debugLog('warn', '[NC SYNC] items attempt0 status', { folderId: fid, status: res0?.status }); } catch {} }
          } catch {}
          // Attempt 0b: folders[] variant
          try {
            const url0b = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?limit=1000&page=0&sortby=lastmodified&folders[]=${encodeURIComponent(fid)}&deleted=false`);
            const res0b = await MB.Extension.davRequest({ method:'GET', url:url0b, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res0b?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt0b body head', { folderId: fid, head: (res0b.bodyText||'').slice(0, 200) }); } catch {}
              const arr0b = parseNcList(res0b.bodyText, 'attempt0b-folders[]-page0');
              if (arr0b.length) return arr0b;
            } else { try { debugLog('warn', '[NC SYNC] items attempt0b status', { folderId: fid, status: res0b?.status }); } catch {} }
          } catch {}
          // Attempt 1: folder=ID
          try {
            const url1 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?folder=${encodeURIComponent(fid)}&page=1&limit=1000`);
            const res1 = await MB.Extension.davRequest({ method:'GET', url:url1, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res1?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt1 body head', { folderId: fid, head: (res1.bodyText||'').slice(0, 200) }); } catch {}
              const arr1 = parseNcList(res1.bodyText, 'attempt1-folder');
              if (arr1.length) return arr1;
            }
          } catch {}
          // Attempt 2: folders[]=ID
          try {
            const url2 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?folders[]=${encodeURIComponent(fid)}&page=1&limit=1000`);
            const res2 = await MB.Extension.davRequest({ method:'GET', url:url2, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res2?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt2 body head', { folderId: fid, head: (res2.bodyText||'').slice(0, 200) }); } catch {}
              const arr2 = parseNcList(res2.bodyText, 'attempt2-folders[]');
              if (arr2.length) return arr2;
            }
          } catch {}
          // Attempt 3: all bookmarks then filter by folder membership if present
          try {
            const url3 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?page=1&limit=1000`);
            const res3 = await MB.Extension.davRequest({ method:'GET', url:url3, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res3?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt3 body head', { folderId: fid, head: (res3.bodyText||'').slice(0, 200) }); } catch {}
              const arr3 = parseNcList(res3.bodyText, 'attempt3-all');
              if (Array.isArray(arr3) && arr3.length) {
                const out = arr3.filter(it => {
                  const flds = Array.isArray(it.folders) ? it.folders : [];
                  const fSingle = (it.folder!==undefined && it.folder!==null) ? Number(it.folder) : null;
                  return (flds.includes(fid) || flds.includes(Number(fid)) || (fSingle!==null && fSingle === Number(fid)));
                });
                if (out.length) return out;
              }
            }
          } catch {}
          // Attempt 4: OCS fallback
          try {
            const url4 = MB.CardDAV.joinUrl(serverUrl, `/ocs/v2.php/apps/bookmarks/api/v1/bookmark?folder=${encodeURIComponent(fid)}&page=1&limit=1000&format=json`);
            const res4 = await MB.Extension.davRequest({ method:'GET', url:url4, headers:Object.assign({}, hJson, {'OCS-APIREQUEST':'true'}), username: bk.username||'', password: bk.password||'' });
            if (res4?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt4 OCS body head', { folderId: fid, head: (res4.bodyText||'').slice(0, 200) }); } catch {}
              let parsed=null; try { parsed = JSON.parse(res4.bodyText||'null'); } catch {}
              let items = [];
              const ocs = parsed && parsed.ocs ? parsed.ocs : parsed;
              const data = ocs && ocs.data ? ocs.data : (Array.isArray(parsed) ? parsed : (parsed && parsed.data ? parsed.data : []));
              if (Array.isArray(data)) items = data; else if (data && Array.isArray(data.items)) items = data.items;
              if (items && items.length) return items;
            } else { try { debugLog('warn', '[NC SYNC] items attempt4 OCS status', { folderId: fid, status: res4?.status, head: (res4.bodyText||'').slice(0,120) }); } catch {} }
          } catch {}
          // Attempt 5: REST nested per folder
          try {
            const url5 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(fid)}/bookmark?page=1&limit=1000`);
            const res5 = await MB.Extension.davRequest({ method:'GET', url:url5, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res5?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt5 nested body head', { folderId: fid, head: (res5.bodyText||'').slice(0, 200) }); } catch {}
              const arr5 = parseNcList(res5.bodyText, 'attempt5-folder-nested');
              if (arr5.length) return arr5;
            } else { try { debugLog('warn', '[NC SYNC] items attempt5 status', { folderId: fid, status: res5?.status }); } catch {} }
          } catch {}
          // Attempt 6: REST with folderId variant
          try {
            const url6 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?folderId=${encodeURIComponent(fid)}&page=1&limit=1000`);
            const res6 = await MB.Extension.davRequest({ method:'GET', url:url6, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res6?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt6 folderId body head', { folderId: fid, head: (res6.bodyText||'').slice(0, 200) }); } catch {}
              const arr6 = parseNcList(res6.bodyText, 'attempt6-folderId');
              if (arr6.length) return arr6;
            } else { try { debugLog('warn', '[NC SYNC] items attempt6 status', { folderId: fid, status: res6?.status }); } catch {} }
          } catch {}
          // Attempt 7: OCS folder path
          try {
            const url7 = MB.CardDAV.joinUrl(serverUrl, `/ocs/v2.php/apps/bookmarks/api/v1/folder/${encodeURIComponent(fid)}/bookmarks?format=json&page=1&limit=1000`);
            const res7 = await MB.Extension.davRequest({ method:'GET', url:url7, headers:Object.assign({}, hJson, {'OCS-APIREQUEST':'true'}), username: bk.username||'', password: bk.password||'' });
            if (res7?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt7 OCS folder body head', { folderId: fid, head: (res7.bodyText||'').slice(0, 200) }); } catch {}
              let parsed=null; try { parsed = JSON.parse(res7.bodyText||'null'); } catch {}
              let items = [];
              const ocs = parsed && parsed.ocs ? parsed.ocs : parsed;
              const data = ocs && ocs.data ? ocs.data : (Array.isArray(parsed) ? parsed : (parsed && parsed.data ? parsed.data : []));
              if (Array.isArray(data)) items = data; else if (data && Array.isArray(data.items)) items = data.items;
              if (items && items.length) return items;
            } else { try { debugLog('warn', '[NC SYNC] items attempt7 status', { folderId: fid, status: res7?.status, head: (res7.bodyText||'').slice(0,120) }); } catch {} }
          } catch {}
          return [];
        };
        // Helper to fetch single bookmark to resolve conflicts when folder-hash says no change
        // Trace helper: set a specific NC bookmark id to trace via localStorage.setItem('mbTraceNcId','2073')
        const TRACE_NC_ID = Number(localStorage.getItem('mbTraceNcId')||2073);
        const traceFlags = { fetch:false, folderItem:false, merge:false, reconcile:false, pushPre0:false, pushPre:false };
        const fetchBookmark = async (bid) => {
          try {
            const gUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(bid)}`);
            const gRes = await MB.Extension.davRequest({ method:'GET', url:gUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (!gRes.ok) return null;
            let obj=null; try { obj = JSON.parse(gRes.bodyText||'null'); } catch {}
            // Unwrap common NC REST wrappers: {data:{...}}, {item:{...}}, or direct object
            if (obj && obj.data && obj.data.item) obj = obj.data.item;
            else if (obj && obj.item) obj = obj.item;
            else if (obj && obj.data && !obj.id) obj = obj.data;
            // Some servers wrap in {status, item}
            if (obj && obj.status && obj.item) obj = obj.item;
            try {
              if (Number(bid) === TRACE_NC_ID) {
                traceFlags.fetch = true;
                debugLog('log', '[NC-TRACE 2073] fetchBookmark() response', {
                  url: gUrl,
                  ok: gRes.ok,
                  status: gRes.status,
                  bodyHead: (gRes.bodyText||'').slice(0, 500),
                  parsed: MB.Utils.safeClone(obj),
                  lastmodified: obj?.lastmodified || obj?.lastModified || obj?.updated,
                });
              }
            } catch {}
            return obj && (obj.id !== undefined) ? obj : null;
          } catch { return null; }
        };

        // 1) Folders
        const fUrl = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
        const fRes = await MB.Extension.davRequest({ method:'GET', url:fUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
        if (!fRes.ok) throw new Error('Folders fetch failed: '+fRes.status);
        const parseFolderList = (bodyText) => {
          let obj=null; try { obj = JSON.parse(bodyText||'[]'); } catch {}
          if (Array.isArray(obj)) return obj;
          const d = obj && obj.data ? obj.data : obj;
          if (Array.isArray(d)) return d;
          if (d && Array.isArray(d.items)) return d.items;
          if (obj && Array.isArray(obj.items)) return obj.items;
          // Some servers return {status:'success', item:{...}} for single; normalize to array
          if (d && d.item) return [d.item];
          if (obj && obj.item) return [obj.item];
          return [];
        };
        let folders = parseFolderList(fRes.bodyText);
        // Flatten embedded children recursively (server returns children inline)
        const seenFolderIds = new Set();
        const flat = [];
        const pushFolder = (f, parentHint = undefined) => {
          if (!f || f.id === undefined || f.id === null) return;
          if (parentHint !== undefined && (f.parent_folder === undefined || f.parent_folder === null)) f.parent_folder = parentHint;
          if (!seenFolderIds.has(f.id)) { seenFolderIds.add(f.id); flat.push(f); }
          const kids = Array.isArray(f.children) ? f.children : [];
          for (const k of kids) {
            if (k && typeof k === 'object') pushFolder(k, f.id); else if (typeof k === 'number') flat.push({ id: k, parent_folder: f.id });
          }
        };
        for (const f of (folders||[])) pushFolder(f, f.parent_folder);
        // Replace with flattened list and normalize id/parent_folder to numbers
        folders = flat.map(f => {
          const idNum = Number(f.id);
          const parentNum = (f.parent_folder === null || f.parent_folder === undefined) ? -1 : Number(f.parent_folder);
          const title = (f.title !== undefined) ? f.title : (f.name || '');
          return Object.assign({}, f, { id: idNum, parent_folder: parentNum, title });
        });
        try { debugLog('log', '[NC SYNC] fetched folders', { count: folders.length }); if (app && app.syncInProgress!==undefined) { app.syncProgress = 12; app.syncProgressText = `Preparing folders (${folders.length})…`; } } catch {}
        const byId = Object.fromEntries(folders.map(f=>[f.id, f]));
        const byTitle = Object.fromEntries(folders.map(f=>[(f.title||'').toLowerCase(), f]));

        // Limit to rootFolderId if configured (include subtree)
        const rootId = Number(bk.rootFolderId||0);
        // If we have a specific root but the server didn't return its subtree, first try to fetch child folders explicitly (BFS)
        if (rootId > 0) {
          const fetchChildrenOnce = async (pid) => {
            const results = [];
            const tryParse = (txt) => { try { const o = JSON.parse(txt||'[]'); const d=o&&o.data?o.data:o; return Array.isArray(d)?d:(d&&Array.isArray(d.items)?d.items:[]); } catch { return []; } };
            // Attempt 1: ?parent_folder=
            try {
              const u1 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder?parent_folder=${encodeURIComponent(pid)}`);
              const r1 = await MB.Extension.davRequest({ method:'GET', url:u1, headers:hJson, username: bk.username||'', password: bk.password||'' });
              if (r1?.ok) { const arr = tryParse(r1.bodyText); if (arr.length) return arr; }
            } catch {}
            // Attempt 2: ?parent=
            try {
              const u2 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder?parent=${encodeURIComponent(pid)}`);
              const r2 = await MB.Extension.davRequest({ method:'GET', url:u2, headers:hJson, username: bk.username||'', password: bk.password||'' });
              if (r2?.ok) { const arr = tryParse(r2.bodyText); if (arr.length) return arr; }
            } catch {}
            // Attempt 3: paged full list and filter by parent
            try {
              const u3 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder?page=1&limit=1000`);
              const r3 = await MB.Extension.davRequest({ method:'GET', url:u3, headers:hJson, username: bk.username||'', password: bk.password||'' });
              if (r3?.ok) { const arr = tryParse(r3.bodyText); return arr.filter(x => Number(x.parent_folder||-1) === Number(pid)); }
            } catch {}
            return results;
          };
          // BFS discover subtree
          const discovered = new Map();
          const queue = [];
          if (byId[rootId]) discovered.set(rootId, byId[rootId]); else queue.push(rootId);
          queue.push(rootId);
          const visited = new Set();
          while (queue.length) {
            const pid = queue.shift();
            if (visited.has(pid)) continue; visited.add(pid);
            let kids = [];
            try { kids = await fetchChildrenOnce(pid); } catch {}
            for (const k of (kids||[])) {
              const kid = Object.assign({}, k, { parent_folder: (k.parent_folder!==undefined?k.parent_folder:pid) });
              if (!byId[kid.id]) folders.push(kid);
              byId[kid.id] = kid; byTitle[(kid.title||'').toLowerCase()] = kid;
              if (!discovered.has(kid.id)) { discovered.set(kid.id, kid); queue.push(kid.id); }
            }
          }
          try { debugLog('log', '[NC SYNC] expanded folders via children BFS', { total: folders.length }); } catch {}
        }
        // If still only the root is known, try to expand by scanning bookmarks and fetching missing folder metas
        if (rootId > 0) {
          try {
            const allUrl = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/bookmark?page=1&limit=1000');
            const allRes = await MB.Extension.davRequest({ method:'GET', url:allUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (allRes?.ok) {
              const allItems = (function(bt){ let arr=[]; try{arr=JSON.parse(bt||'[]');}catch{}; const d=arr&&arr.data?arr.data:arr; return Array.isArray(d)?d:(d&&Array.isArray(d.items)?d.items:[]); })(allRes.bodyText);
              const needed = new Set();
              for (const it of (allItems||[])) {
                const fids = Array.isArray(it.folders) ? it.folders : [];
                for (const fid of fids) if (!byId[fid]) needed.add(fid);
              }
              for (const fid of needed) {
                try {
                  const getUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(fid)}`);
                  const r = await MB.Extension.davRequest({ method:'GET', url:getUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
                  if (r?.ok) {
                    let fo=null; try { fo = JSON.parse(r.bodyText||'null'); } catch {}
                    if (fo && fo.data && fo.data.item) fo=fo.data.item; else if (fo && fo.item) fo=fo.item; else if (fo && fo.data && !fo.id) fo=fo.data;
                    if (fo && (fo.id!==undefined)) { byId[fo.id]=fo; byTitle[(fo.title||'').toLowerCase()]=fo; folders.push(fo); }
                  }
                } catch {}
              }
              try { debugLog('log', '[NC SYNC] expanded folders via bookmark scan', { total: folders.length }); } catch {}
            }
          } catch {}
        }

        // Final fallback: try to fetch the root folder detail and inspect embedded children fields
        if (rootId > 0 && (!byId[rootId] || folders.length <= 1)) {
          try {
            const detailUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(rootId)}`);
            const det = await MB.Extension.davRequest({ method:'GET', url:detailUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (det?.ok) {
              let fo=null; try { fo = JSON.parse(det.bodyText||'null'); } catch {}
              if (fo && fo.data && fo.data.item) fo=fo.data.item; else if (fo && fo.item) fo=fo.item; else if (fo && fo.data && !fo.id) fo=fo.data;
              if (fo) {
                // Normalize a few potential child notations
                const childIds = [];
                if (Array.isArray(fo.children)) {
                  for (const c of fo.children) { if (typeof c === 'number') childIds.push(c); else if (c && c.id!==undefined) { childIds.push(c.id); if (!byId[c.id]) { byId[c.id]=c; folders.push(c); } } }
                }
                if (Array.isArray(fo.childIds)) childIds.push(...fo.childIds);
                if (fo.childCount > 0 && childIds.length === 0 && Array.isArray(fo.childs)) {
                  for (const c of fo.childs) { if (typeof c === 'number') childIds.push(c); else if (c && c.id!==undefined) { childIds.push(c.id); if (!byId[c.id]) { byId[c.id]=c; folders.push(c); } } }
                }
                // Fetch missing child meta
                for (const cid of childIds) {
                  if (byId[cid]) continue;
                  try {
                    const cu = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(cid)}`);
                    const cr = await MB.Extension.davRequest({ method:'GET', url:cu, headers:hJson, username: bk.username||'', password: bk.password||'' });
                    if (cr?.ok) { let co=null; try { co=JSON.parse(cr.bodyText||'null'); } catch {}; if (co && co.data && co.data.item) co=co.data.item; else if (co && co.item) co=co.item; else if (co && co.data && !co.id) co=co.data; if (co && co.id!==undefined) { byId[co.id]=co; folders.push(co); } }
                  } catch {}
                }
                try { debugLog('log', '[NC SYNC] expanded folders via root detail', { total: folders.length, childIds }); } catch {}
              }
            }
          } catch {}
        }
        const getChildren = (id) => {
          const f = byId[id];
          if (!f) return [];
          // children may be provided; otherwise derive from parent_folder
          let kids = [];
          if (Array.isArray(f.children)) {
            for (const ch of f.children) {
              if (typeof ch === 'number') kids.push(Number(ch));
              else if (ch && ch.id !== undefined) kids.push(Number(ch.id));
            }
          }
          if (!kids.length) {
            kids = folders.filter(x => Number(x.parent_folder||-1) === Number(id)).map(x => Number(x.id));
          }
          return kids;
        };
        const collectDescendants = (id, acc = new Set()) => {
          for (const cid of getChildren(id)) {
            if (!acc.has(cid)) { acc.add(cid); collectDescendants(cid, acc); }
          }
          return acc;
        };
        // Only sync descendants of selected root; not the root itself
        const targetIds = rootId>0 ? Array.from(collectDescendants(Number(rootId))) : folders.map(f=>Number(f.id));
        const targetFolders = folders.filter(x=> targetIds.includes(Number(x.id)));
        try { debugLog('log', '[NC SYNC] target folders', { ids: targetIds, count: targetFolders.length }); } catch {}

        let createdGroups=0, createdLinks=0, updatedLinks=0, createdFolders=0, renamedFolders=0, removedLinks=0;

        // Helper: ensure a local group exists and is linked to a given NC folder
        const ensureGroupForFolder = (folder) => {
          const title = folder.title || 'Bookmarks';
          // 1) Prefer existing mapping by folderId
          let g = (app.data.groups||[]).find(x => x.ncBookmarks && x.ncBookmarks.folderId === folder.id);
          if (g) {
            if ((g.name||'') !== title) { app.$set(g, 'name', title); }
            return g;
          }
          // 2) Fallback: find by current name and attach mapping
          g = (app.data.groups||[]).find(x => (x.name||'') === title);
          if (g) {
            app.$set(g, 'ncBookmarks', Object.assign({}, g.ncBookmarks||{}, { folderId: folder.id }));
            return g;
          }
          // 3) Create new group when not found
          g = app.getNewGroupTemplate(title);
          app.$set(g, 'ncBookmarks', Object.assign({}, g.ncBookmarks||{}, { folderId: folder.id }));
          app.data.groups.push(g);
          createdGroups++;
          return g;
        };

        // Map existing groups to folders (create folders if missing)
        for (const g of (app.data.groups||[])) {
          let fid = g.ncBookmarks?.folderId;
          if (fid && byId[fid]) { // ensure local name follows server if mapped folder exists
            const f = byId[fid];
            if (f && (g.name||'') !== (f.title||'')) app.$set(g, 'name', f.title||'Bookmarks');
            continue;
          }
          // If we have a stored mapping but it's not in the current list, trust mapping and try to fetch/insert into cache
          if (fid && !byId[fid]) {
            try {
              const getUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(fid)}`);
              const r = await MB.Extension.davRequest({ method:'GET', url:getUrl, headers:hJson, username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
              if (r?.ok) {
                let fo=null; try { fo=JSON.parse(r.bodyText||'null'); } catch {}
                // Unwrap
                if (fo && fo.data && fo.data.item) fo = fo.data.item; else if (fo && fo.item) fo = fo.item; else if (fo && fo.data && !fo.id) fo = fo.data;
                byId[fid] = fo; if (fo && (fo.title||fo.name)) byTitle[(fo.title||fo.name||'').toLowerCase()] = fo;
                debugLog('log', '[NC SYNC] Verified existing mapped folder via GET', { folderId: fid, title: fo?.title||fo?.name||'' });
                // Align group name if server has a title
                if (fo && (fo.title||fo.name) && (g.name||'') !== (fo.title||fo.name)) app.$set(g, 'name', (fo.title||fo.name));
                continue;
              } else {
                debugLog('warn', '[NC SYNC] Stored folderId not found on server, will try match/create', { folderId: fid, status: r?.status });
              }
            } catch {}
          }
          const match = byTitle[(g.name||'').toLowerCase()];
          if (match) { app.$set(g,'ncBookmarks',Object.assign({},g.ncBookmarks||{}, { folderId: match.id })); continue; }
          // create folder (only if enabled)
          if (bk.autoCreateFolders) {
            try {
              const cUrl = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
              const payload = { title: g.name||'Bookmarks' };
              if (rootId && rootId > 0) payload.parent_folder = rootId;
              try { debugLog('log', '[NC SYNC] Creating folder', { title: payload.title, parent_folder: payload.parent_folder||null }); } catch {}
              const cRes = await MB.Extension.davRequest({ method:'POST', url:cUrl, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(payload), username: bk.username||'', password: bk.password||'' });
              if (cRes.ok) { let cf=null; try{ cf=JSON.parse(cRes.bodyText||'null'); }catch{}; cf = unwrapNc(cf); const id=cf?.id; app.$set(g,'ncBookmarks',Object.assign({},g.ncBookmarks||{}, { folderId:id })); createdFolders++; if (id!==undefined) { byId[id]=cf; byTitle[(cf.title||'').toLowerCase()]=cf; } try { debugLog('log', '[NC SYNC] Created folder OK', { id, title: cf?.title, parent_folder: cf?.parent_folder }); } catch {} }
              else { try { debugLog('error', '[NC SYNC] Create folder FAILED', { status:cRes.status, bodyHead:(cRes.bodyText||'').slice(0,300) }); } catch {} }
            } catch {}
          }
        }

        // Rename handling: if names differ, either push rename (if enabled) or take server name into local
        for (const g of (app.data.groups||[])) {
          const fid = g.ncBookmarks?.folderId; if (!fid) continue;
          const f = byId[fid]; if (!f) continue;
          if ((f.title||'') !== (g.name||'')) {
            if (bk.autoRenameFolders) {
              try {
                const uUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(fid)}`);
                const uRes = await MB.Extension.davRequest({ method:'PATCH', url:uUrl, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify({ title: g.name||'' }), username: bk.username||'', password: bk.password||'' });
                if (uRes.ok) { let pf=null; try{ pf=JSON.parse(uRes.bodyText||'null'); } catch{}; pf = pf && pf.data && !pf.id ? pf.data : pf; if (pf && (pf.title || pf.id)) { f.title = pf.title || (g.name||''); } else { f.title = g.name||''; } renamedFolders++; byTitle[(f.title||'').toLowerCase()]=f; }
              } catch {}
            } else {
              // Server wins: rename local group to server title
              app.$set(g, 'name', f.title||'Bookmarks');
            }
          }
        }

        // 2) For each folder, fetch bookmarks
        const folderHashes = Object.assign({}, app.data.options?.bookmarks?.folderHashes||{});
        // Build an index of all local links by Nextcloud bookmark ID for robust matching/moves
        const localByNcId = new Map();
        for (const g of (app.data.groups||[])) {
          for (const l of (g.links||[])) {
            const nid = l?.ncBookmarks?.id;
            if (nid) localByNcId.set(nid, { group: g, link: l });
          }
        }
        let __pulledIdx = 0; const __pullTotal = targetFolders.length||1;
        for (const folder of targetFolders) {
          const hUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(folder.id)}/hash?hashFn=xxh32`);
          let mustFetch = true;
          try {
            const hRes = await MB.Extension.davRequest({ method:'GET', url:hUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (hRes.ok) {
              let newH = (hRes.bodyText||'').trim();
              try {
                const parsed = JSON.parse(hRes.bodyText||'null');
                if (parsed && typeof parsed === 'object') {
                  if (parsed.hash) newH = String(parsed.hash);
                  else if (typeof parsed.data === 'string') newH = parsed.data;
                  else if (parsed.data && typeof parsed.data === 'object' && parsed.data.hash) newH = String(parsed.data.hash);
                }
              } catch {}
              const oldH = folderHashes[folder.id] || null;
              if (newH && oldH===newH) mustFetch=false; else folderHashes[folder.id]=newH;
              debugLog('log', '[NC SYNC] folder hash decision', { folderId: folder.id, oldHash: oldH, newHash: newH, mustFetchDefault: mustFetch, forceFetchAll });
            }
          } catch {}
          if (!mustFetch && !forceFetchAll) {
            debugLog('log', '[NC SYNC] hash unchanged; still fetching to detect remote edits', { folderId: folder.id });
          }
          let items = await fetchFolderItems(folder.id);
            try {
              debugLog('log', '[NC SYNC] fetched items for folder', { folderId: folder.id, count: items.length });
              if (TRACE_NC_ID>0 && items.some(ii=> Number(ii.id)===TRACE_NC_ID)) traceFlags.folderItem = true;
              if (app && app.syncInProgress) { __pulledIdx++; app.syncProgressText = `Pulling folders (${__pulledIdx}/${__pullTotal})…`; app.syncProgress = 12 + Math.round((__pulledIdx/__pullTotal)*53); }
            } catch {}
          const group = ensureGroupForFolder(folder);
          if (!group.links) app.$set(group,'links',[]);
          app.$set(group, 'ncBookmarks', Object.assign({}, group.ncBookmarks||{}, { folderId: folder.id }));
          const remoteIds = new Set(items.map(i=>i.id));

          for (const it of items) {
            const url = it.url || '';
            const text = it.title || url;
            const tags = Array.isArray(it.tags)? it.tags : [];
            const desc = it.description || '';
            const ncId = it.id;
            const remoteUpdatedAt = parseNcTs(it.lastmodified || it.lastModified || it.updated || it.edited || it.lastUpdate || it.mtime || it.modTime);
            // Skip re-adding items that are pending deletion locally
            try {
              const pending = Array.isArray(app.data.pendingNcDeletes) ? app.data.pendingNcDeletes : [];
              if (pending.some(pd => (pd.id && Number(pd.id)===Number(ncId)) || (pd.url && pd.url===url))) {
                debugLog('log', '[NC SYNC] Skipping item (pending local deletion)', { id: ncId, url });
                continue;
              }
            } catch {}
            try { if (Number(ncId) === TRACE_NC_ID) debugLog('log', '[NC-TRACE 2073] Folder fetch item', { item: MB.Utils.safeClone(it), remoteUpdatedAt }); } catch {}
            // Prefer global match by Nextcloud ID across all groups
            let existingEntry = localByNcId.get(ncId) || null;
            let existing = existingEntry?.link || null;
            if (existing && existingEntry.group !== group) {
              // Move locally to the correct group to reflect server structure
              try {
                const src = existingEntry.group;
                const idx = (src.links||[]).indexOf(existing);
                if (idx >= 0) src.links.splice(idx, 1);
              } catch {}
              if (!group.links) app.$set(group,'links',[]);
              group.links.push(existing);
              // Update index to new group
              localByNcId.set(ncId, { group, link: existing });
            }
            if (!existing) {
              // Fallback: search in current group by id or url
              existing = group.links.find(l=> (l.ncBookmarks && l.ncBookmarks.id===ncId) || (l.url && l.url===url));
              if (existing) localByNcId.set(ncId, { group, link: existing });
            }
            const linkObj = {
              uuid: existing?.uuid || (app.generateUUID()),
              text, url,
              keywords: tags.join(', '),
              infoHtml: desc,
              deleted: false,
              ncBookmarks: { id:ncId, folderId:folder.id, lastSyncedAt:Date.now(), remoteUpdatedAt, localUpdatedAt: 0, justPulled: sessionId }
            };
            // Compute a local hash for change detection symmetry with push phase
            try {
              const payloadForHash = { text:linkObj.text||'', url:linkObj.url||'', keywords:linkObj.keywords||'', infoHtml:linkObj.infoHtml||'' };
              linkObj.ncBookmarks.lastHash = btoa(unescape(encodeURIComponent(JSON.stringify(payloadForHash))));
            } catch { linkObj.ncBookmarks.lastHash = ''; }
            // Also remember remote signature to detect remote changes without timestamp
            linkObj.ncBookmarks.remoteSig = linkObj.ncBookmarks.lastHash;
            if (existing) {
              try {
                if (Number(ncId) === TRACE_NC_ID) { traceFlags.merge = true; debugLog('log', '[NC-TRACE 2073] Before merge existing', {
                  group: group.name,
                  existing: MB.Utils.safeClone(existing),
                  incoming: MB.Utils.safeClone({ text, url, tags, desc, ncId, remoteUpdatedAt })
                }); }
              } catch {}
              // Decide direction per link based on timestamps and signatures
              const prevNB = existing.ncBookmarks || {};
              const prevLocalAt = parseNcTs(prevNB.localUpdatedAt || 0);
              const prevRemoteAt = parseNcTs(prevNB.remoteUpdatedAt || 0);
              // Compute local signature from current existing content BEFORE any overwrite
              let localSig = '';
              try { localSig = btoa(unescape(encodeURIComponent(JSON.stringify({ text: existing.text||'', url: existing.url||'', keywords: existing.keywords||'', infoHtml: existing.infoHtml||'' })))); } catch { localSig = JSON.stringify({ text: existing.text||'', url: existing.url||'', keywords: existing.keywords||'', infoHtml: existing.infoHtml||'' }); }
              const prevLastHash = prevNB.lastHash || '';
              const localChanged = (!prevLastHash || prevLastHash !== localSig) || !!prevLocalAt;
              const rSig = linkObj.ncBookmarks.lastHash || '';
              const storedRemoteSig = prevNB.remoteSig || '';
              const remoteChanged = (rSig !== storedRemoteSig) || (remoteUpdatedAt && remoteUpdatedAt > prevRemoteAt);
              // If remote is newer or no local change, adopt remote; otherwise keep local and only refresh remote meta
              const remoteWins = remoteChanged && (!localChanged || (remoteUpdatedAt && remoteUpdatedAt >= prevLocalAt));
              try {
                if (Number(ncId) === TRACE_NC_ID) { debugLog('log', '[NC-TRACE 2073] Merge decision', {
                  prevLocalAt, prevRemoteAt, remoteUpdatedAt, localSig, prevLastHash,
                  localChanged, remoteChanged, storedRemoteSig, rSig, remoteWins
                }); }
              } catch {}
              if (remoteWins) {
                existing.text = linkObj.text; existing.url = linkObj.url; existing.keywords = linkObj.keywords; existing.infoHtml = linkObj.infoHtml;
                existing.ncBookmarks = Object.assign({}, prevNB, linkObj.ncBookmarks, { remoteSig: rSig, lastHash: rSig, localUpdatedAt: 0 });
              } else {
                // Keep local content; refresh mapping/meta only
                existing.ncBookmarks = Object.assign({}, prevNB, {
                  id: linkObj.ncBookmarks.id,
                  folderId: linkObj.ncBookmarks.folderId,
                  lastSyncedAt: Date.now(),
                  remoteUpdatedAt: Math.max(prevRemoteAt, parseNcTs(linkObj.ncBookmarks.remoteUpdatedAt||0)),
                  remoteSig: rSig || storedRemoteSig,
                  // keep lastHash and localUpdatedAt as-is to push later
                });
              }
              try { if (Number(ncId) === TRACE_NC_ID) debugLog('log', '[NC-TRACE 2073] After merge', { existing: MB.Utils.safeClone(existing) }); } catch {}
              existing.deleted = false; updatedLinks++;
            } else { group.links.push(linkObj); createdLinks++; }
          }
          // Remove local links that are no longer on server (same folder & has nc id)
          const before = group.links.length;
          group.links = group.links.filter(l=> !(l.ncBookmarks && l.ncBookmarks.folderId===folder.id && l.ncBookmarks.id && !remoteIds.has(l.ncBookmarks.id)));
          removedLinks += (before - group.links.length);
          // Persist folder hash
          app.$set(app.data.options.bookmarks, 'folderHashes', Object.assign({}, folderHashes));
          app.saveData();
        }

        // 2.4) Try to resolve missing NC IDs by URL (to avoid creating/updating wrong records)
        const fetchByUrl = async (u) => {
          if (!u) return null;
          const tryParseList = (bodyText, label) => {
            let parsed=null; try { parsed = JSON.parse(bodyText||'[]'); } catch {}
            const d = parsed && parsed.data ? parsed.data : parsed;
            const items = Array.isArray(d) ? d : (d && Array.isArray(d.items) ? d.items : []);
            if (!Array.isArray(items)) return [];
            return items;
          };
          const norm = (s) => { try { return decodeURIComponent(String(s||'').trim()); } catch { return String(s||'').trim(); } };
          const cand = [];
          try {
            const url1 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?url=${encodeURIComponent(u)}&page=1&limit=5`);
            const r1 = await MB.Extension.davRequest({ method:'GET', url:url1, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (r1?.ok) { cand.push(...tryParseList(r1.bodyText, 'byUrl')); }
          } catch {}
          if (!cand.length) {
            try {
              const url2 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?search=${encodeURIComponent(u)}&page=1&limit=20`);
              const r2 = await MB.Extension.davRequest({ method:'GET', url:url2, headers:hJson, username: bk.username||'', password: bk.password||'' });
              if (r2?.ok) { cand.push(...tryParseList(r2.bodyText, 'search')); }
            } catch {}
          }
          const target = cand.find(x => norm(x.url) === norm(u)) || null;
          return target;
        };

        try {
          for (const gg of (app.data.groups||[])) {
            for (const ll of (gg.links||[])) {
              if (ll?.ncBookmarks?.id) continue;
              if (!ll?.url) continue;
              try {
                const remote = await fetchByUrl(ll.url);
                if (remote && remote.id) {
                  const rUpdated = parseNcTs(remote.lastmodified || remote.lastModified || remote.updated || remote.edited || remote.lastUpdate || remote.mtime || remote.modTime);
                  const rTags = Array.isArray(remote.tags)? remote.tags : [];
                  const rPayload = { text: (remote.title||remote.url||''), url: (remote.url||''), keywords: rTags.join(', '), infoHtml: (remote.description||'') };
                  let rSig = '';
                  try { rSig = btoa(unescape(encodeURIComponent(JSON.stringify(rPayload)))); } catch { rSig = JSON.stringify(rPayload); }
                  const nb = Object.assign({}, ll.ncBookmarks||{}, { id: remote.id, folderId: (Array.isArray(remote.folders) && remote.folders[0]) ? remote.folders[0] : (gg.ncBookmarks?.folderId||0), remoteUpdatedAt: rUpdated||0, remoteSig: rSig });
                  // Keep local lastHash/localUpdatedAt as-is (we're only attaching ID here)
                  app.$set(ll, 'ncBookmarks', nb);
                  debugLog('log', '[NC SYNC] Resolved remote id by URL', { url: ll.url, id: remote.id, folderId: nb.folderId });
                }
              } catch {}
            }
          }
        } catch {}

        // 2.5) Remote-first reconcile per link (independent of folder hashes)
        try {
          const allLocal = [];
          for (const gg of (app.data.groups||[])) {
            for (const ll of (gg.links||[])) {
              if (ll?.ncBookmarks?.id) allLocal.push({ group: gg, link: ll });
            }
          }
          for (const entry of allLocal) {
            const ll = entry.link; const gg = entry.group;
            try {
              const remoteObj = await fetchBookmark(ll.ncBookmarks.id);
              if (!remoteObj) continue;
              const rUpdated = parseNcTs(remoteObj.lastmodified || remoteObj.lastModified || remoteObj.updated || remoteObj.edited || remoteObj.lastUpdate || remoteObj.mtime || remoteObj.modTime);
              const knownRemote = parseNcTs(ll.ncBookmarks?.remoteUpdatedAt||0);
              const localUpdatedAt = parseNcTs(ll.ncBookmarks?.localUpdatedAt || 0);
              const rTags = Array.isArray(remoteObj.tags)? remoteObj.tags : [];
              const rPayload = { text: (remoteObj.title||remoteObj.url||''), url: (remoteObj.url||''), keywords: rTags.join(', '), infoHtml: (remoteObj.description||'') };
              let rSig = '';
              try { rSig = btoa(unescape(encodeURIComponent(JSON.stringify(rPayload)))); } catch { rSig = JSON.stringify(rPayload); }
              const storedRemoteSig = ll.ncBookmarks?.remoteSig || '';
              const remoteChanged = (rSig !== storedRemoteSig) || (rUpdated && rUpdated > knownRemote);
              const lastHash = ll.ncBookmarks?.lastHash || '';
              const nextHash = (function(){ try { return btoa(unescape(encodeURIComponent(JSON.stringify({ text: ll.text||'', url: ll.url||'', keywords: ll.keywords||'', infoHtml: ll.infoHtml||'' })))); } catch { return JSON.stringify({ text: ll.text||'', url: ll.url||'', keywords: ll.keywords||'', infoHtml: ll.infoHtml||'' }); } })();
              const localChanged = (!lastHash || lastHash !== nextHash);
              try {
                if (Number(ll.ncBookmarks.id) === TRACE_NC_ID) { traceFlags.reconcile = true; debugLog('log', '[NC-TRACE 2073] Reconcile entry', {
                  group: gg.name,
                  remoteObj: MB.Utils.safeClone(remoteObj),
                  rUpdated, knownRemote, localUpdatedAt, storedRemoteSig, rSig,
                  lastHash, nextHash, localChanged, remoteChanged
                }); }
              } catch {}
              debugLog('log', '[NC SYNC] Reconcile preflight', { id: ll.ncBookmarks.id, rUpdated, knownRemote, localUpdatedAt, remoteChanged, localChanged });
              if (remoteChanged && (!localChanged || rUpdated === 0 || (rUpdated && rUpdated >= localUpdatedAt))) {
                // Apply remote to local
                ll.url = rPayload.url;
                ll.text = rPayload.text || rPayload.url;
                ll.keywords = rPayload.keywords;
                ll.infoHtml = rPayload.infoHtml;
                ll.deleted = false;
                ll.ncBookmarks.remoteUpdatedAt = rUpdated || Date.now();
                ll.ncBookmarks.lastHash = rSig;
                ll.ncBookmarks.remoteSig = rSig;
                ll.ncBookmarks.localUpdatedAt = 0;
                // Optional: respect remote folder move (first folder if provided)
                const rFolders = Array.isArray(remoteObj.folders) ? remoteObj.folders : [];
                if (rFolders.length) {
                  const targetFolderId = rFolders[0];
                  if (targetFolderId && targetFolderId !== ll.ncBookmarks.folderId) {
                    const targetGroup = (app.data.groups||[]).find(x=> x.ncBookmarks && x.ncBookmarks.folderId === targetFolderId);
                    if (targetGroup && targetGroup !== gg) {
                      try { const idx = (gg.links||[]).indexOf(ll); if (idx>=0) gg.links.splice(idx,1); } catch {}
                      if (!targetGroup.links) app.$set(targetGroup, 'links', []);
                      targetGroup.links.push(ll);
                      ll.ncBookmarks.folderId = targetFolderId;
                    }
                  }
                }
                debugLog('log', '[NC SYNC] Reconcile applied remote', { id: ll.ncBookmarks.id });
              }
            } catch {}
          }
        } catch {}

        // 3) Push local changes (best-effort)
        try {
          const totalLinks = (app.data.groups||[]).reduce((s,g)=> s + ((g.links||[]).length), 0);
          debugLog('log', '[NC SYNC] Begin push phase', { groups: (app.data.groups||[]).length, totalLinks });
          if (app && app.syncInProgress) { app.syncProgressText = totalLinks ? `Pushing updates (0/${totalLinks})…` : 'Finalizing…'; app.syncProgress = Math.max(app.syncProgress, 70); }
        } catch {}

        // 3.1) Process pending deletions (tombstones) queued from local deletes
        try {
          const pending = Array.isArray(app.data.pendingNcDeletes) ? [...app.data.pendingNcDeletes] : [];
          for (const pd of pending) {
            if (!pd?.id) continue;
            const delUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(pd.id)}`);
            let delRes = null; try { delRes = await MB.Extension.davRequest({ method:'DELETE', url: delUrl, headers:hJson, username: bk.username||'', password: bk.password||'' }); } catch { delRes = { ok:false, status:0 }; }
            // Accept 2xx and 404 as success (already gone)
            if (delRes?.ok || delRes?.status === 404) {
              try {
                app.data.pendingNcDeletes = (app.data.pendingNcDeletes||[]).filter(x => x !== pd);
                debugLog('log', '[NC SYNC] Remote delete OK', { id: pd.id, status: delRes?.status||200 });
              } catch {}
            } else {
              debugLog('warn', '[NC SYNC] Remote delete failed (will retry later)', { id: pd.id, status: delRes?.status });
            }
          }
          app.saveData();
        } catch {}
        // Hash only content fields (exclude folderId to detect moves separately)
        const computeHash = (l) => {
          const payload = { text:l.text||'', url:l.url||'', keywords:l.keywords||'', infoHtml:l.infoHtml||'' };
          try { return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))); } catch { return JSON.stringify(payload); }
        };
        let pushedNew=0, pushedUpd=0, pushedDel=0, skipped=0;
        let __pushed=0; const __pushTotal = (app.data.groups||[]).reduce((s,g)=> s + ((g.links||[]).length), 0) || 1;
        for (const g of (app.data.groups||[])) {
          // Ensure folder mapping for this group before pushing links
          let fId = g.ncBookmarks?.folderId;
          if (!fId) {
            try {
              const match = byTitle[(g.name||'').toLowerCase()];
              if (match && match.id) {
                app.$set(g, 'ncBookmarks', Object.assign({}, g.ncBookmarks||{}, { folderId: match.id }));
                fId = match.id;
                debugLog('log', '[NC SYNC] Mapped group to existing NC folder', { group: g.name, folderId: fId });
              } else if (bk.autoCreateFolders) {
                const cUrl = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
                const payload = { title: g.name||'Bookmarks' };
                if (rootId && rootId > 0) payload.parent_folder = rootId;
                debugLog('log', '[NC SYNC] Creating folder (push ensure)', { title: payload.title, parent_folder: payload.parent_folder||null });
                const cRes = await MB.Extension.davRequest({ method:'POST', url:cUrl, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(payload), username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
                if (cRes?.ok) {
                  let cf=null; try{ cf=JSON.parse(cRes.bodyText||'null'); }catch{}; cf = unwrapNc(cf); const id=cf?.id;
                  app.$set(g,'ncBookmarks',Object.assign({},g.ncBookmarks||{}, { folderId:id }));
                  if (id!==undefined) { byId[id]=cf; byTitle[(cf.title||'').toLowerCase()]=cf; fId = id; }
                  debugLog('log', '[NC SYNC] Created folder (push ensure) OK', { id: id, title: cf?.title, parent_folder: cf?.parent_folder, raw: (cRes.bodyText||'').slice(0,200) });
                } else {
                  debugLog('error', '[NC SYNC] Create folder (push ensure) FAILED', { status:cRes?.status, bodyHead:(cRes?.bodyText||'').slice(0,300) });
                }
              }
            } catch {}
          }
          for (const l of (g.links||[])) {
            try { debugLog('log', '[NC SYNC][LOCAL] Push candidate', { group: g.name, link: MB.Utils.safeClone(l) }); } catch {}
            try { if (app && app.syncInProgress) { __pushed++; app.syncProgressText = `Pushing updates (${__pushed}/${__pushTotal})…`; app.syncProgress = 70 + Math.round((__pushed/__pushTotal)*25); } } catch {}
            const pulledInSession = l.ncBookmarks?.justPulled === sessionId;
            // DELETE
            if (l.deleted && l.ncBookmarks?.id) {
              const dUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(l.ncBookmarks.id)}`);
              const dRes = await MB.Extension.davRequest({ method:'DELETE', url:dUrl, headers:hJson, username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
              if (dRes?.ok) { pushedDel++; l.ncBookmarks=null; } else skipped++;
              continue;
            }
            // CREATE
            if (!l.deleted && !l.ncBookmarks?.id && fId) {
              const tags = (Array.isArray(l.keywords)?l.keywords:(l.keywords||'')).toString().split(',').map(s=>s.trim()).filter(Boolean);
              const payload = { url:l.url||'', title:l.text||l.url||'', description:l.infoHtml||'', tags, folders: [fId] };
              const cUrl = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/bookmark');
              try { debugLog('log', '[NC SYNC] Creating bookmark', { group: g.name, folderId: fId, payload: MB.Utils.safeClone(payload) }); } catch {}
              // Skip create if URL is empty or clearly invalid for NC
              if (!payload.url || !/^https?:\/\//i.test(payload.url)) {
                try { debugLog('warn', '[NC SYNC] Skip create: invalid or empty URL', { group: g.name, url: payload.url, title: payload.title }); } catch {}
                skipped++;
                continue;
              }
              const cRes = await MB.Extension.davRequest({ method:'POST', url:cUrl, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(payload), username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
              if (cRes?.ok) {
                let created=null; try { created=JSON.parse(cRes.bodyText||'null'); } catch {}
                created = unwrapNc(created);
                const nid = created?.id; app.$set(l, 'ncBookmarks', { id:nid, folderId:fId, lastSyncedAt:Date.now(), lastHash:computeHash(l) }); pushedNew++;
                try { debugLog('log', '[NC SYNC] Created bookmark OK', { id: nid, folderId: fId }); } catch {}
              } else { skipped++; try { debugLog('error', '[NC SYNC] Create bookmark FAILED', { status:cRes?.status, bodyHead:(cRes?.bodyText||'').slice(0,300) }); } catch {} }
              continue;
            }
            // No ID and no folder mapping: cannot create
            if (!l.deleted && !l.ncBookmarks?.id && !fId) {
              try { debugLog('warn', '[NC SYNC] Skip create: no folder mapping for group', { group: g.name, linkUuid: l.uuid, linkText: l.text }); } catch {}
            }
            // UPDATE
            if (!l.deleted && l.ncBookmarks?.id) {
              const nextHash = computeHash(l), lastHash = l.ncBookmarks?.lastHash||'';
              const localUpdatedAtVal = parseNcTs(l.ncBookmarks?.localUpdatedAt || 0);
              const knownRemoteVal = parseNcTs(l.ncBookmarks?.remoteUpdatedAt || 0);
              const localChangedByHash = (!lastHash || lastHash !== nextHash);
              let localChanged = localChangedByHash || (localUpdatedAtVal && (!knownRemoteVal || localUpdatedAtVal > knownRemoteVal));
              if (localChangedByHash && !l.ncBookmarks.localUpdatedAt) { l.ncBookmarks.localUpdatedAt = Date.now(); }
              const moveNeeded = !!(fId && l.ncBookmarks?.folderId !== fId);
              if (!moveNeeded && lastHash && lastHash === nextHash) {
                // Even if no local change, preflight remote to detect newer server edits
                try {
                  const remoteObj0 = await fetchBookmark(l.ncBookmarks.id);
                  if (remoteObj0) {
                    const rUpdated0 = parseNcTs(remoteObj0.lastmodified || remoteObj0.lastModified || remoteObj0.updated || remoteObj0.edited || remoteObj0.lastUpdate || remoteObj0.mtime || remoteObj0.modTime);
                    const knownRemote0 = parseNcTs(l.ncBookmarks?.remoteUpdatedAt||0);
                    const rTags0 = Array.isArray(remoteObj0.tags)? remoteObj0.tags : [];
                    const rPayload0 = { text: (remoteObj0.title||remoteObj0.url||''), url: (remoteObj0.url||''), keywords: rTags0.join(', '), infoHtml: (remoteObj0.description||'') };
                    let rSig0 = '';
                    try { rSig0 = btoa(unescape(encodeURIComponent(JSON.stringify(rPayload0)))); } catch { rSig0 = JSON.stringify(rPayload0); }
                    const storedRemoteSig0 = l.ncBookmarks?.remoteSig || '';
                    const remoteChanged0 = (rSig0 !== storedRemoteSig0) || (rUpdated0 && rUpdated0 > knownRemote0);
                    const localUpdatedAt0 = parseNcTs(l.ncBookmarks?.localUpdatedAt || 0);
                    try { if (Number(l.ncBookmarks.id) === TRACE_NC_ID) { traceFlags.pushPre0 = true; debugLog('log', '[NC-TRACE 2073] Push preflight (no-local-change)', { rUpdated0, knownRemote0, localUpdatedAt0, remoteChanged0, storedRemoteSig0, rSig0, remoteObj0: MB.Utils.safeClone(remoteObj0) }); } } catch {}
                    debugLog('log', '[NC SYNC] Preflight (no-local-change) fetched remote', { id: l.ncBookmarks?.id, rUpdated: rUpdated0, knownRemote: knownRemote0, localUpdatedAt: localUpdatedAt0, remoteChanged: remoteChanged0, storedRemoteSig: storedRemoteSig0, rSig: rSig0 });
                    if (remoteChanged0 && (rUpdated0 === 0 || (rUpdated0 && rUpdated0 >= localUpdatedAt0))) {
                      // Remote newer: adopt remote locally, skip push
                      try {
                        l.url = rPayload0.url;
                        l.text = rPayload0.text || rPayload0.url;
                        l.keywords = rPayload0.keywords;
                        l.infoHtml = rPayload0.infoHtml;
                        l.deleted = false;
                        l.ncBookmarks.remoteUpdatedAt = rUpdated0 || Date.now();
                        l.ncBookmarks.lastHash = rSig0;
                        l.ncBookmarks.remoteSig = rSig0;
                        l.ncBookmarks.localUpdatedAt = 0;
                      } catch {}
                      debugLog('log', '[NC SYNC] Remote wins (no-local-change), skip push', { id: l.ncBookmarks?.id });
                      skipped++; continue;
                    }
                  } else {
                    // Remote record missing (likely deleted) -> CREATE fallback even without local content change
                    try { debugLog('warn', '[NC SYNC] Remote record missing for id, creating anew', { id: l.ncBookmarks?.id, group: g.name, folderId: fId }); } catch {}
                    const tags2 = (Array.isArray(l.keywords)?l.keywords:(l.keywords||'')).toString().split(',').map(s=>s.trim()).filter(Boolean);
                    const createPayload = { url:l.url||'', title:l.text||l.url||'', description:l.infoHtml||'', tags: tags2, folders: [fId] };
                    if (!createPayload.url || !/^https?:\/\//i.test(createPayload.url)) { skipped++; try { debugLog('warn', '[NC SYNC] Fallback CREATE (no-change) skipped: invalid URL', { url:createPayload.url }); } catch {} }
                    else {
                      const cUrl2 = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/bookmark');
                      const cRes2 = await MB.Extension.davRequest({ method:'POST', url:cUrl2, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(createPayload), username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
                      if (cRes2?.ok) {
                        let created2=null; try { created2=JSON.parse(cRes2.bodyText||'null'); } catch {}
                        created2 = unwrapNc(created2);
                        const nid2 = created2?.id; app.$set(l, 'ncBookmarks', { id:nid2, folderId:fId, lastSyncedAt:Date.now(), lastHash:computeHash(l) }); pushedNew++;
                        try { debugLog('log', '[NC SYNC] Fallback CREATE (no-change) OK', { id: nid2, folderId: fId }); } catch {}
                        continue;
                      } else {
                        skipped++;
                        try { debugLog('error', '[NC SYNC] Fallback CREATE (no-change) FAILED', { status:cRes2?.status, bodyHead:(cRes2?.bodyText||'').slice(0,300) }); } catch {}
                      }
                    }
                  }
                } catch {}
                debugLog('log', '[NC SYNC] Skip update (no local change, no move)', { id: l.ncBookmarks?.id, groupFolder: fId });
                skipped++; continue;
              }
              // If this item was just pulled in this session, avoid overwriting remote content; allow pure MOVE
              let allowContentUpdate = !pulledInSession && (!lastHash || lastHash !== nextHash);
              // Preflight: ALWAYS check remote to avoid overwriting newer server data
              {
                const remoteObj = await fetchBookmark(l.ncBookmarks.id);
                if (remoteObj) {
                  try { debugLog('log', '[NC SYNC][REMOTE] Preflight item', { id: l.ncBookmarks?.id, remote: MB.Utils.safeClone(remoteObj) }); } catch {}
                  const rUpdated = parseNcTs(remoteObj.lastmodified || remoteObj.lastModified || remoteObj.updated || remoteObj.edited || remoteObj.lastUpdate || remoteObj.mtime || remoteObj.modTime);
                  const knownRemote = parseNcTs(l.ncBookmarks?.remoteUpdatedAt||0);
                  // Compute remote content signature
                  const rTags = Array.isArray(remoteObj.tags)? remoteObj.tags : [];
                  const rPayload = { text: (remoteObj.title||remoteObj.url||''), url: (remoteObj.url||''), keywords: rTags.join(', '), infoHtml: (remoteObj.description||'') };
                  let rSig = '';
                  try { rSig = btoa(unescape(encodeURIComponent(JSON.stringify(rPayload)))); } catch { rSig = JSON.stringify(rPayload); }
                  const storedRemoteSig = l.ncBookmarks?.remoteSig || '';
                  const remoteChanged = (rSig !== storedRemoteSig) || (rUpdated && rUpdated > knownRemote);
                  const localUpdatedAt = parseNcTs(l.ncBookmarks?.localUpdatedAt || 0);
                  try { if (Number(l.ncBookmarks.id) === TRACE_NC_ID) { traceFlags.pushPre = true; debugLog('log', '[NC-TRACE 2073] Push preflight (with-local-change)', { rUpdated, knownRemote, localUpdatedAt, remoteChanged, storedRemoteSig, rSig, nextHash, lastHash, moveNeeded, allowContentUpdate, remoteObj: MB.Utils.safeClone(remoteObj) }); } } catch {}
                  debugLog('log', '[NC SYNC] Preflight fetched remote', { id: l.ncBookmarks?.id, rUpdated, knownRemote, localUpdatedAt, remoteChanged, localChanged, storedRemoteSig, rSig });
                  if (remoteChanged && (!localChanged || rUpdated === 0 || (rUpdated && rUpdated >= localUpdatedAt))) {
                    // Remote wins: adopt remote content locally, update hashes/sigs, and skip pushing content
                    try {
                      l.url = rPayload.url;
                      l.text = rPayload.text || rPayload.url;
                      l.keywords = rPayload.keywords;
                      l.infoHtml = rPayload.infoHtml;
                      l.deleted = false;
                      l.ncBookmarks.remoteUpdatedAt = rUpdated || Date.now();
                      l.ncBookmarks.lastHash = rSig; // sync local content hash to remote
                      l.ncBookmarks.remoteSig = rSig;
                      l.ncBookmarks.localUpdatedAt = 0;
                      // Remote folder move handling
                      const rFolders = Array.isArray(remoteObj.folders) ? remoteObj.folders : [];
                      if (rFolders.length) {
                        const targetFolderId = rFolders[0];
                        if (targetFolderId && targetFolderId !== l.ncBookmarks.folderId) {
                          const targetGroup = (app.data.groups||[]).find(x=> x.ncBookmarks && x.ncBookmarks.folderId === targetFolderId);
                          if (targetGroup && targetGroup !== g) {
                            try { const idx = (g.links||[]).indexOf(l); if (idx>=0) g.links.splice(idx,1); } catch {}
                            if (!targetGroup.links) app.$set(targetGroup, 'links', []);
                            targetGroup.links.push(l);
                            l.ncBookmarks.folderId = targetFolderId;
                          }
                        }
                      }
                    } catch {}
                    // Allow a pure MOVE even when remote changed (folders-only patch)
                    if (moveNeeded) {
                      const p = { folders: [fId] };
                      const uUrl2 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(l.ncBookmarks.id)}`);
                      await MB.Extension.davRequest({ method:'PATCH', url:uUrl2, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(p) }).catch(()=>({ok:false}));
                      l.ncBookmarks.folderId = fId;
                    }
                    debugLog('log', '[NC SYNC] Remote wins, skip local content push', { id: l.ncBookmarks?.id });
                    skipped++;
                    continue;
                  }
                  // else: only local changed → continue to push content
                  // Extra safety: even if remoteChanged=false (e.g. equal signature), never push content if remote timestamp is newer
                  if (rUpdated && rUpdated > localUpdatedAt) {
                    debugLog('log', '[NC SYNC] Remote newer (timestamp), suppressing content push', { id: l.ncBookmarks?.id, rUpdated, localUpdatedAt });
                    allowContentUpdate = false;
                    if (!moveNeeded) { skipped++; continue; }
                    // fall through to allow a pure MOVE-only PATCH below
                  }
                }
              }
              const tags = (Array.isArray(l.keywords)?l.keywords:(l.keywords||'')).toString().split(',').map(s=>s.trim()).filter(Boolean);
              const payload = {};
              if (allowContentUpdate) {
                Object.assign(payload, { url:l.url||'', title:l.text||l.url||'', description:l.infoHtml||'', tags });
              }
              if (moveNeeded) { payload.folders = [fId]; }
              debugLog('log', '[NC SYNC] Pushing update', { id: l.ncBookmarks?.id, contentUpdate: !!allowContentUpdate, move: moveNeeded, payloadKeys: Object.keys(payload) });
              const uUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(l.ncBookmarks.id)}`);
              const uRes = await MB.Extension.davRequest({ method:'PATCH', url:uUrl, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(payload), username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
              if (uRes?.ok) {
                // Fetch latest remote to refresh timestamps/signature
                let after=null; try { after = await fetchBookmark(l.ncBookmarks.id); } catch {}
                let rUpdated2 = 0; let rSig2 = nextHash;
                if (after) {
                  rUpdated2 = parseNcTs(after.lastmodified || after.lastModified || after.updated || after.edited || after.lastUpdate || after.mtime || after.modTime);
                  const aTags = Array.isArray(after.tags)? after.tags : [];
                  const aPayload = { text: (after.title||after.url||''), url: (after.url||''), keywords: aTags.join(', '), infoHtml: (after.description||'') };
                  try { rSig2 = btoa(unescape(encodeURIComponent(JSON.stringify(aPayload)))); } catch { rSig2 = JSON.stringify(aPayload); }
                }
                l.ncBookmarks.lastHash = nextHash; l.ncBookmarks.lastSyncedAt = Date.now();
                l.ncBookmarks.remoteSig = rSig2; // remote now matches local
                l.ncBookmarks.remoteUpdatedAt = rUpdated2 || Date.now();
                l.ncBookmarks.localUpdatedAt = 0;
                if (moveNeeded) l.ncBookmarks.folderId = fId; pushedUpd++;
                debugLog('log', '[NC SYNC] Push OK', { id: l.ncBookmarks?.id, remoteUpdatedAt: l.ncBookmarks.remoteUpdatedAt, moveApplied: moveNeeded });
              } else {
                // If the record no longer exists remotely (e.g., 404), fall back to CREATE
                let status = uRes?.status||0; let bodyHead=(uRes?.bodyText||'').slice(0,300);
                try { debugLog('warn', '[NC SYNC] Update FAILED, will try CREATE fallback', { id: l.ncBookmarks?.id, status, bodyHead }); } catch {}
                const tags2 = (Array.isArray(l.keywords)?l.keywords:(l.keywords||'')).toString().split(',').map(s=>s.trim()).filter(Boolean);
                const createPayload = { url:l.url||'', title:l.text||l.url||'', description:l.infoHtml||'', tags: tags2, folders: [fId] };
                // Skip create if URL invalid
                if (!createPayload.url || !/^https?:\/\//i.test(createPayload.url)) { skipped++; try { debugLog('warn', '[NC SYNC] Fallback CREATE skipped: invalid URL', { url:createPayload.url }); } catch {} }
                else {
                  const cUrl2 = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/bookmark');
                  const cRes2 = await MB.Extension.davRequest({ method:'POST', url:cUrl2, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(createPayload), username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
                    if (cRes2?.ok) {
                    let created2=null; try { created2=JSON.parse(cRes2.bodyText||'null'); } catch {}
                    created2 = unwrapNc(created2);
                    const nid2 = created2?.id; app.$set(l, 'ncBookmarks', { id:nid2, folderId:fId, lastSyncedAt:Date.now(), lastHash:computeHash(l) }); pushedNew++;
                    try { debugLog('log', '[NC SYNC] Fallback CREATE OK', { id: nid2, folderId: fId }); } catch {}
                  } else {
                    skipped++;
                    try { debugLog('error', '[NC SYNC] Fallback CREATE FAILED', { status:cRes2?.status, bodyHead:(cRes2?.bodyText||'').slice(0,300) }); } catch {}
                  }
                }
              }
            }
          }
        }

        try {
          if (TRACE_NC_ID>0) {
            const haveLocal = (()=>{ try { for (const gg of (app.data.groups||[])) { for (const ll of (gg.links||[])) { if (Number(ll?.ncBookmarks?.id)===TRACE_NC_ID) return true; } } } catch {} return false; })();
            debugLog('log', '[NC-TRACE] Summary', { traceId: TRACE_NC_ID, flags: MB.Utils.safeClone(traceFlags), haveLocal });
          }
        } catch {}
        app.saveData();
        showAppToast(`NC: +${createdLinks} pull, ~${updatedLinks} pull, -${removedLinks} removed, groups +${createdGroups}, folders +${createdFolders}/renamed ${renamedFolders}; push +${pushedNew}, ~${pushedUpd}, -${pushedDel}`, 'success');
        try { app.syncProgress = 100; app.syncProgressText = 'Done'; setTimeout(()=>{ app.syncInProgress=false; }, 800); } catch {}
      }
    });

    // WebDAV/Cal/CardDAV discovery helpers
    MB.CardDAV.getCurrentUserPrincipal = async function(baseUrl, authHeader) {
      // Try PROPFIND Depth:0 for current-user-principal
      const body = `<?xml version="1.0" encoding="utf-8"?>
<D:propfind xmlns:D="DAV:">
  <D:prop>
    <D:current-user-principal/>
  </D:prop>
</D:propfind>`;
      const res = await MB.CardDAV.propfind(baseUrl, 0, body, authHeader);
      if (!res.ok) return null;
      const doc = MB.CardDAV.parseXml(res.bodyText);
      const cup = doc.getElementsByTagNameNS('DAV:','current-user-principal')[0];
      const href = cup?.getElementsByTagNameNS('DAV:','href')[0]?.textContent || '';
      return href || null;
    };

    MB.CardDAV.getAddressbookHome = async function(principalUrl, authHeader) {
      const body = `<?xml version="1.0" encoding="utf-8"?>
<D:propfind xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:carddav">
  <D:prop>
    <C:addressbook-home-set/>
  </D:prop>
</D:propfind>`;
      const res = await MB.CardDAV.propfind(principalUrl, 0, body, authHeader);
      if (!res.ok) return null;
      const doc = MB.CardDAV.parseXml(res.bodyText);
      const ahs = doc.getElementsByTagNameNS('urn:ietf:params:xml:ns:carddav','addressbook-home-set')[0];
      const href = ahs?.getElementsByTagNameNS('DAV:','href')[0]?.textContent || '';
      return href || null;
    };

    MB.CardDAV.listAddressbooks = async function(homeSetUrl, authHeader) {
      const body = `<?xml version="1.0" encoding="utf-8"?>
<D:propfind xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:carddav">
  <D:prop>
    <D:displayname/>
    <D:resourcetype/>
  </D:prop>
</D:propfind>`;
      const res = await MB.CardDAV.propfind(homeSetUrl, 1, body, authHeader);
      if (!res.ok) return [];
      const doc = MB.CardDAV.parseXml(res.bodyText);
      const responses = Array.from(doc.getElementsByTagNameNS('*','response'));
      const out = [];
      for (const r of responses) {
        const href = (r.getElementsByTagNameNS('DAV:','href')[0]?.textContent || '').trim();
        const displayname = (r.getElementsByTagNameNS('DAV:','displayname')[0]?.textContent || '').trim();
        const rt = r.getElementsByTagNameNS('DAV:','resourcetype')[0];
        const isAB = !!(rt && (rt.getElementsByTagNameNS('urn:ietf:params:xml:ns:carddav','addressbook')[0]));
        if (isAB) out.push({ href, displayname });
      }
      return out;
    };

    MB.CardDAV.mkcolAddressbook = async function(homeSetUrl, name, authHeader) {
      let url = MB.CardDAV.joinUrl(homeSetUrl, name.replace(/\s+/g,'-').toLowerCase());
      if (!url.endsWith('/')) url = url + '/';
      const body = `<?xml version="1.0" encoding="UTF-8"?>
<D:mkcol xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:carddav">
  <D:set>
    <D:prop>
      <D:resourcetype><D:collection/><C:addressbook/></D:resourcetype>
      <D:displayname>${name}</D:displayname>
    </D:prop>
  </D:set>
</D:mkcol>`;
      const headers = { 'Content-Type': 'application/xml; charset=utf-8' };
      if (authHeader) headers['Authorization'] = authHeader;
      const res = await MB.CardDAV.request({ method: 'MKCOL', url, headers, body });
      if (res.ok || res.status === 201 || res.status === 200) return { href: url };
      throw new Error(`MKCOL failed: ${res.status} ${res.statusText}`);
    };

    MB.CardDAV.syncCollection = async function(addressbookUrl, syncToken, authHeader) {
      const include = `<D:prop><D:getetag/><C:address-data/></D:prop>`;
      const tokenPart = syncToken ? `<D:sync-token>${syncToken}</D:sync-token>` : '';
      const body = `<?xml version="1.0" encoding="utf-8"?>
<D:sync-collection xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:carddav">
  <D:sync-level>1</D:sync-level>
  ${tokenPart}
  ${include}
</D:sync-collection>`;
      const res = await MB.CardDAV.report(addressbookUrl, body, authHeader, 1);
      if (!res.ok) throw new Error(`sync-collection failed: ${res.status} ${res.statusText}`);
      const doc = MB.CardDAV.parseXml(res.bodyText);
      const responses = Array.from(doc.getElementsByTagNameNS('DAV:','response'));
      const nextToken = doc.getElementsByTagNameNS('DAV:','sync-token')[0]?.textContent || '';
      const changes = [];
      const deletions = [];
      for (const r of responses) {
        const href = (r.getElementsByTagNameNS('DAV:','href')[0]?.textContent || '').trim();
        const status = (r.getElementsByTagNameNS('DAV:','status')[0]?.textContent || '').trim();
        const propstat = r.getElementsByTagNameNS('DAV:','propstat');
        let etag = '';
        let addressData = '';
        for (const ps of Array.from(propstat)) {
          const st = ps.getElementsByTagNameNS('DAV:','status')[0]?.textContent || '';
          const isOk = st.includes('200');
          if (isOk) {
            etag = ps.getElementsByTagNameNS('DAV:','getetag')[0]?.textContent || etag;
            const ad = ps.getElementsByTagNameNS('urn:ietf:params:xml:ns:carddav','address-data')[0]?.textContent || '';
            if (ad) addressData = ad;
          }
        }
        if (status.includes('404') || (!etag && !addressData)) {
          deletions.push({ href });
        } else {
          changes.push({ href, etag, vcard: addressData });
        }
      }
      return { changes, deletions, nextToken };
    };

    MB.CardDAV.parseXml = function(xmlText) {
      const parser = new DOMParser();
      return parser.parseFromString(xmlText || '', 'application/xml');
    };

    MB.CardDAV.addressbookQueryAll = async function(addressbookUrl, authHeader) {
      const body = `<?xml version="1.0" encoding="utf-8"?>
<C:addressbook-query xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:carddav">
  <D:prop>
    <D:getetag/>
    <C:address-data/>
  </D:prop>
</C:addressbook-query>`;
      const res = await MB.CardDAV.report(addressbookUrl, body, authHeader, 1);
      if (!res.ok) throw new Error(`addressbook-query failed: ${res.status} ${res.statusText}`);
      const doc = MB.CardDAV.parseXml(res.bodyText);
      const responses = Array.from(doc.getElementsByTagNameNS('*','response'));
      return responses.map(r => {
        const href = (r.getElementsByTagNameNS('*','href')[0]?.textContent || '').trim();
        const etag = (r.getElementsByTagNameNS('*','getetag')[0]?.textContent || '').trim();
        const ad = r.getElementsByTagNameNS('urn:ietf:params:xml:ns:carddav','address-data')[0]?.textContent || '';
        return { href, etag, vcard: ad };
      }).filter(x => x.vcard);
    };

    MB.CardDAV.unfoldVCard = function(text) {
      const lines = (text || '').replace(/\r\n/g, '\n').split('\n');
      const out = [];
      for (const line of lines) {
        if (line.startsWith(' ') || line.startsWith('\t')) {
          if (out.length) out[out.length - 1] += line.slice(1);
        } else {
          out.push(line);
        }
      }
      return out;
    };

    MB.CardDAV.parseVCard = function(vcardText) {
      const lines = MB.CardDAV.unfoldVCard(vcardText);
      const obj = { raw: vcardText };
      for (const raw of lines) {
        if (!raw || raw.startsWith('BEGIN') || raw.startsWith('END')) continue;
        const idx = raw.indexOf(':');
        if (idx < 0) continue;
        const namePart = raw.slice(0, idx);
        const value = raw.slice(idx + 1);
        const name = namePart.split(';')[0]; // ignore params
        const key = name.includes('.') ? name.split('.').pop() : name; // strip group prefix
        const up = key.toUpperCase();
        switch (up) {
          case 'UID': obj.uid = value.trim(); break;
          case 'FN': obj.fn = value.trim(); break;
          case 'URL': obj.url = value.trim(); break;
          case 'CATEGORIES': obj.categories = value.split(',').map(s => s.replace(/\\,/g, ',').trim()).filter(Boolean); break;
          case 'NOTE': obj.note = value; break;
          default:
            if (up === 'X-MB-KEYWORDS') obj.mbKeywords = value;
            else if (up === 'X-MB-META') { try { obj.mbMeta = JSON.parse(value); } catch { obj.mbMeta = null; }
            }
        }
      }
      return obj;
    };
    // Generic DAV request wrapper via browser extension (only when available)
    MB.Extension.davRequest = async function(request) {
      if (!MB.Extension.isAvailable() || !window.MyBookmarksExtension || typeof window.MyBookmarksExtension.davRequest !== 'function') {
        throw new Error('Extension DAV API not available');
      }
      try {
        const res = await window.MyBookmarksExtension.davRequest(request);
        return res;
      } catch (e) {
        debugLog('error', 'Extension davRequest failed:', e);
        throw e;
      }
    };

    class DropManager {
      constructor(appInstance) {
        this.app = appInstance; // Referenz zur Vue-Instanz
        this.draggedState = null;
        this.oldArr = null;
        this.oldItem = null;
        this.draggedElement = null; // Referenz auf das gezogene DOM-Element
        this.dragStartTime = null; // Track when drag started to prevent premature dragend
        this.dragTimeout = null; // Timeout to prevent stuck drag states
        this.delayedResetTimeout = null; // Timeout for delayed resets that can be cancelled
        this.activeDropZone = null; // Track active drop zone for highlighting
        this.dragImageEl = null; // Custom drag image element
        this.edgeDragAttempt = false; // Track Edge drag attempts
        this.edgeDragPending = false; // Track if Edge is waiting for real drag
        // No need for appElement anymore - using Vue reactive state
        debugLog('log', "DropManager initialized with Vue reactivity");
      }

      reset() {
        debugLog('log', "DropManager reset() called."); // DEBUG

        // Clear any existing timeout
        if (this.dragTimeout) {
          clearTimeout(this.dragTimeout);
          this.dragTimeout = null;
          debugLog('log', "Cleared drag timeout"); // DEBUG
        }

        // Clear any delayed reset timeout
        if (this.delayedResetTimeout) {
          clearTimeout(this.delayedResetTimeout);
          this.delayedResetTimeout = null;
          debugLog('log', "Cleared delayed reset timeout"); // DEBUG
        }

        // Reset reactive state for Vue
        this.app.dragState = null;
        debugLog('log', "Reset dragState to null"); // DEBUG
        if (this.app && this.app.clearExpandHoverTimers) {
          this.app.clearExpandHoverTimers();
        }
        // Reset all mouseover states
        if (this.app && this.app.resetAllMouseOverStates) {
          this.app.resetAllMouseOverStates();
        }

        // Stelle sicher, dass die 'grabbing'-Klasse vom Body entfernt wird
        document.body.classList.remove('grabbing');
        debugLog('log', "Removed grabbing class from body"); // DEBUG

        // Reset draggedElement reference without manipulating its classes
        if (this.draggedElement) {
          debugLog('log', "Reset dragged element reference:", this.draggedElement); // DEBUG
          this.draggedElement = null; // Referenz zurücksetzen
        }
        // Reset Edge-specific flags
        this.edgeDragAttempt = false;
        this.edgeDragPending = false;

        // Reset drop zone state
        if (this.activeDropZone) {
          this.activeDropZone.classList.remove('drag-over-active');
          this.activeDropZone = null;
        }

        // Remove custom drag image if any
        if (this.dragImageEl && this.dragImageEl.parentNode) {
          this.dragImageEl.parentNode.removeChild(this.dragImageEl);
        }
        this.dragImageEl = null;

        // Reset state variables
        this.draggedState = null;
        this.oldArr = null;
        this.oldItem = null;
        this.dragStartTime = null; // Reset drag start time

        debugLog('log', "DropManager state reset complete."); // DEBUG
      }

      isDragged(type) {
        return this.draggedState === type;
      }

      // --- Column Helpers ---
      isMostLeftColumn(columns, column) {
        if (!columns || columns.length === 0) return true;
        return column === Math.min(...columns);
      }

      getMostLeftColumn(columns) {
        if (!columns || columns.length === 0) return 0;
        return Math.min(...columns);
      }

      isMostRightColumn(columns, column) {
        if (!columns || columns.length === 0) return true;
        return column === Math.max(...columns);
      }

      getMostRightColumn(columns) {
        if (!columns || columns.length === 0) return 0;
        return Math.max(...columns);
      }

      // Get max index for a specific column within an array
      getMaxIndex(arr, column) {
        const itemsInColumn = arr.filter(item => item.column === column);
        return itemsInColumn.length > 0 ? Math.max(...itemsInColumn.map(item => item.index)) : -1;
      }

      // --- Drag Lifecycle ---
      startDrag(evt, sourceArray, item, type) {
        debugLog('log', "startDrag called - Type:", type, "Item:", item);
        
        // Edge browser detection
        const isEdge = /Edg/.test(navigator.userAgent);
        
        // Edge specific: Need special handling for immediate dragend
        if (isEdge) {
          debugLog('log', "Edge: Starting drag operation with special handling");
          // For Edge, we need to handle the immediate dragend differently
          // Mark this as an Edge drag attempt
          this.edgeDragAttempt = true;
        }
        
        // Stop propagation AFTER logging to ensure we see the call
        evt.stopPropagation();
        
        // For Edge, don't block second attempts based on time
        if (!isEdge && this.dragStartTime && (Date.now() - this.dragStartTime < 1000)) {
          debugLog('log', "Blocking new drag - previous drag still in progress");
          evt.preventDefault();
          return;
        }
        
        // For Edge with an active drag state from a cancelled attempt, allow the drag
        if (isEdge && this.draggedState && this.edgeDragAttempt) {
          debugLog('log', "Edge: Allowing second drag attempt with existing state");
        }

        // Record the time when drag starts
        this.dragStartTime = Date.now();

        // Clear any existing timeout
        if (this.dragTimeout) {
          clearTimeout(this.dragTimeout);
          this.dragTimeout = null;
        }

        // Clear any delayed reset timeout
        if (this.delayedResetTimeout) {
          clearTimeout(this.delayedResetTimeout);
          this.delayedResetTimeout = null;
        }

        // Clear any previous drag state to ensure clean start (only if it's old)
        if (this.draggedState) {
          debugLog('log', "Warning: Clearing previous drag state before starting new one");
          this.draggedState = null;
          this.oldArr = null;
          this.oldItem = null;
          this.app.dragState = null;
        }

        // Speichere das gezogene Element
        this.draggedElement = evt.target;
        debugLog('log', "startDrag - Type:", type, "Item UUID:", item.uuid, "Element:", this.draggedElement); // DEBUG

        this.draggedState = type;

        // Set reactive state for Vue
        this.app.dragState = type;
        debugLog('log', "Set dragState to:", type); // DEBUG

        // CRITICAL FOR EDGE: Set effectAllowed FIRST
        evt.dataTransfer.effectAllowed = 'move';
        
        // CRITICAL: ALWAYS set data, even dummy data - Edge/Chrome won't drag without it!
        // Use multiple formats for maximum compatibility
        const dragData = JSON.stringify({
          type: type,
          uuid: item.uuid || 'no-uuid',
          timestamp: Date.now()
        });
        
        try {
          // Set multiple data types for compatibility
          evt.dataTransfer.setData('text/plain', dragData);
          evt.dataTransfer.setData('text', dragData);
          evt.dataTransfer.setData('application/json', dragData);
        } catch (e) {
          debugLog('warn', "Failed to set some drag data formats:", e);
          // Ensure at least one format is set
          evt.dataTransfer.setData('text', 'dummy-drag-data');
        }
        
        evt.dataTransfer.dropEffect = 'move';

        // Provide a clearer drag image so the user sees the element being dragged
        try {
          const ghost = document.createElement('div');
          ghost.style.position = 'fixed';
          ghost.style.top = '-1000px';
          ghost.style.left = '-1000px';
          ghost.style.padding = '6px 10px';
          ghost.style.background = type === 'link' ? '#fff' : '#f7f7f7';
          ghost.style.border = '1px solid #ccc';
          ghost.style.borderRadius = '4px';
          ghost.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
          ghost.style.font = '14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif';
          ghost.style.pointerEvents = 'none';
          ghost.textContent = type === 'link' ? (item.text || 'Link') : (item.name || 'Group');
          document.body.appendChild(ghost);
          evt.dataTransfer.setDragImage(ghost, 10, 10);
          this.dragImageEl = ghost;
        } catch (e) {
          // setDragImage not supported: noop
        }

        this.oldArr = sourceArray;
        this.oldItem = item;

        // Only manipulate document.body for cursor styling
        document.body.classList.add('grabbing');

        // Do not auto-reset a running drag; rely on drop/dragend

        debugLog('log', "startDrag completed successfully");
      }

      handleDragEnterZone(evt) {
        // Remove highlight from previous active zone
        if (this.activeDropZone && this.activeDropZone !== evt.currentTarget) {
          this.activeDropZone.classList.remove('drag-over-active');
        }
        // Add highlight to current zone
        evt.currentTarget.classList.add('drag-over-active');
        this.activeDropZone = evt.currentTarget;
      }

      handleDragLeaveZone(evt) {
        // Remove highlight if leaving the current active zone
        if (this.activeDropZone === evt.currentTarget) {
          evt.currentTarget.classList.remove('drag-over-active');
          this.activeDropZone = null;
        }
      }

      handleDragEnterVerticalZone(evt) {
        // Prevent event bubbling that causes flickering
        evt.stopPropagation();

        // Remove highlight from any other active zone
        if (this.activeDropZone && this.activeDropZone !== evt.currentTarget) {
          this.activeDropZone.classList.remove('drag-over-active');
        }

        // Add highlight to vertical drop zone
        evt.currentTarget.classList.add('drag-over-active');
        this.activeDropZone = evt.currentTarget;
      }

      handleDragLeaveVerticalZone(evt) {
        // Check if we're actually leaving the dropzone (not just moving to a child element)
        const rect = evt.currentTarget.getBoundingClientRect();
        const x = evt.clientX;
        const y = evt.clientY;

        // Only remove highlight if we're truly leaving the expanded hit area
        if (x < rect.left - 15 || x > rect.right + 15 || y < rect.top || y > rect.bottom) {
          evt.currentTarget.classList.remove('drag-over-active');
          if (this.activeDropZone === evt.currentTarget) {
            this.activeDropZone = null;
          }
        }
      }

      onDropToNewColumn(evt, newColumnIndex) {
        debugLog('log', `onDropToNewColumn called for column ${newColumnIndex}`);
        debugLog('log', 'Current draggedState:', this.draggedState);
        debugLog('log', 'Current oldItem:', this.oldItem);

        // Prevent default to ensure drop is handled
        evt.preventDefault();
        evt.stopPropagation();

        // Check for correct drag type - draggedState is a string, not an object
        if (!this.draggedState || this.draggedState !== 'group') {
          debugLog('warn', 'No group being dragged or wrong type. draggedState:', this.draggedState);
          this.reset();
          return;
        }

        const movedItem = this.oldItem;
        if (!movedItem) {
          debugLog('warn', 'No item to move. oldItem:', this.oldItem);
          this.reset();
          return;
        }

        debugLog('log', `Moving group "${movedItem.name}" from column ${movedItem.column} to column ${newColumnIndex}`);

        // First, adjust indices in the old column
        const oldColumn = movedItem.column;
        const oldIndex = movedItem.index;

        // Shift groups up in the old column
        const groupsInOldColumn = this.app.data.groups.filter(g =>
          g.column === oldColumn && g.uuid !== movedItem.uuid && g.index > oldIndex
        );
        groupsInOldColumn.forEach(g => {
          g.index--;
        });

        // Now move to new column
        movedItem.column = newColumnIndex;

        // Find the correct index in the new column (add to the end)
        const groupsInNewColumn = this.app.data.groups.filter(g =>
          g.column === newColumnIndex && g.uuid !== movedItem.uuid
        );

        // Set index to be after all existing groups in the column
        const maxIndex = groupsInNewColumn.reduce((max, g) => Math.max(max, g.index || 0), -1);
        movedItem.index = maxIndex + 1;

        debugLog('log', `Group "${movedItem.name}" moved to column ${newColumnIndex} at index ${movedItem.index}`);

        // Clear any active drop zone styling
        if (this.activeDropZone) {
          this.activeDropZone.classList.remove('drag-over-active');
          this.activeDropZone = null;
        }

        // Handle shared group sync if needed
        if (movedItem.shared && movedItem.useEventLog) {
          try {
            // Log the position change for event-log based groups
            const event = {
              type: 'group-move',
              groupId: movedItem.uuid,
              oldColumn,
              oldIndex,
              newColumn: newColumnIndex,
              newIndex: movedItem.index,
              timestamp: Date.now()
            };
            debugLog('log', '[DRAG] Group position change event:', event);
          } catch (error) {
            debugLog('error', '[DRAG] Error logging group move:', error);
          }
        }

        // Save and reset
        this.app.saveData();
        this.reset();
      }

      isDragOverActive(element) {
        return this.activeDropZone === element;
      }


      async onDrop(evt, targetArray, targetItem, targetIndex, targetColumn, type) {
        if (type !== this.draggedState || !this.oldItem) {
          debugLog('warn', "Drop cancelled or invalid state. Resetting early.");
          this.reset();
          return;
        }
        evt.preventDefault();

        // Remove drag-over-active class on drop
        if (this.activeDropZone) {
          this.activeDropZone.classList.remove('drag-over-active');
          this.activeDropZone = null;
        }

        debugLog('log', `onDrop - Type: ${type}, TargetItem: ${targetItem?.uuid}, TargetIndex: ${targetIndex}, TargetColumn: ${targetColumn}`);

        const oldItemUuid = this.oldItem.uuid;
        const oldColumn = this.oldItem.column;

        // Check if this is a cross-group move for links and verify permissions FIRST
        if (type === 'link') {
          const oldGroup = (this.app.data.groups || []).find(g =>
            g.links === this.oldArr
          );
          const newGroup = (this.app.data.groups || []).find(g =>
            g.links === targetArray
          );

          if (oldGroup && newGroup && oldGroup !== newGroup) {
            // Check permissions BEFORE making any changes
            if (!this.app.canDelete(oldGroup)) {
              alert(this.app.getTranslation('error.perm.delete') || 'You do not have permission to remove links from this group');
              this.reset();
              return;
            }

            if (!this.app.canAdd(newGroup)) {
              alert(this.app.getTranslation('error.perm.add') || 'You do not have permission to add links to this group');
              this.reset();
              return;
            }
          }
        }

        // 1) Remove item from its original array (only after permission check)
        const oldItemIndex = this.oldArr.findIndex(item =>
          this.oldItem.uuid && item.uuid === this.oldItem.uuid
        );
        let movedItem;
        if (oldItemIndex > -1) {
          movedItem = this.oldArr.splice(oldItemIndex, 1)[0];
          debugLog('log', `Removed item ${movedItem.uuid} from old index ${oldItemIndex}`);
        } else {
          debugLog('error', "Could not find dragged item in source array.");
          return;
        }

        // 2) Assign new column and ensure the moved item exists in the target array
        movedItem.column = targetColumn;
        if (!targetArray.includes(movedItem)) {
          targetArray.push(movedItem);
          debugLog('log', `Pushed item ${movedItem.uuid} into target array (column ${targetColumn}).`);
        }

        // 3) Reorder within the target column with fractional indexing (cheap reindex)
        const assignFractionalIndex = (items, column, desiredIndex) => {
          const EPS = 1e-6;
          const inCol = items.filter(it => it.column === column && it !== movedItem)
                              .sort((a, b) => a.index - b.index);
          const clamped = Math.max(0, Math.min(desiredIndex, inCol.length));
          const prev = clamped > 0 ? inCol[clamped - 1] : null;
          const next = clamped < inCol.length ? inCol[clamped] : null;
          let newIdx;
          if (prev && next) {
            const gap = next.index - prev.index;
            if (gap > EPS) {
              newIdx = prev.index + gap / 2;
            } else {
              // Gap too small; fallback to full reindex once, then place at middle
              this.app.reindexArr(inCol);
              newIdx = (inCol[clamped - 1]?.index || 0) + 0.5;
            }
          } else if (prev && !next) {
            newIdx = prev.index + 1;
          } else if (!prev && next) {
            newIdx = next.index - 1;
          } else {
            newIdx = 0;
          }
          movedItem.index = newIdx;
          debugLog('log', `Assigned fractional index ${newIdx} for ${type} in column ${column}`);
        };

        if (type === 'group') {
          assignFractionalIndex(this.app.data.groups, targetColumn, targetIndex);
          debugLog('log', "Normalizing group columns after drop...");
          this.app.normalizeColumnNumbers();
        } else if (type === 'link') {
          const parentGroup = this.app.data.groups.find(g => g.links === targetArray);
          if (parentGroup) {
            assignFractionalIndex(parentGroup.links, targetColumn, targetIndex);
          } else {
            debugLog('error', "Could not find parent group for link drop target array.");
          }
        }

        // 4) Reindex old column (from which the item was removed)
        if (type === 'group') {
          const leftBehind = this.app.data.groups.filter(g => g.column === oldColumn);
          if (leftBehind.length) this.app.reindexArr(leftBehind);
        } else if (type === 'link') {
          const srcGroup = this.app.data.groups.find(g => g.links === this.oldArr);
          if (srcGroup) {
            const leftBehind = srcGroup.links.filter(l => l.column === oldColumn);
            if (leftBehind.length) this.app.reindexArr(leftBehind);
          }
        }

        debugLog('log', "Saving data after drop and re-index...");
        this.app.saveData();
        
        // Send share-links update for shared groups
        if (type === 'link' && movedItem) {
          try {
            // Find the OLD group (where the link was dragged FROM)
            const oldGroup = (this.app.data.groups || []).find(g => 
              g.links === this.oldArr
            );
            
            // Find the NEW group (where the link was dragged TO)
            // Important: targetArray is the links array of the target group
            const newGroup = (this.app.data.groups || []).find(g =>
              g.links === targetArray
            );
            
            // If the link was moved between different groups
            if (oldGroup && newGroup && oldGroup !== newGroup) {
              // Permissions were already checked before making any changes

              // Handle sync for cross-group moves
              // Send DELETE event/message to old group if it's shared
              if (oldGroup.shared) {
                if (oldGroup.useEventLog && this.app.eventLogManager) {
                  // Create link-delete event for old group
                  this.app.createAndApplyEvent(oldGroup, {
                    type: 'link-delete',
                    linkId: movedItem.uuid,
                    data: {
                      deletedLink: {
                        uuid: movedItem.uuid,
                        text: movedItem.text,
                        url: movedItem.url,
                        column: oldColumn,
                        index: movedItem.index
                      }
                    }
                  });
                  debugLog('log', '[DND EVENT-LOG] Created link-delete event for old group:', oldGroup.name);
                } else if (oldGroup.groupTopic && oldGroup.groupKey) {
                  // Legacy sync for old group
                  try {
                    const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name || '' };
                    const deleteEnv = {
                      v: 1,
                      type: 'link-delete',
                      ts: Date.now(),
                      from,
                      groupId: oldGroup.groupId,
                      link: { uuid: movedItem.uuid, url: movedItem.url || null },
                      version: oldGroup.version || CONSTS.VERSION_FALLBACK,
                      msgId: (Math.random().toString(36).slice(2) + Date.now())
                    };
                    debugLog('log', '[DRAG] Sending link-delete to old shared group:', oldGroup.name, movedItem.uuid);
                    if (typeof sharing !== 'undefined' && sharing) {
                      await sharing.sendToGroup(oldGroup, deleteEnv);
                    }
                  } catch (error) {
                    debugLog('error', '[DRAG] Error sending link-delete:', error);
                  }
                }
              }

              // Send ADD event/message to new group if it's shared
              if (newGroup.shared) {
                if (newGroup.useEventLog && this.app.eventLogManager) {
                  // Create link-add event for new group
                  this.app.createAndApplyEvent(newGroup, {
                    type: 'link-add',
                    linkId: movedItem.uuid,
                    data: {
                      uuid: movedItem.uuid,
                      text: movedItem.text || '',
                      url: movedItem.url || '',
                      rawUrlInput: movedItem.rawUrlInput || '',
                      keywords: movedItem.keywords || '',
                      shortcut: movedItem.shortcut || '',
                      itemType: this.app.normalizeLinkItemType(movedItem),
                      refTargetUuid: movedItem.refTargetUuid || '',
                      inheritSourceKeywords: movedItem.inheritSourceKeywords !== false,
                      urlPlaceholders: this.app.normalizePlaceholderList(movedItem.urlPlaceholders || []),
                      column: movedItem.column || 0,
                      index: movedItem.index || 0,
                      createdAt: movedItem.createdAt || Date.now(),
                      lastModified: movedItem.lastModified || Date.now()
                    }
                  });
                  debugLog('log', '[DND EVENT-LOG] Created link-add event for new group:', newGroup.name);
                } else if (newGroup.groupTopic && newGroup.groupKey) {
                  // Legacy sync for new group
                  try {
                    const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name || '' };
                    const linkData = this.app.serializeLinkForSync(movedItem);
                    const addEnv = {
                      v: 1,
                      type: 'share-links',
                      ts: Date.now(),
                      from,
                      groupId: newGroup.groupId,
                      selection: { groups: [], links: [linkData] },
                      mode: 'merge',
                      msgId: (Math.random().toString(36).slice(2) + Date.now())
                    };
                    debugLog('log', '[DRAG] Sending share-links to new shared group:', newGroup.name, linkData);
                    if (typeof sharing !== 'undefined' && sharing) {
                      await sharing.sendToGroup(newGroup, addEnv);
                    }
                  } catch (error) {
                    debugLog('error', '[DRAG] Error sending share-links:', error);
                  }
                }
              }
            }
            // If the link was moved within the same group (just repositioned)
            else if (newGroup && newGroup.shared) {
              // For event-log groups, create a link-update event
              if (newGroup.useEventLog && this.app.eventLogManager) {
                this.app.createAndApplyEvent(newGroup, {
                  type: 'link-update',
                  linkId: movedItem.uuid,
                  data: {
                    uuid: movedItem.uuid,
                    text: movedItem.text || '',
                    url: movedItem.url || '',
                    keywords: movedItem.keywords || '',
                    shortcut: movedItem.shortcut || '',
                    itemType: this.app.normalizeLinkItemType(movedItem),
                    refTargetUuid: movedItem.refTargetUuid || '',
                    inheritSourceKeywords: movedItem.inheritSourceKeywords !== false,
                    urlPlaceholders: this.app.normalizePlaceholderList(movedItem.urlPlaceholders || []),
                    column: movedItem.column || 0,
                    index: movedItem.index || 0,
                    lastModified: movedItem.lastModified || Date.now()
                  }
                });
                debugLog('log', '[DND EVENT-LOG] Created link-update event for position change:', newGroup.name);
              }
              // Legacy sync needs explicit position updates
              else if (newGroup.groupTopic && newGroup.groupKey && !newGroup.useEventLog) {
                try {
                  const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name || '' };
                  const linkData = this.app.serializeLinkForSync(movedItem);
                  const env = {
                    v: 1,
                    type: 'share-links',
                    ts: Date.now(),
                    from,
                    groupId: newGroup.groupId,
                    selection: { groups: [], links: [linkData] },
                    mode: 'merge',
                    msgId: (Math.random().toString(36).slice(2) + Date.now())
                  };
                  debugLog('log', '[DRAG] Sending share-links update within same group:', linkData);
                  if (typeof sharing !== 'undefined' && sharing) {
                    await sharing.sendToGroup(newGroup, env);
                  }
                } catch (error) {
                  debugLog('error', '[DRAG] Error sending share-links update:', error);
                }
              }
            }
          } catch (e) {
            debugLog('error', '[DRAG] Failed to send share-links:', e);
          }
        }
        
        debugLog('log', `onDrop finished processing for item ${movedItem.id}`);

        // Ensure reset in case dragend isn't reliable
        debugLog('log', "Resetting drag state after successful drop");
        this.reset();
      }
    } // Ende DropManager Klasse

    // --- Helpers for base64url ---
    const B64 = {
      enc(bytes) {
        const bin = Array.from(bytes).map(b => String.fromCharCode(b)).join('');
        return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      },
      dec(str) {
        str = str.replace(/-/g, '+').replace(/_/g, '/');
        const pad = str.length % 4 ? '='.repeat(4 - (str.length % 4)) : '';
        const bin = atob(str + pad);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
        return arr;
      }
    };

    // --- WebCrypto utilities: ECDH/HKDF/AES-GCM ---
    class CryptoUtil {
      static async generateIdentity() {
        const kp = await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']);
        const pubRaw = new Uint8Array(await crypto.subtle.exportKey('raw', kp.publicKey));
        const privPkcs8 = new Uint8Array(await crypto.subtle.exportKey('pkcs8', kp.privateKey));
        return { pubKeyB64: B64.enc(pubRaw), privKeyB64: B64.enc(privPkcs8) };
      }
      static async importPub(rawB64) {
        return await crypto.subtle.importKey('raw', B64.dec(rawB64), { name: 'ECDH', namedCurve: 'P-256' }, true, []);
      }
      static async importPriv(pkcs8B64) {
        return await crypto.subtle.importKey('pkcs8', B64.dec(pkcs8B64), { name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']);
      }
      static async deriveBits(privKey, pubKey) {
        return new Uint8Array(await crypto.subtle.deriveBits({ name: 'ECDH', public: pubKey }, privKey, 256));
      }
      static async hkdf(inputBytes, infoStr, len = 32, salt = new Uint8Array(32)) {
        const baseKey = await crypto.subtle.importKey('raw', inputBytes, 'HKDF', false, ['deriveBits']);
        const info = new TextEncoder().encode(infoStr);
        const bits = await crypto.subtle.deriveBits({ name: 'HKDF', hash: 'SHA-256', salt, info }, baseKey, len * 8);
        return new Uint8Array(bits);
      }
      static async deriveChannel(sharedSecret) {
        const k = await this.hkdf(sharedSecret, 'mybookmarks:channel-key', 32);
        const topicBytes = await this.hkdf(sharedSecret, 'mybookmarks:channel-topic', 32);
        const topic = B64.enc(topicBytes).slice(0, 22);
        return { k, topic };
      }
      static async aesEncrypt(keyBytes, plaintextObj) {
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-GCM', length: 256 }, false, ['encrypt']);
        const pt = new TextEncoder().encode(JSON.stringify(plaintextObj));
        const ct = new Uint8Array(await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, pt));
        const out = new Uint8Array(iv.length + ct.length);
        out.set(iv, 0); out.set(ct, iv.length);
        return B64.enc(out);
      }
      static async aesDecrypt(keyBytes, payloadB64) {
        const all = B64.dec(payloadB64);
        const iv = all.slice(0, 12);
        const ct = all.slice(12);
        const key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-GCM', length: 256 }, false, ['decrypt']);
        const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
        return JSON.parse(new TextDecoder().decode(pt));
      }
    }

    // Expose classes in in-file namespaces for clarity
    MB.DnD.DropManager = DropManager;
    MB.Utils.CryptoUtil = CryptoUtil;

    // --- ntfy client ---
    class NtfyClient {
      constructor(serverUrl, token) { this.serverUrl = serverUrl?.replace(/\/$/, ''); this.token = token || ''; this.subs = new Map(); this.valid = /^https?:\/\//i.test(this.serverUrl||''); this.memberWindows = new Map(); }
      setConfig(serverUrl, token) { this.serverUrl = serverUrl?.replace(/\/$/, ''); this.token = token || ''; this.valid = /^https?:\/\//i.test(this.serverUrl||''); }
      buildTopicPath(topic) {
        // Sanitize to a single path component: ntfy topics should not contain '/'
        let t = String(topic || '');
        t = t.replace(/[\/\\]/g, '-');            // replace any slashes with '-'
        t = t.replace(/[^A-Za-z0-9._-]/g, '_');     // keep only safe chars
        return `${this.serverUrl}/${t}`;
      }
      headers(extra) {
        const h = {};
        // Only attach Authorization on http(s) origins to avoid CORS preflight from file://
        if (/^https?:/i.test(location.protocol) && this.token) h['Authorization'] = `Bearer ${this.token}`;
        if (extra) Object.assign(h, extra);
        return h;
      }
      async publish(topic, bodyB64, ttlSec) {
        if (!this.valid) { debugLog('warn', 'ntfy serverUrl not configured or invalid'); return; }
        // Lightweight per-destination rate limit (windowed)
        try {
          // Token-bucket rate limit per topic for steady control
          const isQc = String(topic||'').startsWith('mb-qc-');
          const limit = Number((window.app?.data?.options?.sync?.memberRateLimit)||0);
          if (!isQc && limit > 0) {
            const key = topic;
            if (!this.memberBuckets) this.memberBuckets = new Map();
            let b = this.memberBuckets.get(key);
            if (!b) { b = { tokens: Math.min(limit, Math.max(1, Math.floor(limit/2))), last: Date.now(), capacity: limit, rate: limit / 60 }; this.memberBuckets.set(key, b); }
            const now = Date.now();
            const delta = (now - b.last) / 1000;
            b.tokens = Math.min(b.capacity, b.tokens + delta * b.rate);
            b.last = now;
            if (b.tokens < 1) { debugLog('warn', '[RATE] token bucket drop', { topic, tokens: b.tokens.toFixed(2) }); return; }
            b.tokens -= 1;
          }
        } catch (e) { debugLog('warn','[RATE] token bucket error', e); }
        // Prefer token as query to keep request "simple" (no preflight) for file:// origins
        let url = this.buildTopicPath(topic);
        if (this.token && !/^https?:/i.test(location.protocol)) {
          url += (url.includes('?') ? '&' : '?') + 'token=' + encodeURIComponent(this.token);
        }
        const headers = this.headers({ 'Content-Type': 'text/plain' });
        // Only set X-Ttl on http(s) origins to avoid non-simple headers on file://
        if (ttlSec && /^https?:/i.test(location.protocol)) headers['X-Ttl'] = String(ttlSec);
        const opts = { method: 'POST', headers, body: bodyB64 };
        if (!/^https?:/i.test(location.protocol)) Object.assign(opts, { mode: 'no-cors', keepalive: true });
        const res = await fetch(url, opts);
        if (/^https?:/i.test(location.protocol)) {
          if (!res.ok) throw new Error(`ntfy publish failed: ${res.status}`);
        } else {
          // On file:// with no-cors we cannot read status; assume best-effort
          return;
        }
      }
      async subscribeLongPoll(topic, onMsg) {
        // Avoid cross-origin issues when running from file:// — require http(s) origin
        if (!/^https?:/i.test(location.protocol)) { debugLog('warn', 'Skipping long-poll on non-http origin'); return { abort(){} }; }
        if (!this.valid) { debugLog('warn', 'ntfy serverUrl not configured or invalid'); return { abort(){} }; }
        const controller = new AbortController();
        const headers = this.headers();
        const url = this.buildTopicPath(topic) + '/json';
        let backoffMs = 1000;
        const run = async () => {
          try {
            const res = await fetch(url, { method: 'GET', headers, signal: controller.signal });
            if (!res.ok) throw new Error('ntfy poll failed ' + res.status);
            backoffMs = 1000;
            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            let buf = '';
            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              buf += decoder.decode(value, { stream: true });
              let idx;
              while ((idx = buf.indexOf('\n')) >= 0) {
                const line = buf.slice(0, idx).trim();
                buf = buf.slice(idx + 1);
                if (!line) continue;
                try {
                  const evt = JSON.parse(line);
                  const payload = (evt && typeof evt.message === 'string') ? evt.message : line;
                  onMsg({ text: payload, id: evt.id, time: evt.time, event: evt.event });
                } catch (_) { /* ignore */ }
              }
            }
          } catch (e) {
            if (controller.signal.aborted) return;
            debugLog('warn', 'ntfy long-poll error', e);
          }
          if (!controller.signal.aborted) {
            const factor = 1.5 + Math.random() * 0.5; // jitter 1.5x..2.0x
            backoffMs = Math.min(backoffMs * factor, CONSTS.BACKOFF_MAX_MS);
            setTimeout(run, backoffMs);
          }
        };
        run();
        this.subs.set(topic, controller);
        return controller;
      }
      subscribe(topic, onMsg) {
        if (!this.valid) { debugLog('warn', 'ntfy serverUrl not configured or invalid'); return { close(){}, abort(){} }; }
        // Start both SSE (no headers) and long-poll (with headers) to maximize compatibility
        const handles = { es: null, lp: null, closed: false, lpPaused: false, lpPauseTimer: null };
        try {
          let url = this.buildTopicPath(topic) + '/sse';
          // If token is configured, prefer passing it as query for SSE to avoid CORS headers
          if (this.token) url += (url.includes('?') ? '&' : '?') + 'token=' + encodeURIComponent(this.token);
          const es = new EventSource(url, { withCredentials: false });
          es.onmessage = (ev) => {
            try {
              const evt = JSON.parse(ev.data);
              const payload = (evt && typeof evt.message === 'string') ? evt.message : ev.data;
              onMsg({ text: payload, id: evt.id, time: evt.time, event: evt.event });
            } catch (e) {
              try { onMsg({ text: ev.data }); } catch (_) {}
            }
          };
          es.onerror = (e) => {
            debugLog('warn', '[NTFY] EventSource error for topic', topic, e);
            // Resume long-poll if it was paused
            if (handles.lpPaused && !handles.closed) {
              this.subscribeLongPoll(topic, onMsg).then(ctrl => { handles.lp = ctrl; handles.lpPaused = false; }).catch((err)=>debugLog('warn','[NTFY] resume LP failed', err));
            }
            // Don't close ES on error - let it auto-reconnect
          };
          es.onopen = () => {
            debugLog('log', '[NTFY] EventSource connected for topic', topic);
            // If ES remains open for a short delay, pause long-poll to save resources
            try {
              if (handles.lpPauseTimer) clearTimeout(handles.lpPauseTimer);
              handles.lpPauseTimer = setTimeout(() => {
                try { if (!handles.closed && handles.lp && handles.lp.abort) { handles.lp.abort(); handles.lp = null; handles.lpPaused = true; } } catch (e) { debugLog('warn','[NTFY] pause LP failed', e); }
              }, 2000);
            } catch (e) { debugLog('warn','[NTFY] schedule LP pause failed', e); }
          };
          handles.es = es;
        } catch (error) {
          debugLog('error', '[Sharing] Failed to initialize EventSource:', error);
        }
        // Also start long-polling loop (works with Authorization header if set) when origin is http(s)
        this.subscribeLongPoll(topic, onMsg).then(ctrl => { handles.lp = ctrl; }).catch((e) => { debugLog('warn', '[NTFY] subscribeLongPoll init failed', e); });
        // Unified abort/close handle
        handles.abort = () => {
          if (handles.closed) return;
          try { handles.es && handles.es.close && handles.es.close(); } catch (e) { debugLog('warn', '[NTFY] ES close failed', e); }
          try { handles.lp && handles.lp.abort && handles.lp.abort(); } catch (e) { debugLog('warn', '[NTFY] LP abort failed', e); }
          try { handles.lpPauseTimer && clearTimeout(handles.lpPauseTimer); } catch (e) { }
          handles.closed = true;
        };
        handles.close = handles.abort;
        this.subs.set(topic, handles);
        return handles;
      }
      unsubscribe(topic) {
        const h = this.subs.get(topic);
        if (h) {
          try { h.es && h.es.close && h.es.close(); } catch (e) { debugLog('warn', '[Sharing] Error closing EventSource:', e); }
          try { h.lp && h.lp.abort && h.lp.abort(); } catch (e) { debugLog('warn', '[Sharing] Error aborting long-poll:', e); }
          try { h.close && h.close(); } catch (e) { debugLog('warn', '[Sharing] Error closing connection:', e); }
          try { h.abort && h.abort(); } catch (e) { debugLog('warn', '[Sharing] Error aborting connection:', e); }
          this.subs.delete(topic);
        }
      }
      
    }

    // --- Event-Log System for Advanced Sync (Future Migration) ---
    class VectorClock {
      constructor(memberId) {
        this.clock = {};
        this.memberId = memberId;
      }
      
      increment() {
        this.clock[this.memberId] = (this.clock[this.memberId] || 0) + 1;
        return this.clone();
      }
      
      merge(otherClock) {
        if (!otherClock) return;
        Object.keys(otherClock).forEach(id => {
          this.clock[id] = Math.max(
            this.clock[id] || 0,
            otherClock[id] || 0
          );
        });
      }
      
      clone() {
        const cloned = new VectorClock(this.memberId);
        cloned.clock = { ...this.clock };
        return cloned;
      }
      
      happensBefore(other) {
        if (!other || !other.clock) return false;
        let hasLess = false;
        for (let id in this.clock) {
          if (this.clock[id] > (other.clock[id] || 0)) return false;
          if (this.clock[id] < (other.clock[id] || 0)) hasLess = true;
        }
        return hasLess;
      }
      
      isConcurrent(other) {
        return !this.happensBefore(other) && !other.happensBefore(this);
      }
      
      toJSON() {
        return this.clock;
      }
    }

    MB.EventLog.VectorClock = VectorClock;
    
    class EventLogManager {
      constructor(maxEvents = CONSTS.EVENT_LOG_MAX_EVENTS, snapshotInterval = CONSTS.EVENT_LOG_SNAPSHOT_INTERVAL * 2) {
        this.maxEvents = maxEvents;
        this.snapshotInterval = snapshotInterval;
      }

      // Compare two vector clocks. Returns 'lt' | 'gt' | 'eq' | 'concurrent'
      static compareVectorClocks(a = {}, b = {}) {
        const keys = new Set([...Object.keys(a||{}), ...Object.keys(b||{})]);
        let aLTEb = true;
        let bLTEa = true;
        let aLTb = false;
        let bLTa = false;
        for (const k of keys) {
          const av = a[k] || 0;
          const bv = b[k] || 0;
          if (av > bv) { aLTEb = false; aLTb = false; bLTa = true; }
          if (bv > av) { bLTEa = false; bLTa = false; aLTb = true; }
        }
        if (aLTEb && bLTEa) return 'eq';
        if (aLTEb && aLTb) return 'lt';
        if (bLTEa && bLTa) return 'gt';
        return 'concurrent';
      }
      
      shouldCreateSnapshot(group) {
        const eventCount = group.eventLog?.length || 0;
        const lastSnapTime = group.snapshot?.timestamp || 0;
        const hoursSinceSnap = (Date.now() - lastSnapTime) / (1000 * 60 * 60);
        
        return eventCount >= this.snapshotInterval || hoursSinceSnap > 24;
      }
      
      createSnapshot(group) {
        // Create a point-in-time snapshot of the group state
          const snapshot = {
            timestamp: Date.now(),
            eventId: group.headEventId || null,
            vectorClock: group.vectorClock ? { ...group.vectorClock } : {},
            data: {
              links: JSON.parse(JSON.stringify(group.links || [])),
              members: JSON.parse(JSON.stringify(group.members || [])),
              version: group.version || 0,
              name: group.name,
              emoji: group.emoji || '',
              color: group.color,
              urlPlaceholders: JSON.parse(JSON.stringify(group.urlPlaceholders || [])),
            }
          };
        
        // Garbage collect old events
        if (group.eventLog && snapshot.eventId) {
          const snapEventIndex = group.eventLog.findIndex(
            e => e.eventId === snapshot.eventId
          );
          
          if (snapEventIndex >= 0) {
            // Keep only events after snapshot
            group.eventLog = group.eventLog.slice(snapEventIndex + 1);
          }
        }
        
        group.snapshot = snapshot;
        debugLog('log', '[EVENT-LOG] Created snapshot', { 
          groupId: group.groupId, 
          eventCount: group.eventLog?.length || 0 
        });
        return snapshot;
      }
      
      addEvent(event, group) {
        debugLog('log', '[EventLogManager.addEvent] Called with:', {
          groupName: group.name,
          groupId: group.groupId,
          eventType: event.operation?.type || event.type,
          eventId: event.eventId,
          hasEventLog: !!group.eventLog,
          eventLogLength: group.eventLog?.length || 0
        });
        
        // Initialize event log if needed
        if (!group.eventLog) {
          debugLog('log', '[EventLogManager.addEvent] Initializing event log for group');
          group.eventLog = [];
        }
        
        // Generate event ID if not present
        if (!event.eventId) {
          event.eventId = `${event.authorId || event.author}-${Date.now()}-${Math.random().toString(36).slice(2)}`;
          debugLog('log', '[EventLogManager.addEvent] Generated event ID:', event.eventId);
        }
        
        // Check for duplicates
        if (group.eventLog.some(e => e.eventId === event.eventId)) {
          debugLog('log', '[EVENT-LOG] Skipping duplicate event', event.eventId);
          return false;
        }
        
        // Add event to log
        group.eventLog.push(event);
        group.headEventId = event.eventId;
        debugLog('log', '[EventLogManager.addEvent] Event added to log:', {
          eventId: event.eventId,
          newLength: group.eventLog.length
        });
        
        // Update vector clock
        if (!group.vectorClock) {
          group.vectorClock = {};
        }
        const authorKey = event.author || event.authorId;
        if (authorKey) {
          group.vectorClock[authorKey] = (group.vectorClock[authorKey] || 0) + 1;
          event.vectorClock = { ...group.vectorClock };
          debugLog('log', '[EventLogManager.addEvent] Updated vector clock:', group.vectorClock);
        }
        
        // Check if snapshot is needed
        if (this.shouldCreateSnapshot(group)) {
          this.createSnapshot(group);
        }
        
        debugLog('log', '[EVENT-LOG] Added event', {
          type: event.type,
          eventId: event.eventId,
          eventCount: group.eventLog.length
        });
        
        return true;
      }
      
      applyEvent(group, event) {
        // Initialize event log if needed
        if (!group.eventLog) group.eventLog = [];
        
        // Check for duplicates
        if (group.eventLog.some(e => e.eventId === event.eventId)) {
          debugLog('log', '[EVENT-LOG] Skipping duplicate event', event.eventId);
          return false;
        }
        
        // Add to log
        group.eventLog.push(event);
        group.headEventId = event.eventId;
        
        // Apply the operation - MUST use Vue reactivity for UI updates
        switch(event.operation?.type) {
          case 'link-add':
            if (!group.links) {
              // Use Vue's reactivity if app is available
              if (window.app && window.app.$set) {
                window.app.$set(group, 'links', []);
              } else {
                group.links = [];
              }
            }
            const incomingData = event.operation?.data || {};
            const rawItemType = (window.app && window.app.normalizeLinkItemType)
              ? window.app.normalizeLinkItemType(incomingData)
              : ((String(incomingData.itemType || '').toLowerCase() === 'separator')
                ? 'separator'
                : ((String(incomingData.itemType || '').toLowerCase() === 'note')
                  ? 'note'
                  : (incomingData.refTargetUuid ? 'ref' : 'link')));
            const newLink = {
              uuid: event.operation.data.uuid || event.operation.linkId,  // Support both formats
              ...incomingData,
              itemType: rawItemType,
              shortcut: event.operation?.data?.shortcut || '',
              refTargetUuid: event.operation?.data?.refTargetUuid || '',
              inheritSourceKeywords: event.operation?.data?.inheritSourceKeywords !== false,
              urlPlaceholders: (window.app && window.app.normalizePlaceholderList)
                ? window.app.normalizePlaceholderList(event.operation?.data?.urlPlaceholders || [])
                : (event.operation?.data?.urlPlaceholders || []),
              // Ensure reactive UI properties
              editing: false,
              isMouseOver: false
            };
            if (window.app && window.app.normalizeLinkDataForItemType) {
              window.app.normalizeLinkDataForItemType(newLink, rawItemType);
            }
            // Use Vue's reactivity to add the link
            if (window.app && window.app.$set) {
              window.app.$set(group.links, group.links.length, newLink);
            } else {
              group.links.push(newLink);
            }
            group.version = (group.version || 0) + 1;
            debugLog('log', '[EVENT-LOG] Applied link-add', newLink.uuid);
            break;
            
          case 'link-edit':
            // Support both linkId formats
            const editLinkId = event.operation.linkId || event.operation.data?.linkId || event.operation.data?.uuid;
            const linkToEdit = group.links?.find(l => l.uuid === editLinkId);
            if (linkToEdit) {
              // Use Vue's reactivity for updates
              if (window.app && window.app.$set) {
                Object.keys(event.operation.data).forEach(key => {
                  // Skip linkId/uuid in data to avoid overwriting
                  if (key !== 'linkId' && key !== 'uuid') {
                    const nextValue = (key === 'urlPlaceholders' && window.app.normalizePlaceholderList)
                      ? window.app.normalizePlaceholderList(event.operation.data[key] || [])
                      : event.operation.data[key];
                    window.app.$set(linkToEdit, key, nextValue);
                  }
                });
                if (window.app.normalizeLinkDataForItemType) {
                  const fallbackType = window.app.normalizeLinkItemType
                    ? window.app.normalizeLinkItemType(linkToEdit)
                    : (linkToEdit.refTargetUuid ? 'ref' : 'link');
                  window.app.normalizeLinkDataForItemType(linkToEdit, fallbackType);
                }
              } else {
                Object.assign(linkToEdit, event.operation.data);
              }
              group.version = (group.version || 0) + 1;
              debugLog('log', '[EVENT-LOG] Applied link-edit', editLinkId);
            }
            break;
            
          case 'link-delete':
            // Support both linkId formats
            const deleteLinkId = event.operation.linkId || event.operation.data?.linkId || event.operation.data?.uuid;
            const idx = group.links?.findIndex(l => l.uuid === deleteLinkId);
            if (idx >= 0) {
              group.links.splice(idx, 1);
              group.version = (group.version || 0) + 1;
              debugLog('log', '[EVENT-LOG] Applied link-delete', deleteLinkId);
              // Trigger Vue update
              if (window.app && window.app.$forceUpdate) {
                try { window.app.$forceUpdate(); } catch {}
              }
            }
            break;
            
          case 'snapshot':
            // Full snapshot replacement
            if (event.operation.data) {
              const snapshotLinks = event.operation.data.links || [];
              group.links = (window.app && window.app.normalizeLinkDataForItemType)
                ? snapshotLinks.map((link) => window.app.normalizeLinkDataForItemType(Object.assign({}, link), (window.app.normalizeLinkItemType ? window.app.normalizeLinkItemType(link) : 'link')))
                : snapshotLinks;
              group.urlPlaceholders = (window.app && window.app.normalizePlaceholderList)
                ? window.app.normalizePlaceholderList(event.operation.data.urlPlaceholders || [])
                : (event.operation.data.urlPlaceholders || []);
              group.version = event.operation.data.version || 0;
              debugLog('log', '[EVENT-LOG] Applied snapshot');
            }
            break;
        }
        
        // Update vector clock
        if (event.vectorClock) {
          if (!group.vectorClock) group.vectorClock = {};
          Object.assign(group.vectorClock, event.vectorClock);
        }
        
        // Check if we need a snapshot
        if (this.shouldCreateSnapshot(group)) {
          this.createSnapshot(group);
        }
        
        return true;
      }
      
      findMissingEvents(group, remoteVectorClock) {
        if (!group.eventLog || !remoteVectorClock) return [];
        
        const missing = [];
        for (const event of group.eventLog) {
          if (event.author && 
              (!remoteVectorClock[event.author] || 
               remoteVectorClock[event.author] < (event.vectorClock?.[event.author] || 0))) {
            missing.push(event);
          }
        }
        
        return missing;
      }
      
      // Conflict Resolution Methods
      detectConflict(localEvent, remoteEvent) {
        // Check if two events conflict
        if (!localEvent || !remoteEvent) return false;
        
        // Different operation types on same entity
        if (localEvent.operation?.linkId === remoteEvent.operation?.linkId) {
          // Check if events are concurrent using vector clocks
          const localVC = new VectorClock();
          localVC.clock = localEvent.vectorClock || {};
          const remoteVC = new VectorClock();
          remoteVC.clock = remoteEvent.vectorClock || {};
          
          return localVC.isConcurrent(remoteVC);
        }
        
        return false;
      }
      
      resolveConflict(localEvent, remoteEvent, strategy = 'last-write-wins') {
        debugLog('log', '[CONFLICT] Resolving conflict', {
          local: localEvent.eventId,
          remote: remoteEvent.eventId,
          strategy
        });
        
        switch (strategy) {
          case 'last-write-wins':
            // Use timestamp to determine winner
            const localTime = localEvent.timestamp || 0;
            const remoteTime = remoteEvent.timestamp || 0;
            
            if (remoteTime > localTime) {
              return remoteEvent;
            } else if (localTime > remoteTime) {
              return localEvent;
            } else {
              // Same timestamp - use author UUID as tiebreaker for consistency
              return (remoteEvent.author || '') > (localEvent.author || '') ? remoteEvent : localEvent;
            }
            
          case 'owner-wins':
            // Owner changes always win
            if (remoteEvent.authorRole === 'owner') return remoteEvent;
            if (localEvent.authorRole === 'owner') return localEvent;
            // Fall back to last-write-wins
            return this.resolveConflict(localEvent, remoteEvent, 'last-write-wins');
            
          case 'merge':
            // For edit operations, try to merge changes
            if (localEvent.operation?.type === 'link-edit' && 
                remoteEvent.operation?.type === 'link-edit' &&
                localEvent.operation?.linkId === remoteEvent.operation?.linkId) {
              
              // Merge the changes
              const mergedData = { ...localEvent.operation.data };
              
              // For each field, use the most recent change
              Object.keys(remoteEvent.operation.data || {}).forEach(field => {
                // Compare field-level timestamps if available
                const localFieldTime = localEvent.fieldTimestamps?.[field] || localEvent.timestamp;
                const remoteFieldTime = remoteEvent.fieldTimestamps?.[field] || remoteEvent.timestamp;
                
                if (remoteFieldTime >= localFieldTime) {
                  mergedData[field] = remoteEvent.operation.data[field];
                }
              });
              
              // Create merged event
              return {
                ...remoteEvent,
                operation: {
                  ...remoteEvent.operation,
                  data: mergedData
                },
                merged: true,
                mergedFrom: [localEvent.eventId, remoteEvent.eventId]
              };
            }
            
            // For non-mergeable operations, use last-write-wins
            return this.resolveConflict(localEvent, remoteEvent, 'last-write-wins');
            
          default:
            return this.resolveConflict(localEvent, remoteEvent, 'last-write-wins');
        }
      }
      
      // Check if an operation is still valid given current state
      validateOperation(group, event) {
        if (!event?.operation) return false;
        
        const op = event.operation;
        
        switch (op.type) {
          case 'link-edit':
          case 'link-delete':
            // Check if link still exists - support both linkId formats
            const linkId = op.linkId || op.data?.linkId || op.data?.uuid;
            const link = group.links?.find(l => l.uuid === linkId);
            if (!link) {
              debugLog('warn', '[CONFLICT] Operation invalid - link not found', linkId);
              return false;
            }
            // For edits, check if link hasn't been deleted
            if (link.deleted && op.type === 'link-edit') {
              debugLog('warn', '[CONFLICT] Cannot edit deleted link', linkId);
              return false;
            }
            break;
            
          case 'link-add':
            // Check for duplicate UUIDs - support both linkId formats
            const addLinkId = op.linkId || op.data?.linkId || op.data?.uuid;
            if (group.links?.some(l => l.uuid === addLinkId)) {
              debugLog('warn', '[CONFLICT] Link with UUID already exists', addLinkId);
              return false;
            }
            break;
        }
        
        return true;
      }
      
      // Apply remote event with conflict detection
      applyRemoteEvent(group, remoteEvent, conflictStrategy = 'last-write-wins') {
        // Check for conflicts with recent local events
        const recentLocalEvents = (group.eventLog || [])
          .filter(e => e.timestamp > Date.now() - CONSTS.MINUTE_MS); // Last minute
        
        let hasConflict = false;
        let winningEvent = remoteEvent;
        
        for (const localEvent of recentLocalEvents) {
          if (this.detectConflict(localEvent, remoteEvent)) {
            hasConflict = true;
            winningEvent = this.resolveConflict(localEvent, remoteEvent, conflictStrategy);
            
            if (winningEvent !== remoteEvent) {
              debugLog('log', '[CONFLICT] Local event wins', {
                local: localEvent.eventId,
                remote: remoteEvent.eventId
              });
              return false; // Don't apply remote event
            }
          }
        }
        
        // Validate operation is still applicable
        if (!this.validateOperation(group, winningEvent)) {
          debugLog('warn', '[CONFLICT] Operation no longer valid', winningEvent.eventId);
          return false;
        }
        
        // Apply the winning event
        if (hasConflict) {
          debugLog('log', '[CONFLICT] Applying winning remote event after conflict', winningEvent.eventId);
          // Notify user of conflict resolution
          this.notifyConflictResolution(group, winningEvent, 'remote');
        }
        
        return this.applyEvent(group, winningEvent);
      }
      
      // Notify user about conflict resolution
      notifyConflictResolution(group, winningEvent, winner) {
        // Store conflict info for UI notification
        if (!group.conflictNotifications) {
          group.conflictNotifications = [];
        }
        
        group.conflictNotifications.push({
          timestamp: Date.now(),
          eventId: winningEvent.eventId,
          winner: winner,
          operation: winningEvent.operation?.type,
          resolved: true
        });
        
        // Keep only recent notifications
        group.conflictNotifications = group.conflictNotifications
          .filter(n => n.timestamp > Date.now() - 300000); // 5 minutes
        
        // Trigger UI notification check if app is available
        if (window.app && typeof window.app.checkAndShowConflictNotifications === 'function') {
          setTimeout(() => window.app.checkAndShowConflictNotifications(), 100);
        }
      }
      
      isOlderThanSnapshot(memberClock, snapshotClock) {
        if (!memberClock || !snapshotClock) return false;
        
        for (let memberId in snapshotClock) {
          if ((memberClock[memberId] || 0) < snapshotClock[memberId]) {
            return true;
          }
        }
        return false;
      }
    }

    // --- Sharing service (identity, contacts, quick-connect, inbox) ---
    class SharingService {
      constructor(app) {
        this.app = app;
        this.ntfy = new NtfyClient('', '');
        this.pairSubs = new Map();
        this.qcSub = null;
        this.qcSecrets = new Map();
        this.onQcStatus = null;
        this.qcTopic = '';
        this.qcCode = '';
        this.syncResponded = new Set();
        // Chunked transfer reassembly buffers
        this.groupTransfers = new Map(); // transferId -> { groupId, contentType, total, parts: Map, timer, from }
        // Per-topic msgId dedupe
        this.msgIds = new Map(); // topic -> Set(msgId)
      }
      setStatusHandler(fn) { this.onQcStatus = typeof fn === 'function' ? fn : null; }
      get cfg() { return this.app.data.options?.sharing || {}; }
      applyConfig() {
        // Provide sensible default for demos if not configured
        const server = this.cfg.ntfyServerUrl && this.cfg.ntfyServerUrl.trim() ? this.cfg.ntfyServerUrl.trim() : 'https://ntfy.c5p.de';
        this.ntfy.setConfig(server, this.cfg.ntfyAuthToken || '');
      }
      async ensureIdentity() {
        if (!this.app.data.identity?.uuid || !this.app.data.identity?.privKey || !this.app.data.identity?.pubKey) {
          const { pubKeyB64, privKeyB64 } = await CryptoUtil.generateIdentity();
          this.app.$set(this.app.data, 'identity', { uuid: this.uuidv4(), name: this.app.data.identity?.name || '', pubKey: pubKeyB64, privKey: privKeyB64 });
          this.app.saveData();
        }
      }
      uuidv4() { 
        try { 
          // Prefer native crypto.randomUUID
          if (crypto && crypto.randomUUID) {
            return crypto.randomUUID();
          }
          // Fallback to crypto.getRandomValues with proper UUID v4 format
          if (crypto && crypto.getRandomValues) {
            const bytes = new Uint8Array(16);
            crypto.getRandomValues(bytes);
            // Set version (4) and variant bits according to UUID v4 spec
            bytes[6] = (bytes[6] & 0x0f) | 0x40; // Version 4
            bytes[8] = (bytes[8] & 0x3f) | 0x80; // Variant 10
            // Format as UUID string
            const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
            return `${hex.substr(0,8)}-${hex.substr(8,4)}-${hex.substr(12,4)}-${hex.substr(16,4)}-${hex.substr(20,12)}`;
          }
          // Fallback to URL.createObjectURL (still better than timestamp)
          return URL.createObjectURL(new Blob()).split('/').pop();
        } catch (error) { 
          debugLog('error', '[UUID] Failed to generate secure UUID:', error);
          // Last resort with better entropy
          const timestamp = Date.now().toString(36);
          const random1 = Math.random().toString(36).substr(2, 9);
          const random2 = Math.random().toString(36).substr(2, 9);
          const random3 = performance.now().toString(36).substr(2, 5);
          return `${timestamp}-${random1}-${random2}-${random3}`;
        } 
      }
      getContactCard() {
        const id = this.app.data.identity || {};
        return { v: 1, uuid: id.uuid, name: id.name || '', pubKey: id.pubKey };
      }
      async addContactFromCard(card) {
        if (!card || !card.uuid || !card.pubKey) throw new Error('invalid card');
        const exists = (this.app.data.contacts || []).some(c => c.uuid === card.uuid);
        if (!exists) {
          if (!Array.isArray(this.app.data.contacts)) this.app.$set(this.app.data, 'contacts', []);
          this.app.data.contacts.push({ uuid: card.uuid, name: card.name || '', pubKey: card.pubKey, topic: '', kChannelB64: '' });
        }
        
        // Remove from blocked list if previously blocked
        if (this.app.data.blockedContacts?.includes(card.uuid)) {
          const idx = this.app.data.blockedContacts.indexOf(card.uuid);
          if (idx >= 0) {
            this.app.data.blockedContacts.splice(idx, 1);
            debugLog('log', '[CONTACT] Removed from blocked list:', card.uuid);
          }
        }
        
        await this.derivePairwiseFor(card.uuid);
        this.app.saveData();
      }
      async derivePairwiseFor(contactUuid) {
        const me = this.app.data.identity;
        const c = (this.app.data.contacts || []).find(x => x.uuid === contactUuid);
        if (!me || !c) return;
        const pubOther = await CryptoUtil.importPub(c.pubKey);
        const privSelf = await CryptoUtil.importPriv(me.privKey);
        const shared = await CryptoUtil.deriveBits(privSelf, pubOther);
        const { k, topic } = await CryptoUtil.deriveChannel(shared);
        c.topic = topic; c.kChannelB64 = B64.enc(k);
        this.subscribePairwise(c);
      }
      subscribePairwise(contact) {
        if (!contact.topic || !contact.kChannelB64) return;
        if (this.pairSubs.has(contact.topic)) return;
        this.applyConfig();
        const seen = new Set();
        const handles = this.ntfy.subscribe(contact.topic, async (evt) => {
          try {
            const id = evt && evt.id;
            if (id) { if (seen.has(id)) return; seen.add(id); }
            if (evt && evt.event && evt.event !== 'message') return; // ignore non-message events
            const payload = (evt && typeof evt.text === 'string') ? evt.text : (typeof evt === 'string' ? evt : '');
            if (!payload || !/^[A-Za-z0-9_\-]+$/.test(payload)) return; // only accept base64url bodies
            const env = await CryptoUtil.aesDecrypt(B64.dec(contact.kChannelB64), payload);
            this.onEnvelope(env, { scope: 'pair', contact, id });
          } catch (e) { debugLog('warn', 'pair decrypt failed', e); }
        });
        this.pairSubs.set(contact.topic, { handles, seen });
      }
      // --- Chunked send helper ---
      async sendChunkedGroup(group, contentType, envelopeObj) {
        try {
          const json = JSON.stringify(envelopeObj);
          // compute sha256 over UTF-8 bytes to validate on receiver
          let sha256 = '';
          try {
            const bytes = new TextEncoder().encode(json);
            const digest = await crypto.subtle.digest('SHA-256', bytes);
            sha256 = B64.enc(new Uint8Array(digest));
          } catch (e) { debugLog('warn', '[SYNC] sha256 failed', e); }
          // encode to base64url chunks without padding (supports Unicode)
          const b64 = B64.enc(new TextEncoder().encode(json));
          const chunkSize = CONSTS.NTFY_CHUNK_SIZE; // ~80KB per chunk
          const total = Math.ceil(b64.length / chunkSize);
          const transferId = (Math.random().toString(36).slice(2)+Date.now());
          const from = { uuid: this.app.data.identity?.uuid, name:this.app.data.identity?.name||'' };
          for (let i=0;i<total;i++) {
            const part = b64.slice(i*chunkSize, (i+1)*chunkSize);
            const chunkEnv = { v:1, type:'sync-chunk', ts:Date.now(), from, groupId: group.groupId, transferId, seq:i, total, contentType, payloadB64: part, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
            await this.sendToGroup(group, chunkEnv);
          }
          const doneEnv = { v:1, type:'sync-chunks-done', ts:Date.now(), from, groupId: group.groupId, transferId, total, contentType, sha256, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
          await this.sendToGroup(group, doneEnv);
        } catch(e) {
          try { debugLog('warn','[SYNC] sendChunkedGroup failed', e); } catch {}
        }
      }

      // --- Chunked send helper over pairwise channel ---
      async sendChunkedToContact(contactUuid, contentType, envelopeObj) {
        try {
          const json = JSON.stringify(envelopeObj);
          // compute sha256 over UTF-8 bytes to validate on receiver
          let sha256 = '';
          try {
            const bytes = new TextEncoder().encode(json);
            const digest = await crypto.subtle.digest('SHA-256', bytes);
            sha256 = B64.enc(new Uint8Array(digest));
          } catch (e) { debugLog('warn', '[SYNC] sha256 failed', e); }
          // encode to base64url chunks without padding (supports Unicode)
          const b64 = B64.enc(new TextEncoder().encode(json));
          const chunkSize = CONSTS.NTFY_CHUNK_SIZE; // ~80KB per chunk
          const total = Math.ceil(b64.length / chunkSize);
          const transferId = (Math.random().toString(36).slice(0,8) + Date.now());
          const from = { uuid: this.app.data.identity?.uuid, name:this.app.data.identity?.name||'' };
          for (let i=0;i<total;i++) {
            const part = b64.slice(i*chunkSize, (i+1)*chunkSize);
            const chunkEnv = { v:1, type:'sync-chunk', ts:Date.now(), from, transferId, seq:i, total, contentType, payloadB64: part, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
            await this.sendToContact(contactUuid, chunkEnv);
          }
          const doneEnv = { v:1, type:'sync-chunks-done', ts:Date.now(), from, transferId, total, contentType, sha256, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
          await this.sendToContact(contactUuid, doneEnv);
        } catch (e) {
          try { debugLog('warn','[SYNC] sendChunkedToContact failed', e); } catch {}
        }
      }
      unsubscribePairwise(contact) {
        if (!contact.topic) return;
        const sub = this.pairSubs.get(contact.topic);
        if (sub) {
          try {
            // Close the subscription
            if (sub.handles) {
              this.ntfy.unsubscribe(contact.topic);
            }
            // Remove from map
            this.pairSubs.delete(contact.topic);
            debugLog('log', '[PAIR] Unsubscribed from contact topic:', contact.topic);
          } catch (e) {
            debugLog('error', '[PAIR] Failed to unsubscribe:', e);
          }
        }
      }
      async sendToContact(contactUuid, envelope) {
        const c = (this.app.data.contacts || []).find(x => x.uuid === contactUuid);
        if (!c || !c.kChannelB64 || !c.topic) throw new Error('no channel');
        // Ensure minimal envelope fields
        const env = (envelope && envelope.v && envelope.ts && envelope.msgId) ? envelope : MB.Sync.buildEnvelope(this.app, envelope?.type || 'message', envelope);
        const b64 = await CryptoUtil.aesEncrypt(B64.dec(c.kChannelB64), env);
        await this.ntfy.publish(c.topic, b64, this.cfg.defaultTtl || undefined);
      }
      // --- Group sharing ---
      genGroupId() { return this.uuidv4(); }
      genGroupKeyB64() { const k=new Uint8Array(32); crypto.getRandomValues(k); return B64.enc(k); }
      genGroupTopic() { const seed=new Uint8Array(16); crypto.getRandomValues(seed); return (this.app.data.options?.groupSharing?.topicPrefix || 'mb-g-') + B64.enc(seed).slice(0,12); }
      async sendToGroup(group, envelope) {
        if (!group?.groupTopic || !group?.groupKey) throw new Error('group not shared');
        // Ensure minimal envelope fields and groupId
        const env = (envelope && envelope.v && envelope.ts && envelope.msgId) ? Object.assign({ groupId: group.groupId }, envelope) : MB.Sync.buildEnvelope(this.app, envelope?.type || 'message', Object.assign({ groupId: group.groupId }, envelope || {}));
        // Debug logging - errors can be ignored
        try { debugLog('log', '[SYNC] sendToGroup', { topic: group.groupTopic, groupId: group.groupId, type: env?.type, from: this.app.data.identity?.uuid }); } catch (e) { /* Console error */ }
        const b64 = await CryptoUtil.aesEncrypt(B64.dec(group.groupKey), env);
        try {
          await this.ntfy.publish(group.groupTopic, b64, this.cfg.defaultTtl || undefined);
          try { debugLog('log', '[SYNC] publish ok', { type: env?.type, topic: group.groupTopic }); } catch {}
        } catch (e) {
          debugLog('warn', '[SYNC] publish failed', e);
          throw e;
        }
      }
      subscribeGroup(group, skipUpdateRequest = false) {
        if (!group?.groupTopic || !group?.groupKey) return;
        if (!this.groupSubs) this.groupSubs = new Map();
        if (this.groupSubs.has(group.groupTopic)) {
          debugLog('log', '[SYNC] Already subscribed to group', group.groupTopic);
          return;
        }
        this.applyConfig();
        
        // Check if NTFY is properly configured
        if (!this.ntfy.valid) {
          debugLog('warn', '[SYNC] NTFY not configured, cannot subscribe to group', group.groupTopic);
          return;
        }
        
        try { debugLog('log', '[SYNC] subscribeGroup start', { 
          topic: group.groupTopic, 
          groupId: group.groupId,
          ntfyServer: this.ntfy.serverUrl,
          hasToken: !!this.ntfy.token
        }); } catch (error) {
          debugLog('error', '[Sharing] Failed to subscribe to group:', error);
        }
        
        const seen = new Set();
        const handles = this.ntfy.subscribe(group.groupTopic, async (evt) => {
          try {
            const id = evt && evt.id; 
            if (id) { 
              if (seen.has(id)) { 
                try { debugLog('log', '[SYNC] drop duplicate ntfy id', id); } catch {} 
                return; 
              } 
              seen.add(id); 
            }
            if (evt && evt.event && evt.event !== 'message') { 
              try { debugLog('log', '[SYNC] skip non-message event', evt.event); } catch {} 
              return; 
            }
            const payload = (evt && typeof evt.text === 'string') ? evt.text : (typeof evt === 'string' ? evt : '');
            
            // Check if this is an attachment notification (not our encrypted message)
            if (payload && payload.includes('attachment.txt')) {
              try { 
                debugLog('log', '[SYNC] Skipping NTFY attachment notification:', payload); 
              } catch {} 
              return;
            }
            
            if (!payload || !/^[A-Za-z0-9_\-]+$/.test(payload)) { 
              try { 
                debugLog('log', '[SYNC] skip non-b64url payload', {
                  hasPayload: !!payload,
                  payloadType: typeof payload,
                  payloadLength: payload ? payload.length : 0,
                  payloadSample: payload ? payload.substring(0, 50) : 'none',
                  eventType: evt?.event,
                  hasMessage: !!evt?.message
                }); 
              } catch {} 
              return; 
            }
            const env = await CryptoUtil.aesDecrypt(B64.dec(group.groupKey), payload);
            try { debugLog('log', '[SYNC] recv envelope', { type: env?.type, from: env?.from?.uuid, groupId: env?.groupId }); } catch {}
            // Envelope-level dedup by msgId per topic
            if (env && env.msgId) {
              const topic = group.groupTopic;
              let set = this.msgIds.get(topic);
              if (!set) { set = new Set(); this.msgIds.set(topic, set); }
              if (set.has(env.msgId)) { debugLog('log', '[SYNC] drop duplicate msgId', env.msgId); return; }
              set.add(env.msgId);
            }
            
            // Use the current group from data.groups, not the old reference
            // Always pass the original group to handleGroupEnvelope
            // The handleGroupEnvelope will find the current group internally
            this.handleGroupEnvelope(group, env);
          } catch(e){ 
            debugLog('warn', 'group decrypt failed', e); 
          }
        });
        
        this.groupSubs.set(group.groupTopic, { handles, seen });
        debugLog('log', '[SYNC] Subscription created for group', group.groupTopic);
        
        // Request a full update after subscribing (covers offline gaps) - but skip if caller will do it
        if (!skipUpdateRequest) {
          // Add a small delay to ensure subscription is fully established
          setTimeout(() => {
            try {
              const from = { uuid: this.app.data.identity?.uuid, name:this.app.data.identity?.name||'' };
              try { debugLog('log', '[SYNC] send group-update-request after subscribe', { topic: group.groupTopic, groupId: group.groupId }); } catch {}
              this.sendToGroup(group, { v:1, type:'group-update-request', ts:Date.now(), from, groupId: group.groupId, msgId:(Math.random().toString(36).slice(2)+Date.now()) });
            } catch(e) {
              debugLog('warn', '[SYNC] Failed to send update request after subscribe', e);
            }
          }, 500);
        }
      }
      async handleGroupEnvelope(group, env) {
        if (!env || !env.type) { try { debugLog('log', '[SYNC] ignore envelope without type'); } catch {} return; }
        if (env.msgId && this.app.processedMsgIds && this.app.processedMsgIds.has(env.msgId)) { try { debugLog('log', '[SYNC] drop duplicate msgId', env.msgId); } catch {} return; }
        if (env.msgId && this.app.processedMsgIds) this.app.processedMsgIds.add(env.msgId);
        // Ignore our own outbound messages to prevent echo/duplication
        try { if (env.from && env.from.uuid && this.app.data.identity && env.from.uuid === this.app.data.identity.uuid) { try { debugLog('log', '[SYNC] drop self-echo'); } catch {} return; } } catch {}

        // Chunked sync reassembly
        if (env.type === 'sync-chunk' || env.type === 'sync-chunks-done') {
          try {
            const tId = env.transferId;
            if (!tId) return;
            let buf = this.groupTransfers.get(tId);
            if (!buf) {
              // Enforce max concurrent transfers
              if (this.groupTransfers.size >= CONSTS.MAX_CONCURRENT_TRANSFERS) {
                debugLog('warn', '[SYNC] dropping chunk: too many concurrent transfers');
                return;
              }
              buf = { groupId: env.groupId, contentType: env.contentType || 'snapshot', total: env.total || 0, parts: new Map(), timer: null, from: env.from?.uuid, bytes: 0 };
              this.groupTransfers.set(tId, buf);
              // Timeout cleanup
              buf.timer = setTimeout(() => { this.groupTransfers.delete(tId); }, CONSTS.MINUTE_MS);
            }
            if (env.type === 'sync-chunk') {
              if (typeof env.seq === 'number' && typeof env.payloadB64 === 'string') {
                buf.parts.set(env.seq, env.payloadB64);
                buf.bytes += env.payloadB64.length;
                // Size cap safety
                if (buf.bytes > CONSTS.MAX_TRANSFER_SIZE) {
                  debugLog('warn', '[SYNC] dropping transfer: size exceeds cap');
                  clearTimeout(buf.timer);
                  this.groupTransfers.delete(tId);
                  return;
                }
                if (env.total && !buf.total) buf.total = env.total;
                // Early assemble if all parts are present (in case DONE is lost)
                if (buf.total && buf.parts.size === buf.total) {
                  const ordered = Array.from({ length: buf.total }, (_, i) => buf.parts.get(i) || '');
                  try {
                    const bytes = B64.dec(ordered.join(''));
                    const json = new TextDecoder().decode(bytes);
                    const fullEnv = JSON.parse(json);
                    const g = (this.app.data.groups || []).find(x => x.groupId === (fullEnv.groupId || buf.groupId));
                    if (g) this.handleGroupEnvelope(g, fullEnv);
                  } catch (e) { debugLog('warn','[SYNC] early chunk reassembly failed', e); }
                  if (buf.timer) clearTimeout(buf.timer);
                  this.groupTransfers.delete(tId);
                }
              }
              return; // wait for DONE (or already assembled)
            }
            if (env.type === 'sync-chunks-done') {
              // assemble if complete
              const total = buf.total || env.total || 0;
              const have = buf.parts.size;
              if (total > 0 && have === total) {
              const ordered = Array.from({ length: total }, (_, i) => buf.parts.get(i) || '');
              let joined = ordered.join('');
              try {
                  // Decode base64url to bytes, then UTF-8 to string
                  const bytes = B64.dec(joined);
                  const json = new TextDecoder().decode(bytes);
                  // optional integrity check if sha256 present
                  if (typeof env.sha256 === 'string' && env.sha256) {
                    try {
                      const encBytes = new TextEncoder().encode(json);
                      const digest = await crypto.subtle.digest('SHA-256', encBytes);
                      const hashB64 = B64.enc(new Uint8Array(digest));
                      if (hashB64 !== env.sha256) {
                        debugLog('warn','[SYNC] chunk hash mismatch – dropping transfer');
                        if (buf.timer) clearTimeout(buf.timer);
                        this.groupTransfers.delete(tId);
                        return;
                      }
                    } catch (e) { debugLog('warn','[SYNC] sha256 verify failed', e); }
                  }
                  const fullEnv = JSON.parse(json);
                  // Dispatch reconstructed envelope
                  const g = (this.app.data.groups || []).find(x => x.groupId === (fullEnv.groupId || buf.groupId));
                  if (g) this.handleGroupEnvelope(g, fullEnv);
                } catch (e) { debugLog('warn','[SYNC] chunk reassembly failed', e); }
              } else {
                debugLog('warn', '[SYNC] chunks-done but parts missing', { have, total });
              }
              // cleanup
              if (buf.timer) clearTimeout(buf.timer);
              this.groupTransfers.delete(tId);
              return;
            }
          } catch (e) { debugLog('warn', '[SYNC] envelope handling error', e); }
        }
        
        // Handle Event-Log activation message
        if (env.type === 'event-log-activation') {
          debugLog('log', '[EVENT-LOG] Received activation message from owner', { 
            groupId: env.groupId, 
            from: env.from?.uuid 
          });
          
          const g = (this.app.data.groups || []).find(x => x.groupId === env.groupId);
          if (g && !g.useEventLog) {
            // Owner has activated event-log, members should adopt it
            debugLog('log', '[EVENT-LOG] Adopting event-log for group', g.name);
            
            // Use complete event-log data if provided, otherwise use migration snapshot
            if (env.eventLog && env.eventLog.length > 0) {
              debugLog('log', '[EVENT-LOG] Applying complete event-log from owner', {
                eventCount: env.eventLog.length,
                hasSnapshot: !!env.snapshot
              });
              this.app.$set(g, 'eventLog', env.eventLog);
              this.app.$set(g, 'snapshot', env.snapshot || null);
              this.app.$set(g, 'headEventId', env.headEventId || env.eventLog[env.eventLog.length - 1].eventId);
              this.app.$set(g, 'vectorClock', env.vectorClock || {});
              this.app.$set(g, 'useEventLog', true);
            } else if (env.migrationSnapshot) {
              // Fallback to migration snapshot if no complete event-log
              const migrationEvent = {
                eventId: env.migrationSnapshot.eventId,
                parentId: null,
                timestamp: env.migrationSnapshot.timestamp,
                author: 'owner-migration',
                vectorClock: { 'system': 1 },
                operation: {
                  type: 'snapshot',
                  data: env.migrationSnapshot.data
                }
              };
              
              this.app.$set(g, 'eventLog', [migrationEvent]);
              this.app.$set(g, 'headEventId', migrationEvent.eventId);
              this.app.$set(g, 'vectorClock', { 'system': 1 });
              this.app.$set(g, 'useEventLog', true);
              
              debugLog('log', '[EVENT-LOG] Member adopted event-log for group', g.groupId);
              this.app.saveData();
              
              // Force UI update
              try { this.app.$forceUpdate(); } catch {}
            }
          }
          return;
        }
        
        // Handle Event-Log sync events
        else if (env.type === 'sync-event') {
          debugLog('log', '[EVENT-LOG] Received sync-event', {
            groupId: env.groupId,
            eventType: env.event?.operation?.type,
            from: env.from?.uuid
          });

          const g = (this.app.data.groups || []).find(x => x.groupId === env.groupId);
          
          // If group doesn't have event-log enabled yet but receives events, enable it
          if (g && !g.useEventLog && env.event) {
            debugLog('log', '[EVENT-LOG] Enabling event-log for group due to received event', g.name);
            this.app.$set(g, 'useEventLog', true);
            if (!g.eventLog) {
              this.app.$set(g, 'eventLog', []);
            }
            if (!g.vectorClock) {
              this.app.$set(g, 'vectorClock', {});
            }
          }
          
          if (g && g.useEventLog && env.event) {
            // Fork detection via vector clock comparison
            try {
              const localVC = g.vectorClock || {};
              const remoteVC = env.event.vectorClock || {};
              const rel = EventLogManager.compareVectorClocks(localVC, remoteVC);
              if (rel === 'concurrent') {
                // Mark local flag and alert owner to send a snapshot
                this.app.$set(g, 'forkDetected', true);
                const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name||'' };
                const alert = { v:1, type:'sync-fork-alert', ts:Date.now(), from, groupId: g.groupId, headVC: localVC, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
                this.sendToGroup(g, alert).catch(()=>{});
              }
            } catch {}
            // Determine conflict resolution strategy based on group settings and user options
            let strategy = 'last-write-wins'; // Default
            
            // Check if user is owner and has configured a strategy
            if (this.app.isOwnerOfGroup(g)) {
              strategy = this.app.data.options?.sync?.conflictResolution || 'last-write-wins';
            } else {
              // Members always use last-write-wins unless group has specific setting
              strategy = g.conflictResolution || 'last-write-wins';
            }
            
            // Apply the event using EventLogManager with conflict detection
            const applied = this.app.eventLogManager.applyRemoteEvent(g, env.event, strategy);
            
            if (applied) {
              debugLog('log', '[EVENT-LOG] Applied event to group', g.name);
              this.app.saveData();
              
              // Check for conflict notifications to show to user
              if (g.conflictNotifications?.length > 0) {
                const recentConflicts = g.conflictNotifications.filter(
                  n => n.timestamp > Date.now() - 5000 // Last 5 seconds
                );
                if (recentConflicts.length > 0) {
                  debugLog('info', '[CONFLICT] Conflicts resolved automatically', {
                    count: recentConflicts.length,
                    strategy: strategy
                  });
                }
              }
              
              try { this.app.$forceUpdate(); } catch {}
            } else {
              debugLog('warn', '[EVENT-LOG] Event not applied (conflict or invalid)', {
                eventId: env.event.eventId,
                from: env.from?.uuid
              });
            }
          }
          return;
        }

        // Fork alert: owner prepares a consistent snapshot and rebases members
        else if (env.type === 'sync-fork-alert') {
          try { debugLog('log', '[SMART-SYNC] Fork alert received', { from: env.from?.uuid, groupId: env.groupId }); } catch {}
          const g = (this.app.data.groups || []).find(x => x.groupId === env.groupId);
          if (!g) return;
          if (!this.app.isOwnerOfGroup(g)) return; // Only owner responds
          try {
            // Generate/ensure snapshot
            const snap = this.app.eventLogManager.createSnapshot(g);
            const eventsSince = Array.isArray(g.eventLog) ? g.eventLog.slice() : [];
            const from = { uuid: this.app.data.identity?.uuid, name:this.app.data.identity?.name||'' };
            const envSnap = { v:1, type:'sync-snapshot', ts:Date.now(), from, groupId: g.groupId, baseVC: snap.vectorClock||{}, snapshot: snap, eventsSince, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
            // Choose chunked path for large payloads
            const raw = JSON.stringify(envSnap);
            if (raw.length > 100000) {
              await this.sendChunkedGroup(g, 'snapshot', envSnap);
            } else {
              await this.sendToGroup(g, envSnap);
            }
          } catch(e) { debugLog('warn','[SMART-SYNC] Failed to send sync-snapshot', e); }
          return;
        }

        // Apply snapshot and optional delta events
        else if (env.type === 'sync-snapshot') {
          try { debugLog('log', '[SMART-SYNC] Applying snapshot', { groupId: env.groupId }); } catch {}
          const g = (this.app.data.groups || []).find(x => x.groupId === env.groupId);
          if (!g) return;
          try {
            // Replace state from snapshot
            const snap = env.snapshot || {};
            const d = snap.data || {};
            if (Array.isArray(d.links)) {
              const links = JSON.parse(JSON.stringify(d.links));
              links.forEach((l) => {
                l.urlPlaceholders = this.app.normalizePlaceholderList(l.urlPlaceholders || []);
                if (l.inheritSourceKeywords === undefined && l.refTargetUuid) l.inheritSourceKeywords = true;
              });
              this.app.$set(g, 'links', links);
            }
            if (Array.isArray(d.members)) this.app.$set(g, 'members', JSON.parse(JSON.stringify(d.members)));
            if (d.name !== undefined) this.app.$set(g, 'name', d.name);
            if (d.color !== undefined) this.app.$set(g, 'color', d.color);
            if (d.urlPlaceholders !== undefined) this.app.$set(g, 'urlPlaceholders', this.app.normalizePlaceholderList(d.urlPlaceholders || []));
            this.app.$set(g, 'version', d.version || 0);
            this.app.$set(g, 'vectorClock', snap.vectorClock || {});
            this.app.$set(g, 'headEventId', snap.eventId || null);
            // Reset event log to eventsSince
            const eventsSince = Array.isArray(env.eventsSince) ? env.eventsSince : [];
            this.app.$set(g, 'eventLog', []);
            for (const ev of eventsSince) {
              try { this.app.eventLogManager.applyEvent(g, ev); } catch {}
            }
            this.app.$set(g, 'forkDetected', false);
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch {}
          } catch(e) { debugLog('warn', '[SMART-SYNC] Snapshot apply failed', e); }
          return;
        }

        // Ownership transfer
        else if (env.type === 'owner-transfer') {
          const g = (this.app.data.groups || []).find(x => x.groupId === env.groupId);
          if (!g) return;
          // Validate that the sender is current owner
          if (env.from?.uuid && g.ownerUuid && env.from.uuid !== g.ownerUuid) return;
          // Ask the designated new owner to accept; others do nothing and wait for roster
          const my = this.app.data.identity?.uuid;
          if (my && my === env.newOwnerUuid) {
            const ok = confirm(this.app.getTranslation('dialog.transfer.acceptPrompt') || 'Owner transfer requested. Accept?');
            if (!ok) {
              // Optionally notify rejection
              try { const rej = { v:1, type:'owner-transfer-reject', ts:Date.now(), from:{uuid:my,name:this.app.data.identity?.name||''}, groupId: env.groupId, msgId:(Math.random().toString(36).slice(2)+Date.now()) }; this.sendToGroup(g, rej); } catch {}
              return;
            }
            // Apply locally and broadcast roster as the new owner
            this.app.$set(g, 'ownerUuid', env.newOwnerUuid);
            if (Array.isArray(g.members)) {
              g.members = g.members.map(m => {
                if (m.uuid === env.newOwnerUuid) return Object.assign({}, m, { role: 'owner' });
                if (m.role === 'owner') return Object.assign({}, m, { role: 'member' });
                return m;
              });
              const from = { uuid: my, name: this.app.data.identity?.name||'' };
              const roster = { v:1, type:'group-roster', ts:Date.now(), from, groupId: g.groupId, members: g.members, groupOwnerUuid: env.newOwnerUuid };
              await this.sendToGroup(g, roster);
            }
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch {}
          }
          return;
        }

        // Identity migration
        else if (env.type === 'identity-migrate') {
          const oldId = env.from?.oldUuid;
          const newId = env.from?.newUuid;
          if (!oldId || !newId) return;
          // Update contacts
          try {
            const c = (this.app.data.contacts||[]).find(x => x.uuid === oldId);
            if (c) c.uuid = newId;
          } catch {}
          // Update group rosters (owner action authoritative)
          (this.app.data.groups||[]).forEach(g => {
            const m = Array.isArray(g.members) ? g.members.find(x => x.uuid === oldId) : null;
            if (m) m.uuid = newId;
          });
          this.app.saveData();
          return;
        }
      
        // Handle Smart Sync protocol messages
        else if (env.type === 'sync-version-check') {
          debugLog('log', '[SMART-SYNC] Received version check request', { from: env.from?.uuid, groupId: env.groupId });
          await this.app.handleSyncVersionCheck(env, env.from?.uuid);
          return;
        } else if (env.type === 'sync-version-response') {
          debugLog('log', '[SMART-SYNC] Received version response', { from: env.from?.uuid, version: env.myVersion });
          this.app.handleSyncVersionResponse(env);
          return;
        } else if (env.type === 'sync-request-full') {
          debugLog('log', '[SMART-SYNC] Received full update request', { from: env.from?.uuid, toMember: env.toMember });
          if (env.toMember === this.app.data.identity?.uuid) {
            await this.app.handleSyncFullRequest(env);
          }
          return;
        } else if (env.type === 'sync-full-update') {
          debugLog('log', '[SMART-SYNC] Received full update', { from: env.from?.uuid, version: env.version });
          await this.app.handleSyncFullUpdate(env);
          return;
        } else if (env.type === 'sync-request-any') {
          debugLog('log', '[SMART-SYNC] Received broadcast update request', { from: env.from?.uuid });
          await this.app.handleSyncBroadcastRequest(env);
          return;
        }
        
        if (env.type === 'group-meta') {
          // Find group by groupId (for shared groups only - no fallback)
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          if (g) {
            if (env.name) g.name = env.name;
            if (env.emoji !== undefined) g.emoji = env.emoji || '';
            if (env.shortcut !== undefined) this.app.$set(g, 'shortcut', this.app.normalizeShortcutText(env.shortcut || ''));
            if (env.color!==undefined) g.color=env.color;
            if (env.favicon !== undefined) {
              this.app.$set(g, 'favicon', env.favicon || '');
              this.app.$set(g, 'faviconError', false);
              this.app.$set(g, 'faviconLoading', false);
            }
            if (env.faviconSource !== undefined) this.app.$set(g, 'faviconSource', env.faviconSource || null);
            if (env.faviconRuleId !== undefined) this.app.$set(g, 'faviconRuleId', env.faviconRuleId || null);
            if (typeof env.opacity==='number') g.opacity = Math.max(0, Math.min(100, env.opacity));
            if (env.infoHtml !== undefined) g.infoHtml = this.app.sanitizeHtml(String(env.infoHtml || ''));
            if (env.urlPlaceholders !== undefined) this.app.$set(g, 'urlPlaceholders', this.app.normalizePlaceholderList(env.urlPlaceholders || []));
          }
          this.app.saveData();
          try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
        } else if (env.type === 'group-roster') {
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          if (g) {
            let list = Array.isArray(env.members)?env.members:[];
            // Fill missing names from identity/contacts and preserve all permission fields
            try {
              const myUuid = this.app.data.identity?.uuid;
              const myName = this.app.data.identity?.name || '';
              const contacts = Array.isArray(this.app.data.contacts) ? this.app.data.contacts : [];
              list = list.map(m => {
                // Copy all properties from the incoming member object, including permissions
                const mm = Object.assign({}, m);
                if (!mm.name || mm.name === mm.uuid) {
                  if (mm.uuid === myUuid && myName) mm.name = myName;
                  else {
                    const c = contacts.find(x => x.uuid === mm.uuid);
                    if (c && c.name) mm.name = c.name;
                    // Fallback: if this member is the sender (owner usually sends roster), use from.name
                    if ((!mm.name || mm.name === mm.uuid) && env.from?.uuid === mm.uuid && env.from?.name) mm.name = env.from.name;
                  }
                }
                // Ensure permission fields are preserved exactly as sent by owner
                // Keep the permissions as they are in the incoming roster
                mm.canAdd = m.canAdd;
                mm.canEdit = m.canEdit;
                mm.canDelete = m.canDelete;
                return mm;
              });
            } catch {}
            this.app.$set(g, 'members', list);
            // Update ownerUuid from roster if provided, and normalize roles
            if (typeof env.groupOwnerUuid === 'string' && env.groupOwnerUuid) this.app.$set(g, 'ownerUuid', env.groupOwnerUuid);
            if (g.ownerUuid) {
              // Ensure exactly one owner role matches ownerUuid
              g.members = g.members.map(m => {
                if (m.uuid === g.ownerUuid) return Object.assign({}, m, { role: 'owner' });
                if (m.role === 'owner') return Object.assign({}, m, { role: 'member' });
                return m;
              });
            } else {
              // Infer ownerUuid if missing
              const owner = list.find(m=>m.role==='owner');
              if (owner && owner.uuid) this.app.$set(g, 'ownerUuid', owner.uuid);
            }
            // Ensure inbound prefs exist and default allow for known members (do not override existing choices)
            try {
              if (!g.prefs) this.app.$set(g, 'prefs', { inbound: { perMember: {} } });
              if (!g.prefs.inbound) this.app.$set(g.prefs, 'inbound', { perMember: {} });
              if (!g.prefs.inbound.perMember) this.app.$set(g.prefs.inbound, 'perMember', {});
              const per = g.prefs.inbound.perMember;
              (list||[]).forEach(m => { if (!per[m.uuid]) per[m.uuid] = 'allow'; });
            } catch {}
          }
          this.app.saveData();
          try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
        } else if (env.type === 'group-update') {
          // Replace local state with provided snapshot (but preserve roster/permissions)
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          if (g) {
            // CRITICAL FIX: Version checking to prevent old updates overwriting new ones
            if (env.version && g.version && env.version < g.version) {
              debugLog('warn', '[SYNC] Ignoring older group-update', {
                incoming: env.version,
                current: g.version,
                from: env.from?.uuid
              });
              
              // Send back our newer version to help the sender sync up
              const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name || '' };
              const snapshot = {
                v: 1,
                type: 'group-update',
                ts: Date.now(),
                from,
                version: g.version,
                ...this.app.serializeGroupForSync(g),
                msgId: (Math.random().toString(36).slice(2) + Date.now())
              };
              
              try {
                debugLog('log', '[SYNC] Sending newer version back to', env.from?.uuid);
                this.sendToGroup(g, snapshot);
              } catch (e) {
                debugLog('error', '[SYNC] Failed to send newer version back', e);
              }
              return; // Don't apply the older update
            }
            
            // Update version if provided
            if (env.version) {
              g.version = env.version;
            }
            if (env.name) g.name = env.name;
            if (env.emoji !== undefined) g.emoji = env.emoji || '';
            if (env.shortcut !== undefined) this.app.$set(g, 'shortcut', this.app.normalizeShortcutText(env.shortcut || ''));
            if (env.color!==undefined) g.color = env.color;
            if (env.favicon !== undefined) {
              this.app.$set(g, 'favicon', env.favicon || '');
              this.app.$set(g, 'faviconError', false);
              this.app.$set(g, 'faviconLoading', false);
            }
            if (env.faviconSource !== undefined) this.app.$set(g, 'faviconSource', env.faviconSource || null);
            if (env.faviconRuleId !== undefined) this.app.$set(g, 'faviconRuleId', env.faviconRuleId || null);
            if (typeof env.opacity==='number') g.opacity = Math.max(0, Math.min(100, env.opacity));
            if (env.infoHtml !== undefined) g.infoHtml = this.app.sanitizeHtml(String(env.infoHtml || ''));
            if (env.urlPlaceholders !== undefined) this.app.$set(g, 'urlPlaceholders', this.app.normalizePlaceholderList(env.urlPlaceholders || []));
            // Note: We don't update members/roster here - that's handled by group-roster messages
            const isOwner = (g?.members||[]).some(m=>m.role==='owner' && m.uuid===this.app.data.identity?.uuid) || (g.ownerUuid===this.app.data.identity?.uuid);
            try { 
              debugLog('log', '[SYNC] handle group-update', { 
                isOwner, 
                links: Array.isArray(env.links)?env.links.length:0,
                sampleLink: env.links?.[0] ? { text: env.links[0].text, url: env.links[0].url, hasUrl: !!env.links[0].url } : null
              }); 
            } catch {}
            // Hydrate links for members on initial bootstrap even if event-log is present
            if (!isOwner) {
              const incomingLinks = Array.isArray(env.links)
                ? env.links
                : (env.snapshot && env.snapshot.data && Array.isArray(env.snapshot.data.links) ? env.snapshot.data.links : null);
              if (incomingLinks && (!Array.isArray(g.links) || g.links.length === 0)) {
                if (!Array.isArray(g.links)) this.app.$set(g, 'links', []);
                g.links = [];
                incomingLinks.forEach((l, i) => {
                  const col = (typeof l.column==='number') ? l.column : 0;
                  const idx = (typeof l.index==='number') ? l.index : i;
                  const nl = {
                    uuid: l.uuid || this.app.generateUUID(),
                    text: l.text || l.url || '',
                    url: l.url || '',
                    rawUrlInput: l.rawUrlInput || '',
                    urlPlaceholders: this.app.normalizePlaceholderList(l.urlPlaceholders || []),
                    keywords: l.keywords || '',
                    color: l.color || '',
                    emoji: l.emoji || '',
                    shortcut: l.shortcut || '',
                    infoHtml: this.app.sanitizeHtml(String(l.infoHtml || '')),
                    refTargetUuid: l.refTargetUuid || '',
                    inheritSourceKeywords: l.inheritSourceKeywords !== false,
                    column: col,
                    index: idx,
                    editing: false,
                    isMouseOver: false
                  };
                  this.app.$set(g.links, g.links.length, nl);
                });
              }
            }

            if (Array.isArray(env.links)) {
              if (isOwner) {
                // Owner is canonical; ignore incoming link snapshots to avoid overriding positions/order
                try { debugLog('log', '[SYNC] owner ignoring incoming link snapshot'); } catch {}
              } else {
                // Member: merge by remoteId (or URL) and preserve local order
                // Ensure g.links is an array
                if (!Array.isArray(g.links)) {
                  this.app.$set(g, 'links', []);
                }
                const ensure = (l)=>{
                  debugLog('log', '[SYNC] Processing link in group-update:', {
                    uuid: l.uuid,
                    text: l.text,
                    url: l.url,
                    hasUrl: !!l.url && l.url !== '',
                    urlType: typeof l.url,
                    urlLength: l.url ? l.url.length : 0
                  });
                  
                  // Find existing link by UUID (preferred)
                  let ex = null;
                  
                  // First try to find by UUID if available
                  if (l.uuid) {
                    ex = g.links.find(x => x.uuid === l.uuid);
                    if (ex) {
                      debugLog('log', '[SYNC] Found existing link by UUID in group-update');
                    }
                  }
                  
                  // Only use URL matching as fallback if both links have URLs
                  // Don't skip links without URLs
                  if (!ex && l.url && l.url.trim()) {
                    ex = g.links.find(x => x.url && this.app.urlsEqual(x.url, l.url));
                    if (ex) {
                      debugLog('log', '[SYNC] Found existing link by URL in group-update');
                    }
                  }
                  
                  if (ex) {
                    // Update existing link with reactive properties
                    debugLog('log', '[SYNC] Updating link - before:', { text: ex.text, url: ex.url });
                    this.app.$set(ex, 'text', l.text || '');
                    this.app.$set(ex, 'url', l.url || '');
                    this.app.$set(ex, 'rawUrlInput', l.rawUrlInput || '');
                    this.app.$set(ex, 'urlPlaceholders', this.app.normalizePlaceholderList(l.urlPlaceholders || []));
                    this.app.$set(ex, 'keywords', l.keywords || '');
                    this.app.$set(ex, 'color', l.color || '');
                    this.app.$set(ex, 'emoji', l.emoji || '');
                    this.app.$set(ex, 'shortcut', l.shortcut || '');
                    this.app.$set(ex, 'infoHtml', this.app.sanitizeHtml(String(l.infoHtml || '')));
                    this.app.$set(ex, 'refTargetUuid', l.refTargetUuid || '');
                    this.app.$set(ex, 'inheritSourceKeywords', l.inheritSourceKeywords !== false);
                    // Always preserve UUID consistency
                    if (l.uuid && !ex.uuid) this.app.$set(ex, 'uuid', l.uuid);
                    // Ensure reactive UI properties exist
                    if (ex.editing === undefined) this.app.$set(ex, 'editing', false);
                    if (ex.isMouseOver === undefined) this.app.$set(ex, 'isMouseOver', false);
                    debugLog('log', '[SYNC] Updated link - after:', { uuid: ex.uuid, text: ex.text, url: ex.url, hasUrl: !!ex.url && ex.url !== '' });
                  } else {
                    // Add new link with reactive properties - including those without URL
                    const col = (typeof l.column==='number') ? l.column : 0;
                    // compute next index in that column if none provided
                    const nextIdx = (() => { const arr=g.links.filter(x=>x.column===col); return arr.length? Math.max(...arr.map(x=>x.index||0))+1 : 0; })();
                    const idx = (typeof l.index==='number') ? l.index : nextIdx;
                    const nl = this.app.$set(g.links, g.links.length, { 
                      uuid: l.uuid || this.app.generateUUID(), // Use UUID from update or generate new one
                      text: l.text || '', // Links can have text without URL
                      url: l.url || '', // URL can be empty
                      rawUrlInput: l.rawUrlInput || '',
                      urlPlaceholders: this.app.normalizePlaceholderList(l.urlPlaceholders || []),
                      keywords: l.keywords || '', 
                      color: l.color || '',
                      emoji: l.emoji || '',
                      shortcut: l.shortcut || '',
                      infoHtml: this.app.sanitizeHtml(String(l.infoHtml || '')),
                      refTargetUuid: l.refTargetUuid || '',
                      inheritSourceKeywords: l.inheritSourceKeywords !== false,
                      column: col, 
                      index: idx, 
                      editing: false, 
                      isMouseOver: false 
                    });
                    try { debugLog('log', '[SYNC] added link from snapshot', { uuid: nl.uuid, column: nl.column, index: nl.index, text: nl.text, hasUrl: !!nl.url }); } catch {}
                  }
                };
                debugLog('log', '[SYNC] processing', env.links.length, 'links from update');
                env.links.forEach(ensure);
                // Final dedupe pass to avoid multiple occurrences
                this.dedupeGroupLinks(g);
                // tidy indices column-wise
                const cols = [...new Set((g.links||[]).map(x=>x.column))];
                cols.forEach(c => {
                  const arr = g.links.filter(x=>x.column===c).sort((a,b)=> (a.index||0)-(b.index||0));
                  arr.forEach((l,i)=> l.index = i);
                });
              }
            }
            
            // Apply event-log data if provided in the update - BUT DON'T OVERWRITE OWNER'S DATA
            if (env.useEventLog && env.eventLog) {
              const isOwner = (g?.members||[]).some(m=>m.role==='owner' && m.uuid===this.app.data.identity?.uuid) || (g.ownerUuid===this.app.data.identity?.uuid);
              
              if (isOwner) {
                // OWNER: Never overwrite own event-log, only merge new events
                debugLog('log', '[SYNC] Owner merging event-log from member update', {
                  currentEventCount: g.eventLog?.length || 0,
                  incomingEventCount: env.eventLog?.length || 0
                });
                
                // Only process if we already have event-log enabled
                if (g.useEventLog && g.eventLog) {
                  // Find new events that we don't have yet
                  const existingEventIds = new Set((g.eventLog || []).map(e => e.eventId));
                  const newEvents = (env.eventLog || []).filter(e => !existingEventIds.has(e.eventId));
                  
                  if (newEvents.length > 0) {
                    debugLog('log', '[SYNC] Owner found new events to merge', { count: newEvents.length });
                    // Merge new events using EventLogManager
                    if (this.app.eventLogManager) {
                      newEvents.forEach(event => {
                        this.app.eventLogManager.applyRemoteEvent(g, event, 'owner-leads');
                      });
                    }
                  }
                  
                  // Update vector clock by merging
                  if (env.vectorClock) {
                    const mergedVC = { ...(g.vectorClock || {}) };
                    Object.keys(env.vectorClock).forEach(key => {
                      mergedVC[key] = Math.max(mergedVC[key] || 0, env.vectorClock[key] || 0);
                    });
                    this.app.$set(g, 'vectorClock', mergedVC);
                  }
                } else if (!g.useEventLog) {
                  // Owner doesn't have event-log yet, but member does - enable it
                  debugLog('log', '[SYNC] Owner enabling event-log based on member data');
                  this.app.$set(g, 'useEventLog', true);
                  this.app.$set(g, 'eventLog', env.eventLog || []);
                  this.app.$set(g, 'snapshot', env.snapshot || null);
                  this.app.$set(g, 'headEventId', env.headEventId || null);
                  this.app.$set(g, 'vectorClock', env.vectorClock || {});
                }
              } else {
                // MEMBER: Accept event-log from owner or other members
                debugLog('log', '[SYNC] Member applying event-log data from group-update', {
                  eventLogCount: env.eventLog?.length || 0,
                  hasSnapshot: !!env.snapshot,
                  vectorClock: env.vectorClock
                });
                
                this.app.$set(g, 'useEventLog', true);
                this.app.$set(g, 'eventLog', env.eventLog || []);
                this.app.$set(g, 'snapshot', env.snapshot || null);
                this.app.$set(g, 'headEventId', env.headEventId || null);
                this.app.$set(g, 'vectorClock', env.vectorClock || {});
              }
            }
            
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
          }
        } else if (env.type === 'group-update-request') {
          // Respond with snapshot: ONLY the owner should respond
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          const isOwner = (g?.members||[]).some(m=>m.role==='owner' && m.uuid===this.app.data.identity?.uuid);
          if (!g) return;
          if (!isOwner) return; // Members do not respond to group-update-request
          try { debugLog('log', '[SYNC] respond group-update', { isOwner, to: env.from?.uuid, groupId: g.groupId }); } catch {}
          const snapshot = { 
            v:1, 
            type:'group-update', 
            ts:Date.now(), 
            from:{ uuid:this.app.data.identity.uuid, name:this.app.data.identity.name||'' }, 
            ...this.app.serializeGroupForSync(g), 
            msgId:(Math.random().toString(36).slice(2)+Date.now()) 
          };
          try { await this.sendChunkedGroup(g, 'group-update', snapshot); } catch {}
          // Also send the current roster if owner, so members get the latest permissions
          if (isOwner && g.members) {
            try {
              const rosterMsg = { v:1, type:'group-roster', ts:Date.now(), from:{ uuid:this.app.data.identity.uuid, name:this.app.data.identity.name||'' }, groupId: g.groupId, members: g.members||[] };
              await this.sendToGroup(g, rosterMsg);
              debugLog('log', '[SYNC] sent roster after update-request', { members: g.members.length });
            } catch {}
          }
        } else if (env.type === 'share-links') {
          // import into this group
          const sel = env.selection || {};
          // Resolve current up-to-date group reference by groupId only
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          
          // IMPORTANT: Ignore share-links if event-log is active
          if (g && g.useEventLog) {
            debugLog('log', '[SYNC] Ignoring share-links because event-log is active for group', g.name);
            return;
          }
          
          // inbound filter by prefs
          const fromUuid = env.from?.uuid;
          const prefs = g?.prefs?.inbound;
          if (prefs) {
            const per = prefs.perMember || {};
            const st = per[fromUuid] || 'unset';
            // For owner: always allow updates from all members
            // For members: allow by default unless explicitly denied  
            const isOwner = this.app.isOwnerOfGroup(g);
            const allow = isOwner || st==='allow' || st==='unset';
            try { debugLog('log', '[SYNC] inbound share-links filter', { from: fromUuid, state: st, isOwner, allow }); } catch {}
            if (!allow) { try { debugLog('warn', '[SYNC] share-links blocked by inbound prefs'); } catch {} return; }
          }
          if (Array.isArray(sel.links)) {
            debugLog('log', '[SYNC] Processing share-links', { 
              count: sel.links.length, 
              sample: sel.links[0] ? { 
                uuid: sel.links[0].uuid, 
                text: sel.links[0].text, 
                url: sel.links[0].url, 
                hasUrl: !!sel.links[0].url 
              } : null 
            });
            
            sel.links.forEach((l,i)=>{
              debugLog('log', '[SYNC] Processing incoming link:', {
                uuid: l.uuid,
                text: l.text,
                url: l.url,
                hasUrl: !!l.url && l.url !== '',
                urlLength: l.url ? l.url.length : 0
              });
              
              // IMPORTANT: With UUIDs, we must check for UUID match first
              let ex = null;
              
              // First priority: Match by UUID (this is the primary identifier now)
              if (l.uuid) {
                ex = (g.links||[]).find(x => x.uuid === l.uuid);
                if (ex) {
                  debugLog('log', '[SYNC] Found existing link by UUID:', l.uuid, 'existing url:', ex.url, 'new url:', l.url);
                }
              }
              
              // Fallback: URL match (only if no UUID match and URL exists)
              if (!ex && l.url && l.url.trim()) {
                ex = (g.links||[]).find(x => x.url && this.app.urlsEqual(x.url, l.url));
                if (ex) {
                  debugLog('log', '[SYNC] Found existing link by URL match');
                }
              }
              
              if (ex) {
                // Update existing link with reactive properties
                debugLog('log', '[SYNC] Updating existing link - before:', { text: ex.text, url: ex.url });
                this.app.$set(ex, 'text', l.text || '');
                this.app.$set(ex, 'url', l.url || '');
                this.app.$set(ex, 'rawUrlInput', l.rawUrlInput || '');
                this.app.$set(ex, 'urlPlaceholders', this.app.normalizePlaceholderList(l.urlPlaceholders || []));
                this.app.$set(ex, 'keywords', l.keywords || '');
                this.app.$set(ex, 'color', l.color || '');
                this.app.$set(ex, 'emoji', l.emoji || '');
                this.app.$set(ex, 'shortcut', l.shortcut || '');
                this.app.$set(ex, 'infoHtml', this.app.sanitizeHtml(String(l.infoHtml || '')));
                this.app.$set(ex, 'refTargetUuid', l.refTargetUuid || '');
                this.app.$set(ex, 'inheritSourceKeywords', l.inheritSourceKeywords !== false);
                // Ensure UUID is set if provided
                if (l.uuid && !ex.uuid) this.app.$set(ex, 'uuid', l.uuid);
                // Ensure reactive UI properties exist
                if (ex.editing === undefined) this.app.$set(ex, 'editing', false);
                if (ex.isMouseOver === undefined) this.app.$set(ex, 'isMouseOver', false);
                debugLog('log', '[SYNC] Updated existing link - after:', { uuid: ex.uuid, text: ex.text, url: ex.url });
              } else {
                // Create new link with UUID and reactive properties - including links without URL
                const col = (typeof l.column==='number') ? l.column : 0;
                const nextIdx = (() => { const arr=(g.links||[]).filter(x=>x.column===col); return arr.length? Math.max(...arr.map(x=>x.index||0))+1 : 0; })();
                const idx = (typeof l.index==='number') ? l.index : nextIdx;
                const newLink = this.app.$set(g.links, g.links.length, { 
                  uuid: l.uuid || this.app.generateUUID(), // Ensure UUID exists 
                  text: l.text || '', // Links can have only text
                  url: l.url || '', // URL can be empty
                  rawUrlInput: l.rawUrlInput || '',
                  urlPlaceholders: this.app.normalizePlaceholderList(l.urlPlaceholders || []),
                  keywords: l.keywords || '',
                  color: l.color || '',
                  emoji: l.emoji || '',
                  shortcut: l.shortcut || '',
                  infoHtml: this.app.sanitizeHtml(String(l.infoHtml || '')),
                  refTargetUuid: l.refTargetUuid || '',
                  inheritSourceKeywords: l.inheritSourceKeywords !== false,
                  column: col, 
                  index: idx, 
                  editing: false, 
                  isMouseOver: false 
                });
                debugLog('log', '[SYNC] Added new link from share-links:', { 
                  uuid: newLink.uuid, 
                  text: newLink.text, 
                  url: newLink.url,
                  hasUrl: !!newLink.url && newLink.url !== '',
                  column: newLink.column, 
                  index: newLink.index 
                });
              }
            });
            // Final dedupe pass to avoid multiple occurrences
            this.dedupeGroupLinks(g);
            // normalize per-column indices
            const cols = [...new Set((g.links||[]).map(x=>x.column))];
            cols.forEach(c => {
              const arr = g.links.filter(x=>x.column===c).sort((a,b)=> (a.index||0)-(b.index||0));
              arr.forEach((l,i)=> l.index=i);
            });
            this.app.saveData();
            // Force Vue to recalc classes that depend on reactive props
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
          }
        } else if (env.type === 'link-delete' && env.link) {
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          if (!g) return;
          
          // CRITICAL FIX: Version checking for delete operations
          if (env.version && g.version && env.version < g.version) {
            debugLog('warn', '[SYNC] Ignoring link-delete from older version', {
              incoming: env.version,
              current: g.version,
              link: env.link?.uuid || env.link?.url,
              from: env.from?.uuid
            });
            // Don't send back update here - the sender will sync via other means
            return;
          }
          const luuid = env.link.uuid;
          const lid = env.link.id; // Legacy - not used anymore
          const lurl = env.link.url;
          let idx = -1;
          let col = 0;
          if (Array.isArray(g.links)) {
            // First try to find by UUID (preferred)
            if (luuid) {
              idx = g.links.findIndex(x => x.uuid === luuid);
            }
            // Fallback to URL matching if no UUID
            if (idx < 0 && lurl) {
              idx = g.links.findIndex(x => this.app.urlsEqual(x.url, lurl));
            }
            if (idx >= 0) col = g.links[idx].column||0;
          }
          if (idx >= 0) {
            g.links.splice(idx,1);
            const colLinks = (g.links||[]).filter(l=>l.column===col).sort((a,b)=>a.index-b.index);
            colLinks.forEach((l,i)=>{ l.index=i; });
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
            try { debugLog('log', '[SYNC] link-delete applied', { lid, lurl, col }); } catch {}
          } else {
            try { debugLog('warn', '[SYNC] link-delete could not find local link', { lid, lurl }); } catch {}
          }
        }
      }
      async sendOwnerSync(group) {
        // Owner initiates snapshot + request once on open
        // Get fresh group data to ensure we have the latest UUIDs after any migrations
        const freshGroup = this.app.data.groups?.find(g => g.uuid === group.uuid) || group;
        const isOwner = (freshGroup?.members||[]).some(m=>m.role==='owner' && m.uuid===this.app.data.identity?.uuid);
        if (!freshGroup || !freshGroup.shared || !isOwner) return;
        const from = { uuid:this.app.data.identity.uuid, name:this.app.data.identity.name||'' };
        // Ensure every link has a UUID before sending
        const linksWithUUIDs = (freshGroup.links||[]).map(l => {
          if (!l.uuid) {
            debugLog('warn', '[SYNC] Link missing UUID during owner sync:', l.text || l.url);
            // Generate UUID only if missing (should not happen after migration)
            l.uuid = this.app.generateUUID ? this.app.generateUUID() : this.generateUUID();
          }
          return this.app.serializeLinkForSync(l);
        });
        const snapshot = { 
          v:1, 
          type:'group-update', 
          ts:Date.now(), 
          from, 
          ...this.app.serializeGroupForSync(freshGroup),
          msgId:(Math.random().toString(36).slice(2)+Date.now()) 
        };
        try { debugLog('log', '[SYNC] owner snapshot+request', { topic: freshGroup.groupTopic, links: linksWithUUIDs.length, uuids: linksWithUUIDs.map(l => l.uuid) }); } catch {}
        try { await this.sendToGroup(freshGroup, snapshot); } catch {}
        const reqId = (Math.random().toString(36).slice(2)+Date.now());
        try { await this.sendToGroup(freshGroup, { v:1, type:'group-update-request', ts:Date.now(), from, groupId: freshGroup.groupId, msgId:reqId }); } catch {}
      }
      async inviteContactToGroup(group, contactUuid) {
        await this.ensureIdentity();
        // Ensure pairwise channel is derived and subscribed before sending invite
        try { await this.derivePairwiseFor(contactUuid); } catch {}
        
        // Get fresh group data to ensure we have the latest UUIDs after any migrations
        const freshGroup = this.app.data.groups?.find(g => g.uuid === group.uuid) || group;
        
        if (!freshGroup.shared || !freshGroup.groupId) {
          // Group is not shared yet OR was previously shared but is now unshared
          this.app.$set(freshGroup, 'shared', true);
          
          // Only generate new sharing properties if they don't exist
          // This preserves groupId for previously shared groups
          if (!freshGroup.groupId) {
            this.app.$set(freshGroup, 'groupId', this.genGroupId());
          }
          if (!freshGroup.groupKey) {
            this.app.$set(freshGroup, 'groupKey', this.genGroupKeyB64());
          }
          if (!freshGroup.groupTopic) {
            this.app.$set(freshGroup, 'groupTopic', this.genGroupTopic());
          }
          
          this.app.$set(freshGroup, 'ownerUuid', this.app.data.identity?.uuid || '');
          // persist newly shared state on owner side
          this.app.saveData();
          this.subscribeGroup(freshGroup);
          // send initial meta
          await this.sendToGroup(freshGroup, { 
            v:1, 
            type:'group-meta', 
            ts:Date.now(), 
            from:{uuid:this.app.data.identity.uuid,name:this.app.data.identity.name||''}, 
            groupId: freshGroup.groupId, 
            ...this.app.serializeGroupMetaForSync(freshGroup) 
          });
        }
        // Update and send roster
        if (!Array.isArray(freshGroup.members)) this.app.$set(freshGroup,'members',[]);
        const owner = { uuid: this.app.data.identity.uuid, name: this.app.data.identity.name||'' , role:'owner' };
        const contact = (this.app.data.contacts||[]).find(c=>c.uuid===contactUuid);
        // New member starts with basic permissions (owner can adjust later)
        // Start with add/edit permissions enabled for better collaboration experience
        const invited = { uuid: contactUuid, name: contact?.name||contactUuid, role:'member', canAdd:true, canEdit:true, canDelete:false };
        const uniqBy = (arr,key) => Object.values(arr.reduce((m,x)=>{m[x[key]]=x;return m;},{}));
        freshGroup.members = uniqBy([owner, ...(freshGroup.members||[]), invited],'uuid');
        // persist updated roster on owner side
        this.app.saveData();
        await this.sendToGroup(freshGroup, { v:1, type:'group-roster', ts:Date.now(), from:{uuid:this.app.data.identity.uuid,name:this.app.data.identity.name||''}, groupId: freshGroup.groupId, members: freshGroup.members });
        
        // Ensure all links have UUIDs before sending in invite
        const linksWithUUIDs = (freshGroup.links||[]).map(l => {
          if (!l.uuid) {
            debugLog('warn', '[INVITE] Link missing UUID:', l.text || l.url);
            // This should not happen after migration, but ensure UUID exists
            l.uuid = this.app.generateUUID ? this.app.generateUUID() : this.generateUUID();
            this.app.saveData(); // Save if we had to generate any UUIDs
          }
          return this.app.serializeLinkForSync(l);
        });
        
        debugLog('log', '[INVITE] Sending links with UUIDs:', linksWithUUIDs.map(l => ({ uuid: l.uuid, text: l.text })));
        debugLog('log', '[INVITE] Group event-log status:', {
          useEventLog: freshGroup.useEventLog,
          eventLogCount: freshGroup.eventLog?.length || 0,
          hasSnapshot: !!freshGroup.snapshot,
          headEventId: freshGroup.headEventId,
          vectorClock: freshGroup.vectorClock
        });
        
        // Keep invite lightweight to avoid ntfy attachments on pairwise channel
        // Full snapshot is delivered via group topic after subscribe
        const inviteSelection = { groups: [], links: [] };
        const invite = { 
          v:1, 
          type:'invite', 
          ts:Date.now(), 
          from:{uuid:this.app.data.identity.uuid,name:this.app.data.identity.name||''}, 
          groupId: freshGroup.groupId, 
          groupName: freshGroup.name, 
          groupColor: freshGroup.color||'', 
          groupOpacity: (typeof freshGroup.opacity==='number'?freshGroup.opacity:100), 
          urlPlaceholders: this.app.normalizePlaceholderList(freshGroup.urlPlaceholders || []),
          groupOwnerUuid: (freshGroup.ownerUuid||this.app.data.identity?.uuid||''), 
          groupTopic: freshGroup.groupTopic, 
          groupKey: freshGroup.groupKey, 
          roles:['member'], 
          members: freshGroup.members||[], 
          selection: inviteSelection,
          // Only signal if event-log is used; no heavy payload here
          useEventLog: !!freshGroup.useEventLog
        };
        // Final safety: ensure contact has channel
        const c = (this.app.data.contacts||[]).find(x=>x.uuid===contactUuid);
        if (!c || !c.topic || !c.kChannelB64) {
          debugLog('warn', '[INVITE] Cannot send invite: contact channel missing', { contactUuid });
          return;
        }
        await this.sendToContact(contactUuid, invite);
        // Also bootstrap member with a pairwise full snapshot (chunked)
        try {
          const snapshot = { 
            v:1, 
            type:'group-update', 
            ts:Date.now(), 
            from:{ uuid:this.app.data.identity.uuid, name:this.app.data.identity.name||'' }, 
            ...this.app.serializeGroupForSync(freshGroup), 
            msgId:(Math.random().toString(36).slice(2)+Date.now()) 
          };
          await this.sendChunkedToContact(contactUuid, 'group-update', snapshot);
          debugLog('log','[INVITE] Pairwise chunked group-update sent to invited contact');
        } catch (e) { debugLog('warn','[INVITE] Pairwise snapshot failed', e); }
        // Proactively send full snapshot over group topic shortly after invite
        try {
          setTimeout(async () => {
            try {
              const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name || '' };
              const snapshot = {
                v: 1,
                type: 'group-update',
                ts: Date.now(),
                from,
                ...this.app.serializeGroupForSync(freshGroup),
                msgId: (Math.random().toString(36).slice(2) + Date.now())
              };
              // Use chunked transfer to avoid ntfy attachments for large payloads
              await this.sendChunkedGroup(freshGroup, 'group-update', snapshot);
              debugLog('log', '[INVITE] Proactive chunked group-update snapshot sent');
            } catch (e) { debugLog('warn', '[INVITE] Proactive snapshot failed', e); }
          }, 800);
        } catch {}
      }
      // Quick-Connect: rendezvous (offer/answer) and secure card exchange using ephemeral ECDH
      async quickCodeReceiveStart(code) {
        this.applyConfig();
        const topic = `mb-qc-${code}`; // avoid '/' in topic for broad server compatibility
        this.qcTopic = topic; this.qcCode = code;
        this.qcSeen = new Set(); this.qcAnswered = false;
        if (this.qcSub) { 
          try {
            if (this.qcSub.es && this.qcSub.es.close) this.qcSub.es.close();
            if (this.qcSub.lp && this.qcSub.lp.abort) this.qcSub.lp.abort();
          } catch {}
          this.qcSub = null; 
        }
        this.onQcStatus && this.onQcStatus({ phase: 'waiting', side: 'receiver', code, topic });
        this.qcSub = this.ntfy.subscribe(topic, async (evt) => {
          try {
            if (evt && evt.id && this.qcSeen && this.qcSeen.has(evt.id)) return; if (evt && evt.id && this.qcSeen) this.qcSeen.add(evt.id);
            const msg = JSON.parse(evt.text);
            if (msg?.type === 'qc-offer' && msg.epub) {
              this.onQcStatus && this.onQcStatus({ phase: 'offer_received' });
              if (!this.qcAnswered) { this.qcAnswered = true; await this.handleQcOffer(topic, msg); }
            } else if (msg?.type === 'qc-final' && msg.payload) {
              const kTemp = this.qcSecrets.get(topic);
              if (!kTemp) return;
              const plain = await CryptoUtil.aesDecrypt(kTemp, msg.payload);
              if (plain?.card) {
                await this.addContactFromCard(plain.card);
                await this.derivePairwiseFor(plain.card.uuid);
              }
              this.onQcStatus && this.onQcStatus({ phase: 'final_received', done: true });
              try { this.qcSub && this.qcSub.close(); } catch {}
              try { this.ntfy.unsubscribe(this.qcTopic); } catch {}
            }
          } catch { /* ignore */ }
        });
      }
      async handleQcOffer(topic, offer) {
        const eph = await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']);
        const otherEpub = await CryptoUtil.importPub(offer.epub);
        const shared = await CryptoUtil.deriveBits(eph.privateKey, otherEpub);
        const kTemp = await CryptoUtil.hkdf(shared, 'mybookmarks:qc-temp', 32);
        await this.ensureIdentity();
        const plaintext = { v: 1, type: 'qc-answer', ts: Date.now(), from: { uuid: this.app.data.identity.uuid, name: this.app.data.identity.name || '' }, card: this.getContactCard() };
        const payload = await CryptoUtil.aesEncrypt(kTemp, plaintext);
        const myEpubB64 = B64.enc(new Uint8Array(await crypto.subtle.exportKey('raw', eph.publicKey)));
        this.qcSecrets.set(topic, kTemp);
        try {
          await this.ntfy.publish(topic, JSON.stringify({ type: 'qc-answer', epub: myEpubB64, payload }), this.cfg.quickCodeTtlSec || CONSTS.QUICK_CODE_TTL_SEC);
        } catch(e) { try { debugLog('error','[QC] publish qc-answer failed', e); } catch {} }
        this.onQcStatus && this.onQcStatus({ phase: 'answer_sent' });
      }
      async quickCodeSendOffer(code) {
        this.applyConfig();
        const topic = `mb-qc-${code}`; // avoid '/' in topic for broad server compatibility
        this.qcTopic = topic; this.qcCode = code; this.qcSeen = new Set();
        // Close any existing subscription first
        if (this.qcSub) { try { this.qcSub.close(); } catch {} this.qcSub = null; }
        // ephemeral key
        const eph = await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']);
        const epubB64 = B64.enc(new Uint8Array(await crypto.subtle.exportKey('raw', eph.publicKey)));
        this.qcSub = this.ntfy.subscribe(topic, async (evt) => {
          try {
            if (evt && evt.id && this.qcSeen && this.qcSeen.has(evt.id)) return; if (evt && evt.id && this.qcSeen) this.qcSeen.add(evt.id);
            const msg = JSON.parse(evt.text);
            if (msg?.type === 'qc-answer' && msg.payload && msg.epub) {
              this.onQcStatus && this.onQcStatus({ phase: 'answer_received' });
              const otherEpub = await CryptoUtil.importPub(msg.epub);
              const shared = await CryptoUtil.deriveBits(eph.privateKey, otherEpub);
              const kTemp = await CryptoUtil.hkdf(shared, 'mybookmarks:qc-temp', 32);
              const plain = await CryptoUtil.aesDecrypt(kTemp, msg.payload);
              if (plain?.card) {
                await this.addContactFromCard(plain.card);
                // auto-derive pairwise
                await this.derivePairwiseFor(plain.card.uuid);
              }
              // Send back our card encrypted with the same temporary key (finalize pairing for receiver)
              const myCard = this.getContactCard();
              const finalPayload = await CryptoUtil.aesEncrypt(kTemp, { v: 1, type: 'qc-final', ts: Date.now(), from: { uuid: this.app.data.identity.uuid, name: this.app.data.identity.name || '' }, card: myCard });
              await this.ntfy.publish(topic, JSON.stringify({ type: 'qc-final', payload: finalPayload }), this.cfg.quickCodeTtlSec || CONSTS.QUICK_CODE_TTL_SEC);
              this.onQcStatus && this.onQcStatus({ phase: 'final_sent', done: true });
              try { 
                if (this.qcSub) {
                  if (this.qcSub.es && this.qcSub.es.close) this.qcSub.es.close();
                  if (this.qcSub.lp && this.qcSub.lp.abort) this.qcSub.lp.abort();
                }
              } catch { }
              try { this.ntfy.unsubscribe(this.qcTopic); } catch {}
            }
          } catch (e) { /* ignore */ }
        });
        try {
          await this.ntfy.publish(topic, JSON.stringify({ v: 1, type: 'qc-offer', ts: Date.now(), from: { name: this.app.data.identity?.name || '' }, epub: epubB64 }), this.cfg.quickCodeTtlSec || CONSTS.QUICK_CODE_TTL_SEC);
        } catch(e) { try { debugLog('error','[QC] publish qc-offer failed', e); } catch {} }
        this.onQcStatus && this.onQcStatus({ phase: 'offer_sent', side: 'sender', code, topic });
        // Return a promise that resolves when answer handled
        return new Promise((resolve) => {
          const handler = async (data) => {
            try {
              const msg = JSON.parse(data);
              if (msg?.type === 'qc-answer' && msg.payload && msg.epub) { resolve(true); }
            } catch { }
          };
          if (this.qcSub) this.qcSub.onmessage = (ev) => handler(ev.data);
          // timeout safety
          setTimeout(() => { 
            try { 
              if (this.qcSub) {
                if (this.qcSub.es && this.qcSub.es.close) this.qcSub.es.close();
                if (this.qcSub.lp && this.qcSub.lp.abort) this.qcSub.lp.abort();
              }
            } catch { } 
            this.qcSub = null; 
            resolve(null); 
          }, (this.cfg.quickCodeTtlSec || CONSTS.QUICK_CODE_TTL_SEC) * 1000);
        });
      }
      quickCodeStop() { 
        try { 
          if (this.qcSub) {
            // qcSub is a handles object with { es, lp, closed } structure
            if (this.qcSub.es && this.qcSub.es.close) this.qcSub.es.close();
            if (this.qcSub.lp && this.qcSub.lp.abort) this.qcSub.lp.abort();
            // Also unsubscribe from ntfy topic
            if (this.qcTopic) this.ntfy.unsubscribe(this.qcTopic);
          }
        } catch (e) { 
          debugLog('warn', '[QC] Error closing subscription:', e); 
        } 
        this.qcSub = null; 
        this.qcSecrets.clear(); 
        this.onQcStatus && this.onQcStatus({ phase: 'stopped' }); 
      }
      async onEnvelope(env, meta) {
        // Ignore self-echo on pairwise channels to avoid acting on our own messages
        try {
          if (meta?.scope === 'pair' && env?.from?.uuid && this.app.data.identity?.uuid && env.from.uuid === this.app.data.identity.uuid) {
            return;
          }
        } catch {}
        
        // Check if sender is blocked (removed contact)
        if (env?.from?.uuid && this.app.data.blockedContacts?.includes(env.from.uuid)) {
          debugLog('log', '[SECURITY] Dropping message from blocked contact:', env.from.uuid);
          return;
        }
        
        // Dedup by msgId if present
        if (env && env.msgId && this.app.processedMsgIds && this.app.processedMsgIds.has(env.msgId)) return;

        // Pairwise chunked sync (initial snapshot bootstrap)
        if (meta?.scope==='pair' && (env?.type==='sync-chunk' || env?.type==='sync-chunks-done')) {
          try {
            const tId = env.transferId;
            if (!tId) return;
            let buf = this.groupTransfers.get(tId);
            if (!buf) {
              if (this.groupTransfers.size >= CONSTS.MAX_CONCURRENT_TRANSFERS) return;
              buf = { groupId: env.groupId || null, contentType: env.contentType||'snapshot', total: env.total||0, parts: new Map(), timer: null, from: env.from?.uuid, bytes: 0 };
              this.groupTransfers.set(tId, buf);
              buf.timer = setTimeout(()=>{ this.groupTransfers.delete(tId); }, CONSTS.MINUTE_MS);
            }
            if (env.type==='sync-chunk') {
              if (typeof env.seq==='number' && typeof env.payloadB64==='string') {
                buf.parts.set(env.seq, env.payloadB64);
                buf.bytes += env.payloadB64.length;
                if (env.total && !buf.total) buf.total = env.total;
                if (buf.total && buf.parts.size===buf.total) {
                  try {
                    const ordered = Array.from({ length: buf.total }, (_, i)=> buf.parts.get(i)||'');
                    const bytes = B64.dec(ordered.join(''));
                    const json = new TextDecoder().decode(bytes);
                    const fullEnv = JSON.parse(json);
                    const g = (this.app.data.groups||[]).find(x=> x.groupId === fullEnv.groupId);
                    if (g) this.handleGroupEnvelope(g, fullEnv);
                  } catch(e) { debugLog('warn','[PAIR] early chunk reassembly failed', e); }
                  if (buf.timer) clearTimeout(buf.timer);
                  this.groupTransfers.delete(tId);
                }
              }
              return;
            }
            if (env.type==='sync-chunks-done') {
              const total = buf.total || env.total || 0;
              if (total>0 && buf.parts.size===total) {
                const ordered = Array.from({ length: total }, (_, i)=> buf.parts.get(i)||'');
                const bytes = B64.dec(ordered.join(''));
                const json = new TextDecoder().decode(bytes);
                const fullEnv = JSON.parse(json);
                // Dispatch to group handler
                const g = (this.app.data.groups||[]).find(x => x.groupId === fullEnv.groupId);
                if (g) this.handleGroupEnvelope(g, fullEnv);
              }
              if (buf.timer) clearTimeout(buf.timer);
              this.groupTransfers.delete(tId);
              return;
            }
          } catch (e) { debugLog('warn','[PAIR] chunk reassembly failed', e); }
        }
        
        // Show invitation dialog for group invites (don't mark as processed yet)
        if (meta?.scope==='pair' && env?.type==='invite' && env.groupTopic && env.groupKey) {
          this.app.showInvitationDialog('group', env);
          return;
        }
        
        // Show invitation dialog for shared links or groups (don't mark as processed yet)
        if (meta?.scope==='pair' && env?.type==='share' && env?.selection && (env.selection.links || env.selection.groups)) {
          this.app.showInvitationDialog('link', env);
          return;
        }
        
        // Mark as processed for other message types
        if (env && env.msgId && this.app.processedMsgIds) this.app.processedMsgIds.add(env.msgId);
        // Handle membership updates over pairwise
        if (meta?.scope==='pair' && env?.type==='group-member-removed' && env.groupId) {
          debugLog('log', '[GROUP_REMOVED] Received removal notification for group:', env.groupId);
          // Unsubscribe and remove local group
          const gs = (this.app.data.groups||[]);
          const idx = gs.findIndex(x=>x.groupId===env.groupId);
          if (idx>=0) {
            const groupName = gs[idx].name;
            debugLog('log', '[GROUP_REMOVED] Removing group:', groupName, 'with id:', env.groupId);
            try { 
              if (gs[idx].groupTopic) {
                // Unsubscribe from NTFY
                this.ntfy.unsubscribe(gs[idx].groupTopic);
                // Also remove from groupSubs map to allow re-subscription later
                if (this.groupSubs && this.groupSubs.has(gs[idx].groupTopic)) {
                  this.groupSubs.delete(gs[idx].groupTopic);
                  debugLog('log', '[GROUP_REMOVED] Removed from groupSubs:', gs[idx].groupTopic);
                }
              }
            } catch (e) {
              debugLog('error', '[GROUP_REMOVED] Failed to unsubscribe:', e);
            }
            gs.splice(idx,1);
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
            debugLog('log', '[GROUP_REMOVED] Successfully removed group:', groupName);
          } else {
            debugLog('warn', '[GROUP_REMOVED] Group not found with id:', env.groupId);
          }
          return;
        }
        if (meta?.scope==='pair' && env?.type==='group-member-left' && env.groupId && env.memberUuid) {
          // Owner's side: remove member and broadcast roster
          const g = (this.app.data.groups||[]).find(x=>x.groupId===env.groupId);
          if (g) {
            g.members = (g.members||[]).filter(x=>x.uuid!==env.memberUuid);
            // Auto-unshare when only owner remains or no regular members
            try {
              const noMembers = !g.members || g.members.length === 0;
              const onlyOwnerRemains = g.members && g.members.length === 1 && g.members[0].role === 'owner';
              const noRegularMembers = g.members && g.members.length > 0 && !g.members.some(x => x.role === 'member');
              if (g.shared && (noMembers || onlyOwnerRemains || noRegularMembers)) {
                debugLog('log', '[SHARE] Auto-unshare after member left:', g.name,
                  noMembers ? '(no members)' : onlyOwnerRemains ? '(only owner remains)' : '(no regular members)');
                g.shared = false;
                try { if (g.groupTopic) this.ntfy.unsubscribe(g.groupTopic); } catch (e) { debugLog('warn','[SHARE] Unsubscribe failed', e); }
              }
            } catch {}

            this.app.saveData();
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
            
            // Only broadcast roster if group is still shared
            if (g.shared) {
              try { await this.sendToGroup(g, { v:1, type:'group-roster', ts:Date.now(), from:{ uuid:this.app.data.identity?.uuid, name:this.app.data.identity?.name||'' }, groupId: g.groupId, members: g.members||[] }); } catch {}
            }
          }
          return;
        }
        // Contact update: refresh contact name and affected group rosters
        if (meta?.scope==='pair' && env?.type==='contact-update' && env.from?.uuid) {
          try {
            const uuid = env.from.uuid;
            const name = env.from.name || '';
            const contacts = (this.app.data.contacts||[]);
            const c = contacts.find(x=>x.uuid===uuid);
            if (c && name && c.name!==name) { c.name = name; }
            // Update rosters where this member exists
            for (const g of (this.app.data.groups||[])) {
              if (Array.isArray(g.members)) {
                let changed = false;
                g.members = g.members.map(m=>{
                  if (m.uuid===uuid && name && m.name!==name) { changed=true; return Object.assign({}, m, { name }); }
                  return m;
                });
                if (changed) { /* local change suffices; owner will broadcast */ }
              }
            }
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
          } catch {}
          return;
        }
        // Handle ping/pong for online status checking
        if (env?.type === 'ping' && env?.pingId) {
          // Extract sender UUID - it might be directly in 'from' field or in 'from.uuid'
          const senderUuid = typeof env.from === 'string' ? env.from : env.from?.uuid;
          debugLog('log', '[PING/PONG] Received ping from:', senderUuid, 'with ID:', env?.pingId);
          
          // Don't respond to our own pings
          if (senderUuid === this.app.data.identity?.uuid) {
            debugLog('log', '[PING/PONG] Ignoring self-ping');
            return;
          }
          
          // Automatically respond with pong
          try {
            const contact = (this.app.data.contacts || []).find(c => c.uuid === senderUuid);
            if (contact) {
              const pongMessage = {
                type: 'pong',
                pingId: env.pingId, // Echo back the same ID
                from: this.app.data.identity?.uuid,
                timestamp: Date.now()
              };
              await this.sendToContact(contact.uuid, pongMessage);
              debugLog('log', '[PING/PONG] Sent pong response to:', contact.uuid);
            } else {
              debugLog('warn', '[PING/PONG] No contact found for UUID:', senderUuid);
            }
          } catch (e) {
            debugLog('error', '[PING/PONG] Failed to send pong:', e);
          }
          return;
        }
        
        // Handle pong responses
        if (env?.type === 'pong' && env?.pingId) {
          // Extract sender UUID - it might be directly in 'from' field or in 'from.uuid'
          const senderUuid = typeof env.from === 'string' ? env.from : env.from?.uuid;
          debugLog('log', '[PING/PONG] Received pong from:', senderUuid, 'with ID:', env?.pingId);
          
          // Trigger any waiting promise for this pingId
          if (this.app.pendingPings && this.app.pendingPings[env.pingId]) {
            this.app.pendingPings[env.pingId].resolve(true);
            delete this.app.pendingPings[env.pingId];
          }
          return;
        }
        
        // For any other message types, we can optionally log them but don't store in inbox
        debugLog('log', '[MESSAGE] Received message type:', env?.type, 'from:', env?.from?.name || env?.from?.uuid);
      }
      
      dedupeGroupLinks(group) {
        if (!group || !Array.isArray(group.links)) return;
        const seen = new Map();
        const deduped = [];
        
        for (const link of group.links) {
          // Use UUID for deduplication if available, otherwise fall back to URL
          const key = link.uuid 
            ? `uuid:${link.uuid}` 
            : `url:${this.app.normalizeUrl ? this.app.normalizeUrl(link.url) : link.url}`;
          
          if (!seen.has(key)) {
            seen.set(key, true);
            deduped.push(link);
          } else {
            // If we find a duplicate, keep the one with more information
            const existing = deduped.find(l => {
              const existingKey = l.uuid 
                ? `uuid:${l.uuid}` 
                : `url:${this.app.normalizeUrl ? this.app.normalizeUrl(l.url) : l.url}`;
              return existingKey === key;
            });
            // Update existing link with any missing information
            if (existing) {
              if (!existing.uuid && link.uuid) existing.uuid = link.uuid;
              if (!existing.text && link.text) existing.text = link.text;
              if (!existing.keywords && link.keywords) existing.keywords = link.keywords;
            }
          }
        }
        
        group.links = deduped;
      }
    }

    MB.Sync.SharingService = SharingService;

    const initialData = {
      groups: [],
      snapshots: [],
      schemaVersion: 1,
      identity: { uuid: '', name: '', pubKey: '', privKey: '' },
      contacts: [],
      inbox: [],
      pendingNcDeletes: [],
      options: { // Default options structure
        common: {
          language: 'en',
          pageTitle: 'My Bookmarks',
          searchAsYouType: false,
          manualGroupColumnWidth: false,
          debugEnabled: false,
          confirmDeleteGroup: true,
        confirmDeleteLink: true,
        },
        groups: {
          collapseGroupsOnStart: false,
          hoverExpandDelayMs: CONSTS.HOVER_EXPAND_DELAY_MS,
          hoverExpandEnabled: true,
          autoAdjustHeightOnLinkChanges: false,
          columnWidths: {},
          defaultGroupFormatting: '',
          defaultGroupTitleFormatting: '',
          defaultGroupLinkFormatting: '',
          defaultGroupBadgeFormatting: '',
          defaultGroupPillFormatting: '',
          defaultLinkFormatting: '',
          clearClosesAllGroups: false,
          keywordClickExpandsAll: false,
          searchAutoExpandFound: false,
        },
        links: {
          openInNewTab: true,
          addViaDialog: false,
          autoFetchTitle: false,
          autoFetchFavicon: false,
          allowExternalFaviconService: false,
          showLinkBadges: false,
          showReferenceMarker: true,
          showLinkPopover: true,
          progressiveLoadingThreshold: CONSTS.PROGRESSIVE_LOADING_THRESHOLD,
          copyUrlFormat: '{title}: {url}', // Customizable format for copying links
          defaultUrlPrefix: CONSTS.DEFAULT_URL_PREFIX,
          globalShortcuts: [],
          globalPlaceholders: [],
          noteCollapsedState: {},
          faviconRules: getDefaultFaviconRules()
        },
        buttons: {
          // Group quick-action buttons
          showAddLink: true,      // Show "Add link" button in group header
          showDeleteGroup: true,  // Show "Delete group" button in group header
          showKeywordQuickAddBadge: true, // Show + badge for quick keyword assignment
          // Link quick-action buttons
          showCopyUrl: true,      // Show "Copy URL" button for links
          showQrCode: true,       // Show "QR Code" button for links
          showDeleteLink: true    // Show "Delete link" button for links
        },
        sharing: {
          ntfyServerUrl: 'https://ntfy.c5p.de',
          ntfyAuthToken: '',
          defaultTtl: 0,
          quickCodeTtlSec: CONSTS.QUICK_CODE_TTL_SEC,
          contactOnlineTimeoutSeconds: CONSTS.CONTACT_ONLINE_TIMEOUT_SEC,
        },
        groupSharing: {
          topicPrefix: 'mb-g-',
        },
        colors: {
          background: '',  // Changed from websiteBackground to match optionPath
          toolbarBackground: '',
          titleBarBackground: '',
          titleTextColor: '',
          keywordContainer: '',
          keywordBackground: ''  // Default keyword formatting (container and badges background)
        },
        customCss: '',
        visualCss: {
          stateVersion: 0,
          rules: [],
          designTokens: [],
          selectedTemplate: null,
          customRuleSets: {},
          collapsedRules: [],
          designTokensCollapsed: false,
          sidebarWidth: 400,
          sidebarTopHeight: 300
        },
        eventlog: {
          snapshotInterval: CONSTS.EVENT_LOG_SNAPSHOT_INTERVAL,
          maxEvents: CONSTS.EVENT_LOG_MAX_EVENTS * 2, // Double for main setting
          syncStrategy: 'owner-leads'
        },
        // CardDAV configuration defaults
        carddav: {
          serverUrl: '',
          username: '',
          password: '',
          addressbookPath: '',
          createAddressbookIfMissing: true,
          syncIntervalSec: 0, // 0 = manual only
          lastSyncAt: 0,
          addressbookUrl: '',
          syncToken: ''
        },
        // Nextcloud Bookmarks settings
        bookmarks: {
          serverUrl: '',
          username: '',
          password: '',
          rootFolderId: 0, // 0 = all folders
          syncIntervalSec: 0,
          folderHashes: {}
        },
        performance: {
          virtualizeLinks: false,
          initialLimit: 200,
          pageSize: 200
        },
        security: {
          enabled: false,
          sessionTimeoutMinutes: 30
        }
      },
    };

    let linksDb = null;
    let sharing = null;

    

    // Small debounce helper
    function debounce(fn, wait) {
      let t = null;
      function debounced(...args) {
        const ctx = this;
        if (t) clearTimeout(t);
        t = setTimeout(() => fn.apply(ctx, args), wait);
      }
      debounced.cancel = () => { if (t) { clearTimeout(t); t = null; } };
      return debounced;
    }

    // Custom directive for focusing elements
    Vue.directive('focus', {
      inserted: function (el, binding) {
        if (binding.value) {
          el.focus();
        }
      },
      update: function (el, binding) {
        if (binding.value && binding.oldValue !== binding.value) {
          // Need $nextTick to ensure the element is visible/rendered before focusing
          Vue.nextTick(() => {
            el.focus();
          });
        }
      }
    });


    // Main Vue instance
    let app = new Vue({
      el: '#app',
      directives: {
        focus: {
          inserted: function(el, binding) {
            // Store element reference for later use
            el._focusHandler = () => {
              const focusElement = () => {
                el.focus();
                el.select();
                // Keep trying if focus was stolen
                if (document.activeElement !== el) {
                  setTimeout(() => {
                    el.focus();
                    el.select();
                  }, 100);
                }
              };
              
              // Try multiple times to ensure focus stays
              setTimeout(focusElement, CONSTS.FOCUS_DELAY_SHORT_MS);
              setTimeout(focusElement, CONSTS.FOCUS_DELAY_MEDIUM_MS);
              setTimeout(focusElement, CONSTS.FOCUS_DELAY_LONG_MS);
            };
            
            // Focus on initial insert if value is true
            if (binding.value) {
              el._focusHandler();
            }
          },
          update: function(el, binding) {
            // When value changes from false/null to true, focus the element
            if (binding.value && !binding.oldValue) {
              if (el._focusHandler) {
                el._focusHandler();
              }
            }
          },
          unbind: function(el) {
            // Clean up
            delete el._focusHandler;
          }
        }
      },
      data: {
        title: 'My Bookmarks', // Will be updated from options
        filterText: '',
        activeKeywordFilters: [],
        data: JSON.parse(JSON.stringify(initialData)), // Deep clone initial data
        dataId: -1, // ID for the IndexedDB record
        dataLoaded: false, // True once IndexedDB load completed successfully
        loadFailed: false, // True if last load attempt failed
        lastLoadError: '', // Last load error message (debug)
        isDarkMode: false, // Dark mode state
        // Sync progress UI
        syncInProgress: false,
        syncProgress: 0,
        syncProgressText: '' ,
        storageUsed: 0, // Current storage usage in bytes
        customColors: {
          background: '#fafbfc',
          toolbar: '#ffffff',
          titleBar: '#f8f9fa',
          titleText: '#1a1a1a',
          keywordContainer: '#f0f0f0'
        },
        // UI State
        contextMenuTarget: null, // { type: 'link'/'group', item: object }
        isLinkMenuVisible: false,
        // Group body resize
        isGroupHeightResizing: false,
        groupHeightResizeState: { groupUuid: null, startY: 0, startHeight: 0 },
        // Group column resize
        isGroupColumnResizing: false,
        groupColumnResizeState: {
          leftColumn: null,
          rightColumn: null,
          startX: 0,
          startLeftWidth: 0,
          startRightWidth: 0
        },
        // Conflict Resolution UI
        showConflictNotification: false,
        conflictNotificationText: '',
        conflictNotificationTimeout: null,
        // Visual CSS Editor
        cssSidebarVisible: false,
        visualCssRules: [],
        visualCssAvailableSelectors: [],
        showMigrationNotice: false,
        customCssDraft: '', // Keep for computed properties compatibility
        selectedVisualTemplate: null,
        editingRuleId: null,
        editingRuleName: '',
        collapsedRules: [],
        designTokensCollapsed: false,
        // Feature Overview Sidebar
        featureSidebarVisible: false,
        helpLanguageTab: 'de', // Default to German
        selectedColor: '#000000',
        // Browser Extension
        extensionAvailable: false,
        extensionVersion: null,
        autoFetchTimeout: null, // Timeout for debounced auto-fetch
        // CSS Templates
        cssTemplates: [],
        selectedTemplateId: null,
        showSaveTemplateDialog: false,
        newTemplateName: '',
        // Custom Rule Sets
        customRuleSets: {},
        selectedRuleSetName: null,
        showSaveRuleSetDialog: false,
        
        // Visual CSS Rules search
        rulesFilterQuery: '',
        newRuleSetName: '',
        // Toast Notifications
        toastMessage: '',
        toastType: 'success', // success, error, info
        toastVisible: false,
        // CSS Sidebar resize
        isCssSidebarResizing: false,
        cssSidebarTopHeight: 300, // Default height in pixels
        cssSidebarStartY: 0,
        cssSidebarStartHeight: 0,
        cssPropertyEditor: {
          ruleId: null,
          property: '',
          rawValue: '',
          useRawValue: false,
          important: false,
          model: {}
        },
        cssPropertyEditorExpandedSections: {
          basic: true,
          value: true,
          advanced: true
        },
        cssPropertyEditorFonts: [],
        cssPropertyEditorFontsLoaded: false,
        // CSS Sidebar width resize
        isCssSidebarWidthResizing: false,
        cssSidebarWidth: 400, // Default width in pixels
        cssSidebarStartX: 0,
        cssSidebarStartWidth: 0,
        // Element Picker & Pseudo States
        elementPickerActive: false,
        currentPickerRule: null,
        lastHighlightedEl: null,
        lastHighlightedOutline: null,
        // Keyword suggestion context for generic edit dialog
        keywordSuggestionContext: null,
        keywordSuggestionField: null,
        keywordSuggestionStyle: null,
        // Design Tokens
        designTokens: [],
        // CSS Presets
        cssPresets: [
          { id: 'card-shadow', name: 'Card Shadow', properties: {
            'box-shadow': '0 2px 8px rgba(0,0,0,0.12)',
            'border-radius': '12px',
            'background-color': '#ffffff'
          }},
          { id: 'subtle-border', name: 'Subtle Border', properties: {
            'border': '1px solid rgba(0,0,0,0.08)',
            'border-radius': '8px',
            'background-color': '#ffffff'
          }},
          { id: 'button-primary', name: 'Button Primary', properties: {
            'background-color': '#0d6efd',
            'color': '#ffffff',
            'border': '1px solid #0d6efd',
            'padding': '0.375rem 0.75rem',
            'border-radius': '0.375rem'
          }}
        ],
        cssHookClasses: [
          'body',
          '#app.container-fluid.mb-app',
          '.mb-titlebar',
          '.mb-titlebar h1',
          '.mb-toolbar',
          '.btn-toolbar',
          '.mb-tools',
          '.mb-toolbar__search',
          '.mb-toolbar__search .input-group-text',
          '.mb-toolbar__storage',
          '.mb-footer',
          '.groupContainer',
          '.mb-group',
          '.groupContainerHeader',
          '.mb-group__header',
          '.groupTitle',
          '.mb-group__title',
          '.groupLinkCount',
          '.mb-linkcount-badge',
          '.mb-group__badges',
          '.group-info-section',
          '.mb-group-info-section',
          '.mb-group-info-header',
          '.mb-group-info-label',
          '.mb-group-info-content',
          '.linkContainer',
          '.mb-link',
          '.mb-links',
          '.linkText',
          '.linkText a',
          '.mb-link__anchor',
          '.linkTextCategory',
          '.mb-link__badges',
          '.badge',
          '.keyword-badge',
          '.mb-keyword',
          '.mb-group__keyword-badge',
          '.mb-link__keyword-badge',
          '.mb-keyword-suggestions',
          '.mb-keyword-suggestions--overlay',
          '.mb-keyword-suggestion',
          '.mb-keywords-cloud',
          '.mb-keyword-label',
          '.keyword-container',
          '.mb-keyword-bar',
          '.btn',
          '.mb-btn',
          '.btn-primary',
          '.btn-success',
          '.btn-danger',
          '.btn-secondary',
          '.btn-outline-secondary',
          '.form-control',
          '.form-select',
          '.modal',
          '.mb-modal',
          '.mb-ref-alias-modal',
          '.modal-content',
          '.modal-header',
          '.modal-body',
          '.modal-footer',
          '.mb-ref-alias-source-line',
          '.mb-ref-alias-warning',
          '.mb-context-menu',
          '.mb-css-sidebar',
          '.mb-css-sidebar-header',
          '.mb-css-sidebar-title',
          '.mb-css-sidebar-close',
          '.mb-css-sidebar-container',
          '.mb-css-sidebar-help',
          '.mb-css-sidebar-help-content',
          '.mb-css-help-hint',
          '.mb-css-help-code',
          '.mb-css-sidebar-divider',
          '.mb-css-sidebar-editor-section',
          '.mb-css-editor',
          '.mb-css-editor-wrapper',
          '.mb-css-editor-toolbar',
          '.mb-css-editor-title',
          '.mb-css-editor-buttons',
          '.mb-css-editor-textarea',
          '.mb-css-highlighted-container',
          '.mb-css-highlighted-pre',
          '.mb-css-highlighted-code',
          '.mb-css-save-btn',
          '.mb-css-cancel-btn',
          '.mb-css-reset-btn',
          '.mb-css-colorpicker-btn',
          '.mb-css-template-select',
          '.mb-css-template-buttons',
          '.mb-css-hook-insert-btn',
          '.mb-css-hook-selector',
          '.css-sidebar-resize-handle',
          '.sidebar-split-container',
          '.sidebar-top-section',
          '.sidebar-bottom-section',
          '.sidebar-divider',
          '.mb-css-property-editor',
          '.mb-css-property-editor-header',
          '.mb-css-property-editor-content',
          '.editor-header',
          '.editor-content',
          '.sidebar-content',
          '.mb-feature-sidebar',
          '.mb-feature-sidebar-header',
          '.mb-feature-sidebar-title',
          '.mb-feature-sidebar-close',
          '.mb-feature-sidebar-content',
          '.feature-sidebar',
          '.feature-section',
          '.feature-card',
          '.context-menu',
          '.context-menu-visible',
          '.context-menu ul',
          '.context-menu ul li',
          '.context-menu .separator',
          '.context-menu .submenu',
          '.context-menu .submenu::after',
          '.context-submenu',
          '.context-submenu li',
          '.mb-context-menu',
          '.mb-context-menu-visible',
          '.mb-context-menu ul',
          '.mb-context-menu ul li',
          '.mb-context-menu-separator',
          '.mb-context-submenu',
          '.mb-context-submenu-item',
          '.mb-context-submenu::after',
          '.mb-group-menu-btn',
          '.mb-link-menu-btn',
          '.mb-snapshots-dropdown',
          '.mb-snapshots-btn',
          '.mb-snapshots-menu',
          '.mb-edit-modal-title',
          '.mb-edit-modal-body',
          '.mb-edit-modal-footer',
          '.mb-edit-form',
          '.mb-edit-filter-container',
          '.mb-edit-filter-group',
          '.mb-edit-filter-input',
          '.mb-edit-section',
          '.mb-edit-section-header',
          '.mb-edit-section-body',
          '.mb-edit-field-row',
          '.mb-edit-field-label',
          '.mb-edit-field-help',
          '.mb-edit-text-input',
          '.mb-edit-url-input',
          '.mb-edit-number-input',
          '.mb-edit-checkbox',
          '.mb-edit-select',
          '.mb-edit-save-btn',
          '.mb-edit-cancel-btn',
          '.mb-edit-reset-btn',
          '.mb-toast',
          '.mb-toast-success',
          '.mb-toast-error',
          '.mb-toast-warning',
          '.mb-toast-info',
          '.mb-toast-content',
          '.mb-toast-title',
          '.mb-toast-body',
          '.mb-toast-close',
          '.mb-toast-progress',
          '.mb-toast-progress-fill',
          '.group-uuid-<uuid>',
          '.link-uuid-<uuid>'
        ],
        // Sync All state
        syncAllCooldown: 0,
        isSyncingAll: false,
        lastSyncAllTime: 0,
        isGroupMenuVisible: false,
        contextMenuStyle: { top: '0px', left: '0px' },
        editLink: null, // Link being edited in modal
        editLinkOriginalValues: null, // Original values before editing (for event-log)
        linkModalVisible: false, // Track when link edit modal is visible
        refAliasEditData: null, // Data for dedicated reference-link alias dialog
        refAliasExpandedSections: {},
        globalPlaceholderRows: [],
        // Metadata fetch UI state (for edit/add dialog)
        titleFetchState: 'idle', // idle|loading|ok|fail
        faviconFetchState: 'idle', // idle|loading|ok|fail
        metadataMessage: '',
        editGroup: null, // Group being edited in modal
        editGroupEnableStyling: true, // UI switch for per-group styling
        qrCodeUrl: '',
        bookmarkletHref: '',
        // Duplicates dialog
        duplicatesFound: {},
        showDuplicatesDialog: false,
        pasteContent: '',
        pasteHint: '',
        parsedLinks: null,
        detectedFormat: '',
        importGroupTitle: '',
        importCsvSeparator: '',
        isFullExport: false,
        fullExportData: null,
        importUrl: '',
        fetchingUrl: false,
        urlFetchError: '',
        fetchingBrowserBookmarks: false,
        browserBookmarksInfo: '',
        importCollapsedGroups: {}, // Track which groups are collapsed in import preview
        importDialogExpandedSections: { file: true, url: true, clipboard: true },
        exportSelection: [],
        exportFormat: 'json',
        
        prevIdentityName: '',
        // NC Folder Picker state
        ncFolders: [],
        ncFoldersLoading: false,
        ncFolderSelected: 0,
        // Drag & Drop
        dropManager: null, // Will be initialized in mounted()
        dragState: null, // Reactive state for drag & drop
        expandHoverTimers: {}, // timers for auto-expanding collapsed groups while dragging links

        keywordManager: { selected: '', newName: '' },
        keywordQuickDialog: {
          mode: '',
          group: null,
          link: null,
          value: ''
        },
        keywordQuickSuggestionContext: null,
        quickKeywordSuggestionStyle: null,
        shortcutManager: { linkFilter: '', globalDrafts: [] },
        shortcutOpenQueue: null,
        
        // Info popup
        infoPopupContent: '',
        infoPopupTimer: null,
        linkPopover: {
          visible: false,
          link: null,
          style: { top: '0px', left: '0px' },
          titleHtml: '',
          displayUrl: '',
          url: '',
          rawUrlInput: '',
          favicon: '',
          keywords: [],
          emoji: '',
          uuid: '',
          createdAt: { full: '—', relative: '', raw: null },
          updatedAt: { full: '—', relative: '', raw: null }
        },
        linkPopoverHideTimer: null,
        
        // JSON Inspector
        inspectedGroup: null,
        inspectedGroupJSON: '',

        // History (Undo/Redo)
        appInitialized: false,
        historyPast: [],
        historyFuture: [],
        historyLock: false,
        lastSavedJson: '',
        carddavTimer: null,

        // Quick-Connect dialog state
        qcDialog: { visible: false, mode: 'receive', code: '', status: [], progress: 'idle' },
        contactsDialog: { visible: false, tab: 'contacts' },
        shareDialog: { visible: false, mode: 'link', payload: null, selectedContacts: {} },
        // Contact online status tracking
        contactOnlineStatus: {}, // { contactUuid: { online: boolean, lastCheck: timestamp } }
        pendingPings: {}, // { pingId: { resolve: function, reject: function, timeout: timeoutId } }
        // Removed from group notification
        removedGroupInfo: {
          groupName: '',
          ownerName: '',
          removedAt: null,
          groupId: null
        },
        // Invitation dialog for immediate acceptance/rejection
        invitationDialog: { 
          visible: false, 
          type: '', // 'group' or 'link'
          env: null, 
          groupName: '', 
          linkCount: 0,
          fromName: '',
          preview: [] // Preview of links to be added
        },
        processedMsgIds: new Set(),
        localSecurity: {
          isEncryptedStore: false,
          locked: false,
          lockReason: '',
          unlockPassword: '',
          unlockError: '',
          unlockBusy: false,
          encryptedEnvelope: null,
          encryptedDataId: -1,
          sessionExpiresAt: 0
        },
        localSecurityPasswordDialog: {
          password: '',
          confirmPassword: '',
          error: ''
        },

        // --- Generic Edit Dialog Data ---
        genericEditConfig: {
          title: '',
          type: '', // 'options', 'group', or 'link'
          design: {}, // The design structure
          saveCallback: null,
          context: {}
        },
        genericEditData: null, // The data being edited
        genericFilterText: '', // Filter text for generic dialog
        genericExpandedSections: {}, // Track which sections are expanded
        // Legacy properties for old dialogs - kept for compatibility
        expandedLinkSections: {},
        expandedGroupSections: {},
        expandedSections: {},
        settingsFilterText: '',
        optionsDesign: { // Struktur für generischen Dialog
          common: {
            translateKey: 'options.common',
            fields: {
              language: { id: 'CommonLanguage', type: 'select', translateKey: 'options.common.language', values: { 'en': 'options.common.language.english', 'de': 'options.common.language.german' }, optionPath: 'common.language', helpText: 'options.common.language.help' },
              pageTitle: { id: 'CommonPageTitle', type: 'text', translateKey: 'options.common.pageTitle', optionPath: 'common.pageTitle', helpText: 'options.common.pageTitle.help' },
              
              searchAsYouType: { id: 'SearchAsYouType', type: 'checkbox', translateKey: 'options.common.searchAsYouType', optionPath: 'common.searchAsYouType', helpText: 'options.common.searchAsYouType.help' },
              manualGroupColumnWidth: { id: 'CommonManualGroupColumnWidth', type: 'checkbox', translateKey: 'options.common.manualGroupColumnWidth', optionPath: 'common.manualGroupColumnWidth', helpText: 'options.common.manualGroupColumnWidth.help' },
              debugEnabled: { id: 'CommonDebugEnabled', type: 'checkbox', translateKey: 'options.common.debugEnabled', optionPath: 'common.debugEnabled', helpText: 'options.common.debugEnabled.help' },
              confirmDeleteGroup: { id: 'CommonConfirmDeleteGroup', type: 'checkbox', translateKey: 'options.common.confirmDeleteGroup', optionPath: 'common.confirmDeleteGroup', helpText: 'options.common.confirmDeleteGroup.help' },
              confirmDeleteLink: { id: 'CommonConfirmDeleteLink', type: 'checkbox', translateKey: 'options.common.confirmDeleteLink', optionPath: 'common.confirmDeleteLink', helpText: 'options.common.confirmDeleteLink.help' }
            }
          },
          security: {
            translateKey: 'options.security.title',
            fields: {
              enabled: {
                id: 'SecurityEnabled',
                type: 'checkbox',
                translateKey: 'options.security.enabled',
                optionPath: 'security.enabled',
                helpText: 'options.security.enabled.help'
              },
              sessionTimeoutMinutes: {
                id: 'SecuritySessionTimeoutMinutes',
                type: 'number',
                translateKey: 'options.security.sessionTimeoutMinutes',
                optionPath: 'security.sessionTimeoutMinutes',
                helpText: 'options.security.sessionTimeoutMinutes.help',
                min: 0,
                max: 1440,
                step: 1,
                suffix: 'options.security.minutesSuffix'
              }
            }
          },
          groups: {
            translateKey: 'options.groups',
            fields: {
              collapseGroupsOnStart: {
                id: 'GroupsCollapseGroupsOnStart',
                type: 'checkbox',
                translateKey: 'options.groups.collapseGroupsOnStart',
                optionPath: 'groups.collapseGroupsOnStart',
                helpText: 'options.groups.collapseGroupsOnStart.help'
              },
              hoverExpandEnabled: {
                id: 'GroupsHoverExpandEnabled',
                type: 'checkbox',
                translateKey: 'options.groups.hoverExpandEnabled',
                optionPath: 'groups.hoverExpandEnabled',
                helpText: 'options.groups.hoverExpandEnabled.help'
              },
              hoverExpandDelay: {
                id: 'GroupsHoverExpandDelay',
                type: 'number',
                translateKey: 'options.groups.hoverExpandDelay',
                optionPath: 'groups.hoverExpandDelayMs',
                helpText: 'options.groups.hoverExpandDelay.help'
              },
              autoAdjustHeightOnLinkChanges: {
                id: 'GroupsAutoAdjustHeightOnLinkChanges',
                type: 'checkbox',
                translateKey: 'options.groups.autoAdjustHeightOnLinkChanges',
                optionPath: 'groups.autoAdjustHeightOnLinkChanges',
                helpText: 'options.groups.autoAdjustHeightOnLinkChanges.help'
              },
              clearClosesAllGroups: {
                id: 'GroupsClearClosesAll',
                type: 'checkbox',
                translateKey: 'options.groups.clearClosesAllGroups',
                optionPath: 'groups.clearClosesAllGroups',
                helpText: 'options.groups.clearClosesAllGroups.help'
              },
              keywordClickExpandsAll: {
                id: 'GroupsKeywordClickExpandsAll',
                type: 'checkbox',
                translateKey: 'options.groups.keywordClickExpandsAll',
                optionPath: 'groups.keywordClickExpandsAll',
                helpText: 'options.groups.keywordClickExpandsAll.help'
              },
              searchAutoExpandFound: {
                id: 'GroupsSearchAutoExpandFound',
                type: 'checkbox',
                translateKey: 'options.groups.searchAutoExpandFound',
                optionPath: 'groups.searchAutoExpandFound',
                helpText: 'options.groups.searchAutoExpandFound.help'
              }
            }
          },
          links: {
            translateKey: 'options.links',
            fields: {
              openInNewTab: {
              id: 'LinksOpenInNewTab',
              type: 'checkbox',
              translateKey: 'options.links.openInNewTab',
              optionPath: 'links.openInNewTab',
              helpText: 'options.links.openInNewTab.help'
              },
              progressiveLoadingThreshold: {
              id: 'LinksProgressiveLoadingThreshold',
              type: 'number',
              translateKey: 'options.links.progressiveLoadingThreshold',
              optionPath: 'links.progressiveLoadingThreshold',
              helpText: 'options.links.progressiveLoadingThreshold.help',
              defaultValue: 100
              },
              addViaDialog: {
              id: 'LinksAddViaDialog',
              type: 'checkbox',
              translateKey: 'options.links.addViaDialog',
              optionPath: 'links.addViaDialog',
              helpText: 'options.links.addViaDialog.help'
              },
              defaultUrlPrefix: {
              id: 'LinksDefaultUrlPrefix',
              type: 'text',
              translateKey: 'options.links.defaultUrlPrefix',
              optionPath: 'links.defaultUrlPrefix',
              helpText: 'options.links.defaultUrlPrefix.help',
              placeholder: 'https://'
              },
              autoFetchTitle: {
              id: 'LinksAutoFetchTitle',
              type: 'checkbox',
              translateKey: 'options.links.autoFetchTitle',
              optionPath: 'links.autoFetchTitle',
              helpText: 'options.links.autoFetchTitle.help'
              },
              autoFetchFavicon: {
              id: 'LinksAutoFetchFavicon',
              type: 'checkbox',
              translateKey: 'options.links.autoFetchFavicon',
              optionPath: 'links.autoFetchFavicon',
              helpText: 'options.links.autoFetchFavicon.help'
              },
              allowExternalFaviconService: {
              id: 'LinksAllowExternalFaviconService',
              type: 'checkbox',
              translateKey: 'options.links.allowExternalFaviconService',
              optionPath: 'links.allowExternalFaviconService',
              helpText: 'options.links.allowExternalFaviconService.help',
              defaultValue: false
              },
              showLinkBadges: {
              id: 'LinksShowLinkBadges',
              type: 'checkbox',
              translateKey: 'options.links.showLinkBadges',
              optionPath: 'links.showLinkBadges',
              helpText: 'options.links.showLinkBadges.help'
              },
              showReferenceMarker: {
              id: 'LinksShowReferenceMarker',
              type: 'checkbox',
              translateKey: 'options.links.showReferenceMarker',
              optionPath: 'links.showReferenceMarker',
              helpText: 'options.links.showReferenceMarker.help',
              defaultValue: true
              },
              showLinkPopover: {
              id: 'LinksShowLinkPopover',
              type: 'checkbox',
              translateKey: 'options.links.showLinkPopover',
              optionPath: 'links.showLinkPopover',
              helpText: 'options.links.showLinkPopover.help',
              defaultValue: true
              },
              copyUrlFormat: {
                id: 'LinksCopyUrlFormat',
                type: 'text',
                translateKey: 'options.links.copyUrlFormat',
                optionPath: 'links.copyUrlFormat',
                helpText: 'options.links.copyUrlFormat.help',
                defaultValue: '{title}: {url}',
                placeholder: '{title}: {url}'
              },
              
            }
          },
          buttons: {
            translateKey: 'options.buttons',
            fields: {
              showAddLink: {
                id: 'ButtonsShowAddLink',
                type: 'checkbox',
                translateKey: 'options.buttons.showAddLink',
                optionPath: 'buttons.showAddLink',
                helpText: 'options.buttons.showAddLink.help',
                defaultValue: true
              },
              showDeleteGroup: {
                id: 'ButtonsShowDeleteGroup',
                type: 'checkbox',
                translateKey: 'options.buttons.showDeleteGroup',
                optionPath: 'buttons.showDeleteGroup',
                helpText: 'options.buttons.showDeleteGroup.help',
                defaultValue: true
              },
              showKeywordQuickAddBadge: {
                id: 'ButtonsShowKeywordQuickAddBadge',
                type: 'checkbox',
                translateKey: 'options.buttons.showKeywordQuickAddBadge',
                optionPath: 'buttons.showKeywordQuickAddBadge',
                helpText: 'options.buttons.showKeywordQuickAddBadge.help',
                defaultValue: true
              },
              showCopyUrl: {
                id: 'ButtonsShowCopyUrl',
                type: 'checkbox',
                translateKey: 'options.buttons.showCopyUrl',
                optionPath: 'buttons.showCopyUrl',
                helpText: 'options.buttons.showCopyUrl.help',
                defaultValue: true
              },
              showQrCode: {
                id: 'ButtonsShowQrCode',
                type: 'checkbox',
                translateKey: 'options.buttons.showQrCode',
                optionPath: 'buttons.showQrCode',
                helpText: 'options.buttons.showQrCode.help',
                defaultValue: true
              },
              showDeleteLink: {
                id: 'ButtonsShowDeleteLink',
                type: 'checkbox',
                translateKey: 'options.buttons.showDeleteLink',
                optionPath: 'buttons.showDeleteLink',
                helpText: 'options.buttons.showDeleteLink.help',
                defaultValue: true
              }
            }
          },
          sharing: {
            translateKey: 'options.sharing',
            fields: {
              // Move display name here to show above ntfy server URL
              identityName: { id: 'CommonIdentityName', type: 'text', translateKey: 'options.common.identityName', optionPath: 'common.identityName', helpText: 'options.common.identityName.help' },
              ntfyServerUrl: { id: 'SharingNtfyServer', type: 'text', translateKey: 'options.sharing.ntfyServerUrl', optionPath: 'sharing.ntfyServerUrl', helpText: 'options.sharing.ntfyServerUrl.help' },
              ntfyAuthToken: { id: 'SharingNtfyToken', type: 'text', translateKey: 'options.sharing.ntfyAuthToken', optionPath: 'sharing.ntfyAuthToken', helpText: 'options.sharing.ntfyAuthToken.help' },
              defaultTtl: { id: 'SharingDefaultTtl', type: 'number', translateKey: 'options.sharing.defaultTtl', optionPath: 'sharing.defaultTtl', helpText: 'options.sharing.defaultTtl.help' },
              quickCodeTtlSec: { id: 'SharingQuickCodeTtl', type: 'number', translateKey: 'options.sharing.quickCodeTtl', optionPath: 'sharing.quickCodeTtlSec', helpText: 'options.sharing.quickCodeTtl.help' },
              contactOnlineTimeoutSeconds: { id: 'SharingContactOnlineTimeout', type: 'number', translateKey: 'options.sharing.contactOnlineTimeout', optionPath: 'sharing.contactOnlineTimeoutSeconds', helpText: 'options.sharing.contactOnlineTimeout.help' }
            }
          },
          sync: {
            translateKey: 'options.sync',
            fields: {
              // Settings for all users (Owner & Member)
              conflictNotificationLevel: { 
                id: 'SyncConflictNotifications', 
                type: 'select', 
                translateKey: 'options.sync.conflictNotificationLevel', 
                optionPath: 'sync.conflictNotificationLevel',
                helpText: 'options.sync.conflictNotificationLevel.help',
                roleScope: 'all', // For everyone
                values: {
                  'silent': 'options.sync.conflictNotificationLevel.silent',
                  'minimal': 'options.sync.conflictNotificationLevel.minimal',
                  'verbose': 'options.sync.conflictNotificationLevel.verbose'
                }
              },
              autoSyncInterval: {
                id: 'SyncAutoInterval',
                type: 'select',
                translateKey: 'options.sync.autoSyncInterval',
                optionPath: 'sync.autoSyncInterval',
                helpText: 'options.sync.autoSyncInterval.help',
                roleScope: 'all',
                values: {
                  '300': 'options.sync.autoSyncInterval.5min',
                  '600': 'options.sync.autoSyncInterval.10min',
                  '1800': 'options.sync.autoSyncInterval.30min',
                  '3600': 'options.sync.autoSyncInterval.1hour',
                  '0': 'options.sync.autoSyncInterval.manual'
                }
              },
              offlineMode: {
                id: 'SyncOfflineMode',
                type: 'select',
                translateKey: 'options.sync.offlineMode',
                optionPath: 'sync.offlineMode',
                helpText: 'options.sync.offlineMode.help',
                roleScope: 'all',
                values: {
                  'optimistic': 'options.sync.offlineMode.optimistic',
                  'conservative': 'options.sync.offlineMode.conservative'
                }
              },
              // Settings only for Owners
              conflictResolution: {
                id: 'SyncConflictResolution',
                type: 'select',
                translateKey: 'options.sync.conflictResolution',
                optionPath: 'sync.conflictResolution',
                helpText: 'options.sync.conflictResolution.help',
                roleScope: 'owner', // Only for group owners
                values: {
                  'owner-wins': 'options.sync.conflictResolution.ownerWins',
                  'last-write-wins': 'options.sync.conflictResolution.lastWriteWins',
                  'manual': 'options.sync.conflictResolution.manual'
                }
              },
              memberRateLimit: {
                id: 'SyncMemberRateLimit',
                type: 'number',
                translateKey: 'options.sync.memberRateLimit',
                optionPath: 'sync.memberRateLimit',
                helpText: 'options.sync.memberRateLimit.help',
                roleScope: 'owner',
                min: 0,
                max: 100,
                suffix: 'options.sync.memberRateLimit.suffix'
              },
              validationLevel: {
                id: 'SyncValidationLevel',
                type: 'select',
                translateKey: 'options.sync.validationLevel',
                optionPath: 'sync.validationLevel',
                helpText: 'options.sync.validationLevel.help',
                roleScope: 'owner',
                values: {
                  'strict': 'options.sync.validationLevel.strict',
                  'moderate': 'options.sync.validationLevel.moderate',
                  'permissive': 'options.sync.validationLevel.permissive'
                }
              },
              // Settings only for Members
              localCacheStrategy: {
                id: 'SyncLocalCache',
                type: 'select',
                translateKey: 'options.sync.localCacheStrategy',
                optionPath: 'sync.localCacheStrategy',
                helpText: 'options.sync.localCacheStrategy.help',
                roleScope: 'member', // Only for members
                values: {
                  'full': 'options.sync.localCacheStrategy.full',
                  'minimal': 'options.sync.localCacheStrategy.minimal'
                }
              },
              errorHandling: {
                id: 'SyncErrorHandling',
                type: 'select',
                translateKey: 'options.sync.errorHandling',
                optionPath: 'sync.errorHandling',
                helpText: 'options.sync.errorHandling.help',
                roleScope: 'member',
                values: {
                  'retry': 'options.sync.errorHandling.retry',
                  'queue': 'options.sync.errorHandling.queue',
                  'discard': 'options.sync.errorHandling.discard'
                }
              }
            }
          },
          syncEngine: {
            translateKey: 'options.sync.engine',
            fields: {
              backend: {
                id: 'SyncBackend', type: 'select', translateKey: 'options.sync.backend', optionPath: 'sync.backend', helpText: 'options.sync.backend.help',
                values: { 'carddav': 'options.sync.backend.carddav', 'nc-bookmarks': 'options.sync.backend.nc' }
              }
            }
          },
          bookmarks: {
            translateKey: 'bookmarks.title',
            fields: {
              serverUrl: { id: 'BkServerUrl', type: 'text', translateKey: 'bookmarks.serverUrl', optionPath: 'bookmarks.serverUrl', helpText: 'bookmarks.serverUrl.help' },
              username:  { id: 'BkUsername',  type: 'text', translateKey: 'bookmarks.username',  optionPath: 'bookmarks.username',  helpText: 'bookmarks.username.help' },
              password:  { id: 'BkPassword',  type: 'text', translateKey: 'bookmarks.password',  optionPath: 'bookmarks.password',  helpText: 'bookmarks.password.help' },
              rootFolderId: { id: 'BkRootFolder', type: 'select', translateKey: 'bookmarks.rootFolderId', optionPath: 'bookmarks.rootFolderId', helpText: 'bookmarks.rootFolderId.help', values: { '0': 'All folders' } },
              autoCreateFolders: { id: 'BkAutoCreate', type: 'checkbox', translateKey: 'bookmarks.autoCreate', optionPath: 'bookmarks.autoCreateFolders', helpText: 'bookmarks.autoCreate.help' },
              autoRenameFolders: { id: 'BkAutoRename', type: 'checkbox', translateKey: 'bookmarks.autoRename', optionPath: 'bookmarks.autoRenameFolders', helpText: 'bookmarks.autoRename.help' },
              syncIntervalSec: { id: 'BkSyncInterval', type: 'select', translateKey: 'carddav.syncInterval', optionPath: 'bookmarks.syncIntervalSec', helpText: 'carddav.syncInterval.help', values: { '0':'carddav.syncInterval.manual','300':'carddav.syncInterval.5min','600':'carddav.syncInterval.10min','1800':'carddav.syncInterval.30min','3600':'carddav.syncInterval.1hour' } },
              // Actions at the end of the section: Test + Reset in one row
              actionsRow: { type: 'actions', actions: [
                { key: 'testConnection', translateKey: 'carddav.testConnection', buttonClass: 'btn-outline-primary' },
                { key: 'resetBindings', translateKey: 'sync.resetBindings', buttonLabel: 'sync.resetBindings', buttonClass: 'btn-outline-danger' }
              ]}
            }
          },
          carddav: {
            translateKey: 'carddav.title',
            fields: {
              serverUrl: { id: 'CardDAVServerUrl', type: 'text', translateKey: 'carddav.serverUrl', optionPath: 'carddav.serverUrl', helpText: 'carddav.serverUrl.help' },
              username: { id: 'CardDAVUsername', type: 'text', translateKey: 'carddav.username', optionPath: 'carddav.username', helpText: 'carddav.username.help' },
              password: { id: 'CardDAVPassword', type: 'text', translateKey: 'carddav.password', optionPath: 'carddav.password', helpText: 'carddav.password.help' },
              addressbookPath: { id: 'CardDAVAddressbookPath', type: 'text', translateKey: 'carddav.addressbookPath', optionPath: 'carddav.addressbookPath', helpText: 'carddav.addressbookPath.help' },
              createAddressbookIfMissing: { id: 'CardDAVCreateAB', type: 'checkbox', translateKey: 'carddav.createAddressbookIfMissing', optionPath: 'carddav.createAddressbookIfMissing', helpText: 'carddav.createAddressbookIfMissing.help' },
              syncIntervalSec: {
                id: 'CardDAVSyncInterval', type: 'select', translateKey: 'carddav.syncInterval', optionPath: 'carddav.syncIntervalSec', helpText: 'carddav.syncInterval.help',
                values: { '0': 'carddav.syncInterval.manual', '300': 'carddav.syncInterval.5min', '600': 'carddav.syncInterval.10min', '1800': 'carddav.syncInterval.30min', '3600': 'carddav.syncInterval.1hour' }
              }
            }
          },
          eventlog: {
            translateKey: 'options.eventlog.title',
            fields: {
              snapshotInterval: {
                id: 'eventLogSnapshotInterval',
                type: 'number',
                translateKey: 'options.eventlog.snapshotInterval',
                optionPath: 'eventlog.snapshotInterval',
                helpText: 'options.eventlog.snapshotInterval.help',
                min: 10,
                max: 1000,
                suffix: 'Events'
              },
              maxEvents: {
                id: 'eventLogMaxEvents',
                type: 'number',
                translateKey: 'options.eventlog.maxEvents',
                optionPath: 'eventlog.maxEvents',
                helpText: 'options.eventlog.maxEvents.help',
                min: 100,
                max: 10000,
                suffix: 'Events'
              },
              syncStrategy: {
                id: 'syncStrategy',
                type: 'select',
                translateKey: 'options.eventlog.syncStrategy',
                optionPath: 'eventlog.syncStrategy',
                helpText: 'options.eventlog.syncStrategy.help',
                values: {
                  'owner-leads': 'options.eventlog.syncStrategy.ownerLeads',
                  'all-equal': 'options.eventlog.syncStrategy.allEqual',
                  'smart-merge': 'options.eventlog.syncStrategy.smartMerge'
                }
              }
            }
          }
        },
        // Group Edit Dialog Configuration
        groupEditDesign: {
          basic: {
            translateKey: 'group.basic',
            fields: {
              name: {
                type: 'text',
                translateKey: 'group.name',
                placeholder: 'Enter group name',
                helpText: 'group.name.help'
              },
              emoji: {
                type: 'emoji',
                translateKey: 'group.emoji',
                placeholder: 'group.emoji.placeholder',
                helpText: 'group.emoji.help'
              },
              keywords: {
                type: 'text',
                translateKey: 'group.keywords',
                placeholder: 'e.g. work, personal, docs',
                helpText: 'group.keywords.help'
              }
            }
          },
          advanced: {
            translateKey: 'group.advanced',
            fields: {
              shortcut: {
                type: 'shortcut',
                translateKey: 'group.shortcut',
                placeholder: 'group.shortcut.placeholder',
                helpText: 'group.shortcut.help'
              },
              manualHeightResizeOverride: {
                id: 'GroupManualHeightResizeOverride',
                type: 'checkbox',
                translateKey: 'group.manualHeightResizeOverride',
                helpText: 'group.manualHeightResizeOverride.help'
              },
              infoHtml: {
                type: 'textarea',
                translateKey: 'group.infoHtml',
                placeholder: 'group.infoHtml.placeholder',
                helpText: 'group.infoHtml.help',
                rows: 4
              }
            }
          },
          placeholders: {
            translateKey: 'placeholders.group.title',
            fields: {
              urlPlaceholders: {
                type: 'placeholders',
                scope: 'group',
                translateKey: 'placeholders.group.title',
                helpText: 'placeholders.group.help'
              }
            }
          }
        },
        // Link Edit Dialog Configuration
        linkEditDesign: {
          basic: {
            translateKey: 'link.basic',
            fields: {
              itemType: {
                type: 'select',
                translateKey: 'link.itemType',
                helpText: 'link.itemType.help',
                values: {
                  'link': 'link.itemType.link',
                  'note': 'link.itemType.note',
                  'separator': 'link.itemType.separator'
                }
              },
              text: {
                type: 'text',
                translateKey: 'link.text',
                placeholder: 'Enter link text',
                helpText: 'link.text.help'
              },
              url: {
                type: 'url',
                translateKey: 'link.url',
                placeholder: 'https://example.com',
                helpText: 'link.url.info',
                validation: 'url',
                autofocus: true
              },
              emoji: {
                type: 'emoji',
                translateKey: 'link.emoji',
                placeholder: 'link.emoji.placeholder',
                helpText: 'link.emoji.help'
              },
              keywords: {
                type: 'text',
                translateKey: 'link.keywords',
                placeholder: 'e.g. work, personal, docs',
                helpText: 'link.keywords.help'
              }
            }
          },
          advanced: {
            translateKey: 'link.advanced',
            fields: {
              shortcut: {
                type: 'shortcut',
                translateKey: 'link.shortcut',
                placeholder: 'link.shortcut.placeholder',
                helpText: 'link.shortcut.help'
              },
              infoHtml: {
                type: 'textarea',
                translateKey: 'link.infoHtml',
                placeholder: 'link.infoHtml.placeholder',
                helpText: 'link.infoHtml.help',
                rows: 4
              }
            }
          },
          placeholders: {
            translateKey: 'placeholders.link.title',
            fields: {
              urlPlaceholders: {
                type: 'placeholders',
                scope: 'link',
                translateKey: 'placeholders.link.title',
                helpText: 'placeholders.noneInUrl'
              }
            }
          }
        },
        // Favicon Rules working state (Options modal)
        faviconRulesWorking: [],
        faviconRulesTestUrl: '',
        i18n: { // Übersetzungen jetzt hier
          'en': {
            // Favicon rules
            'options.links.faviconRules': 'Favicon rules',
            'options.links.faviconRules.manage': 'Manage favicon rules',
            'favicon.rules.title': 'Favicon Rules',
            'favicon.rules.add': 'Add rule',
            'favicon.rules.apply': 'Apply to existing links',
            'favicon.rules.override': 'Override existing favicons',
            'favicon.rules.type': 'Type',
            'favicon.rules.pattern': 'Pattern',
            'favicon.rules.icon': 'Icon',
            'favicon.rules.comment': 'Comment',
            'favicon.rules.commentPlaceholder': 'Optional comment',
            'favicon.rules.enabled': 'Enabled',
            'favicon.rules.domain': 'Domain',
            'favicon.rules.prefix': 'URL prefix',
            'favicon.rules.regex': 'Regex',
            'favicon.rules.autofetch': 'Auto-fetch',
            'favicon.rules.upload': 'Upload',
            'favicon.rules.delete': 'Delete',
            'favicon.rules.test': 'Test URL',
            'favicon.rules.matchPreview': 'Matched rule preview',
            'favicon.rules.restoreDefaults': 'Restore defaults',
            'favicon.rules.export': 'Export rules',
            'favicon.rules.import': 'Import rules',
            'favicon.rules.none': 'No favicon rules yet.',
            'favicon.rules.defaultsRestored': 'Default favicon rules restored',
            'favicon.rules.defaultsAlreadyPresent': 'All default favicon rules are already present',
            'favicon.rules.exportError': 'Failed to export favicon rules',
            'favicon.rules.importSuccess': 'Imported {count} favicon rules',
            'favicon.rules.importNothing': 'No new favicon rules to import',
            'favicon.rules.importError': 'Failed to import favicon rules',
            'favicon.rules.needsExtension': 'Extension required to auto-fetch icons',
            'favicon.rules.saved': 'Favicon rules saved',
            'favicon.rules.applied': 'Favicon rules applied',
            // CardDAV
            'carddav.title': 'CardDAV Sync',
            'carddav.serverUrl': 'Server URL',
            'carddav.serverUrl.help': 'Base URL of your CardDAV server (e.g., https://cloud.example.com)',
            'carddav.username': 'Username',
            'carddav.username.help': 'Your CardDAV username',
            'carddav.password': 'App password',
            'carddav.password.help': 'Use an app-specific password if available',
            'carddav.addressbookPath': 'Addressbook URL/path (optional)',
            'carddav.addressbookPath.help': 'Leave empty for auto-discovery, or set a full DAV path',
            'carddav.createAddressbookIfMissing': 'Automatically create addressbook if missing',
            'carddav.createAddressbookIfMissing.help': 'Automatically create an addressbook named "MyBookmarks" if allowed',
            'carddav.syncInterval': 'Auto-sync interval',
            'carddav.syncInterval.help': 'How often to sync automatically (0 = manual only)',
            'carddav.syncInterval.manual': 'Manual only',
            'carddav.syncInterval.5min': 'Every 5 minutes',
            'carddav.syncInterval.10min': 'Every 10 minutes',
            'carddav.syncInterval.30min': 'Every 30 minutes',
            'carddav.syncInterval.1hour': 'Every hour',
            'carddav.syncNow': 'Sync now (Nextcloud Bookmarks)',
            'carddav.extensionRequired': 'Browser extension with CardDAV support required',
            'carddav.notEnabled': 'CardDAV is disabled in Options',
            'carddav.syncStarted': 'CardDAV sync started',
            'carddav.syncFailed': 'CardDAV sync failed: {message}',
            'carddav.addressbookPathMissing': 'Please configure Server URL and Addressbook Path in Options',
            'carddav.testConnection': 'Test connection',
            'options.sync.engine': 'Sync Backend',
            'options.sync.backend': 'Sync service',
            'options.sync.backend.help': 'Select sync provider',
            'options.sync.backend.carddav': 'CardDAV (DAV, experimental)',
            'options.sync.backend.nc': 'Nextcloud Bookmarks (REST, alpha)',
            'bookmarks.title': 'Nextcloud Bookmarks',
            'bookmarks.serverUrl': 'Server URL',
            'bookmarks.serverUrl.help': 'Base URL of your Nextcloud (e.g., https://cloud.example.com)',
            'bookmarks.username': 'Username',
            'bookmarks.username.help': 'Your Nextcloud username',
            'bookmarks.password': 'App password',
            'bookmarks.password.help': 'Use an app-specific password',
            'bookmarks.rootFolderId': 'Sync root folder',
            'bookmarks.rootFolderId.help': '0 = all folders; set a specific folder ID to limit sync',
            'bookmarks.autoCreate': 'Auto-create folders from groups',
            'bookmarks.autoCreate.help': 'Create missing Nextcloud folders for local groups',
            'bookmarks.autoRename': 'Rename folders when groups are renamed',
            'bookmarks.autoRename.help': 'Rename Nextcloud folders when group names change',
            'bookmarks.chooseFolder': 'Choose Folder',
            'bookmarks.pickFolder': 'Select a Nextcloud folder',
            'bookmarks.refresh': 'Refresh',
            'bookmarks.select': 'Select',
            'sync.resetBindings': 'Reset Nextcloud mapping bindings',
            'sync.resetBindings.help': 'Remove all stored Nextcloud folder/bookmark IDs from your groups and links. Useful to resync fresh.',
            'sync.resetBindings.confirm': 'This will remove all Nextcloud sync bindings (folder and bookmark IDs) from all groups and links. Your bookmarks stay, but re-sync will recreate mappings. Continue?',
            'sync.resetBindings.done': 'Sync bindings cleared',
            'sync.resetBindings.failed': 'Failed to clear sync bindings',
            'eraseDatabase': 'Erase database',
            'eraseDatabase.warning': 'Warning! This will permanently delete ALL your bookmarks, groups, and settings. This action cannot be undone!',
            'eraseDatabase.confirm': 'Are you absolutely sure you want to delete everything?',
            'addGroup': 'Add group',
            'search': 'Search',
            'importFromFile': 'Import from file',
            'exportToFile': 'Export to file',
            'import': 'Import',
            'options': 'Options',
            'options.applyError': 'Could not apply options.',
            'css.advancedEditor': 'Advanced Editor',
            'options.common': 'Common',
            'options.common.language': 'Language',
            'options.common.language.english': 'English',
            'options.common.language.german': 'German',
            'options.common.language.help': 'Select the language',
            'options.common.pageTitle': 'Page title',
            'options.common.pageTitle.help': 'Set the page title',
            'options.common.identityName': 'Your display name',
            'options.common.identityName.help': 'This name is shown to other members and contacts',
            'options.common.manualGroupColumnWidth': 'Allow manual group column widths',
            'options.common.manualGroupColumnWidth.help': 'Allow dragging vertical separators to resize group columns and persist the widths.',
            'options.groups': 'Groups',
            'options.groups.collapseGroupsOnStart': 'Collapse groups on start',
            'options.groups.collapseGroupsOnStart.help': 'Collapse all groups on start',
            'options.groups.hoverExpandEnabled': 'Auto-open collapsed groups while dragging links',
            'options.groups.hoverExpandEnabled.help': 'When dragging a link, hovering a collapsed group expands it after the delay',
            'options.groups.hoverExpandDelay': 'Auto-open delay while dragging links',
            'options.groups.hoverExpandDelay.help': 'Time to hover a collapsed group with a dragged link before it expands (milliseconds)',
            'options.groups.autoAdjustHeightOnLinkChanges': 'Automatically adjust group height when links are added/removed',
            'options.groups.autoAdjustHeightOnLinkChanges.help': 'Automatically fit group height after adding/removing links if content would otherwise require scrolling. Disables manual height resize unless overridden per group.',
            'options.common.searchAsYouType': 'Instant search while typing',
            'options.common.searchAsYouType.help': 'You can start typing a search term without clicking in the search text field, unless you have focused on another input field',
            'options.common.debugEnabled': 'Enable diagnostic logging',
            'options.common.debugEnabled.help': 'Show debug logs in the browser console',
            'options.common.confirmDeleteGroup': 'Confirm group deletion',
            'options.common.confirmDeleteGroup.help': 'Ask for confirmation when deleting a group',
            'options.common.confirmDeleteLink': 'Confirm link deletion',
            'options.common.confirmDeleteLink.help': 'Ask for confirmation when deleting a link',
            'options.security.title': 'Local Data Protection',
            'options.security.enabled': 'Encrypt local database',
            'options.security.enabled.help': 'Protects locally stored data with a password. The password is required when opening this page.',
            'options.security.sessionTimeoutMinutes': 'Unlocked session duration',
            'options.security.sessionTimeoutMinutes.help': 'How long the decrypted session stays active before it locks again automatically (0 = disabled).',
            'options.security.minutesSuffix': 'min',
            'options.security.disable.confirm': 'Disable local encryption and store data unencrypted?',
            'options.security.passwordDialog.title': 'Set encryption password',
            'options.security.passwordDialog.help': 'This password is required to unlock local data.',
            'options.security.passwordDialog.password': 'Password',
            'options.security.passwordDialog.confirm': 'Confirm password',
            'options.security.passwordDialog.submit': 'Apply password',
            'options.security.passwordDialog.error.empty': 'Please enter a password.',
            'options.security.passwordDialog.error.short': 'Password must be at least 8 characters.',
            'options.security.passwordDialog.error.mismatch': 'Passwords do not match.',
            'options.security.enabledSuccess': 'Local data encryption enabled.',
            'options.security.enableCanceled': 'Encryption was not enabled (password entry canceled).',
            'options.security.enableFailed': 'Could not enable encryption.',
            'options.security.disabledSuccess': 'Local data encryption disabled.',
            'options.security.unlockTitle': 'Unlock local data',
            'options.security.unlockDescription': 'Enter the password to access locally stored data.',
            'options.security.unlockPassword': 'Password',
            'options.security.unlockButton': 'Unlock',
            'options.security.unlockError': 'Could not unlock data. Please check the password.',
            'options.security.lockedByTimeout': 'Session expired. Data has been locked again.',
            'confirm.deleteGroup': 'Delete group "%s" and all its links?',
            'confirm.deleteLink': 'Delete this link?',
            'confirm.deleteRefLink': 'Delete this ref link?',
            'options.groups.defaultGroupFormatting': 'Default group formatting',
            'options.groups.defaultGroupFormatting.help': 'Background formatting applied to newly created groups',
            'options.groups.defaultGroupTitleFormatting': 'Default group title formatting',
            'options.groups.defaultGroupTitleFormatting.help': 'Title formatting applied to newly created groups',
            'options.groups.defaultGroupLinkFormatting': 'Default group link formatting',
            'options.groups.defaultGroupLinkFormatting.help': 'Link formatting applied to all links in newly created groups',
            'options.groups.defaultGroupBadgeFormatting': 'Default badge formatting',
            'options.groups.defaultGroupBadgeFormatting.help': 'Badge formatting for link count and keywords in newly created groups',
            'options.groups.defaultLinkCountFormatting': 'Default link count formatting',
            'options.groups.defaultLinkCountFormatting.help': 'Formatting for link count display in newly created groups',
            'options.links.defaultLinkFormatting': 'Default link formatting',
            'options.links.defaultLinkFormatting.help': 'Default formatting for individual links',
            'options.links.defaultUrlPrefix': 'Automatic URL prefix',
            'options.links.defaultUrlPrefix.help': 'Prefix to add when a URL has no scheme (e.g., https://). Leave empty to add nothing.',
            'options.groups.clearClosesAllGroups': 'Collapse all groups when clearing search',
            'options.groups.clearClosesAllGroups.help': 'On Clear, collapse all groups for privacy',
            'options.groups.keywordClickExpandsAll': 'Expand all groups on keyword click',
            'options.groups.keywordClickExpandsAll.help': 'When clicking a keyword chip, expand all groups',
            'options.groups.searchAutoExpandFound': 'Auto-expand matching groups during search',
            'options.groups.searchAutoExpandFound.help': 'Expand groups that match the current search text',
            'options.colors.generalSection': 'General Website Colors',
            'options.colors.globalFormatting': 'Global Formatting',
            'options.colors.globalFormatting.help': 'Sets the overall appearance and background of the entire application',
            'options.colors.background': 'Website Background',
            'options.colors.background.help': 'Sets the main background color of the entire website',
            'options.colors.toolbarBackground': 'Toolbar Background',
            'options.colors.toolbarBackground.help': 'Background color of the toolbar containing search and action buttons',
            'options.colors.titleBarBackground': 'Title Bar Background',
            'options.colors.titleBarBackground.help': 'Background color of the title bar at the top of the page',
            'options.colors.titleTextColor': 'Title Text Color',
            'options.colors.titleTextColor.help': 'Color of the title text in the header',
            'options.colors.keywordBackground': 'Default keyword formatting',
            'options.colors.keywordBackground.help': 'Default background/formatting for the keyword area and badges',
            'options.colors.resetAll': 'Reset All Colors',
            'options.colors.reset': 'Reset',
            'css.custom.open': 'Custom CSS',
            'css.custom.title': 'Custom CSS',
            'css.custom.help': 'Styles are applied live. Example selectors: .groupTitle .text-truncate, .linkText a',
            'css.custom.placeholder': 'Example: .linkText a { color: #0d6efd; }',
            'css.reset': 'Reset',
            'css.custom.hooks': 'Hook classes',
            'css.custom.clickToInsert': 'Click to insert',
            'css.custom.selectClass': '-- Select CSS Selector --',
            'css.custom.layoutStructure': 'Layout & Structure',
            'css.custom.groups': 'Groups',
            'css.custom.groupInfo': 'Group Info Section',
            'css.custom.currentGroups': 'Current Groups',
            'css.custom.links': 'Links',
            'css.custom.currentLinks': 'Current Links',
            'css.custom.badges': 'Badges & Keywords',
            'css.custom.currentKeywords': 'Current Keywords',
            'css.custom.keywordsInGroups': 'Keywords in Groups',
            'css.custom.keywordsInLinks': 'Keywords in Links',
            'css.custom.specificGroupKeywords': 'Specific Keywords (Group → Keyword)',
            'css.custom.specificKeywords': 'Specific Keywords (Group → Link → Keyword)',
            'css.custom.multiline': 'With Comments',
            'css.custom.multilineTooltip': 'Add explanatory comments above complex selectors for better readability',
            'css.selectorExists': 'CSS selector already exists! Jumped to line.',
            'css.custom.buttons': 'Buttons & Forms',
            'css.custom.modals': 'Dialogs & Modals',
            'css.custom.sidebar': 'Sidebar & CSS Editor',
            'css.custom.keywordBar': 'Keyword Bar',
            'link.favicon.upload': 'Upload favicon',
            'link.favicon.remove': 'Remove',
            'link.favicon.invalidFile': 'Please select an image file',
            'link.favicon.tooLarge': 'Image is too large (max 256KB)',
            'link.favicon.uploaded': 'Favicon uploaded',
            'link.favicon.readError': 'Could not read image file',
            'group.favicon.upload': 'Upload group icon',
            'group.favicon.remove': 'Remove icon',
            'group.favicon.invalidFile': 'Please select an image file',
            'group.favicon.tooLarge': 'Image is too large (max 256KB)',
            'group.favicon.uploaded': 'Group icon updated',
            'group.favicon.readError': 'Could not read image file',
            'css.custom.slugHelpTitle': 'Keyword slugs',
            'css.custom.slugHelpText': 'Keywords are transformed to slugs: lowercased, spaces → dash, other non [a-z0-9_-] → dash.\nExamples: "UI/UX" → ui-ux, "C++" → c--, "Foo Bar" → foo-bar.\n\nKeyword CSS levels:\n1) Global keyword chips:\n   .mb-keyword { ... }\n   .mb-keyword-kw-<slug> { ... }\n\n2) Per group keyword chips:\n   .group-uuid-<uuid> .mb-group__keyword-badge { ... }\n   .group-uuid-<uuid> .mb-keyword-kw-<slug> { ... }\n\n3) Per link keyword chips:\n   .link-uuid-<uuid> .mb-link__keyword-badge { ... }\n   .link-uuid-<uuid> .mb-keyword-kw-<slug> { ... }\n\n4) Combined / specific anchor styles:\n   .group-uuid-<uuid> .mb-link__anchor { ... }\n   .link-uuid-<uuid> .mb-link__anchor { ... }\n\nTip: Copy UUID via context menu → "Copy CSS class".',
            'css.custom.helpTitle': '🎨 CSS CUSTOMIZATION GUIDE',
            'css.templates.select': '-- Select Template --',
            'css.templates.save': 'Save as Template',
            'css.templates.delete': 'Delete Template',
            'css.templates.namePlaceholder': 'Enter template name...',
            'css.templates.overwriteConfirm': 'Template "{0}" already exists. Overwrite?',
            'css.templates.saved': 'Template "{0}" saved',
            'css.templates.loaded': 'Template "{0}" loaded',
            'css.templates.deleted': 'Template "{0}" deleted',
            'css.templates.deleteConfirm': 'Really delete template "{0}"?',
            'css.templates.darkMode': 'Dark Mode',
            'css.templates.minimal': 'Minimal',
            'css.templates.colorful': 'Colorful',
            'css.visual.title': 'Visual CSS Editor',
            'css.visual.templates': 'CSS Templates',
            'css.visual.rules': 'CSS Rules',
            'css.visual.generated': 'Generated CSS',
            'css.visual.importantHint': 'Override other styles with !important',
            'css.visual.designTokens': 'Design Tokens',
            'css.visual.addToken': 'Add Token',
            'css.visual.noTokens': 'No tokens yet. Add some (e.g., brand-primary (without --), #3b82f6)',
            'css.visual.tokensHint': 'Use tokens via the dropdown next to properties (var(--token)).',
            'css.visual.tokensSelect': '-- Select Token --',
            'css.visual.valuePlaceholder': 'Enter value (e.g., #ff0000, rgb(), var(--...))',
            'css.visual.openFormatEditor': 'Open property format editor',
            'css.visual.formatEditor': 'Property Format Editor',
            'css.visual.formatEditorNoSelection': 'Select a property with the gear button next to "Enter value...".',
            'css.visual.formatEditorBasic': 'Basic',
            'css.visual.formatEditorValue': 'Value Builder',
            'css.visual.formatEditorAdvanced': 'Advanced',
            'css.visual.formatEditorApply': 'Apply',
            'css.visual.formatEditorRevert': 'Revert',
            'css.visual.formatEditorUseRaw': 'Edit as raw CSS value',
            'css.visual.formatEditorPreview': 'Preview',
            'css.visual.formatEditorProperty': 'Property',
            'css.visual.formatEditorType': 'Type',
            'css.visual.formatEditorRawEnabled': 'Raw mode enabled. Disable it to use guided controls.',
            'css.visual.formatEditorRawOnly': 'This property uses raw mode only.',
            'css.visual.value': 'Value',
            'css.visual.none': 'None',
            'css.visual.color': 'Color',
            'css.visual.alpha': 'Alpha',
            'css.visual.fontFamilyCustom': 'Custom font-family value',
            'css.visual.linkValues': 'Link values',
            'css.unit': 'Unit',
            'css.blur': 'Blur',
            'css.spread': 'Spread',
            'css.visual.tokenName': 'Token name',
            'css.visual.tokenValue': 'Token value',
            'css.visual.invalidCssValue': 'Invalid CSS value',
            'css.visual.missingTokens': 'Missing tokens',
            'css.visual.invalidTokenValue': 'Invalid token value (e.g., #rrggbb, rgb(), linear-gradient(), var(--name))',
            'extension.clearCache': 'Clear extension cache',
            'extension.cacheCleared': 'Extension cache cleared',
            'extension.cacheClearFailed': 'Failed to clear extension cache',
            'extension.notAvailable': 'Extension not available',
            'extension.refetchFavicons': 'Re-fetching favicons…',
            
            'css.visual.pickElement': 'Pick element',
            'css.visual.pickerActive': 'Element picker active: Click an element in content',
            'css.visual.picked': 'Picked',
            'css.visual.applyPreset': 'Apply preset…',
            'css.visual.presetApplied': 'Preset applied',
            'css.visual.rule': 'Rule',
            'css.visual.doubleClickToEdit': 'Double-click to edit',
            'css.visual.copy': 'Copy',
            'css.visual.toggleCollapse': 'Toggle collapse',
            'css.visual.expandAll': 'Expand all',
            'css.visual.collapseAll': 'Collapse all',
            'css.visual.activate': 'Activate',
            'css.visual.deactivate': 'Deactivate',
            'css.visual.searchRules': 'Search rules…',
            'css.visual.activateProperty': 'Activate property',
            'css.visual.deactivateProperty': 'Deactivate property',
            'css.visual.selectElementShort': 'Select element',
            'css.visual.customCss': 'Custom CSS',
            'css.visual.moveUp': 'Move up',
            'css.visual.moveDown': 'Move down',
            'css.visual.duplicate': 'Duplicate',
            'css.visual.delete': 'Delete',
            'css.visual.selectTemplate': '-- Select Template --',
            'css.visual.defaultTemplates': 'Default Templates',
            'css.visual.appLevel': 'App Level',
            'css.visual.uiPrimitives': 'UI Primitives',
            'css.visual.groupLevel': 'Group Level',
            'css.visual.linkLevel': 'Link Level',
            'css.visual.allGroups': 'All Groups',
            'css.visual.groupHeader': 'Group Header',
            'css.visual.groupTitle': 'Group Title',
            'css.visual.groupContent': 'Group Content',
            'css.visual.allLinks': 'All Links',
            'css.visual.allSeparators': 'All Separators',
            'css.visual.allNotes': 'All Notes',
            'css.visual.linkHover': 'Link (Hover)',
            'css.visual.state': 'State',
            'css.visual.hoverState': 'Hover (:hover)',
            'css.visual.dragOverState': 'Drag Over (.drag-over-active)',
            'css.visual.linkAnchor': 'Link Anchor',
            'css.visual.linkUrl': 'Link URL',
            'css.visual.linkIcon': 'Link Icon',
            'css.visual.keywords': 'Keywords',
            'css.visual.allKeywords': 'All Keywords (Keyword Bar)',
            'css.visual.selectedKeywords': 'Selected Keywords (Keyword Bar)',
            'css.visual.selectedKeywordText': 'Selected Keyword Text',
            'css.visual.keywordsHierarchical': 'Keywords (Hierarchical)',
            'css.visual.keywordByName': 'Keyword by Name',
            'css.visual.keywordSuggestions': 'Keyword Suggestions List',
            'css.visual.keywordSuggestionItem': 'Keyword Suggestion Item',
            'css.visual.apply': 'Apply',
            'css.visual.save': 'Save',
            'css.visual.migrationNotice': 'Note: Your existing Custom CSS has been imported. You can edit or delete it above as a "Legacy CSS" rule.',
            'css.visual.selectGroup': '-- All Groups --',
            'css.visual.selectLink': '-- All Links --',
            'css.visual.selectSeparator': '-- All Separators --',
            'css.visual.selectNote': '-- All Notes --',
            'css.visual.separatorShort': 'Sep.',
            'css.visual.noteShort': 'Note',
            'css.visual.selectKeyword': '-- All Keywords --',
            'css.visual.keyword': 'Keyword',
            'css.visual.customProperties': 'Custom CSS Properties',
            'css.visual.customPropertiesHint': 'e.g. display: flex;\njustify-content: center;',
            'css.visual.customPropertiesHelp': 'Enter any CSS properties (one per line)',
            'css.visual.generatedSelector': 'Generated Selector',
            'css.visual.ruleSets': 'Rule Sets',
            'css.visual.loadRuleSet': 'Load Rule Set',
            'css.visual.saveCurrentRules': 'Save Current Rules',
            'css.visual.savedRuleSets': 'Saved Sets',
            'css.visual.rulesCount': 'rules',
            'css.visual.deleteRuleSet': 'Delete',
            'css.visual.ruleSetName': 'Rule Set Name:',
            'css.visual.ruleSetSaved': 'Rule set saved!',
            'css.visual.loadRuleSetConfirm': 'Load this rule set? Your current rules will be replaced.',
            'css.visual.deleteRuleSetConfirm': 'Delete this rule set?',
            'css.visual.selectRuleSet': '-- Select --',
            'css.visual.ruleSetLoaded': 'Rule set loaded',
            'css.visual.ruleSetDeleted': 'Rule set deleted',
            'css.visual.clearAll': 'Clear All',
            'css.visual.clearAllTooltip': 'Delete all CSS settings',
            'css.visual.clearAllConfirm': 'Do you really want to delete ALL CSS settings?\n\nThis will remove:\n• All CSS rules\n• The selected template\n• All saved rule sets\n\nThis action cannot be undone!',
            'css.visual.clearedAll': 'All CSS settings have been deleted',
            'css.visual.clearProperties': 'Clear Properties',
            'css.visual.clearPropertiesTitle': 'Delete all properties of this rule',
            'css.visual.propertiesCleared': 'Properties cleared',
            'css.visual.propertyAlreadyExists': 'This property already exists in this rule',
            'css.templates.defaultTemplates': 'Default Templates',
            'css.templates.customTemplates': 'Custom Templates',
            'css.templates.cannotDeleteDefault': 'Default templates cannot be deleted',
            'options.colors.add': 'Add Color',
            'options.links': 'Links',
            'options.sharing': 'Sharing',
            'options.sync': 'NTFY Synchronization',
            // Role badges
            'sync.role.all': 'All',
            'sync.role.owner': 'Owner',
            'sync.role.member': 'Member',
            // Conflict notification settings
            'options.sync.conflictNotificationLevel': 'Sync conflict notifications',
            'options.sync.conflictNotificationLevel.help': 'How to display sync conflict resolutions (applies to everyone):\n• Silent - No notifications, conflicts resolved automatically\n• Important only - Show only critical conflicts that may affect your data\n• All conflicts - Show every conflict resolution for full transparency',
            'options.sync.conflictNotificationLevel.silent': 'Silent',
            'options.sync.conflictNotificationLevel.minimal': 'Important only',
            'options.sync.conflictNotificationLevel.verbose': 'All conflicts',
            // Auto sync interval
            'options.sync.autoSyncInterval': 'Automatic sync interval',
            'options.sync.autoSyncInterval.help': 'How often to check for updates (applies to everyone):\n• 5 minutes - For active collaboration, moderate battery usage\n• 10 minutes - Good balance between updates and resource usage\n• 30 minutes - Battery-friendly, suitable for less active groups\n• 1 hour - Minimal resource usage, for rarely changing content\n• Manual only - You control when to sync, no automatic updates',
            'options.sync.autoSyncInterval.5min': '5 minutes',
            'options.sync.autoSyncInterval.10min': '10 minutes',
            'options.sync.autoSyncInterval.30min': '30 minutes',
            'options.sync.autoSyncInterval.1hour': '1 hour',
            'options.sync.autoSyncInterval.manual': 'Manual only',
            // Offline mode
            'options.sync.offlineMode': 'Offline Mode',
            'options.sync.offlineMode.help': 'How to handle changes when offline (applies to everyone):\n• Show immediately - Changes appear instantly, may need correction later if conflicts occur\n• Wait for confirmation - Changes only appear after successful sync, more reliable but slower',
            'options.sync.offlineMode.optimistic': 'Show immediately',
            'options.sync.offlineMode.conservative': 'Wait for confirmation',
            // Owner-only settings
            'options.sync.conflictResolution': 'Conflict resolution strategy',
            'options.sync.conflictResolution.help': 'How to resolve editing conflicts (owner groups only):\n• Owner wins - Your changes as owner always take priority\n• Latest wins - Most recent change wins regardless of who made it\n• Ask me - Prompt for each conflict (may interrupt workflow)',
            'options.sync.conflictResolution.ownerWins': 'Owner wins',
            'options.sync.conflictResolution.lastWriteWins': 'Latest wins',
            'options.sync.conflictResolution.manual': 'Ask me',
            'options.sync.memberRateLimit': 'Change limit per member (per minute)',
            'options.sync.memberRateLimit.help': 'Max changes per minute per member (0 = unlimited, owner groups only)',
            'options.sync.memberRateLimit.suffix': 'per min',
            'options.sync.validationLevel': 'Validation Level',
            'options.sync.validationLevel.help': 'How strictly to validate incoming changes (owner groups only):\n• Strict - Reject any suspicious or malformed data\n• Moderate - Allow minor issues but block major problems\n• Permissive - Accept most changes, only block critical errors',
            'options.sync.validationLevel.strict': 'Strict',
            'options.sync.validationLevel.moderate': 'Moderate',
            'options.sync.validationLevel.permissive': 'Permissive',
            // Member-only settings
            'options.sync.localCacheStrategy': 'Amount of data kept locally',
            'options.sync.localCacheStrategy.help': 'How much data to keep locally (member groups only):\n• Everything - Keep full history and all versions locally (uses more storage)\n• Current only - Keep only latest version (saves storage space)',
            'options.sync.localCacheStrategy.full': 'Everything',
            'options.sync.localCacheStrategy.minimal': 'Current only',
            'options.sync.errorHandling': 'Behavior on sync errors',
            'options.sync.errorHandling.help': 'How to handle sync errors (member groups only):\n• Auto-retry - Automatically retry failed operations (recommended)\n• Queue for later - Save failed changes to retry manually\n• Discard on error - Give up on failed changes (data may be lost)',
            'options.sync.errorHandling.retry': 'Auto-retry',
            'options.sync.errorHandling.queue': 'Queue for later',
            'options.sync.errorHandling.discard': 'Discard on error',
            'options.sharing.ntfyServerUrl': 'Notification server (ntfy) URL',
            'options.sharing.ntfyServerUrl.help': 'URL of the ntfy push notification server, Default: https://ntfy.c5p.de (high limits)',
            'options.sharing.ntfyAuthToken': 'Auth Token',
            'options.sharing.ntfyAuthToken.help': 'Optional Bearer token for authentication',
            'options.sharing.defaultTtl': 'Default message lifetime (TTL)',
            'options.sharing.defaultTtl.help': 'Time to live in seconds (0 = server default)',
            'options.sharing.quickCodeTtl': 'Quick-Connect code lifetime (sec)',
            'options.sharing.quickCodeTtl.help': 'Validity of quick share codes in seconds',
            'options.sharing.contactOnlineTimeout': 'Contact online status timeout (sec)',
            'options.sharing.contactOnlineTimeout.help': 'How long a contact is shown as online without response (in seconds)',
            'options.links.openInNewTab': 'Open links in new tab',
            'options.links.openInNewTab.help': 'If enabled, clicking a link opens it in a new browser tab',
            'options.links.progressiveLoadingThreshold': 'Initial link count before "Show more"',
            'options.links.progressiveLoadingThreshold.help': 'Number of links to show initially per group (show more button appears above this limit)',
            'options.links.addViaDialog': 'Add links via dialog',
            'options.links.addViaDialog.help': 'Show an add button in the group header and hide inline inputs',
            'options.links.autoFetchTitle': 'Automatically fetch page title on add',
            'options.links.autoFetchTitle.help': 'Try to fetch the web page title and prefill link title (best-effort)',
            'options.links.autoFetchFavicon': 'Automatically fetch website icon (favicon)',
            'options.links.autoFetchFavicon.help': 'Use a favicon service URL to render the icon before the link',
            'options.links.allowExternalFaviconService': 'Allow external favicon fallback service (Google)',
            'options.links.allowExternalFaviconService.help': 'If enabled, missing popover favicons are loaded via Google favicon service (can trigger requests to t3.gstatic.com).',
            'options.links.showLinkBadges': 'Show link keyword badges',
            'options.links.showLinkBadges.help': 'Display keyword badges next to links',
            'options.links.showReferenceMarker': 'Show reference link marker (*)',
            'options.links.showReferenceMarker.help': 'Display a subtle asterisk next to reference links.',
            'options.links.showLinkPopover': 'Show link info popover on hover',
            'options.links.showLinkPopover.help': 'Display a multi-line popover with metadata when hovering or focusing a link',
            'css.visual.popoverLevel': 'Link Popover',
            'css.visual.linkPopover': 'Popover container',
            'css.visual.linkPopoverTitle': 'Popover title row',
            'css.visual.linkPopoverUrl': 'Popover URL line',
            'css.visual.linkPopoverMeta': 'Popover metadata block',
            'css.visual.linkPopoverRow': 'Popover metadata row',
            'css.visual.linkPopoverLabel': 'Popover label',
            'css.visual.linkPopoverValue': 'Popover value',
            'css.visual.linkPopoverValueMuted': 'Popover relative value',
            'css.visual.linkPopoverKeywords': 'Popover keywords container',
            'css.visual.linkPopoverBadge': 'Popover keyword badge',
            'css.visual.linkPopoverFavicon': 'Popover favicon',
            'options.links.copyUrlFormat': 'Format for "Copy URL"',
            'options.links.copyUrlFormat.help': 'Format for copying links. Available placeholders: {title}, {url}, {keywords}, {date}, {time}',
            'options.buttons': 'Quick Action Buttons',
            'options.buttons.showAddLink': 'Show quick action "Add link"',
            'options.buttons.showAddLink.help': 'Display the add link button in group headers',
            'options.buttons.showDeleteGroup': 'Show quick action "Delete group"',
            'options.buttons.showDeleteGroup.help': 'Display the delete button in group headers',
            'options.buttons.showKeywordQuickAddBadge': 'Show "+" keyword badge on hover',
            'options.buttons.showKeywordQuickAddBadge.help': 'Show a round + badge next to group and link keywords on mouseover to add keywords quickly',
            'options.buttons.showCopyUrl': 'Show quick action "Copy URL"',
            'options.buttons.showCopyUrl.help': 'Display the copy URL button for links',
            'options.buttons.showQrCode': 'Show quick action "QR code"',
            'options.buttons.showQrCode.help': 'Display the QR code button for links',
            'options.buttons.showDeleteLink': 'Show quick action "Delete link"',
            'options.buttons.showDeleteLink.help': 'Display the delete button for links',
            'groups.openAll': 'Open all',
            'groups.closeAll': 'Close all',
            'toolbar.equalizeGroupColumns': 'Equalize group column widths',
            'group.toggleGroupCollapse': 'Toggle group collapse',
            'group.moveGroupLeft': 'Move group left',
            'group.moveGroupRight': 'Move group right',
            'group.deleteGroup': 'Delete group',
            'group.link.moveLinkLeft': 'Move link left',
            'group.link.moveLinkRight': 'Move link right',
            'group.link.deleteLink': 'Delete link',
            'group.link.linkText': 'Link text',
            'group.link.linkUrl': 'Link URL',
            'group.link.add': 'Add',
            'group.link.dropAfter': 'Drop here',
            // Sync and Conflict Resolution
            'sync.conflictResolved': 'Sync Conflict Resolved',
            'sync.conflict.linkEdit': 'Link edit conflict resolved automatically',
            'sync.conflict.linkAdd': 'Duplicate link prevented',
            'sync.conflict.linkDelete': 'Link deletion conflict resolved',
            'sync.conflict.generic': 'Sync conflict automatically resolved',
            'group.dropAfter': 'Drop here',
            'menu.group.editGroup': 'Edit group',
            'group.showMore': 'Show more',
            'group.showLess': 'Show less',
            'group.resizeHeight': 'Drag to resize group height. Double-click to auto-fit this group.',
            'menu.group.inviteMembers': 'Invite members…',
            'menu.group.transferOwnership': 'Transfer ownership…',
            'menu.group.duplicate': 'Duplicate',
            'menu.keywords': 'Keywords',
            'menu.keyword.new': 'New keyword',
            'menu.keyword.remove': 'Remove',
            'menu.keyword.add': 'Add',
            'menu.keyword.noneAssigned': 'No assigned keywords',
            'menu.keyword.noneAvailable': 'No remaining keywords',
            'keywords.manage': 'Manage',
            'keywords.dialog.title': 'Manage Keywords',
            'keywords.dialog.empty': 'No keywords available',
            'keywords.dialog.newName': 'New name',
            'keywords.dialog.rename': 'Rename',
            'keywords.dialog.delete': 'Delete',
            'keywords.dialog.renameMissing': 'Please select a keyword.',
            'keywords.dialog.renameSame': 'Please enter a different keyword name.',
            'keywords.dialog.renameSuccess': 'Keyword renamed.',
            'keywords.dialog.deleteSuccess': 'Keyword deleted.',
            'keywords.dialog.confirmDelete': 'Delete keyword "%s" everywhere?',
            'keywords.quick.title.group': 'Add group keyword',
            'keywords.quick.title.link': 'Add link keyword',
            'keywords.quick.inputLabel': 'Keyword',
            'keywords.quick.placeholder': 'Enter keyword',
            'keywords.quick.help': 'Separate multiple keywords with comma or semicolon.',
            'keywords.quick.add': 'Add',
            'keywords.quick.empty': 'Please enter at least one keyword.',
            'keywords.quick.added': 'Keyword added.',
            'keywords.quick.duplicate': 'Keyword already assigned.',
            'dialog.contacts.title': 'Contacts',
            'dialog.contacts.empty': 'No contacts yet',
            'dialog.contacts.name': 'Name',
            'dialog.contacts.uuid': 'UUID',
            'dialog.contacts.status': 'Status',
            'dialog.contacts.actions': 'Actions',
            'dialog.contacts.sendTest': 'Send test',
            'dialog.contacts.remove': 'Remove',
            'dialog.contacts.online': 'online',
            'dialog.contacts.offline': 'offline', 
            'dialog.contacts.checking': 'checking...',
            'dialog.contacts.reachable': 'reachable',
            'dialog.contacts.unreachable': 'unreachable',
            'dialog.contacts.offlineTooltip': 'Contact is offline',
            'dialog.contacts.cannotSendOffline': 'Cannot send to offline contact',
            'dialog.contacts.removeWarningOwner': 'This contact owns',
            'dialog.contacts.removeWarningGroups': 'shared group(s) that will be deleted',
            'dialog.contacts.removeWarningMember': 'This contact is member of',
            'dialog.contacts.removeWarningYourGroups': 'of your shared group(s)',
            'dialog.contacts.removeConfirm': 'Remove contact',
            'dialog.contacts.removeNote': 'This contact will no longer be able to send you messages.',
            'dialog.share.title': 'Share',
            'dialog.send.linkTitle': 'Send Link',
            'dialog.send.groupTitle': 'Send Group',
            'dialog.send.selectContacts': 'Select contacts to send to:',
            'dialog.send.noContacts': 'No contacts available. Add contacts first.',
            'dialog.send.send': 'Send',
            'dialog.send.cancel': 'Cancel',
            'dialog.transfer.title': 'Transfer Ownership',
            'dialog.transfer.select': 'Select new owner:',
            'dialog.transfer.noCandidates': 'No eligible members found.',
            'dialog.transfer.transfer': 'Transfer',
            'dialog.transfer.acceptPrompt': 'The current owner requests to transfer group ownership to you. Do you accept?',
            'dialog.invite.title': 'Invite Members',
            'qc.receive': 'RECEIVE',
            'qc.receive.desc': 'Show code',
            'qc.receive.instruction': 'Share this code:',
            'qc.send': 'SEND',
            'qc.send.desc': 'Enter code',
            'qc.send.instruction': 'Enter the code:',
            'qc.generate': 'Generate Code',
            'qc.connect': 'Connect',
            'qc.stop': 'Stop',
            'qc.cancel': 'Cancel',
            'dialog.contacts.tabTitle': 'Contacts',
            'dialog.quickconnect.tabTitle': 'Quick-Connect',
            'dialog.close': 'Close',
            'members.title': 'Members',
            'members.filter.allow': 'allowed',
            'members.filter.deny': 'blocked',
            'members.filter.unset': 'local default',
            'members.remove': 'Remove',
            'members.noRoster': 'No member list received yet',
            'removedFromGroup.title': 'Group Membership Removed',
            'removedFromGroup.message': 'You have been removed from the following group while you were offline:',
            'removedFromGroup.owner': 'Group Owner:',
            'removedFromGroup.removedAt': 'Removed:',
            'removedFromGroup.explanation': 'The group will be removed from your list. If you need access again, please contact the group owner.',
            'removedFromGroup.acknowledge': 'I Understand',
            'members.perm.add': 'Add',
            'members.perm.edit': 'Edit',
            'members.perm.delete': 'Delete',
            'error.perm.add': 'You do not have permission to add links in this group.',
            'error.perm.edit': 'You do not have permission to edit links in this group.',
            'error.perm.delete': 'You do not have permission to delete links in this group.',
            'permission.denied': 'No permission',
            'error.onlyOwner': 'Only the owner can invite members.',
            'group.shared': 'Shared group',
            'group.keywords': 'Keywords',
            'group.shortcut': 'Group shortcut',
            'group.basic': 'Basic Settings',
            'group.styling': 'Styling',
            'group.advanced': 'Advanced',
            'group.name': 'Group Name',
            'group.name.help': 'HTML is allowed. Safe tags only (b, i, strong, em, br, span, small, code, pre, a with http/https/mailto).',
            'group.name.required': 'Please enter a group name',
            'group.keywords.help': 'Keywords for searching and filtering (separate with comma or semicolon)',
            'group.shortcut.placeholder': 'Focus field and press e.g. Ctrl+Alt+G',
            'group.shortcut.help': 'Press the key combination here to open all links in this group at once.',
            'group.manualHeightResizeOverride': 'Allow manual height resize for this group',
            'group.manualHeightResizeOverride.help': 'Overrides the global auto-height setting for this group. When enabled, you can resize this group manually.',
            'group.color': 'Color',
            'group.backgroundFormatting': 'Background Formatting',
            'group.titleFormatting': 'Title Formatting',
            'group.linkFormatting': 'Link Formatting',
            'group.badgeFormatting': 'Keyword Badge Formatting',
            'group.pillFormatting': 'Link Count Formatting',
            'group.infoHtml': 'Info HTML',
            'group.infoHtml.placeholder': 'Enter HTML content to display in info section...',
            'group.infoHtml.help': 'This HTML will be displayed in a collapsible section below the group title.',
            'group.emoji': 'Icon',
            'group.emoji.placeholder': 'Click to select emoji',
            'group.emoji.help': 'Select an emoji icon for this group',
            'group.info.toggle': 'Information',
            'link.info': 'Information',
            'link.infoHtml': 'Info HTML',
            'link.infoHtml.placeholder': 'Enter HTML content to display in tooltip...',
            'link.infoHtml.help': 'This HTML will be displayed when hovering over the info icon.',
            'link.popover.url': 'URL',
            'link.popover.noUrl': 'No URL available',
            'link.popover.created': 'Created',
            'link.popover.updated': 'Updated',
            'link.popover.originalUrl': 'Original Input',
            'link.popover.untitled': 'Untitled link',
            'link.popover.notAvailable': 'Not recorded',
            'link.url.info': 'Leave URL empty to create a heading/category',
            'link.basic': 'Basic Settings',
            'link.advanced': 'Advanced',
            'link.text': 'Text',
            'link.text.help': 'HTML is allowed in the visible link text. Safe tags only. Note: anchors are stripped inside the link label.',
            'link.text.required': 'Please enter link text',
            'link.url': 'URL',
            'link.shortcut': 'Shortcut',
            'link.shortcut.placeholder': 'Focus field and press e.g. Ctrl+Alt+M',
            'link.shortcut.help': 'Press the key combination directly in this field. If multiple links share the same shortcut, all of them open together.',
            'link.shortcut.invalid': 'Please use Ctrl/Alt/Cmd plus a key (e.g. Ctrl+Alt+M).',
            'link.shortcut.reserved': 'This shortcut is reserved by the browser/system.',
            'link.shortcut.opened': 'Opened {count} link(s) via shortcut.',
            'link.shortcut.openedPartial': 'Only opened {opened} of {total} link(s). Popup blocker may have blocked the rest.',
            'link.shortcut.batchRemaining': 'Opened {opened} of {total} link(s). {remaining} remaining. Trigger the same shortcut/action again to continue.',
            'link.shortcut.confirmMany': 'Open {count} links at once?',
            'shortcuts.manage': 'Shortcut Manager',
            'shortcuts.manager.title': 'Shortcut Manager',
            'shortcuts.manager.linkAssignments': 'Defined link shortcuts',
            'shortcuts.manager.filterPlaceholder': 'Filter by shortcut, group, title or URL',
            'shortcuts.manager.noneDefined': 'No link shortcuts defined yet.',
            'shortcuts.manager.linksCount': 'links',
            'shortcuts.manager.urlsCount': 'valid URLs',
            'shortcuts.manager.openNow': 'Open now',
            'shortcuts.manager.editLink': 'Edit',
            'shortcuts.manager.globalTitle': 'Global shortcuts (open multiple pages)',
            'shortcuts.manager.globalHelp': 'Select groups and links from your bookmarks. Group selection includes all links in that group.',
            'shortcuts.manager.globalEmpty': 'No global shortcuts configured.',
            'shortcuts.manager.globalCombo': 'Shortcut',
            'shortcuts.manager.globalName': 'Name',
            'shortcuts.manager.globalNamePlaceholder': 'Optional label (e.g. Morning Start)',
            'shortcuts.manager.globalTargets': 'Select groups and links',
            'shortcuts.manager.globalNoLinks': 'No groups/links available.',
            'shortcuts.manager.invalidLinkUrl': 'Invalid URL; cannot be opened via shortcut.',
            'shortcuts.manager.remove': 'Remove',
            'shortcuts.manager.addGlobal': 'Add global shortcut',
            'shortcuts.manager.selectionStats': '{groups} groups, {links} links selected, {urls} URLs will open',
            'shortcuts.manager.invalidCombo': 'Please define a valid shortcut in row {row}.',
            'shortcuts.manager.invalidTargets': 'Please select at least one link or group in row {row}.',
            'shortcuts.manager.saved': 'Saved {count} global shortcuts.',
            'shortcuts.manager.popupBlockerHint': 'Browsers may block opening many tabs at once. If that happens, allow pop-ups for this site or trigger the shortcut/action again.',
            'shortcut.notice.globalDefined': 'Global shortcut "{combo}" is already defined and opens {count} URL(s).',
            'shortcut.notice.groupDefined': 'Group "{group}" already has shortcut "{combo}".',
            'shortcut.notice.groupInGlobal': 'Group "{group}" is already part of global shortcut "{combo}".',
            'shortcut.notice.linkInGlobalViaGroup': 'Link is already included in global shortcut "{combo}" via group "{group}".',
            'shortcut.notice.linkInGlobalDirect': 'Link is already selected in global shortcut "{combo}".',
            'shortcut.notice.linkInGroupShortcut': 'Link is already covered by group shortcut "{combo}" (group "{group}").',
            'link.itemType': 'Entry type',
            'link.itemType.help': 'Choose whether this item is a normal link, a note, or a visual separator.',
            'link.itemType.link': 'Link',
            'link.itemType.note': 'Note',
            'link.itemType.separator': 'Separator',
            'link.note.defaultLabel': 'Note',
            'note.expand': 'Expand note',
            'note.collapse': 'Collapse note',
            'link.separator.defaultLabel': 'Separator',
            'link.keywords': 'Keywords',
            'link.keywords.help': 'Keywords for searching and filtering (separate with comma or semicolon)',
            'link.emoji': 'Icon',
            'link.emoji.placeholder': 'Click to select emoji',
            'link.emoji.help': 'Select an emoji icon for this link',
            // Emoji picker
            'emoji.recent': 'Recent',
            'emoji.smileys': 'Smileys',
            'emoji.people': 'People',
            'emoji.animals': 'Animals',
            'emoji.food': 'Food',
            'emoji.travel': 'Travel',
            'emoji.activities': 'Activities',
            'emoji.objects': 'Objects',
            'emoji.symbols': 'Symbols',
            'emoji.flags': 'Flags',
            'link.color': 'Link Color',
            'color.reset': 'Reset',
            'color.remove': 'Remove',
            'color.add': 'Add Color',
            'menu.link.editLink': 'Edit link',
            'menu.link.editRefLink': 'Edit ref link',
            'menu.link.editNote': 'Edit note',
            'menu.link.editSeparator': 'Edit separator',
            'menu.link.deleteLink': 'Delete link',
            'menu.link.deleteRefLink': 'Delete ref link',
            'menu.link.deleteNote': 'Delete note',
            'menu.link.deleteSeparator': 'Delete separator',
            'menu.link.createRefLink': 'Create ref link…',
            'menu.link.editOriginalLink': 'Edit original link…',
            'link.copyUrl': 'Copy URL to clipboard',
            'link.urlCopied': 'URL copied',
            'link.copyFailed': 'Failed to copy URL',
            'link.ref.markerTitle': 'Reference link',
            'link.ref.missing': 'Reference link (original missing)',
            'link.ref.keywordReadOnly': 'Reference link keywords are read-only. Edit the original link.',
            'link.ref.sourceMissing': 'Original link could not be resolved.',
            'link.ref.createFromRefDisabled': 'Create ref link is only available for original URL links.',
            'link.ref.editDialog.title': 'Edit reference link text',
            'link.ref.editDialog.original': 'Original link',
            'link.ref.editDialog.originalKeywords': 'Original keywords',
            'link.ref.editDialog.none': 'None',
            'link.ref.editDialog.sourceMissingHint': 'The original link could not be found. You can still set a local reference text.',
            'link.ref.editDialog.aliasLabel': 'Reference text',
            'link.ref.editDialog.aliasPlaceholder': 'Leave empty to use the original link text',
            'link.ref.editDialog.help': 'Only this reference text is changed. URL and metadata stay linked to the original link.',
            'link.ref.editDialog.inheritKeywords': 'Use original link keywords',
            'link.ref.editDialog.localKeywordsLabel': 'Additional reference keywords',
            'link.ref.editDialog.localKeywordsPlaceholder': 'keyword1, keyword2',
            'link.ref.editDialog.localKeywordsHelp': 'These keywords belong only to this reference link.',
            'link.ref.selectTargetPrompt': 'Select target group number for the reference link:',
            'link.ref.invalidTarget': 'Invalid group selection.',
            'link.ref.aliasPrompt': 'Optional reference text (leave empty to use original text):',
            'link.ref.created': 'Reference link created.',
            'link.ref.deleteSourceConfirm': 'This link is used by {count} reference link(s). Delete anyway?',
            'placeholders.global.manage': 'Manage global placeholders',
            'placeholders.global.title': 'Global placeholders',
            'placeholders.global.help': 'Global placeholders are available for all links.',
            'placeholders.group.title': 'Group placeholders',
            'placeholders.group.help': 'Group placeholders override global placeholders for links in this group.',
            'placeholders.link.title': 'Link placeholders',
            'placeholders.urlTemplate': 'URL template',
            'placeholders.noneInUrl': 'No placeholders found in URL template.',
            'placeholders.name': 'Name',
            'placeholders.value': 'Value',
            'placeholders.encode': 'Encode',
            'placeholders.valuePlaceholder': 'Enter value',
            'placeholders.encodeLabel': 'URL-encode',
            'placeholders.preview': 'Preview',
            'placeholders.unresolvedHint': 'Unresolved placeholders',
            'placeholders.add': 'Add placeholder',
            'placeholders.inheritedValue': 'Inherited value',
            'placeholders.restoreInherited': 'Restore inherited',
            'placeholders.inheritedLocked': 'Inherited placeholders cannot be deleted.',
            'toast.success': 'Success',
            'toast.error': 'Error',
            'toast.warning': 'Warning',
            'toast.info': 'Information',
            'menu.link.sendLink': 'Send link…',
            'menu.link.createQrCode': 'Create QR code',
            'menu.link.copyForCss': 'Copy for CSS',
            'menu.link.copyCssClass': 'Copy CSS class',
            'menu.link.copyUuid': 'Copy UUID',
            'menu.link.copyCssSelector': 'Copy CSS selector [data-link-uuid]',
            'menu.group.sendGroup': 'Send group…',
            'menu.group.members': 'Members…',
            'menu.group.inspectJSON': 'Inspect JSON',
            'menu.group.enableEventLog': 'Enable Event-Log (Beta)',
            'menu.group.copyForCss': 'Copy for CSS',
            'menu.group.copyCssClass': 'Copy CSS class',
            'menu.group.copyUuid': 'Copy UUID',
            'menu.group.copyCssSelector': 'Copy CSS selector [data-group-uuid]',
            'menu.group.leaveGroup': 'Leave group…',
            'menu.group.sort': 'Sort links',
            'menu.group.sort.withinColumns': 'Within columns (A→Z)',
            'menu.group.sort.preserveCounts': 'Global A→Z, preserve column sizes',
            'menu.group.sort.rebalance': 'Global A→Z, rebalance columns',
            'menu.group.sort.withinColumnsDesc': 'Within columns (Z→A)',
            'menu.group.sort.preserveCountsDesc': 'Global Z→A, preserve column sizes',
            'menu.group.sort.rebalanceDesc': 'Global Z→A, rebalance columns',
            'menu.group.sort.separatorFallback': 'Groups with separators can only be sorted within columns.',
            'menu.group.addSeparator': 'Add separator…',
            'menu.group.addNote': 'Add note…',
            'group.separator.add': 'Add separator',
            'group.note.add': 'Add note',
            'json.inspector.title': 'Group JSON Inspector',
            'json.inspector.info': 'Complete JSON representation of the group object',
            'json.inspector.copy': 'Copy JSON',
            'json.inspector.stats': 'Statistics',
            'error.eventlog.ownerOnly': 'Only the owner can enable event-log for this group',
            'Are you sure?': 'Are you sure?',
            'tools': 'Tools',
            'snapshots.title': 'Snapshots',
            'snapshots.save': 'Save snapshot',
            'snapshots.none': 'No snapshots yet',
            'snapshots.promptName': 'Snapshot name:',
            'snapshots.restore.confirm': 'Restore this snapshot? Current state will be added to Undo.',
            'snapshots.delete.confirm': 'Delete this snapshot?',
            'clear': 'Clear',
            'undo': 'Undo',
            'redo': 'Redo',
            'duplicates.find': 'Find duplicates',
            'duplicates.title': 'Duplicate Links Found',
            'duplicates.description': 'The following links appear in multiple groups:',
            'duplicates.none': 'No duplicates found.',
            'duplicates.copies': 'copies',
            'duplicates.keep': 'Keep',
            'duplicates.remove': 'Remove',
            'duplicates.info': 'The first occurrence of each link will be kept. Unchecked items will not be deleted.',
            'duplicates.removeSelected': 'Remove Selected Duplicates',
            'duplicates.confirmDelete': 'Delete %s duplicate(s) and keep the first?',
            'duplicates.deleted': 'Deleted %s duplicate(s).',
            'bookmarklet.addCurrentTab': 'Bookmarklet: Add current tab',
            'bookmarklet.instructions': 'Drag this link to your bookmarks bar to add the current tab here. Clicking it on any page opens this app with the URL prefilled.'
            , 'bookmarklet.helpTitle': 'Add Current Tab (Clipboard Bookmarklet)'
            , 'bookmarklet.dragThis': 'Drag this to your bookmarks bar'
            , 'bookmarklet.step.drag': 'Drag the button below to your bookmarks bar.'
            , 'bookmarklet.step.clickAnyPage': 'On any page, click the bookmarklet to copy URL and title to your clipboard.'
            , 'bookmarklet.step.switchBack': 'Switch back to this app and click “Paste from clipboard” to add it.'
            , 'clipboard.paste': 'Paste from clipboard'
            , 'clipboard.pastePrompt': 'Paste clipboard content here (JSON or URL):'
            , 'clipboard.empty': 'Clipboard is empty.'
            , 'clipboard.invalid': 'Clipboard content is not a valid URL or JSON.'
            , 'clipboard.noPermission': 'Could not read clipboard. Paste manually when prompted.'
            , 'clipboard.modalTitle': 'Import Links'
            , 'clipboard.instructions': 'Paste JSON, CSV, or HTML bookmarks:'
            , 'clipboard.read': 'Read from Clipboard'
            , 'clipboard.add': 'Add'
            , 'clipboard.placeholder': 'Paste your data here...'
            , 'clipboard.detectedFormat': 'Detected format:'
            , 'clipboard.preview': 'Preview'
            , 'clipboard.selectAll': 'Select All'
            , 'clipboard.deselectAll': 'Deselect All'
            , 'clipboard.import': 'Import Selected'
            , 'clipboard.cancel': 'Cancel'
            , 'clipboard.noLinksFound': 'No valid links found'
            , 'clipboard.noSelection': 'Please select at least one link'
            , 'clipboard.importSuccess': 'Successfully imported links'
            , 'clipboard.readOk': 'Content read from clipboard'
            , 'import.fromFile': 'Import from file:'
            , 'import.fromUrl': 'Import from URL:'
            , 'import.urlPlaceholder': 'https://example.com/bookmarks.json'
            , 'import.fetch': 'Fetch'
            , 'import.fetching': 'Fetching...'
            , 'import.corsError': 'Cannot fetch due to CORS policy. Try downloading the file and importing it locally, or use a CORS proxy.'
            , 'import.fetchError': 'Failed to fetch'
            , 'import.fromClipboard': 'Paste from clipboard:'
            , 'import.csvSeparator': 'CSV separator (optional):'
            , 'import.csvSeparator.placeholder': 'Auto-detect (e.g. ; or ,)'
            , 'import.csvSeparator.help': 'Leave empty for automatic detection. Use \\t for tab.'
            , 'import.or': '— OR —'
            , 'import.newGroupTitle': 'New group title:'
            , 'import.groupTitlePlaceholder': 'Enter group title (optional)'
            , 'import.fullExportWarning.title': 'Warning!'
            , 'import.fullExportWarning.message': 'This is a full database export. It should only be imported into an EMPTY database to avoid conflicts. All existing data will be replaced.'
            , 'import.fullExportConfirm': 'This will REPLACE your entire database (groups, settings, contacts, etc.).\n\nThis is a restore operation - all UUIDs will be preserved.\n\nContinue?'
            , 'import.fullExportSuccess': 'Database restored successfully!'
            , 'import.groupsFound': 'Found links from the following groups:'
            , 'import.groupsWillBeCreated': 'These groups will be created automatically if they don\'t exist.'
            , 'import.defaultGroupTitle': 'Import'
            , 'import.fromBrowser': 'Import from browser:'
            , 'import.fetchingBookmarks': 'Loading bookmarks...'
            , 'import.browserBookmarks': 'Import Browser Bookmarks'
            , 'import.fullExportError': 'Database restore failed. Check console for details.'
            , 'export.title': 'Export Bookmarks'
            , 'export.selectItems': 'Select groups and links to export:'
            , 'export.groups': 'Groups'
            , 'export.selectAll': 'Select All'
            , 'export.deselectAll': 'Deselect All'
            , 'export.format': 'Export Format:'
            , 'export.selected': 'links selected'
            , 'export.export': 'Export'
            , 'export.cancel': 'Cancel'
            // Invitation dialog translations
            , 'invitation.groupTitle': 'Shared Group Invitation'
            , 'invitation.linkTitle': 'Shared Links Received'
            , 'share.groupTitle': 'Group Received'
            , 'share.linkTitle': 'Links Received'
            , 'invitation.from': 'From'
            , 'invitation.groupName': 'Group name'
            , 'invitation.linkCount': 'Number of links'
            , 'invitation.linksToAdd': 'Links to be added'
            , 'invitation.groupDescription': 'Would you like to add this shared group? You will be able to share links with other members of the group.'
            , 'invitation.linkDescription': 'Would you like to add these links to your selected group?'
            , 'invitation.sharedGroupDescription': 'Would you like to add this shared group with all its links?'
            , 'share.groupDescription': 'Would you like to add this group with all its links?'
            , 'share.linkDescription': 'Would you like to add these links?'
            , 'share.add': 'Add'
            , 'share.cancel': 'Cancel'
            , 'invitation.reject': 'Reject'
            , 'invitation.accept': 'Accept'
            // Browser Extension translations
            , 'extension.importBookmarks': 'Import Browser Bookmarks'
            , 'extension.enrichMetadata': 'Enrich Links with Metadata'
            , 'extension.notInstalled': 'Browser Extension not installed'
            , 'extension.installHint': 'Please install the MyBookmarks extension from local2/extensions/'
            , 'extension.imported': 'Imported {count} bookmarks in {groups} groups!'
            , 'extension.enriched': 'Enriched {count} links with metadata!'
            , 'extension.allHaveMetadata': 'All links already have metadata!'
            , 'extension.fetchMetadataConfirm': 'Fetch metadata for {count} links?'
            , 'extension.error': 'Error: {message}'

            // Event-Log Tab translations
            , 'eventlog.time': 'Time'
            , 'eventlog.type': 'Type'
            , 'eventlog.author': 'Author'
            , 'eventlog.details': 'Details'
            , 'eventlog.changes': 'changes'
            
            // Snapshot Tab translations
            , 'snapshot.info': 'Snapshot Information'
            , 'snapshot.created': 'Created'
            , 'snapshot.eventId': 'Event ID'
            , 'snapshot.links': 'Links in snapshot'
            , 'snapshot.members': 'Members in snapshot'
            , 'snapshot.version': 'Version'
            , 'snapshot.vectorClock': 'Vector Clock'
            , 'snapshot.member': 'Member'
            , 'snapshot.eventCount': 'Event Count'
            , 'snapshot.noVectorClock': 'No vector clock data'
            , 'snapshot.showData': 'Show snapshot data'
            
            // Event-Log & Sync Settings
            , 'options.eventlog.title': 'Event-Log & Sync'
            , 'options.eventlog.snapshotInterval': 'Snapshot every X events'
            , 'options.eventlog.snapshotInterval.help': 'Create snapshot after this many events (reduces memory usage)'
            , 'options.eventlog.maxEvents': 'Maximum number of events'
            , 'options.eventlog.maxEvents.help': 'Maximum events before forced cleanup (hard limit)'
            , 'options.eventlog.syncStrategy': 'Conflict strategy during sync'
            , 'options.eventlog.syncStrategy.help': 'How to handle conflicts when syncing'
            , 'options.eventlog.syncStrategy.ownerLeads': 'Owner leads (recommended)'
            , 'options.eventlog.syncStrategy.allEqual': 'All members equal'
            , 'options.eventlog.syncStrategy.smartMerge': 'Smart merge (experimental)'
            , 'Events': 'Events'
            , 'options.eventlog.note': 'Note:'
            , 'options.eventlog.note.text': 'Event-log settings apply when you are the group owner. Members use the owner\'s settings.'
            
            // CSS Dialog translations
            , 'css.format': 'CSS Format'
            , 'css.noStyle': 'No custom style'
            , 'css.clear': 'Clear'
            , 'css.preview.text': 'Preview Text'
            , 'css.opacity.warning': 'Note:'
            , 'css.opacity.websiteBackgroundInfo': 'For Website Background, opacity is applied to the background color only (using rgba). This prevents dialogs from becoming transparent.'
            , 'css.background': 'Background (shorthand)'
            , 'css.backgroundColor': 'Background Color'
            , 'css.backgroundOpacity': 'Opacity'
            , 'css.text': 'Text'
            , 'css.textColor': 'Text Color'
            , 'css.fontFamily': 'Font Family'
            , 'css.default': 'Default'
            , 'css.fontSize': 'Font Size'
            , 'css.fontWeight': 'Font Weight'
            , 'css.normal': 'Normal'
            , 'css.bold': 'Bold'
            , 'css.lighter': 'Lighter'
            , 'css.fontStyle': 'Font Style'
            , 'css.italic': 'Italic'
            , 'css.oblique': 'Oblique'
            , 'css.textDecoration': 'Text Decoration'
            , 'css.underline': 'Underline'
            , 'css.overline': 'Overline'
            , 'css.lineThrough': 'Line Through'
            , 'css.underlineOverline': 'Underline + Overline'
            , 'css.border': 'Border'
            , 'css.borderStyle': 'Border Style'
            , 'css.none': 'None'
            , 'css.solid': 'Solid'
            , 'css.dashed': 'Dashed'
            , 'css.dotted': 'Dotted'
            , 'css.double': 'Double'
            , 'css.groove': 'Groove'
            , 'css.ridge': 'Ridge'
            , 'css.inset': 'Inset'
            , 'css.outset': 'Outset'
            , 'css.borderWidth': 'Border Width'
            , 'css.borderColor': 'Border Color'
            , 'css.borderRadius': 'Border Radius'
            , 'css.shadow': 'Shadow'
            , 'css.boxShadow': 'Box Shadow'
            , 'css.shadowPresets': 'Presets'
            , 'css.shadowSubtle': 'Subtle'
            , 'css.shadowMedium': 'Medium'
            , 'css.shadowStrong': 'Strong'
            , 'css.shadowInset': 'Inset'
            , 'css.generatedCode': 'Generated CSS:'
            , 'css.apply': 'Apply'
            , 'css.cancel': 'Cancel'
            , 'css.shorthand': 'Shorthand'
            , 'css.spacing': 'Spacing'
            , 'css.padding': 'Padding'
            , 'css.margin': 'Margin'
            , 'css.top': 'Top'
            , 'css.right': 'Right'
            , 'css.bottom': 'Bottom'
            , 'css.left': 'Left'
            , 'css.resetAll': 'Reset All'
            
            // Visual CSS Editor translations
            , 'css.visual.addRule': 'Add New CSS Rule'
            , 'css.visual.deleteRule': 'Delete Rule'
            , 'css.visual.element': 'Element'
            , 'css.visual.selectElement': '-- Select Element --'
            , 'css.visual.group': 'Group'
            , 'css.visual.link': 'Link'
            , 'css.visual.properties': 'CSS Properties'
            , 'css.visual.addProperty': '+ Add Property...'
            , 'css.visual.colors': 'Colors'
            , 'css.visual.typography': 'Typography'
            , 'css.visual.borders': 'Borders'
            , 'css.visual.sizes': 'Sizes'
            , 'css.visual.complete': 'complete'
            , 'css.outline': 'Outline'
            , 'css.outlineWidth': 'Outline Width'
            , 'css.outlineStyle': 'Outline Style'
            , 'css.outlineColor': 'Outline Color'
            , 'css.outlineOffset': 'Outline Offset'
            , 'css.width': 'Width'
            , 'css.height': 'Height'
            , 'css.opacity': 'Opacity'
            , 'css.textAlign': 'Text Align'
            , 'css.topLeft': 'top left'
            , 'css.topRight': 'top right'
            , 'css.bottomLeft': 'bottom left'
            , 'css.bottomRight': 'bottom right'
            , 'css.visual.layout': 'Layout'
            , 'css.visual.effects': 'Effects'

            // Generic button translations
            , 'apply': 'Apply'
            , 'cancel': 'Cancel'
            , 'save': 'Save'
            , 'delete': 'Delete'
            , 'members.select': 'Select member by number:'
            , 'close': 'Close'
            , 'ok': 'OK'
            , 'features.open': 'Help / Feature overview'
            , 'sync.progress': 'Sync in progress…'
            , 'group.addLink': 'Add link'
            , 'group.resizeWidth': 'Drag to resize group column width'
            , 'link.qrCode': 'Generate QR Code'
            , 'link.copyError': 'Could not access clipboard'
            , 'favicon.loadError': 'Could not load favicon'
            , 'import.extensionRequired': 'Browser extension required for URL import. Please install the MyBookmarks extension or use file upload.'
            , 'quick.test.note': 'Test message'
            , 'quick.test.failed': 'Quick test failed.'
            , 'link.ref.editDialog.originalUrl': 'Original URL template'
            , 'link.ref.editDialog.placeholders': 'Placeholders'
          },
          'de': {
            // Favicon rules
            'options.links.faviconRules': 'Favicon-Regeln',
            'options.links.faviconRules.manage': 'Favicon-Regeln verwalten',
            'favicon.rules.title': 'Favicon-Regeln',
            'favicon.rules.add': 'Regel hinzufügen',
            'favicon.rules.apply': 'Auf bestehende Links anwenden',
            'favicon.rules.override': 'Vorhandene Favicons überschreiben',
            'favicon.rules.type': 'Typ',
            'favicon.rules.pattern': 'Muster',
            'favicon.rules.icon': 'Icon',
            'favicon.rules.comment': 'Kommentar',
            'favicon.rules.commentPlaceholder': 'Optionaler Kommentar',
            'favicon.rules.enabled': 'Aktiv',
            'favicon.rules.domain': 'Domain',
            'favicon.rules.prefix': 'URL-Präfix',
            'favicon.rules.regex': 'Regex',
            'favicon.rules.autofetch': 'Auto laden',
            'favicon.rules.upload': 'Hochladen',
            'favicon.rules.delete': 'Löschen',
            'favicon.rules.test': 'Test-URL',
            'favicon.rules.matchPreview': 'Treffervorschau',
            'favicon.rules.restoreDefaults': 'Standardregeln wiederherstellen',
            'favicon.rules.export': 'Regeln exportieren',
            'favicon.rules.import': 'Regeln importieren',
            'favicon.rules.none': 'Keine Favicon-Regeln vorhanden.',
            'favicon.rules.defaultsRestored': 'Standard-Favicon-Regeln wiederhergestellt',
            'favicon.rules.defaultsAlreadyPresent': 'Alle Standard-Favicon-Regeln sind bereits vorhanden',
            'favicon.rules.exportError': 'Export der Favicon-Regeln fehlgeschlagen',
            'favicon.rules.importSuccess': '{count} Favicon-Regeln importiert',
            'favicon.rules.importNothing': 'Keine neuen Favicon-Regeln importiert',
            'favicon.rules.importError': 'Import der Favicon-Regeln fehlgeschlagen',
            'favicon.rules.needsExtension': 'Extension erforderlich zum automatischen Laden von Icons',
            'favicon.rules.saved': 'Favicon-Regeln gespeichert',
            'favicon.rules.applied': 'Favicon-Regeln angewendet',
            // CardDAV
            'carddav.title': 'CardDAV-Sync',
            'carddav.serverUrl': 'Server-URL',
            'carddav.serverUrl.help': 'Basis-URL deines CardDAV-Servers (z. B. https://cloud.example.com)',
            'carddav.username': 'Benutzername',
            'carddav.username.help': 'Dein CardDAV-Benutzername',
            'carddav.password': 'App-Passwort',
            'carddav.password.help': 'Falls möglich App-Passwort verwenden',
            'carddav.addressbookPath': 'Adressbuch-URL/Pfad (optional)',
            'carddav.addressbookPath.help': 'Leer lassen für Auto-Discovery oder vollständigen DAV-Pfad angeben',
            'carddav.createAddressbookIfMissing': 'Adressbuch automatisch erstellen, falls nicht vorhanden',
            'carddav.createAddressbookIfMissing.help': 'Adressbuch "MyBookmarks" automatisch anlegen, sofern erlaubt',
            'carddav.syncInterval': 'Auto-Sync-Intervall',
            'carddav.syncInterval.help': 'Wie oft automatisch synchronisiert wird (0 = nur manuell)',
            'carddav.syncInterval.manual': 'Nur manuell',
            'carddav.syncInterval.5min': 'Alle 5 Minuten',
            'carddav.syncInterval.10min': 'Alle 10 Minuten',
            'carddav.syncInterval.30min': 'Alle 30 Minuten',
            'carddav.syncInterval.1hour': 'Stündlich',
            'carddav.syncNow': 'Jetzt synchronisieren (Nextcloud Bookmarks)',
            'carddav.extensionRequired': 'Browser-Erweiterung mit CardDAV-Unterstützung erforderlich',
            'carddav.notEnabled': 'CardDAV ist in den Optionen deaktiviert',
            'carddav.syncStarted': 'CardDAV-Synchronisierung gestartet',
            'carddav.syncFailed': 'CardDAV-Synchronisierung fehlgeschlagen: {message}',
            'carddav.addressbookPathMissing': 'Bitte Server-URL und Adressbuch-Pfad in den Optionen konfigurieren',
            'carddav.testConnection': 'Verbindung testen',
            'options.sync.engine': 'Sync-Backend',
            'options.sync.backend': 'Sync-Dienst',
            'options.sync.backend.help': 'Sync-Anbieter wählen',
            'options.sync.backend.carddav': 'CardDAV (experimentell)',
            'options.sync.backend.nc': 'Nextcloud Bookmarks (REST)',
            'bookmarks.title': 'Nextcloud Bookmarks',
            'bookmarks.serverUrl': 'Server-URL',
            'bookmarks.serverUrl.help': 'Basis-URL deiner Nextcloud (z. B. https://cloud.example.com)',
            'bookmarks.username': 'Benutzername',
            'bookmarks.username.help': 'Dein Nextcloud-Benutzername',
            'bookmarks.password': 'App-Passwort',
            'bookmarks.password.help': 'App-spezifisches Passwort verwenden',
            'bookmarks.rootFolderId': 'Sync-Startordner',
            'bookmarks.rootFolderId.help': '0 = alle Ordner; eine Ordner-ID setzen, um zu begrenzen',
            'bookmarks.autoCreate': 'Ordner aus Gruppen automatisch anlegen',
            'bookmarks.autoCreate.help': 'Nicht vorhandene Nextcloud-Ordner für lokale Gruppen anlegen',
            'bookmarks.autoRename': 'Ordnernamen bei Gruppen-Umbenennung mitziehen',
            'bookmarks.autoRename.help': 'Nextcloud-Ordnernamen aktualisieren, wenn Gruppen umbenannt werden',
            'bookmarks.chooseFolder': 'Ordner wählen',
            'bookmarks.pickFolder': 'Nextcloud-Ordner auswählen',
            'bookmarks.refresh': 'Aktualisieren',
            'bookmarks.select': 'Auswählen',
            'sync.resetBindings': 'Zuordnungen zu Nextcloud zurücksetzen',
            'sync.resetBindings.help': 'Entfernt alle gespeicherten Nextcloud Ordner-/Bookmark-IDs aus Gruppen und Links. Nützlich für einen frischen Neuabgleich.',
            'sync.resetBindings.confirm': 'Dies entfernt ALLE Nextcloud-Sync-Verknüpfungen (Ordner- und Bookmark-IDs) aus allen Gruppen und Links. Deine Bookmarks bleiben erhalten, aber beim nächsten Sync werden die Verknüpfungen neu erstellt. Fortfahren?',
            'sync.resetBindings.done': 'Sync-Verknüpfungen wurden entfernt',
            'sync.resetBindings.failed': 'Zurücksetzen der Sync-Verknüpfungen fehlgeschlagen',
            'eraseDatabase': 'Lösche Datenbank',
            'eraseDatabase.warning': 'Warnung! Dies wird ALLE Ihre Lesezeichen, Gruppen und Einstellungen dauerhaft löschen. Diese Aktion kann nicht rückgängig gemacht werden!',
            'eraseDatabase.confirm': 'Sind Sie absolut sicher, dass Sie alles löschen möchten?',
            'addGroup': 'Gruppe hinzufügen',
            'search': 'Suche',
            'importFromFile': 'Importiere aus Datei',
            'exportToFile': 'Exportiere in Datei',
            'import': 'Importieren',
            'options': 'Optionen',
            'options.applyError': 'Optionen konnten nicht übernommen werden.',
            'css.advancedEditor': 'Erweiterter Editor',
            'options.common': 'Allgemein',
            'options.common.language': 'Sprache',
            'options.common.language.english': 'Englisch',
            'options.common.language.german': 'Deutsch',
            'options.common.language.help': 'Wähle die Sprache',
            'options.common.pageTitle': 'Seitentitel',
            'options.common.pageTitle.help': 'Setze den Seitentitel',
            'options.common.identityName': 'Ihr Anzeigename',
            'options.common.identityName.help': 'Dieser Name wird anderen Mitgliedern und Kontakten angezeigt',
            'options.common.manualGroupColumnWidth': 'Manuelle Spaltenbreite für Gruppen aktivieren',
            'options.common.manualGroupColumnWidth.help': 'Erlaubt das Ziehen der vertikalen Trenner zur Breitenanpassung der Gruppenspalten und speichert die Breiten.',
            'options.groups': 'Gruppen',
            'options.groups.collapseGroupsOnStart': 'Gruppen beim Start einklappen',
            'options.groups.collapseGroupsOnStart.help': 'Klappe alle Gruppen beim Start ein',
            'options.groups.hoverExpandEnabled': 'Eingeklappte Gruppen beim Link-Ziehen automatisch öffnen',
            'options.groups.hoverExpandEnabled.help': 'Beim Ziehen eines Links öffnet sich eine eingeklappte Gruppe nach der Wartezeit',
            'options.groups.hoverExpandDelay': 'Verzögerung fürs Auto-Öffnen beim Link-Ziehen (ms)',
            'options.groups.hoverExpandDelay.help': 'Zeit in Millisekunden, die ein gezogener Link über einer eingeklappten Gruppe schweben muss, um sie zu öffnen',
            'options.groups.autoAdjustHeightOnLinkChanges': 'Gruppenhöhe beim Hinzufügen/Entfernen automatisch anpassen',
            'options.groups.autoAdjustHeightOnLinkChanges.help': 'Passt die Gruppenhöhe nach dem Hinzufügen/Entfernen von Links automatisch an, wenn sonst gescrollt werden müsste. Deaktiviert manuelles Höhen-Resizing, außer bei Gruppen-Override.',
            'options.common.searchAsYouType': 'Sofortsuche beim Tippen',
            'options.common.searchAsYouType.help': 'Du kannst anfangen, einen Suchbegriff einzugeben, ohne in das Suchfeld zu klicken, es sei denn, du hast ein anderes Eingabefeld fokussiert',
            'options.common.debugEnabled': 'Diagnose-Protokoll aktivieren',
            'options.common.debugEnabled.help': 'Zeigt Debug-Ausgaben in der Browser-Konsole',
            'options.common.confirmDeleteGroup': 'Löschen von Gruppen bestätigen',
            'options.common.confirmDeleteGroup.help': 'Beim Löschen einer Gruppe eine Bestätigung anzeigen',
            'options.common.confirmDeleteLink': 'Löschen von Links bestätigen',
            'options.common.confirmDeleteLink.help': 'Beim Löschen eines Links eine Bestätigung anzeigen',
            'options.security.title': 'Lokaler Datenschutz',
            'options.security.enabled': 'Lokale Datenbank verschlüsseln',
            'options.security.enabled.help': 'Schützt lokal gespeicherte Daten mit einem Passwort. Beim Öffnen der Seite wird das Passwort benötigt.',
            'options.security.sessionTimeoutMinutes': 'Dauer der entsperrten Session',
            'options.security.sessionTimeoutMinutes.help': 'Wie lange die entschlüsselte Session aktiv bleibt, bevor sie automatisch wieder gesperrt wird (0 = deaktiviert).',
            'options.security.minutesSuffix': 'Min',
            'options.security.disable.confirm': 'Lokale Verschlüsselung deaktivieren und Daten unverschlüsselt speichern?',
            'options.security.passwordDialog.title': 'Verschlüsselungs-Passwort festlegen',
            'options.security.passwordDialog.help': 'Dieses Passwort wird benötigt, um lokale Daten zu entsperren.',
            'options.security.passwordDialog.password': 'Passwort',
            'options.security.passwordDialog.confirm': 'Passwort bestätigen',
            'options.security.passwordDialog.submit': 'Passwort übernehmen',
            'options.security.passwordDialog.error.empty': 'Bitte ein Passwort eingeben.',
            'options.security.passwordDialog.error.short': 'Das Passwort muss mindestens 8 Zeichen lang sein.',
            'options.security.passwordDialog.error.mismatch': 'Die Passwörter stimmen nicht überein.',
            'options.security.enabledSuccess': 'Lokale Datenverschlüsselung aktiviert.',
            'options.security.enableCanceled': 'Verschlüsselung nicht aktiviert (Passworteingabe abgebrochen).',
            'options.security.enableFailed': 'Verschlüsselung konnte nicht aktiviert werden.',
            'options.security.disabledSuccess': 'Lokale Datenverschlüsselung deaktiviert.',
            'options.security.unlockTitle': 'Lokale Daten entsperren',
            'options.security.unlockDescription': 'Bitte Passwort eingeben, um auf lokal gespeicherte Daten zuzugreifen.',
            'options.security.unlockPassword': 'Passwort',
            'options.security.unlockButton': 'Entsperren',
            'options.security.unlockError': 'Daten konnten nicht entsperrt werden. Passwort prüfen.',
            'options.security.lockedByTimeout': 'Session abgelaufen. Daten wurden wieder gesperrt.',
            'confirm.deleteGroup': 'Gruppe "%s" und alle enthaltenen Links löschen?',
            'confirm.deleteLink': 'Diesen Link löschen?',
            'confirm.deleteRefLink': 'Diesen Ref-Link löschen?',
            'options.groups.defaultGroupFormatting': 'Standard-Gruppenformatierung',
            'options.groups.defaultGroupFormatting.help': 'Hintergrundformatierung für neu erstellte Gruppen',
            'options.groups.defaultGroupTitleFormatting': 'Standard-Titelformatierung',
            'options.groups.defaultGroupTitleFormatting.help': 'Titelformatierung für neu erstellte Gruppen',
            'options.groups.defaultGroupLinkFormatting': 'Standard-Gruppenlink-Formatierung',
            'options.groups.defaultGroupLinkFormatting.help': 'Linkformatierung für alle Links in neu erstellten Gruppen',
            'options.groups.defaultGroupBadgeFormatting': 'Standard-Badge-Formatierung',
            'options.groups.defaultGroupBadgeFormatting.help': 'Badge-Formatierung für Link-Anzahl und Keywords in neu erstellten Gruppen',
            'options.groups.defaultLinkCountFormatting': 'Standard-Linkanzahl-Formatierung',
            'options.groups.defaultLinkCountFormatting.help': 'Formatierung für Link-Anzahl-Anzeige in neu erstellten Gruppen',
            'options.links.defaultLinkFormatting': 'Standard-Link-Formatierung',
            'options.links.defaultLinkFormatting.help': 'Standardformatierung für einzelne Links',
            'options.groups.clearClosesAllGroups': 'Beim Löschen der Suche alle Gruppen einklappen',
            'options.groups.clearClosesAllGroups.help': 'Beim Clear alle Gruppen einklappen (Datensicherheit)',
            'options.groups.keywordClickExpandsAll': 'Klick auf Keyword öffnet alle Gruppen',
            'options.groups.keywordClickExpandsAll.help': 'Beim Klick auf ein Keyword alle Gruppen ausklappen',
            'options.groups.searchAutoExpandFound': 'Treffergruppen während der Suche automatisch öffnen',
            'options.groups.searchAutoExpandFound.help': 'Passende Gruppen bei aktiver Suche automatisch ausklappen',
            'options.colors': 'Darstellung & Farben',
            'options.colors.generalSection': 'Allgemeine Website-Farben',
            'options.colors.globalFormatting': 'Globale Formatierung',
            'options.colors.globalFormatting.help': 'Legt das allgemeine Erscheinungsbild und den Hintergrund der gesamten Anwendung fest',
            'options.colors.background': 'Website-Hintergrund',
            'options.colors.background.help': 'Legt die Haupthintergrundfarbe der gesamten Website fest',
            'options.colors.toolbarBackground': 'Werkzeugleiste-Hintergrund',
            'options.colors.toolbarBackground.help': 'Hintergrundfarbe der Werkzeugleiste mit Such- und Aktionsschaltflächen',
            'options.colors.titleBarBackground': 'Titelleiste-Hintergrund',
            'options.colors.titleBarBackground.help': 'Hintergrundfarbe der Titelleiste am oberen Rand der Seite',
            'options.colors.titleTextColor': 'Titeltext-Farbe',
            'options.colors.titleTextColor.help': 'Farbe des Titeltextes in der Kopfzeile',
            'options.colors.keywordBackground': 'Standard-Schlagwort-Formatierung',
            'options.colors.keywordBackground.help': 'Standard-Hintergrund/Formatierung für den Schlagwortbereich und Badges',
            'options.colors.resetAll': 'Alle Farben zurücksetzen',
            'options.colors.reset': 'Zurücksetzen',
            'css.custom.open': 'Benutzerdefiniertes CSS',
            'css.custom.title': 'Benutzerdefiniertes CSS',
            'css.custom.help': 'Styles werden live angewendet. Beispiel-Selektoren: .groupTitle .text-truncate, .linkText a',
            'css.custom.placeholder': 'Beispiel: .linkText a { color: #0d6efd; }',
            'css.reset': 'Zurücksetzen',
            'css.custom.hooks': 'Hook‑Klassen',
            'css.custom.clickToInsert': 'Zum Einfügen klicken',
            'css.custom.selectClass': '-- CSS-Selektor wählen --',
            'css.custom.layoutStructure': 'Layout & Struktur',
            'css.custom.groups': 'Gruppen',
            'css.custom.groupInfo': 'Gruppen Info-Bereich',
            'css.custom.currentGroups': 'Aktuelle Gruppen',
            'css.custom.links': 'Links',
            'css.custom.currentLinks': 'Aktuelle Links',
            'css.custom.badges': 'Badges & Keywords',
            'css.custom.currentKeywords': 'Aktuelle Keywords',
            'css.custom.keywordsInGroups': 'Keywords in Gruppen',
            'css.custom.keywordsInLinks': 'Keywords in Links',
            'css.custom.specificGroupKeywords': 'Spezifische Keywords (Gruppe → Keyword)',
            'css.custom.specificKeywords': 'Spezifische Keywords (Gruppe → Link → Keyword)',
            'css.custom.multiline': 'Mit Kommentaren',
            'css.custom.multilineTooltip': 'Erklärende Kommentare über komplexen Selektoren für bessere Lesbarkeit hinzufügen',
            'css.selectorExists': 'CSS-Selektor existiert bereits! Zur Zeile gesprungen.',
            'css.custom.buttons': 'Buttons & Formulare',
            'css.custom.modals': 'Dialoge & Modals',
            'css.custom.sidebar': 'Sidebar & CSS Editor',
            'css.custom.keywordBar': 'Keyword-Leiste',
            'link.favicon.upload': 'Favicon hochladen',
            'link.favicon.remove': 'Entfernen',
            'link.favicon.invalidFile': 'Bitte eine Bilddatei auswählen',
            'link.favicon.tooLarge': 'Bild ist zu groß (max. 256KB)',
            'link.favicon.uploaded': 'Favicon hochgeladen',
            'link.favicon.readError': 'Bilddatei konnte nicht gelesen werden',
            'group.favicon.upload': 'Gruppen-Icon hochladen',
            'group.favicon.remove': 'Icon entfernen',
            'group.favicon.invalidFile': 'Bitte eine Bilddatei auswählen',
            'group.favicon.tooLarge': 'Bild ist zu groß (max. 256KB)',
            'group.favicon.uploaded': 'Gruppen-Icon aktualisiert',
            'group.favicon.readError': 'Bilddatei konnte nicht gelesen werden',
            'css.custom.slugHelpTitle': 'Keyword‑Slugs',
            'css.custom.slugHelpText': 'Keywords werden zu Slugs umgewandelt: Kleinbuchstaben, Leerzeichen → Bindestrich, andere Nicht‑[a-z0-9_-] → Bindestrich.\nBeispiele: "UI/UX" → ui-ux, "C++" → c--, "Foo Bar" → foo-bar.\n\nKeyword‑CSS Ebenen:\n1) Globale Keywordchips:\n   .mb-keyword { ... }\n   .mb-keyword-kw-<slug> { ... }\n\n2) Pro Gruppe (Keywordchips):\n   .group-uuid-<uuid> .mb-group__keyword-badge { ... }\n   .group-uuid-<uuid> .mb-keyword-kw-<slug> { ... }\n\n3) Pro Link (Keywordchips):\n   .link-uuid-<uuid> .mb-link__keyword-badge { ... }\n   .link-uuid-<uuid> .mb-keyword-kw-<slug> { ... }\n\n4) Kombiniert / spezifische Link‑Stile:\n   .group-uuid-<uuid> .mb-link__anchor { ... }\n   .link-uuid-<uuid> .mb-link__anchor { ... }\n\nTipp: UUID über Kontextmenü → "CSS‑Klasse kopieren".',
            'css.custom.helpTitle': '🎨 CSS ANPASSUNGS-LEITFADEN',
            'css.templates.select': '-- Vorlage wählen --',
            'css.templates.save': 'Als Vorlage speichern',
            'css.templates.delete': 'Vorlage löschen',
            'css.templates.namePlaceholder': 'Vorlagen-Name eingeben...',
            'css.templates.overwriteConfirm': 'Vorlage "{0}" existiert bereits. Überschreiben?',
            'css.templates.saved': 'Vorlage "{0}" gespeichert',
            'css.templates.loaded': 'Vorlage "{0}" geladen',
            'css.templates.deleted': 'Vorlage "{0}" gelöscht',
            'css.templates.deleteConfirm': 'Vorlage "{0}" wirklich löschen?',
            'css.templates.darkMode': 'Dunkler Modus',
            'css.templates.minimal': 'Minimal',
            'css.templates.colorful': 'Farbenfroh',
            'css.visual.title': 'Visueller CSS Editor',
            'css.visual.templates': 'CSS Vorlagen',
            'css.visual.rules': 'CSS Regeln',
            'css.visual.generated': 'Generiertes CSS',
            'css.visual.importantHint': 'Andere Styles mit !important überschreiben',
            'css.templates.defaultTemplates': 'Standard-Vorlagen',
            'css.templates.customTemplates': 'Eigene Vorlagen',
            'css.templates.cannotDeleteDefault': 'Standard-Vorlagen können nicht gelöscht werden',
            'options.colors.add': 'Farbe hinzufügen',
            'options.links': 'Links',
            'options.sharing': 'Teilen',
            'options.sharing.ntfyServerUrl': 'Benachrichtigungsserver (ntfy) URL',
            'options.sharing.ntfyServerUrl.help': 'URL des ntfy Push-Benachrichtigungsservers',
            'options.sharing.ntfyAuthToken': 'Authentifizierungs-Token',
            'options.sharing.ntfyAuthToken.help': 'Optionales Bearer-Token für die Authentifizierung',
            'options.sharing.defaultTtl': 'Standard-Gültigkeitsdauer (TTL)',
            'options.sharing.defaultTtl.help': 'Gültigkeitsdauer in Sekunden (0 = Server-Standard)',
            'options.sharing.quickCodeTtl': 'Gültigkeit von Quick-Connect-Codes (Sek.)',
            'options.sharing.quickCodeTtl.help': 'Gültigkeit von Quick-Share-Codes in Sekunden',
            'options.sharing.contactOnlineTimeout': 'Online-Status-Timeout für Kontakte (Sek.)',
            'options.sharing.contactOnlineTimeout.help': 'Wie lange ein Kontakt als online angezeigt wird, ohne zu antworten (in Sekunden)',
            'options.links.openInNewTab': 'Links in neuem Tab öffnen',
            'options.links.openInNewTab.help': 'Wenn aktiviert, öffnet ein Klick auf einen Link einen neuen Browser-Tab',
            'options.links.progressiveLoadingThreshold': 'Anzahl Links vor „Mehr anzeigen“',
            'options.links.progressiveLoadingThreshold.help': 'Anzahl der Links, die anfangs pro Gruppe angezeigt werden ("Weitere anzeigen"-Button erscheint oberhalb dieses Limits)',
            'options.links.addViaDialog': 'Links über Dialog hinzufügen',
            'options.links.addViaDialog.help': 'Zeige oben rechts einen Hinzufügen-Button und blende die Inline-Eingaben aus',
            'options.links.autoFetchTitle': 'Seitentitel beim Hinzufügen automatisch laden',
            'options.links.autoFetchTitle.help': 'Versuche, den Seitentitel zu laden und das Titelfeld vorzufüllen (Best-Effort)',
            'options.links.autoFetchFavicon': 'Website-Icon (Favicon) automatisch laden',
            'options.links.autoFetchFavicon.help': 'Verwende eine Favicon-Service-URL, um das Icon vor dem Link anzuzeigen',
            'options.links.allowExternalFaviconService': 'Externen Favicon-Fallback-Service (Google) erlauben',
            'options.links.allowExternalFaviconService.help': 'Wenn aktiviert, werden fehlende Popover-Favicons über den Google-Favicon-Service geladen (kann Anfragen an t3.gstatic.com auslösen).',
            'options.links.showLinkBadges': 'Link-Keyword-Badges anzeigen',
            'options.links.showLinkBadges.help': 'Zeige Keyword-Badges neben Links an',
            'options.links.showReferenceMarker': 'Referenz-Link-Markierung (*) anzeigen',
            'options.links.showReferenceMarker.help': 'Zeigt ein dezentes Sternchen neben Referenz-Links an.',
            'options.links.showLinkPopover': 'Link-Infobox bei Hover anzeigen',
            'options.links.showLinkPopover.help': 'Zeigt beim Überfahren oder Fokussieren eines Links ein Popover mit wichtigsten Metadaten an',
            'css.visual.popoverLevel': 'Link-Popover',
            'css.visual.linkPopover': 'Popover-Container',
            'css.visual.linkPopoverTitle': 'Popover-Titelzeile',
            'css.visual.linkPopoverUrl': 'Popover-URL-Zeile',
            'css.visual.linkPopoverMeta': 'Popover-Metadatenblock',
            'css.visual.linkPopoverRow': 'Popover-Zeile',
            'css.visual.linkPopoverLabel': 'Popover-Label',
            'css.visual.linkPopoverValue': 'Popover-Wert',
            'css.visual.linkPopoverValueMuted': 'Popover-Wert (relativ)',
            'css.visual.linkPopoverKeywords': 'Popover-Keywords',
            'css.visual.linkPopoverBadge': 'Popover-Keyword-Badge',
            'css.visual.linkPopoverFavicon': 'Popover-Favicon',
            'options.links.copyUrlFormat': 'Format für „URL kopieren“',
            'options.links.copyUrlFormat.help': 'Format zum Kopieren von Links. Verfügbare Platzhalter: {title}, {url}, {keywords}, {date}, {time}',
            'options.links.defaultUrlPrefix': 'Automatisches URL-Präfix',
            'options.links.defaultUrlPrefix.help': 'Präfix, das ergänzt wird, wenn eine URL kein Schema hat (z. B. https://). Leer lassen, um nichts zu ergänzen.',
            'options.buttons': 'Schnellaktions-Schaltflächen',
            'options.buttons.showAddLink': 'Quick-Action „Link hinzufügen“ anzeigen',
            'options.buttons.showAddLink.help': 'Zeigt die Schaltfläche zum Hinzufügen von Links in Gruppenkopfzeilen',
            'options.buttons.showDeleteGroup': 'Quick-Action „Gruppe löschen“ anzeigen',
            'options.buttons.showDeleteGroup.help': 'Zeigt die Löschen-Schaltfläche in Gruppenkopfzeilen',
            'options.buttons.showKeywordQuickAddBadge': '„+“-Keyword-Badge bei Hover anzeigen',
            'options.buttons.showKeywordQuickAddBadge.help': 'Zeigt bei Mouseover neben Gruppen- und Link-Keywords ein rundes +-Badge zum schnellen Hinzufügen',
            'options.buttons.showCopyUrl': 'Quick-Action „URL kopieren“ anzeigen',
            'options.buttons.showCopyUrl.help': 'Zeigt die URL-Kopieren-Schaltfläche für Links',
            'options.buttons.showQrCode': 'Quick-Action „QR-Code“ anzeigen',
            'options.buttons.showQrCode.help': 'Zeigt die QR-Code-Schaltfläche für Links',
            'options.buttons.showDeleteLink': 'Quick-Action „Link löschen“ anzeigen',
            'options.buttons.showDeleteLink.help': 'Zeigt die Löschen-Schaltfläche für Links',
            'groups.openAll': 'Alle öffnen',
            'groups.closeAll': 'Alle schließen',
            'toolbar.equalizeGroupColumns': 'Gruppenspalten gleichmäßig breit machen',
            'group.toggleGroupCollapse': 'Gruppe ein-/ausklappen',
            'group.moveGroupLeft': 'Gruppe nach links verschieben',
            'group.moveGroupRight': 'Gruppe nach rechts verschieben',
            'group.deleteGroup': 'Gruppe löschen',
            'group.link.moveLinkLeft': 'Link nach links verschieben',
            'group.link.moveLinkRight': 'Link nach rechts verschieben',
            'group.link.deleteLink': 'Link löschen',
            'group.link.linkText': 'Link Text',
            'group.link.linkUrl': 'Link URL',
            'group.link.add': 'Hinz.',
            'group.link.dropAfter': 'Hier einfügen',
            'group.dropAfter': 'Hier einfügen',
            'menu.group.editGroup': 'Gruppe bearbeiten',
            'group.showMore': 'Weitere anzeigen',
            'group.showLess': 'Weniger anzeigen',
            'group.resizeHeight': 'Gruppenhöhe ziehen zum Ändern. Doppelklick passt diese Gruppe automatisch an.',
            'menu.group.inviteMembers': 'Mitglieder einladen…',
            'menu.group.transferOwnership': 'Eigentümer übertragen…',
            'menu.group.duplicate': 'Duplizieren',
            'menu.keywords': 'Keywords',
            'menu.keyword.new': 'Neues Keyword',
            'menu.keyword.remove': 'Entfernen',
            'menu.keyword.add': 'Hinzufügen',
            'menu.keyword.noneAssigned': 'Keine zugewiesenen Keywords',
            'menu.keyword.noneAvailable': 'Keine weiteren Keywords',
            'keywords.manage': 'Verwalten',
            'keywords.dialog.title': 'Keywords verwalten',
            'keywords.dialog.empty': 'Keine Keywords vorhanden',
            'keywords.dialog.newName': 'Neuer Name',
            'keywords.dialog.rename': 'Umbenennen',
            'keywords.dialog.delete': 'Löschen',
            'keywords.dialog.renameMissing': 'Bitte ein Keyword auswählen.',
            'keywords.dialog.renameSame': 'Bitte einen anderen Keyword-Namen eingeben.',
            'keywords.dialog.renameSuccess': 'Keyword umbenannt.',
            'keywords.dialog.deleteSuccess': 'Keyword gelöscht.',
            'keywords.dialog.confirmDelete': 'Keyword "%s" überall löschen?',
            'keywords.quick.title.group': 'Gruppen-Keyword hinzufügen',
            'keywords.quick.title.link': 'Link-Keyword hinzufügen',
            'keywords.quick.inputLabel': 'Keyword',
            'keywords.quick.placeholder': 'Keyword eingeben',
            'keywords.quick.help': 'Mehrere Keywords mit Komma oder Semikolon trennen.',
            'keywords.quick.add': 'Hinzufügen',
            'keywords.quick.empty': 'Bitte mindestens ein Keyword eingeben.',
            'keywords.quick.added': 'Keyword hinzugefügt.',
            'keywords.quick.duplicate': 'Keyword ist bereits zugewiesen.',
            'dialog.contacts.title': 'Kontakte',
            'dialog.contacts.empty': 'Keine Kontakte',
            'dialog.contacts.name': 'Name',
            'dialog.contacts.uuid': 'UUID',
            'dialog.contacts.status': 'Status',
            'dialog.contacts.actions': 'Aktionen',
            'dialog.contacts.sendTest': 'Test senden',
            'dialog.contacts.remove': 'Entfernen',
            'dialog.contacts.online': 'online',
            'dialog.contacts.offline': 'offline',
            'dialog.contacts.checking': 'prüfe...',
            'dialog.contacts.reachable': 'erreichbar',
            'dialog.contacts.unreachable': 'nicht erreichbar',
            'dialog.contacts.offlineTooltip': 'Kontakt ist offline',
            'dialog.contacts.cannotSendOffline': 'Kann nicht an offline Kontakt senden',
            'dialog.contacts.removeWarningOwner': 'Dieser Kontakt besitzt',
            'dialog.contacts.removeWarningGroups': 'geteilte Gruppe(n), die gelöscht werden',
            'dialog.contacts.removeWarningMember': 'Dieser Kontakt ist Mitglied von',
            'dialog.contacts.removeWarningYourGroups': 'Ihrer geteilten Gruppe(n)',
            'dialog.contacts.removeConfirm': 'Kontakt entfernen',
            'dialog.contacts.removeNote': 'Dieser Kontakt kann Ihnen keine Nachrichten mehr senden.',
            'dialog.share.title': 'Teilen',
            'dialog.send.linkTitle': 'Link senden',
            'dialog.send.groupTitle': 'Gruppe senden',
            'dialog.send.selectContacts': 'Kontakte zum Senden auswählen:',
            'dialog.send.noContacts': 'Keine Kontakte vorhanden. Fügen Sie zuerst Kontakte hinzu.',
            'dialog.send.send': 'Senden',
            'dialog.send.cancel': 'Abbrechen',
            'dialog.transfer.title': 'Eigentümer übertragen',
            'dialog.transfer.select': 'Neuen Eigentümer auswählen:',
            'dialog.transfer.noCandidates': 'Keine geeigneten Mitglieder gefunden.',
            'dialog.transfer.transfer': 'Übertragen',
            'dialog.transfer.acceptPrompt': 'Der aktuelle Eigentümer möchte die Gruppen-Inhaberschaft an Sie übertragen. Akzeptieren?',
            'dialog.invite.title': 'Mitglieder einladen',
            'qc.receive': 'EMPFANGEN',
            'qc.receive.desc': 'Code anzeigen',
            'qc.receive.instruction': 'Teilen Sie diesen Code:',
            'qc.send': 'SENDEN',
            'qc.send.desc': 'Code eingeben',
            'qc.send.instruction': 'Code eingeben:',
            'qc.generate': 'Code generieren',
            'qc.connect': 'Verbinden',
            'qc.stop': 'Stopp',
            'qc.cancel': 'Abbrechen',
            'dialog.contacts.tabTitle': 'Kontakte',
            'dialog.quickconnect.tabTitle': 'Quick-Connect',
            'dialog.close': 'Schließen',
            'clipboard.paste': 'Aus Zwischenablage einfügen',
            'clipboard.modalTitle': 'Links importieren',
            'clipboard.instructions': 'JSON, CSV oder HTML-Lesezeichen einfügen:',
            'clipboard.read': 'Aus Zwischenablage lesen',
            'clipboard.placeholder': 'Daten hier einfügen...',
            'clipboard.detectedFormat': 'Erkanntes Format:',
            'clipboard.preview': 'Vorschau',
            'clipboard.selectAll': 'Alle auswählen',
            'clipboard.deselectAll': 'Alle abwählen',
            'clipboard.import': 'Ausgewählte importieren',
            'clipboard.cancel': 'Abbrechen',
            'clipboard.noLinksFound': 'Keine gültigen Links gefunden',
            'clipboard.noSelection': 'Bitte mindestens einen Link auswählen',
            // Sync und Konfliktauflösung
            'sync.conflictResolved': 'Sync-Konflikt gelöst',
            'sync.conflict.linkEdit': 'Link-Bearbeitungskonflikt automatisch gelöst',
            'sync.conflict.linkAdd': 'Doppelter Link verhindert',
            'sync.conflict.linkDelete': 'Link-Löschkonflikt gelöst',
            'sync.conflict.generic': 'Sync-Konflikt automatisch gelöst',
            // Sync-Einstellungen
            'options.sync': 'NTFY-Synchronisation',
            // Rollen-Badges
            'sync.role.all': 'Alle',
            'sync.role.owner': 'Besitzer',
            'sync.role.member': 'Mitglied',
            // Konflikt-Benachrichtigungen
            'options.sync.conflictNotificationLevel': 'Benachrichtigungen bei Sync-Konflikten',
            'options.sync.conflictNotificationLevel.help': 'Wie Sync-Konflikte angezeigt werden (gilt für alle):\n• Stumm - Keine Benachrichtigungen, Konflikte werden automatisch gelöst\n• Nur wichtige - Zeigt nur kritische Konflikte die Ihre Daten betreffen könnten\n• Alle Konflikte - Zeigt jede Konfliktlösung für volle Transparenz',
            'options.sync.conflictNotificationLevel.silent': 'Stumm',
            'options.sync.conflictNotificationLevel.minimal': 'Nur wichtige',
            'options.sync.conflictNotificationLevel.verbose': 'Alle Konflikte',
            // Auto-Sync Intervall
            'options.sync.autoSyncInterval': 'Automatisches Sync-Intervall',
            'options.sync.autoSyncInterval.help': 'Wie oft nach Updates gesucht wird (gilt für alle):\n• 5 Minuten - Für aktive Zusammenarbeit, moderater Akkuverbrauch\n• 10 Minuten - Gute Balance zwischen Updates und Ressourcenverbrauch\n• 30 Minuten - Akkuschonend, geeignet für weniger aktive Gruppen\n• 1 Stunde - Minimaler Ressourcenverbrauch, für selten ändernde Inhalte\n• Nur manuell - Sie kontrollieren wann synchronisiert wird',
            'options.sync.autoSyncInterval.5min': '5 Minuten',
            'options.sync.autoSyncInterval.10min': '10 Minuten',
            'options.sync.autoSyncInterval.30min': '30 Minuten',
            'options.sync.autoSyncInterval.1hour': '1 Stunde',
            'options.sync.autoSyncInterval.manual': 'Nur manuell',
            // Offline-Modus
            'options.sync.offlineMode': 'Offline-Modus',
            'options.sync.offlineMode.help': 'Wie Änderungen offline behandelt werden (gilt für alle):\n• Sofort anzeigen - Änderungen erscheinen sofort, müssen evtl. später korrigiert werden\n• Auf Bestätigung warten - Änderungen erst nach erfolgreicher Sync, zuverlässiger aber langsamer',
            'options.sync.offlineMode.optimistic': 'Sofort anzeigen',
            'options.sync.offlineMode.conservative': 'Auf Bestätigung warten',
            // Nur für Besitzer
            'options.sync.conflictResolution': 'Strategie zur Konfliktauflösung',
            'options.sync.conflictResolution.help': 'Wie Bearbeitungskonflikte gelöst werden (nur Besitzer-Gruppen):\n• Besitzer gewinnt - Ihre Änderungen als Besitzer haben immer Vorrang\n• Neueste gewinnt - Die aktuellste Änderung gewinnt, egal von wem\n• Nachfragen - Bei jedem Konflikt nachfragen (kann Workflow unterbrechen)',
            'options.sync.conflictResolution.ownerWins': 'Besitzer gewinnt',
            'options.sync.conflictResolution.lastWriteWins': 'Neueste gewinnt',
            'options.sync.conflictResolution.manual': 'Nachfragen',
            'options.sync.memberRateLimit': 'Änderungslimit pro Mitglied (pro Minute)',
            'options.sync.memberRateLimit.help': 'Max. Änderungen pro Minute pro Mitglied (0 = unbegrenzt, nur Besitzer-Gruppen)',
            'options.sync.memberRateLimit.suffix': 'pro Min',
            'options.sync.validationLevel': 'Validierungsstufe',
            'options.sync.validationLevel.help': 'Wie strikt eingehende Änderungen validiert werden (nur Besitzer-Gruppen):\n• Strikt - Verdächtige oder fehlerhafte Daten ablehnen\n• Moderat - Kleine Probleme erlauben, große blockieren\n• Nachsichtig - Die meisten Änderungen akzeptieren, nur kritische Fehler blockieren',
            'options.sync.validationLevel.strict': 'Strikt',
            'options.sync.validationLevel.moderate': 'Moderat',
            'options.sync.validationLevel.permissive': 'Nachsichtig',
            // Nur für Mitglieder
            'options.sync.localCacheStrategy': 'Lokal gespeicherte Datenmenge',
            'options.sync.localCacheStrategy.help': 'Wie viele Daten lokal gespeichert werden (nur Mitglieder-Gruppen):\n• Alles - Vollständige Historie und alle Versionen lokal (mehr Speicher)\n• Nur aktuell - Nur neueste Version behalten (spart Speicherplatz)',
            'options.sync.localCacheStrategy.full': 'Alles',
            'options.sync.localCacheStrategy.minimal': 'Nur aktuell',
            'options.sync.errorHandling': 'Verhalten bei Sync-Fehlern',
            'options.sync.errorHandling.help': 'Wie Sync-Fehler behandelt werden (nur Mitglieder-Gruppen):\n• Auto-Wiederholen - Fehlgeschlagene Operationen automatisch wiederholen (empfohlen)\n• Für später aufheben - Fehlgeschlagene Änderungen für manuellen Retry speichern\n• Bei Fehler verwerfen - Fehlgeschlagene Änderungen aufgeben (Datenverlust möglich)',
            'options.sync.errorHandling.retry': 'Auto-Wiederholen',
            'options.sync.errorHandling.queue': 'Für später aufheben',
            'options.sync.errorHandling.discard': 'Bei Fehler verwerfen',
            'clipboard.importSuccess': 'Links erfolgreich importiert',
            'clipboard.readOk': 'Inhalt aus Zwischenablage gelesen',
            'clipboard.empty': 'Zwischenablage ist leer.',
            'clipboard.noPermission': 'Konnte Zwischenablage nicht lesen. Bitte manuell einfügen.',
            'import.fromFile': 'Aus Datei importieren:',
            'import.fromUrl': 'Von URL importieren:',
            'import.urlPlaceholder': 'https://beispiel.de/bookmarks.json',
            'import.fetch': 'Abrufen',
            'import.fetching': 'Wird abgerufen...',
            'import.corsError': 'Abruf aufgrund von CORS-Richtlinien nicht möglich. Laden Sie die Datei herunter und importieren Sie sie lokal, oder verwenden Sie einen CORS-Proxy.',
            'import.fetchError': 'Abruf fehlgeschlagen',
            'import.fromClipboard': 'Aus Zwischenablage einfügen:',
            'import.csvSeparator': 'CSV-Trennzeichen (optional):',
            'import.csvSeparator.placeholder': 'Automatisch erkennen (z. B. ; oder ,)',
            'import.csvSeparator.help': 'Leer lassen für automatische Erkennung. Für Tab \\t eingeben.',
            'import.or': '— ODER —',
            'import.newGroupTitle': 'Neuer Gruppentitel:',
            'import.groupTitlePlaceholder': 'Gruppentitel eingeben (optional)',
            'import.fullExportWarning.title': 'Warnung!',
            'import.fullExportWarning.message': 'Dies ist ein vollständiger Datenbank-Export. Er sollte nur in eine LEERE Datenbank importiert werden, um Konflikte zu vermeiden. Alle vorhandenen Daten werden ersetzt.',
            'import.fullExportConfirm': 'Dies wird Ihre GESAMTE Datenbank ERSETZEN (Gruppen, Einstellungen, Kontakte, etc.).\n\nDies ist eine Wiederherstellungsoperation - alle UUIDs bleiben erhalten.\n\nFortfahren?',
            'import.fullExportSuccess': 'Datenbank erfolgreich wiederhergestellt!',
            'import.groupsFound': 'Links aus folgenden Gruppen gefunden:',
            'import.groupsWillBeCreated': 'Diese Gruppen werden automatisch erstellt, falls sie noch nicht existieren.',
            'import.defaultGroupTitle': 'Import',
            'import.fromBrowser': 'Aus Browser importieren:',
            'import.fetchingBookmarks': 'Lade Lesezeichen...',
            'import.browserBookmarks': 'Browser-Lesezeichen importieren',
            'import.fullExportError': 'Datenbankwiederherstellung fehlgeschlagen. Details in der Konsole.',
            'export.title': 'Lesezeichen exportieren',
            'export.selectItems': 'Gruppen und Links zum Export auswählen:',
            'export.groups': 'Gruppen',
            'export.selectAll': 'Alle auswählen',
            'export.deselectAll': 'Alle abwählen',
            'export.format': 'Export-Format:',
            'export.selected': 'Links ausgewählt',
            'export.export': 'Exportieren',
            'export.cancel': 'Abbrechen',
            'members.title': 'Mitglieder',
            'members.filter.allow': 'erlaubt',
            'members.filter.deny': 'blockiert',
            'members.filter.unset': 'lokal standard',
            'members.remove': 'Entfernen',
            'members.noRoster': 'Noch keine Mitgliederliste empfangen',
            'removedFromGroup.title': 'Gruppenmitgliedschaft entfernt',
            'removedFromGroup.message': 'Sie wurden aus der folgenden Gruppe entfernt, während Sie offline waren:',
            'removedFromGroup.owner': 'Gruppenbesitzer:',
            'removedFromGroup.removedAt': 'Entfernt:',
            'removedFromGroup.explanation': 'Die Gruppe wird aus Ihrer Liste entfernt. Falls Sie wieder Zugriff benötigen, kontaktieren Sie bitte den Gruppenbesitzer.',
            'removedFromGroup.acknowledge': 'Verstanden',
            'members.perm.add': 'Hinzufügen',
            'members.perm.edit': 'Bearbeiten',
            'members.perm.delete': 'Löschen',
            'error.perm.add': 'Du hast keine Berechtigung, in dieser Gruppe Links hinzuzufügen.',
            'error.perm.edit': 'Du hast keine Berechtigung, in dieser Gruppe Links zu bearbeiten.',
            'error.perm.delete': 'Du hast keine Berechtigung, in dieser Gruppe Links zu löschen.',
            'permission.denied': 'Keine Berechtigung',
            'error.onlyOwner': 'Nur der Owner kann Mitglieder einladen.',
            'group.shared': 'Geteilte Gruppe',
            'group.keywords': 'Schlagwörter',
            'group.shortcut': 'Gruppen-Shortcut',
            'group.basic': 'Grundeinstellungen',
            'group.styling': 'Darstellung',
            'group.advanced': 'Erweitert',
            'group.name': 'Gruppenname',
            'group.name.help': 'HTML ist erlaubt. Sichere Tags (b, i, strong, em, br, span, small, code, pre, a mit http/https/mailto).',
            'group.name.required': 'Bitte einen Gruppennamen eingeben',
            'group.keywords.help': 'Schlagwörter für Suche und Filterung (mit Komma oder Semikolon trennen)',
            'group.shortcut.placeholder': 'Feld fokussieren und z. B. Strg+Alt+G drücken',
            'group.shortcut.help': 'Die Tastenkombination hier drücken, um alle Links der Gruppe gleichzeitig zu öffnen.',
            'group.manualHeightResizeOverride': 'Manuelles Höhen-Resizing für diese Gruppe erlauben',
            'group.manualHeightResizeOverride.help': 'Überschreibt die globale Auto-Höhenanpassung für diese Gruppe. Wenn aktiv, kann die Gruppenhöhe manuell geändert werden.',
            'group.color': 'Farbe',
            'group.backgroundFormatting': 'Hintergrundformatierung',
            'group.titleFormatting': 'Titelformatierung',
            'group.linkFormatting': 'Link-Formatierung',
            'group.badgeFormatting': 'Schlagwort-Badge-Formatierung',
            'group.pillFormatting': 'Linkanzahl-Formatierung',
            'group.infoHtml': 'Info HTML',
            'group.infoHtml.placeholder': 'HTML-Inhalt eingeben, der im Info-Bereich angezeigt wird...',
            'group.infoHtml.help': 'Dieser HTML-Inhalt wird in einem aufklappbaren Bereich unter dem Gruppentitel angezeigt.',
            'group.emoji': 'Symbol',
            'group.emoji.placeholder': 'Klicke, um ein Emoji zu wählen',
            'group.emoji.help': 'Wähle ein Emoji-Symbol für diese Gruppe',
            'group.info.toggle': 'Information',
            'link.info': 'Information',
            'link.infoHtml': 'Info HTML',
            'link.infoHtml.placeholder': 'HTML-Inhalt eingeben, der im Tooltip angezeigt wird...',
            'link.infoHtml.help': 'Dieser HTML-Inhalt wird beim Überfahren des Info-Symbols angezeigt.',
            'link.popover.url': 'URL',
            'link.popover.noUrl': 'Keine URL vorhanden',
            'link.popover.created': 'Erstellt',
            'link.popover.updated': 'Aktualisiert',
            'link.popover.originalUrl': 'Originaleingabe',
            'link.popover.untitled': 'Unbenannter Link',
            'link.popover.notAvailable': 'Nicht erfasst',
            'link.url.info': 'URL leer lassen, um eine Überschrift/Kategorie zu erstellen',
            'link.basic': 'Grundeinstellungen',
            'link.appearance': 'Darstellung',
            'link.advanced': 'Erweitert',
            'link.text': 'Text',
            'link.text.help': 'HTML ist im sichtbaren Linktext erlaubt. Nur sichere Tags. Hinweis: Anker werden im Linklabel entfernt.',
            'link.text.required': 'Bitte einen Link-Text eingeben',
            'link.url': 'URL',
            'link.itemType': 'Eintragstyp',
            'link.itemType.help': 'Wähle, ob der Eintrag ein normaler Link, eine Notiz oder ein visueller Trenner ist.',
            'link.itemType.link': 'Link',
            'link.itemType.note': 'Notiz',
            'link.itemType.separator': 'Trenner',
            'link.note.defaultLabel': 'Notiz',
            'note.expand': 'Notiz aufklappen',
            'note.collapse': 'Notiz einklappen',
            'link.separator.defaultLabel': 'Trenner',
            'link.keywords': 'Schlagwörter',
            'link.keywords.help': 'Schlagwörter für Suche und Filterung (mit Komma oder Semikolon trennen)',
            'link.emoji': 'Symbol',
            'link.emoji.placeholder': 'Klicke, um ein Emoji zu wählen',
            'link.emoji.help': 'Wähle ein Emoji-Symbol für diesen Link',
            // Emoji-Auswahl
            'emoji.recent': 'Zuletzt',
            'emoji.smileys': 'Smileys',
            'emoji.people': 'Personen',
            'emoji.animals': 'Tiere',
            'emoji.food': 'Essen',
            'emoji.travel': 'Reisen',
            'emoji.activities': 'Aktivitäten',
            'emoji.objects': 'Objekte',
            'emoji.symbols': 'Symbole',
            'emoji.flags': 'Flaggen',
            'link.color': 'Linkfarbe',
            'color.reset': 'Zurücksetzen',
            'color.remove': 'Entfernen',
            'color.add': 'Farbe hinzufügen',
            'menu.link.editLink': 'Link bearbeiten',
            'menu.link.editRefLink': 'Ref-Link bearbeiten',
            'menu.link.editNote': 'Notiz bearbeiten',
            'menu.link.editSeparator': 'Trenner bearbeiten',
            'menu.link.deleteLink': 'Link löschen',
            'menu.link.deleteRefLink': 'Ref-Link löschen',
            'menu.link.deleteNote': 'Notiz löschen',
            'menu.link.deleteSeparator': 'Trenner löschen',
            'menu.link.createRefLink': 'Ref-Link erstellen…',
            'menu.link.editOriginalLink': 'Original-Link bearbeiten…',
            'link.copyUrl': 'URL in Zwischenablage kopieren',
            'link.urlCopied': 'URL kopiert',
            'link.copyFailed': 'URL konnte nicht kopiert werden',
            'link.ref.markerTitle': 'Referenz-Link',
            'link.ref.missing': 'Referenz-Link (Original fehlt)',
            'link.ref.keywordReadOnly': 'Keywords von Referenz-Links sind schreibgeschützt. Bearbeite den Original-Link.',
            'link.ref.sourceMissing': 'Original-Link konnte nicht aufgelöst werden.',
            'link.ref.createFromRefDisabled': 'Ref-Link erstellen ist nur für originale URL-Links verfügbar.',
            'link.ref.editDialog.title': 'Referenz-Link-Text bearbeiten',
            'link.ref.editDialog.original': 'Original-Link',
            'link.ref.editDialog.originalKeywords': 'Keywords des Original-Links',
            'link.ref.editDialog.none': 'Keine',
            'link.ref.editDialog.sourceMissingHint': 'Der Original-Link konnte nicht gefunden werden. Sie können trotzdem einen lokalen Referenztext setzen.',
            'link.ref.editDialog.aliasLabel': 'Referenztext',
            'link.ref.editDialog.aliasPlaceholder': 'Leer lassen, um den Original-Linktext zu verwenden',
            'link.ref.editDialog.help': 'Es wird nur dieser Referenztext geändert. URL und Metadaten bleiben mit dem Original verknüpft.',
            'link.ref.editDialog.inheritKeywords': 'Keywords vom Original-Link übernehmen',
            'link.ref.editDialog.localKeywordsLabel': 'Zusätzliche Keywords für diesen Ref-Link',
            'link.ref.editDialog.localKeywordsPlaceholder': 'keyword1, keyword2',
            'link.ref.editDialog.localKeywordsHelp': 'Diese Keywords gelten nur für diesen Ref-Link.',
            'link.ref.selectTargetPrompt': 'Zielgruppe (Nummer) für den Referenz-Link wählen:',
            'link.ref.invalidTarget': 'Ungültige Gruppenauswahl.',
            'link.ref.aliasPrompt': 'Optionaler Referenz-Text (leer lassen = Originaltext):',
            'link.ref.created': 'Referenz-Link erstellt.',
            'link.ref.deleteSourceConfirm': 'Dieser Link wird von {count} Referenz-Link(s) verwendet. Trotzdem löschen?',
            'placeholders.global.manage': 'Globale Platzhalter verwalten',
            'placeholders.global.title': 'Globale Platzhalter',
            'placeholders.global.help': 'Globale Platzhalter stehen für alle Links zur Verfügung.',
            'placeholders.group.title': 'Gruppen-Platzhalter',
            'placeholders.group.help': 'Gruppen-Platzhalter überschreiben globale Platzhalter für Links in dieser Gruppe.',
            'placeholders.link.title': 'Link-Platzhalter',
            'placeholders.urlTemplate': 'URL-Vorlage',
            'placeholders.noneInUrl': 'Keine Platzhalter in der URL-Vorlage gefunden.',
            'placeholders.name': 'Name',
            'placeholders.value': 'Wert',
            'placeholders.encode': 'Kodieren',
            'placeholders.valuePlaceholder': 'Wert eingeben',
            'placeholders.encodeLabel': 'URL-kodieren',
            'placeholders.preview': 'Vorschau',
            'placeholders.unresolvedHint': 'Nicht aufgelöste Platzhalter',
            'placeholders.add': 'Platzhalter hinzufügen',
            'placeholders.inheritedValue': 'Geerbter Wert',
            'placeholders.restoreInherited': 'Geerbten Wert wiederherstellen',
            'placeholders.inheritedLocked': 'Geerbte Platzhalter können nicht gelöscht werden.',
            'link.shortcut': 'Shortcut',
            'link.shortcut.placeholder': 'Feld fokussieren und z. B. Strg+Alt+M drücken',
            'link.shortcut.help': 'Die Tastenkombination direkt in diesem Feld drücken. Wenn mehrere Links denselben Shortcut haben, werden alle zusammen geöffnet.',
            'link.shortcut.invalid': 'Bitte Strg/Alt/Cmd plus eine Taste verwenden (z. B. Strg+Alt+M).',
            'link.shortcut.reserved': 'Diese Tastenkombination ist vom Browser/System reserviert.',
            'link.shortcut.opened': '{count} Link(s) per Shortcut geöffnet.',
            'link.shortcut.openedPartial': 'Nur {opened} von {total} Link(s) geöffnet. Der Popup-Blocker hat den Rest möglicherweise blockiert.',
            'link.shortcut.batchRemaining': '{opened} von {total} Link(s) geöffnet. {remaining} verbleibend. Gleichen Shortcut/Aktion erneut ausführen, um fortzufahren.',
            'link.shortcut.confirmMany': '{count} Links gleichzeitig öffnen?',
            'shortcuts.manage': 'Shortcut-Manager',
            'shortcuts.manager.title': 'Shortcut-Manager',
            'shortcuts.manager.linkAssignments': 'Definierte Link-Shortcuts',
            'shortcuts.manager.filterPlaceholder': 'Nach Shortcut, Gruppe, Titel oder URL filtern',
            'shortcuts.manager.noneDefined': 'Noch keine Link-Shortcuts definiert.',
            'shortcuts.manager.linksCount': 'Links',
            'shortcuts.manager.urlsCount': 'gültige URLs',
            'shortcuts.manager.openNow': 'Jetzt öffnen',
            'shortcuts.manager.editLink': 'Bearbeiten',
            'shortcuts.manager.globalTitle': 'Globale Shortcuts (mehrere Seiten gleichzeitig öffnen)',
            'shortcuts.manager.globalHelp': 'Wählen Sie Gruppen und Links direkt aus Ihren Lesezeichen aus. Bei Gruppenauswahl werden alle Links der Gruppe geöffnet.',
            'shortcuts.manager.globalEmpty': 'Noch keine globalen Shortcuts konfiguriert.',
            'shortcuts.manager.globalCombo': 'Shortcut',
            'shortcuts.manager.globalName': 'Name',
            'shortcuts.manager.globalNamePlaceholder': 'Optionaler Name (z. B. Morgenstart)',
            'shortcuts.manager.globalTargets': 'Gruppen und Links auswählen',
            'shortcuts.manager.globalNoLinks': 'Keine Gruppen/Links verfügbar.',
            'shortcuts.manager.invalidLinkUrl': 'Ungültige URL, kann per Shortcut nicht geöffnet werden.',
            'shortcuts.manager.remove': 'Entfernen',
            'shortcuts.manager.addGlobal': 'Globalen Shortcut hinzufügen',
            'shortcuts.manager.selectionStats': '{groups} Gruppen, {links} Links ausgewählt, {urls} URLs werden geöffnet',
            'shortcuts.manager.invalidCombo': 'Bitte in Zeile {row} einen gültigen Shortcut definieren.',
            'shortcuts.manager.invalidTargets': 'Bitte in Zeile {row} mindestens einen Link oder eine Gruppe auswählen.',
            'shortcuts.manager.saved': '{count} globale Shortcuts gespeichert.',
            'shortcuts.manager.popupBlockerHint': 'Browser können das gleichzeitige Öffnen vieler Tabs blockieren. Falls das passiert, Pop-ups für diese Seite erlauben oder den Shortcut/die Aktion erneut ausführen.',
            'shortcut.notice.globalDefined': 'Globaler Shortcut "{combo}" ist bereits definiert und öffnet {count} URL(s).',
            'shortcut.notice.groupDefined': 'Die Gruppe "{group}" hat bereits den Shortcut "{combo}".',
            'shortcut.notice.groupInGlobal': 'Die Gruppe "{group}" ist bereits Teil des globalen Shortcuts "{combo}".',
            'shortcut.notice.linkInGlobalViaGroup': 'Der Link ist bereits über die Gruppe "{group}" im globalen Shortcut "{combo}" enthalten.',
            'shortcut.notice.linkInGlobalDirect': 'Der Link ist bereits direkt im globalen Shortcut "{combo}" ausgewählt.',
            'shortcut.notice.linkInGroupShortcut': 'Der Link ist bereits im Gruppen-Shortcut "{combo}" enthalten (Gruppe "{group}").',
            'toast.success': 'Erfolg',
            'toast.error': 'Fehler',
            'toast.warning': 'Warnung',
            'toast.info': 'Information',
            'menu.link.sendLink': 'Link senden…',
            'menu.link.createQrCode': 'QR‑Code erstellen',
            'menu.link.copyForCss': 'Für CSS kopieren',
            'menu.link.copyCssClass': 'CSS‑Klasse kopieren',
            'menu.link.copyUuid': 'UUID kopieren',
            'menu.link.copyCssSelector': 'CSS-Selektor kopieren [data-link-uuid]',
            'menu.group.sendGroup': 'Gruppe senden…',
            'menu.group.members': 'Mitglieder…',
            'menu.group.inspectJSON': 'JSON inspizieren',
            'menu.group.enableEventLog': 'Event-Log aktivieren (Beta)',
            'menu.group.copyForCss': 'Für CSS kopieren',
            'menu.group.copyCssClass': 'CSS‑Klasse kopieren',
            'menu.group.copyUuid': 'UUID kopieren',
            'menu.group.copyCssSelector': 'CSS-Selektor kopieren [data-group-uuid]',
            'menu.group.leaveGroup': 'Gruppe verlassen…',
            'menu.group.sort': 'Links sortieren',
            'menu.group.sort.withinColumns': 'Spaltenweise (A→Z)',
            'menu.group.sort.preserveCounts': 'Global A→Z, Spaltengröße beibehalten',
            'menu.group.sort.rebalance': 'Global A→Z, Spalten ausbalancieren',
            'menu.group.sort.withinColumnsDesc': 'Spaltenweise (Z→A)',
            'menu.group.sort.preserveCountsDesc': 'Global Z→A, Spaltengröße beibehalten',
            'menu.group.sort.rebalanceDesc': 'Global Z→A, Spalten ausbalancieren',
            'menu.group.sort.separatorFallback': 'Gruppen mit Trennern können nur spaltenweise sortiert werden.',
            'menu.group.addSeparator': 'Trenner hinzufügen…',
            'menu.group.addNote': 'Notiz hinzufügen…',
            'group.separator.add': 'Trenner hinzufügen',
            'group.note.add': 'Notiz hinzufügen',
            'json.inspector.title': 'Gruppen JSON Inspector',
            'json.inspector.info': 'Vollständige JSON-Darstellung des Gruppenobjekts',
            'json.inspector.copy': 'JSON kopieren',
            'json.inspector.stats': 'Statistiken',
            'error.eventlog.ownerOnly': 'Nur der Eigentümer kann das Event-Log für diese Gruppe aktivieren',
            'Are you sure?': 'Bist du sicher?',
            'tools': 'Werkzeuge',
            'snapshots.title': 'Snapshots',
            'snapshots.save': 'Snapshot speichern',
            'snapshots.none': 'Noch keine Snapshots',
            'snapshots.promptName': 'Name für Snapshot:',
            'snapshots.restore.confirm': 'Diesen Snapshot wiederherstellen? Der aktuelle Stand wird zum Rückgängig-Verlauf hinzugefügt.',
            'snapshots.delete.confirm': 'Diesen Snapshot löschen?',
            'clear': 'Leeren',
            'undo': 'Rückgängig',
            'redo': 'Wiederholen',
            'duplicates.find': 'Duplikate finden',
            'duplicates.title': 'Gefundene Duplikate',
            'duplicates.description': 'Die folgenden Links erscheinen in mehreren Gruppen:',
            'duplicates.none': 'Keine Duplikate gefunden.',
            'duplicates.copies': 'Kopien',
            'duplicates.keep': 'Behalten',
            'duplicates.remove': 'Entfernen',
            'duplicates.info': 'Das erste Vorkommen jedes Links wird behalten. Nicht angekreuzte Einträge werden nicht gelöscht.',
            'duplicates.removeSelected': 'Ausgewählte Duplikate entfernen',
            'duplicates.confirmDelete': '%s Duplikat(e) löschen und den ersten Eintrag behalten?',
            'duplicates.deleted': '%s Duplikat(e) gelöscht.',
            'bookmarklet.addCurrentTab': 'Bookmarklet: Aktuellen Tab hinzufügen',
            'bookmarklet.instructions': 'Ziehe diesen Link in die Lesezeichenleiste. Ein Klick darauf öffnet diese App und übernimmt die aktuelle Seite.'
            , 'bookmarklet.helpTitle': 'Aktuellen Tab hinzufügen (Clipboard-Bookmarklet)'
            , 'bookmarklet.dragThis': 'Diesen Link in die Lesezeichenleiste ziehen'
            , 'bookmarklet.step.drag': 'Ziehe den Button unten in die Lesezeichenleiste.'
            , 'bookmarklet.step.clickAnyPage': 'Klicke das Bookmarklet auf einer beliebigen Seite, um URL und Titel in die Zwischenablage zu kopieren.'
            , 'bookmarklet.step.switchBack': 'Wechsle zurück zu dieser App und klicke „Aus Zwischenablage einfügen“, um den Link hinzuzufügen.'
            , 'clipboard.pastePrompt': 'Füge den Inhalt der Zwischenablage hier ein (JSON oder URL):'
            , 'clipboard.invalid': 'Der Inhalt ist keine gültige URL oder kein gültiges JSON.'
            , 'clipboard.add': 'Hinzufügen'
            // Einladungsdialog Übersetzungen
            , 'invitation.groupTitle': 'Einladung zur geteilten Gruppe'
            , 'invitation.linkTitle': 'Geteilte Links erhalten'
            , 'share.groupTitle': 'Gruppe erhalten'
            , 'share.linkTitle': 'Links erhalten'
            , 'invitation.from': 'Von'
            , 'invitation.groupName': 'Gruppenname'
            , 'invitation.linkCount': 'Anzahl Links'
            , 'invitation.linksToAdd': 'Zu hinzufügende Links'
            , 'invitation.groupDescription': 'Möchten Sie diese geteilte Gruppe hinzufügen? Sie können dann Links mit anderen Mitgliedern der Gruppe teilen.'
            , 'invitation.linkDescription': 'Möchten Sie diese Links zu Ihrer ausgewählten Gruppe hinzufügen?'
            , 'invitation.sharedGroupDescription': 'Möchten Sie diese geteilte Gruppe mit allen Links hinzufügen?'
            , 'share.groupDescription': 'Möchten Sie diese Gruppe mit allen Links hinzufügen?'
            , 'share.linkDescription': 'Möchten Sie diese Links hinzufügen?'
            , 'share.add': 'Hinzufügen'
            , 'share.cancel': 'Abbrechen'
            , 'invitation.reject': 'Ablehnen'
            , 'invitation.accept': 'Annehmen'
            // Browser Extension Übersetzungen
            , 'extension.importBookmarks': 'Browser-Lesezeichen importieren'
            , 'extension.enrichMetadata': 'Links mit Metadaten anreichern'
            , 'extension.notInstalled': 'Browser-Erweiterung nicht installiert'
            , 'extension.installHint': 'Installiere die MyBookmarks-Erweiterung aus local2/extensions/'
            , 'extension.imported': '{count} Lesezeichen in {groups} Gruppen importiert!'
            , 'extension.enriched': '{count} Links mit Metadaten angereichert!'
            , 'extension.allHaveMetadata': 'Alle Links haben bereits Metadaten!'
            , 'extension.fetchMetadataConfirm': 'Metadaten für {count} Links abrufen?'
            , 'extension.error': 'Fehler: {message}'

            // Event-Log Tab Übersetzungen
            , 'eventlog.time': 'Zeit'
            , 'eventlog.type': 'Typ'
            , 'eventlog.author': 'Autor'
            , 'eventlog.details': 'Details'
            , 'eventlog.changes': 'Änderungen'
            
            // Snapshot Tab Übersetzungen
            , 'snapshot.info': 'Snapshot-Informationen'
            , 'snapshot.created': 'Erstellt'
            , 'snapshot.eventId': 'Event-ID'
            , 'snapshot.links': 'Links im Snapshot'
            , 'snapshot.members': 'Mitglieder im Snapshot'
            , 'snapshot.version': 'Version'
            , 'snapshot.vectorClock': 'Vector Clock'
            , 'snapshot.member': 'Mitglied'
            , 'snapshot.eventCount': 'Event-Anzahl'
            , 'snapshot.noVectorClock': 'Keine Vector Clock Daten'
            , 'snapshot.showData': 'Snapshot-Daten anzeigen'
            
            // Event-Log & Sync Einstellungen
            , 'options.eventlog.title': 'Event-Log & Sync'
            , 'options.eventlog.snapshotInterval': 'Snapshot alle X Ereignisse'
            , 'options.eventlog.snapshotInterval.help': 'Snapshot nach dieser Anzahl von Events erstellen (reduziert Speicherverbrauch)'
            , 'options.eventlog.maxEvents': 'Maximale Anzahl Ereignisse'
            , 'options.eventlog.maxEvents.help': 'Maximale Events vor erzwungener Bereinigung (harte Grenze)'
            , 'options.eventlog.syncStrategy': 'Konfliktstrategie beim Synchronisieren'
            , 'options.eventlog.syncStrategy.help': 'Wie Konflikte beim Synchronisieren behandelt werden'
            , 'options.eventlog.syncStrategy.ownerLeads': 'Besitzer führt (empfohlen)'
            , 'options.eventlog.syncStrategy.allEqual': 'Alle Mitglieder gleich'
            , 'options.eventlog.syncStrategy.smartMerge': 'Smart Merge (experimentell)'
            , 'Events': 'Ereignisse'
            , 'options.eventlog.note': 'Hinweis:'
            , 'options.eventlog.note.text': 'Event-Log-Einstellungen gelten, wenn Sie der Gruppenbesitzer sind. Mitglieder verwenden die Einstellungen des Besitzers.'
            
            // CSS Dialog Übersetzungen
            , 'css.format': 'CSS-Format'
            , 'css.noStyle': 'Kein benutzerdefinierter Stil'
            , 'css.clear': 'Löschen'
            , 'css.preview.text': 'Vorschautext'
            , 'css.opacity.warning': 'Hinweis:'
            , 'css.opacity.websiteBackgroundInfo': 'Für den Website-Hintergrund wird die Deckkraft nur auf die Hintergrundfarbe angewendet (mittels rgba). Dadurch bleiben Dialoge sichtbar.'
            , 'css.background': 'Hintergrund (Kurzform)'
            , 'css.backgroundColor': 'Hintergrundfarbe'
            , 'css.backgroundOpacity': 'Deckkraft'
            , 'css.text': 'Text'
            , 'css.textColor': 'Textfarbe'
            , 'css.fontFamily': 'Schriftfamilie'
            , 'css.default': 'Standard'
            , 'css.fontSize': 'Schriftgröße'
            , 'css.fontWeight': 'Schriftstärke'
            , 'css.normal': 'Normal'
            , 'css.bold': 'Fett'
            , 'css.lighter': 'Leichter'
            , 'css.fontStyle': 'Schriftstil'
            , 'css.italic': 'Kursiv'
            , 'css.oblique': 'Schräg'
            , 'css.textDecoration': 'Textdekoration'
            , 'css.underline': 'Unterstrichen'
            , 'css.overline': 'Überstrichen'
            , 'css.lineThrough': 'Durchgestrichen'
            , 'css.underlineOverline': 'Unter- + Überstrichen'
            , 'css.border': 'Rahmen'
            , 'css.borderStyle': 'Rahmenstil'
            , 'css.none': 'Keiner'
            , 'css.solid': 'Durchgezogen'
            , 'css.dashed': 'Gestrichelt'
            , 'css.dotted': 'Gepunktet'
            , 'css.double': 'Doppelt'
            , 'css.groove': 'Vertieft'
            , 'css.ridge': 'Erhöht'
            , 'css.inset': 'Eingelassen'
            , 'css.outset': 'Hervorstehend'
            , 'css.borderWidth': 'Rahmenbreite'
            , 'css.borderColor': 'Rahmenfarbe'
            , 'css.borderRadius': 'Rahmenradius'
            , 'css.shadow': 'Schatten'
            , 'css.boxShadow': 'Box-Schatten'
            , 'css.shadowPresets': 'Vorlagen'
            , 'css.shadowSubtle': 'Dezent'
            , 'css.shadowMedium': 'Mittel'
            , 'css.shadowStrong': 'Stark'
            , 'css.shadowInset': 'Innen'
            , 'css.generatedCode': 'Generiertes CSS:'
            , 'css.apply': 'Anwenden'
            , 'css.cancel': 'Abbrechen'
            , 'css.shorthand': 'Kurzform'
            , 'css.spacing': 'Abstände'
            , 'css.padding': 'Innenabstand (Padding)'
            , 'css.margin': 'Außenabstand (Margin)'
            , 'css.top': 'Oben'
            , 'css.right': 'Rechts'
            , 'css.bottom': 'Unten'
            , 'css.left': 'Links'
            , 'css.resetAll': 'Alle zurücksetzen'

            // Visual CSS Editor Übersetzungen
            , 'css.visual.designTokens': 'Design Tokens'
            , 'css.visual.addToken': 'Token hinzufügen'
            , 'css.visual.noTokens': 'Noch keine Tokens. Füge welche hinzu (z. B. brand-primary (ohne --), #3b82f6)'
            , 'css.visual.tokensHint': 'Tokens per Dropdown neben den Properties einsetzen (var(--token)).'
            , 'css.visual.tokensSelect': '-- Token wählen --'
            , 'css.visual.valuePlaceholder': 'Wert eingeben (z. B. #ff0000, rgb(), var(--...))'
            , 'css.visual.openFormatEditor': 'Property-Format-Editor öffnen'
            , 'css.visual.formatEditor': 'Property-Format-Editor'
            , 'css.visual.formatEditorNoSelection': 'Wähle eine Property über den Zahnrad-Button neben "Wert eingeben ...".'
            , 'css.visual.formatEditorBasic': 'Basis'
            , 'css.visual.formatEditorValue': 'Wert-Builder'
            , 'css.visual.formatEditorAdvanced': 'Erweitert'
            , 'css.visual.formatEditorApply': 'Anwenden'
            , 'css.visual.formatEditorRevert': 'Zurücksetzen'
            , 'css.visual.formatEditorUseRaw': 'Als rohen CSS-Wert bearbeiten'
            , 'css.visual.formatEditorPreview': 'Vorschau'
            , 'css.visual.formatEditorProperty': 'Property'
            , 'css.visual.formatEditorType': 'Typ'
            , 'css.visual.formatEditorRawEnabled': 'Rohmodus aktiv. Deaktiviere ihn, um geführte Eingaben zu nutzen.'
            , 'css.visual.formatEditorRawOnly': 'Diese Property unterstützt nur den Rohmodus.'
            , 'css.visual.value': 'Wert'
            , 'css.visual.none': 'Keine'
            , 'css.visual.color': 'Farbe'
            , 'css.visual.alpha': 'Alpha'
            , 'css.visual.fontFamilyCustom': 'Eigener font-family-Wert'
            , 'css.visual.linkValues': 'Werte koppeln'
            , 'css.unit': 'Einheit'
            , 'css.blur': 'Unschärfe'
            , 'css.spread': 'Ausdehnung'
            , 'css.visual.tokenName': 'Token-Name'
            , 'css.visual.tokenValue': 'Token-Wert'
            , 'css.visual.invalidCssValue': 'Ungültiger CSS-Wert'
            , 'css.visual.missingTokens': 'Fehlende Tokens'
            , 'css.visual.invalidTokenValue': 'Ungültiger Token-Wert (z. B. #rrggbb, rgb(), linear-gradient(), var(--name))'
            , 'extension.clearCache': 'Extension-Cache leeren'
            , 'extension.cacheCleared': 'Extension-Cache geleert'
            , 'extension.cacheClearFailed': 'Extension-Cache konnte nicht geleert werden'
            , 'extension.notAvailable': 'Extension nicht verfügbar'
            , 'extension.refetchFavicons': 'Favicons werden neu geladen…'
            
            , 'css.visual.pickElement': 'Element wählen'
            , 'css.visual.pickerActive': 'Element-Picker aktiv: Klicke ein Element im Inhalt'
            , 'css.visual.picked': 'Ausgewählt'
            , 'css.visual.applyPreset': 'Preset anwenden…'
            , 'css.visual.presetApplied': 'Preset angewendet'
            , 'css.visual.addRule': 'Neue CSS Regel hinzufügen'
            , 'css.visual.deleteRule': 'Regel löschen'
            , 'css.visual.element': 'Element'
            , 'css.visual.selectElement': '-- Element wählen --'
            , 'css.visual.group': 'Gruppe'
            , 'css.visual.selectGroup': '-- Alle Gruppen --'
            , 'css.visual.link': 'Link'
            , 'css.visual.selectLink': '-- Alle Links --'
            , 'css.visual.properties': 'CSS Eigenschaften'
            , 'css.visual.addProperty': '+ Eigenschaft hinzufügen...'
            , 'css.visual.colors': 'Farben'
            , 'css.visual.typography': 'Typografie'
            , 'css.visual.borders': 'Rahmen'
            , 'css.visual.sizes': 'Größen'
            , 'css.visual.complete': 'komplett'
            , 'css.outline': 'Umrisslinie'
            , 'css.outlineWidth': 'Umrissbreite'
            , 'css.outlineStyle': 'Umrissstil'
            , 'css.outlineColor': 'Umrissfarbe'
            , 'css.outlineOffset': 'Umrissabstand'
            , 'css.width': 'Breite'
            , 'css.height': 'Höhe'
            , 'css.opacity': 'Transparenz'
            , 'css.textAlign': 'Textausrichtung'
            , 'css.topLeft': 'oben links'
            , 'css.topRight': 'oben rechts'
            , 'css.bottomLeft': 'unten links'
            , 'css.bottomRight': 'unten rechts'
            , 'css.visual.layout': 'Layout'
            , 'css.visual.effects': 'Effekte'
            , 'css.visual.rule': 'Regel'
            , 'css.visual.doubleClickToEdit': 'Doppelklick zum Bearbeiten'
            , 'css.visual.copy': 'Kopie'
            , 'css.visual.toggleCollapse': 'Ein-/Ausklappen'
            , 'css.visual.expandAll': 'Alle aufklappen'
            , 'css.visual.collapseAll': 'Alle zuklappen'
            , 'css.visual.activate': 'Aktivieren'
            , 'css.visual.deactivate': 'Deaktivieren'
            , 'css.visual.selectElementShort': 'Element wählen'
            , 'css.visual.customCss': 'Custom CSS'
            , 'css.visual.moveUp': 'Nach oben'
            , 'css.visual.moveDown': 'Nach unten'
            , 'css.visual.duplicate': 'Duplizieren'
            , 'css.visual.delete': 'Löschen'
            , 'css.visual.selectTemplate': '-- Vorlage wählen --'
            , 'css.visual.defaultTemplates': 'Standard-Vorlagen'
            , 'css.visual.appLevel': 'App-Ebene'
            , 'css.visual.uiPrimitives': 'UI-Bausteine'
            , 'css.visual.groupLevel': 'Gruppen-Ebene'
            , 'css.visual.linkLevel': 'Link-Ebene'
            , 'css.visual.allGroups': 'Alle Gruppen'
            , 'css.visual.groupHeader': 'Gruppen Header'
            , 'css.visual.groupTitle': 'Gruppen Titel'
            , 'css.visual.groupContent': 'Gruppen Inhalt'
            , 'css.visual.allLinks': 'Alle Links'
            , 'css.visual.allSeparators': 'Alle Trenner'
            , 'css.visual.allNotes': 'Alle Notizen'
            , 'css.visual.linkHover': 'Link (Hover)'
            , 'css.visual.state': 'Zustand'
            , 'css.visual.hoverState': 'Hover (:hover)'
            , 'css.visual.dragOverState': 'Drag Over (.drag-over-active)'
            , 'css.visual.linkAnchor': 'Link Anchor'
            , 'css.visual.linkUrl': 'Link URL'
            , 'css.visual.linkIcon': 'Link Icon'
            , 'css.visual.keywords': 'Keywords'
            , 'css.visual.allKeywords': 'Alle Keywords (Keyword-Bar)'
            , 'css.visual.selectedKeywords': 'Selektierte Keywords (Keyword-Bar)'
            , 'css.visual.selectedKeywordText': 'Text selektierter Keywords'
            , 'css.visual.keywordsHierarchical': 'Keywords (Hierarchisch)'
            , 'css.visual.keywordByName': 'Keyword nach Name'
            , 'css.visual.keywordSuggestions': 'Keyword-Vorschlagsliste'
            , 'css.visual.keywordSuggestionItem': 'Keyword-Vorschlag'
            , 'css.visual.selectKeyword': '-- Alle Keywords --'
            , 'css.visual.keyword': 'Keyword'
            , 'css.visual.apply': 'Anwenden'
            , 'css.visual.save': 'Speichern'
            , 'css.visual.migrationNotice': 'Hinweis: Ihr bisheriges Custom CSS wurde importiert. Sie können es oben als "Legacy CSS" Regel bearbeiten oder löschen.'
            , 'css.visual.selectSeparator': '-- Alle Trenner --'
            , 'css.visual.separatorShort': 'Sep.'
            , 'css.visual.selectNote': '-- Alle Notizen --'
            , 'css.visual.noteShort': 'Notiz'
            , 'css.visual.customProperties': 'Custom CSS Eigenschaften'
            , 'css.visual.customPropertiesHint': 'z.B. display: flex;\njustify-content: center;'
            , 'css.visual.customPropertiesHelp': 'Geben Sie beliebige CSS-Eigenschaften ein (eine pro Zeile)'
            , 'css.visual.generatedSelector': 'Generierter Selektor'
            , 'css.visual.ruleSets': 'Regel-Sätze'
            , 'css.visual.loadRuleSet': 'Regel-Satz laden'
            , 'css.visual.saveCurrentRules': 'Aktuelle Regeln speichern'
            , 'css.visual.savedRuleSets': 'Gespeicherte Sätze'
            , 'css.visual.rulesCount': 'Regeln'
            , 'css.visual.deleteRuleSet': 'Löschen'
            , 'css.visual.ruleSetName': 'Name für Regel-Satz:'
            , 'css.visual.ruleSetSaved': 'Regel-Satz gespeichert!'
            , 'css.visual.loadRuleSetConfirm': 'Möchten Sie diesen Regel-Satz laden? Ihre aktuellen Regeln werden ersetzt.'
            , 'css.visual.deleteRuleSetConfirm': 'Möchten Sie diesen Regel-Satz wirklich löschen?'
            , 'css.visual.selectRuleSet': '-- Wählen --'
            , 'css.visual.ruleSetLoaded': 'Regel-Satz geladen'
            , 'css.visual.ruleSetDeleted': 'Regel-Satz gelöscht'
            , 'css.visual.clearAll': 'Alles löschen'
            , 'css.visual.clearAllTooltip': 'Alle CSS Einstellungen löschen'
            , 'css.visual.clearAllConfirm': 'Möchten Sie wirklich ALLE CSS-Einstellungen löschen?\n\nDies entfernt:\n• Alle CSS-Regeln\n• Das ausgewählte Template\n• Alle gespeicherten Regel-Sätze\n\nDiese Aktion kann nicht rückgängig gemacht werden!'
            , 'css.visual.clearedAll': 'Alle CSS-Einstellungen wurden gelöscht'
            , 'css.visual.clearProperties': 'Eigenschaften löschen'
            , 'css.visual.clearPropertiesTitle': 'Alle Eigenschaften dieser Regel löschen'
            , 'css.visual.propertiesCleared': 'Eigenschaften gelöscht'
            , 'css.visual.propertyAlreadyExists': 'Diese Eigenschaft existiert bereits in dieser Regel'

            // Generische Button-Übersetzungen
            , 'apply': 'Anwenden'
            , 'cancel': 'Abbrechen'
            , 'save': 'Speichern'
            , 'delete': 'Löschen'
            , 'members.select': 'Mitgliedsnummer auswählen:'
            , 'close': 'Schließen'
            , 'ok': 'OK'
            , 'features.open': 'Hilfe / Feature-Übersicht'
            , 'sync.progress': 'Synchronisierung läuft…'
            , 'group.addLink': 'Link hinzufügen'
            , 'group.resizeWidth': 'Gruppenspaltenbreite per Ziehen ändern'
            , 'link.qrCode': 'QR-Code erzeugen'
            , 'link.copyError': 'Kein Zugriff auf die Zwischenablage'
            , 'favicon.loadError': 'Favicon konnte nicht geladen werden'
            , 'import.extensionRequired': 'Browser-Erweiterung für URL-Import erforderlich. Bitte die MyBookmarks-Erweiterung installieren oder Datei-Import nutzen.'
            , 'quick.test.note': 'Testnachricht'
            , 'quick.test.failed': 'Schnelltest fehlgeschlagen.'
            , 'link.ref.editDialog.originalUrl': 'Original-URL-Vorlage'
            , 'link.ref.editDialog.placeholders': 'Platzhalter'
            , 'css.visual.searchRules': 'Regeln suchen…'
            , 'css.visual.activateProperty': 'Eigenschaft aktivieren'
            , 'css.visual.deactivateProperty': 'Eigenschaft deaktivieren'
          }
        },
      },
      watch: {
        // Focus template name input when dialog opens
        showSaveTemplateDialog(newVal) {
          if (newVal) {
            this.$nextTick(() => {
              if (this.$refs.templateNameInput) {
                this.$refs.templateNameInput.focus();
              }
            });
          }
        },
        // When editing/adding a link, try to auto-fetch metadata after URL changes
        'editLink.url'(newVal, oldVal) {
          if (!this.editLink) return;
          if (!this.data.options?.links) return;
          if (!(this.data.options.links.autoFetchTitle || this.data.options.links.autoFetchFavicon)) return;
          // Only run when user actually changes the field, not on initial dialog open/programmatic set
          if (this._suppressMeta) return;
          if (typeof oldVal === 'undefined') return;
          const a = (newVal || '').trim();
          const b = (oldVal || '').trim();
          if (a === b || !a) return;
          if (!this._debouncedMeta) this._debouncedMeta = debounce(() => this.fetchMetadataForEditLink(false), 500).bind(this);
          this._debouncedMeta();
        },
        filterText(newVal, oldVal) {
          if (!this.data?.options?.groups?.searchAutoExpandFound) return;
          // Save collapsed state once when starting a search
          if (newVal && !oldVal && !this._savedCollapsedStates) {
            this._savedCollapsedStates = {};
            (this.data.groups || []).forEach(g => { this._savedCollapsedStates[g.id] = !!g.collapsed; });
          }
          if (newVal) {
            // Expand matched groups
            (this.data.groups || []).forEach(g => {
              if (this.isGroupMatched(g, newVal)) this.$set(g, 'collapsed', false);
            });
          } else if (!newVal && this._savedCollapsedStates) {
            // Restore previous collapsed states after clearing search
            (this.data.groups || []).forEach(g => {
              const prev = this._savedCollapsedStates[g.id];
              if (prev !== undefined) this.$set(g, 'collapsed', prev);
            });
            this._savedCollapsedStates = null;
          }
        },
        dragState(newValue, oldValue) {
          debugLog('log', "dragState changed from", oldValue, "to", newValue);
          if (newValue) {
            debugLog('log', "#app should now have class 'dragging-" + newValue + "'");
            // Let's verify the CSS classes are actually applied
            this.$nextTick(() => {
              const appElement = document.getElementById('app');
              if (appElement) {
                debugLog('log', "App element classes after dragState change:", appElement.className);
                const dropZones = document.querySelectorAll('.group-drop-zone');
                debugLog('log', "Found", dropZones.length, "drop zones");
                dropZones.forEach((zone, index) => {
                  const computedStyle = window.getComputedStyle(zone);
                  debugLog('log', `Drop zone ${index} display:`, computedStyle.display);
                });
              }
            });
          } else {
            debugLog('log', "#app should now remove all dragging-* classes");
          }
        },
        'data.options.sync.backend'() {
          try { this.scheduleCardDavAutoSync(); } catch {}
        },
        'data.options.carddav.syncIntervalSec'() {
          try { this.scheduleCardDavAutoSync(); } catch {}
        },
        'data.options.bookmarks.syncIntervalSec'() {
          try { this.scheduleCardDavAutoSync(); } catch {}
        },
        extensionAvailable(newValue, oldValue) {
          if (newValue === oldValue) return;
          try { this.scheduleCardDavAutoSync(); } catch {}
        }
      },
      computed: {
        // Check if custom CSS has changes
        hasCustomCssChanges() {
          const currentCss = this.data.options?.customCss || '';
          return this.customCssDraft !== currentCss;
        },

        cssPropertyEditorRule() {
          const ruleId = this.cssPropertyEditor?.ruleId;
          if (!ruleId) return null;
          return (this.visualCssRules || []).find((rule) => String(rule?.id) === String(ruleId)) || null;
        },
        
        // Syntax highlighted CSS for display
        highlightedCss() {
          if (!this.customCssDraft) return '';
          try {
            if (typeof hljs !== 'undefined') {
              const result = hljs.highlight(this.customCssDraft, { language: 'css' });
              return result.value;
            }
          } catch (e) {
            debugLog('warn', 'Highlight.js error:', e);
          }
          // Fallback: escape HTML
          return this.customCssDraft
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        },
        
        settingsMatchesFilter(settingName, helpText) {
          if (!this.settingsFilterText) return true;
          const filter = this.settingsFilterText.toLowerCase();
          const nameTranslated = this.getTranslation(settingName) || settingName || '';
          const helpTranslated = this.getTranslation(helpText) || helpText || '';
          return nameTranslated.toLowerCase().includes(filter) ||
                 helpTranslated.toLowerCase().includes(filter);
        },
        sectionHasVisibleSettings() {
          // Check if a section has any visible settings based on the filter
          return (section) => {
            if (!this.settingsFilterText) return true;

            const mappedSection = (section === 'appearanceColors' || section === 'colors') ? 'appearanceColors' : section;
            const sectionConfig = this.optionsDesign?.[mappedSection];
            if (!sectionConfig?.fields) return false;

            return Object.values(sectionConfig.fields).some((field) => {
              if (!field) return false;
              return this.settingsMatchesFilter(field.translateKey, field.helpText);
            });
          };
        },
        contextLink() {
          return this.contextMenuTarget?.type === 'link' ? this.contextMenuTarget.item : null;
        },
        contextGroup() {
          // For group menu, return the group item
          if (this.contextMenuTarget?.type === 'group') {
            return this.contextMenuTarget.item;
          }
          // For link menu, return the group context
          if (this.contextMenuTarget?.type === 'link') {
            return this.contextMenuTarget.groupContext;
          }
          return null;
        },
        allKeywords() {
          const set = new Set();
          (this.data.groups || []).forEach(g => {
            const add = (keywords) => {
              if (!keywords) return;
              // Handle both string and array formats
              this.parseKeywords(keywords).forEach(k => set.add(k));
            };
            add(g.keywords);
            (g.links || []).forEach(l => add(l.keywords));
          });
          return Array.from(set).sort((a, b) => a.localeCompare(b));
        },
        shortcutManagerLinkGroups() {
          const query = (this.shortcutManager?.linkFilter || '').trim().toLowerCase();
          const buckets = new Map();
          (this.data.groups || []).forEach((group) => {
            (group.links || []).forEach((link) => {
              const combo = this.normalizeShortcutText(link.shortcut || '');
              if (!combo) return;
              const rawUrl = String(this.getEffectiveLinkUrl(link) || '').trim();
              const normalizedUrl = MB.Utils.ensureProtocol(rawUrl);
              const validUrl = MB.Utils.isValidHttpUrl(normalizedUrl);
              if (!buckets.has(combo)) {
                buckets.set(combo, {
                  combo,
                  items: [],
                  validUrls: new Set()
                });
              }
              const bucket = buckets.get(combo);
              bucket.items.push({
                linkUuid: link.uuid || `${group.uuid || group.name || 'group'}-${rawUrl || link.text || 'link'}`,
                linkRef: link,
                groupName: group.name || '',
                linkText: (link.text || '').trim() || rawUrl || '',
                url: rawUrl,
                validUrl
              });
              if (validUrl) bucket.validUrls.add(normalizedUrl);
            });
          });
          let groups = Array.from(buckets.values()).map((bucket) => ({
            combo: bucket.combo,
            items: bucket.items.sort((a, b) => {
              const groupCmp = (a.groupName || '').localeCompare(b.groupName || '');
              if (groupCmp !== 0) return groupCmp;
              return (a.linkText || '').localeCompare(b.linkText || '');
            }),
            itemCount: bucket.items.length,
            validUrlCount: bucket.validUrls.size,
            urls: Array.from(bucket.validUrls)
          })).sort((a, b) => a.combo.localeCompare(b.combo));
          if (!query) return groups;
          groups = groups.filter((group) => {
            if (group.combo.toLowerCase().includes(query)) return true;
            return group.items.some((item) => {
              return (item.groupName || '').toLowerCase().includes(query)
                || (item.linkText || '').toLowerCase().includes(query)
                || (item.url || '').toLowerCase().includes(query);
            });
          });
          return groups;
        },
        shortcutManagerTargetGroups() {
          const groups = [];
          (this.data.groups || []).forEach((group) => {
            const groupId = String(group?.uuid || group?.id || '').trim();
            if (!groupId) return;
            const links = [];
            (group.links || []).forEach((link) => {
              if (link?.deleted) return;
              const linkId = String(link?.uuid || link?.id || '').trim();
              if (!linkId) return;
              const rawUrl = String(this.getEffectiveLinkUrl(link) || '').trim();
              const normalizedUrl = MB.Utils.ensureProtocol(rawUrl);
              const validUrl = MB.Utils.isValidHttpUrl(normalizedUrl);
              links.push({
                linkId,
                linkText: (String(link?.text || '').trim() || rawUrl || ''),
                rawUrl,
                validUrl
              });
            });
            const selectableLinkCount = links.reduce((sum, link) => sum + (link.validUrl ? 1 : 0), 0);
            groups.push({
              groupId,
              groupName: String(group?.name || '').trim(),
              links,
              selectableLinkCount
            });
          });
          return groups;
        },
        displayedKeywords() {
          const set = new Set();
          const query = (this.filterText || '').trim().toLowerCase();
          const rawFilter = (this.filterText || '').trim();
          const tokens = rawFilter ? rawFilter.toLowerCase().split(/\s+/).filter(Boolean) : [];
          const activeKeywords = this.activeKeywordFilters || [];

          (this.data.groups || []).forEach(group => {
            const groupMatchesText = (
              !query ||
              group.name?.toLowerCase().includes(query) ||
              (group.keywords && group.keywords.toLowerCase().includes(query)) ||
              (group.links && group.links.some(link =>
                link.text?.toLowerCase().includes(query) ||
                (link.keywords && link.keywords.toLowerCase().includes(query)) ||
                (link.url && link.url.toLowerCase().includes(query))
              ))
            );
            if (!groupMatchesText) return;

            const groupMatchesKeyword = this.groupMatchesKeywordFilters(group, activeKeywords);
            if (!groupMatchesKeyword) return;

            this.parseKeywords(group.keywords).forEach(kw => set.add(kw));

            const groupHasKeywordToken = tokens.length && this.parseKeywords(group.keywords || '')
              .map(k => k.toLowerCase()).some(kw => tokens.some(t => kw.includes(t)));
            (group.links || []).forEach(link => {
              const linkText = (link.text || '').toLowerCase();
              const linkUrl = (link.url || '').toLowerCase();
              const linkKeywordsLower = this.parseKeywords(link.keywords).map(k => k.toLowerCase()).join(' ');
              const linkMatchesText = tokens.length === 0 || groupHasKeywordToken ||
                tokens.every(t => linkText.includes(t) || linkUrl.includes(t) || linkKeywordsLower.includes(t));
              if (!linkMatchesText) return;
              const linkMatchesKeyword = !activeKeywords.length || this.groupOrLinkKeywordsContainAll(group, link, activeKeywords);
              if (!linkMatchesKeyword) return;
              this.parseKeywords(link.keywords).forEach(kw => set.add(kw));
            });
          });

          (this.activeKeywordFilters || []).forEach(kw => { if (kw) set.add(kw); });
          return Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        },
        keywordColorMap() {
          const map = {};

          const ensureSet = (kw) => { if (!map[kw]) map[kw] = new Set(); };

          const addColors = (kw, colors) => {
            if (!kw) return;
            ensureSet(kw);
            (colors || []).forEach(c => { if (c && c.trim()) map[kw].add(c.trim()); });
          };

          const extractColorsFromValue = (value) => {
            if (!value) return [];
            // Try JSON primary color
            try {
              const primary = this.getPrimaryColorFromCss(value, '');
              if (primary) return [primary];
            } catch {}
            if (typeof value !== 'string') return [];
            const v = value.trim();
            if (!v) return [];
            // If linear-gradient, extract all color tokens (hex/rgb[a])
            if (v.includes('gradient')) {
              const tokens = v.match(/#([0-9a-fA-F]{3,6})|rgba?\([^\)]+\)/g);
              return tokens || [];
            }
            // Simple color string
            return [v];
          };

          const effectiveBadgeColors = (group, link) => {
            const merged = this.mergeFormattingSettings(
              this.data.options?.colors?.background,
              this.data.options?.groups?.defaultGroupBadgeFormatting,
              group?.badgeFormatting,
              link ? link.badgeFormatting : undefined
            );
            const colors = [];
            if (merged.backgroundColor) colors.push(merged.backgroundColor);
            if (merged.background) colors.push(...extractColorsFromValue(merged.background));
            // Fallbacks when no badge background is set
            if (colors.length === 0) {
              if (link) {
                colors.push(...extractColorsFromValue(link.formatting));
                colors.push(...extractColorsFromValue(link.color));
              }
              colors.push(...extractColorsFromValue(group?.titleFormatting));
              colors.push(...extractColorsFromValue(group?.color));
            }
            return colors.filter(Boolean);
          };

          const groups = this.data.groups || [];
          groups.forEach(g => {
            const addFrom = (keywords, link) => {
              if (!keywords) return;
              const colors = effectiveBadgeColors(g, link);
              const list = this.parseKeywords(keywords);
              list.forEach(kw => addColors(kw.trim(), colors));
            };

            // Group-level keywords
            addFrom(g.keywords, null);

            // Link-level keywords
            (g.links || []).forEach(l => addFrom(l.keywords, l));
          });

          const result = {};
          Object.keys(map).forEach(k => result[k] = Array.from(map[k]));
          return result;
        },
        keywordSuggestionList() {
          if (!['link', 'group'].includes(this.genericEditConfig?.type)) return [];
          if (!this.keywordSuggestionContext) return [];
          const context = this.keywordSuggestionContext;
          const searchTerm = (context.searchTerm || '').toLowerCase();
          const prefix = context.prefix || '';
          const suffix = context.suffix || '';
          const seen = new Set();
          const suggestions = [];
          (this.allKeywords || []).forEach(kw => {
            if (!kw) return;
            const kwLower = kw.toLowerCase();
            if (searchTerm && !kwLower.startsWith(searchTerm)) return;
            if (seen.has(kwLower)) return;
            seen.add(kwLower);
            suggestions.push({
              value: `${prefix}${kw}${suffix}`,
              label: kw,
              cursor: prefix.length + kw.length
            });
          });
          return suggestions;
        },
        quickKeywordSuggestionList() {
          const context = this.keywordQuickSuggestionContext;
          if (!context) return [];
          const searchTerm = (context.searchTerm || '').toLowerCase();
          const prefix = context.prefix || '';
          const suffix = context.suffix || '';
          const seen = new Set();
          const suggestions = [];
          (this.allKeywords || []).forEach(kw => {
            if (!kw) return;
            const kwLower = kw.toLowerCase();
            if (searchTerm && !kwLower.startsWith(searchTerm)) return;
            if (seen.has(kwLower)) return;
            seen.add(kwLower);
            suggestions.push({
              value: `${prefix}${kw}${suffix}`,
              label: kw,
              cursor: prefix.length + kw.length
            });
          });
          return suggestions;
        },
        shouldShowKeywordSuggestions() {
          return !!this.keywordSuggestionContext && !!this.keywordSuggestionField && this.keywordSuggestionList.length > 0;
        },
        shouldShowQuickKeywordSuggestions() {
          return !!this.keywordQuickSuggestionContext && this.quickKeywordSuggestionList.length > 0;
        },

        
      },
        created() {
          this.initDatabase();
          sharing = new SharingService(this);
          // Expose sharing service globally for legacy call sites
          try { window.sharing = sharing; } catch {}

          // Load and apply Visual CSS rules on startup
          this.loadVisualCssRules();
          // Restore collapsed state of rule cards
          this.loadCollapsedRules();
          // Restore design tokens collapsed state
          this.loadDesignTokensCollapsed();

          // No wrapping of confirmShare; extend main confirmShare handler directly
          if (!this._onEscapeKeyup) {
            this._onEscapeKeyup = (e) => {
              if (e.key !== 'Escape') return;
              if (this.dropManager && typeof this.dropManager.reset === 'function') {
                this.dropManager.reset();
              }
              this.hideMenus();
              this.cancelEditing(this.editGroup); // Cancel group editing
              this.cancelEditing(this.editLink); // Cancel link editing
            };
          }
          window.addEventListener('keyup', this._onEscapeKeyup);
          // Global click listener to hide menus
          window.addEventListener('click', this.handleGlobalClick, true); // Use capture phase
          document.addEventListener('keydown', this.handleGlobalKeyDown); // Search-as-you-type
          window.addEventListener('resize', this.handleKeywordSuggestionViewportChange);
          window.addEventListener('scroll', this.handleKeywordSuggestionViewportChange, true);
      },
      beforeDestroy() {
        this.stopElementPicker();
        document.body.classList.remove('css-sidebar-open');
        document.body.style.marginRight = '';
        // Clean up global listeners
        if (this._onEscapeKeyup) {
          window.removeEventListener('keyup', this._onEscapeKeyup);
        }
        if (this._onExtensionReady) {
          window.removeEventListener('mybookmarks-extension-ready', this._onExtensionReady);
        }
        window.removeEventListener('click', this.handleGlobalClick, true);
        document.removeEventListener('keydown', this.handleGlobalKeyDown);
        window.removeEventListener('resize', this.handleKeywordSuggestionViewportChange);
        window.removeEventListener('scroll', this.handleKeywordSuggestionViewportChange, true);
        const keywordQuickModal = document.getElementById('keywordQuickAddModal');
        if (keywordQuickModal) {
          if (this._onKeywordQuickModalShown) {
            keywordQuickModal.removeEventListener('shown.bs.modal', this._onKeywordQuickModalShown);
          }
          if (this._onKeywordQuickModalHidden) {
            keywordQuickModal.removeEventListener('hidden.bs.modal', this._onKeywordQuickModalHidden);
          }
        }
        const localSecurityPasswordModal = document.getElementById('localSecurityPasswordModal');
        if (localSecurityPasswordModal && this._onLocalSecurityPasswordModalHidden) {
          localSecurityPasswordModal.removeEventListener('hidden.bs.modal', this._onLocalSecurityPasswordModalHidden);
        }
        document.removeEventListener('mousemove', this.handleGroupHeightResize);
        document.removeEventListener('mouseup', this.endGroupHeightResize);
        document.body.classList.remove('mb-group-resizing');
        this.isGroupHeightResizing = false;
        document.removeEventListener('mousemove', this.handleGroupColumnResize);
        document.removeEventListener('mouseup', this.endGroupColumnResize);
        document.body.classList.remove('mb-group-column-resizing');
        this.isGroupColumnResizing = false;
        
        // Clean up all timers to prevent memory leaks
        this.clearExpandHoverTimers();
        
        // Clean up DropManager timers if they exist
        if (this.dropManager) {
          if (this.dropManager.dragTimeout) {
            clearTimeout(this.dropManager.dragTimeout);
            this.dropManager.dragTimeout = null;
          }
          if (this.dropManager.delayedResetTimeout) {
            clearTimeout(this.dropManager.delayedResetTimeout);
            this.dropManager.delayedResetTimeout = null;
          }
        }
        
        // Clean up any debounced save timer
        if (this._debouncedSave && this._debouncedSave.cancel) {
          this._debouncedSave.cancel();
        }
        if (this._debouncedStorageUsage && this._debouncedStorageUsage.cancel) {
          this._debouncedStorageUsage.cancel();
        }
        if (this.carddavTimer) {
          clearInterval(this.carddavTimer);
          this.carddavTimer = null;
        }
        if (this._localSecurityPasswordPromptResolver) {
          this._localSecurityPasswordPromptResolver(null);
          this._localSecurityPasswordPromptResolver = null;
          this._localSecurityPasswordPromptResult = null;
        }
        this.clearLocalSecuritySessionTimer();
      },
      mounted() { // Example placement
        debugLog('log', '[MOUNTED] Vue app mounted, starting initialization');
        this.initializeDropManager();

        // Initialize browser extension communication
        this.initializeExtension();

        // Add event listener for import modal close to clean up memory
        const importModal = document.getElementById('pasteClipboardModal');
        if (importModal) {
          importModal.addEventListener('hidden.bs.modal', () => {
            this.resetImportDialog();
          });
        }

        const keywordQuickModal = document.getElementById('keywordQuickAddModal');
        if (keywordQuickModal) {
          this._onKeywordQuickModalShown = () => {
            this.focusKeywordQuickInput();
          };
          this._onKeywordQuickModalHidden = () => {
            this.resetKeywordQuickDialog();
          };
          keywordQuickModal.addEventListener('shown.bs.modal', this._onKeywordQuickModalShown);
          keywordQuickModal.addEventListener('hidden.bs.modal', this._onKeywordQuickModalHidden);
        }

        const referenceAliasModal = document.getElementById('referenceAliasModal');
        if (referenceAliasModal) {
          referenceAliasModal.addEventListener('hidden.bs.modal', () => {
            this.refAliasEditData = null;
            this.refAliasExpandedSections = {};
          });
        }
        const localSecurityPasswordModal = document.getElementById('localSecurityPasswordModal');
        if (localSecurityPasswordModal) {
          this._onLocalSecurityPasswordModalHidden = () => {
            this.onLocalSecurityPasswordModalHidden();
          };
          localSecurityPasswordModal.removeEventListener('hidden.bs.modal', this._onLocalSecurityPasswordModalHidden);
          localSecurityPasswordModal.addEventListener('hidden.bs.modal', this._onLocalSecurityPasswordModalHidden);
        }
        const globalPlaceholderModal = document.getElementById('globalPlaceholdersModal');
        if (globalPlaceholderModal) {
          globalPlaceholderModal.addEventListener('hidden.bs.modal', () => {
            this.globalPlaceholderRows = [];
          });
        }

        // Configure moment.js with German locale
        if (typeof moment !== 'undefined') {
          // Set German as default locale
          moment.locale('de');
          
          // Configure relative time strings for German if not already set
          moment.updateLocale('de', {
            relativeTime: {
              future: 'in %s',
              past: 'vor %s',
              s: 'ein paar Sekunden',
              ss: '%d Sekunden',
              m: 'einer Minute',
              mm: '%d Minuten',
              h: 'einer Stunde',
              hh: '%d Stunden',
              d: 'einem Tag',
              dd: '%d Tagen',
              M: 'einem Monat',
              MM: '%d Monaten',
              y: 'einem Jahr',
              yy: '%d Jahren'
            }
          });
          
          debugLog('log', '[INIT] Moment.js configured with German locale');
        }
        
        // Initialize dark mode
        this.initDarkMode();
        // Don't init colors here - will be done in updateSettings after data loads
        
        // Load saved Visual CSS sidebar layout preferences
        this.applyVisualCssSidebarPreferences();
        // Initialize Event-Log Manager for advanced sync with settings
        const eventlogOptions = this.data.options?.eventlog || { snapshotInterval: 100, maxEvents: 500 };
        this.eventLogManager = new EventLogManager(eventlogOptions.maxEvents, eventlogOptions.snapshotInterval);
        debugLog('log', '[INIT] EventLogManager initialized with settings', eventlogOptions);
        debugLog('log', '[INIT] Total groups:', this.data.groups?.length || 0);
        debugLog('log', '[INIT] Groups overview:', this.data.groups?.map(g => ({
          name: g.name,
          groupId: g.groupId,
          useEventLog: g.useEventLog,
          hasEventLog: !!g.eventLog,
          isShared: g.shared
        })));
        this.ensureAllTimestamps();
        
        // Calculate initial storage usage
        this.calculateStorageUsage();
        // Request persistent storage to reduce eviction risk (Edge/Chromium)
        if (navigator.storage && navigator.storage.persist) {
          navigator.storage.persist().then(granted => {
            debugLog('log', `[STORAGE] Persistent storage ${granted ? 'granted' : 'denied'}.`);
          }).catch(e => debugLog('warn', '[STORAGE] persist request failed', e));
        }
        // Apply saved custom CSS
        try { this.applyCustomCss(this.data.options?.customCss || ''); } catch {}
        
        // AUTO-ENABLE: Activate event-log for all groups and fix existing issues
        debugLog('log', '[AUTO-ENABLE] Checking auto-enable setting:', this.data.options?.eventlog);
        if (this.data.options?.eventlog?.autoEnable !== false) {
          const runAutoEnable = () => {
            debugLog('log', '[AUTO-ENABLE] Processing groups for event-log migration:', this.data.groups.length);

            // Ensure we have a user UUID
            if (!this.data.identity?.uuid) {
              if (!this.data.identity) {
                this.$set(this.data, 'identity', {
                  uuid: this.generateUUID(),
                  name: '',
                  pubKey: '',
                  privKey: ''
                });
              } else {
                this.$set(this.data.identity, 'uuid', this.generateUUID());
              }
              debugLog('log', '[AUTO-ENABLE] Generated user UUID:', this.data.identity.uuid);
            }

            const userUuid = this.data.identity.uuid;

            this.data.groups.forEach(group => {
              debugLog('log', '[AUTO-ENABLE] Checking group:', {
                name: group.name,
                hasEventLog: !!group.eventLog,
                useEventLog: group.useEventLog,
                groupId: group.groupId,
                isShared: group.shared,
                vectorClock: group.vectorClock
              });

              // Fix groups with "system" author in event-log
              if (group.eventLog && group.eventLog.length > 0) {
                let needsFix = false;
                group.eventLog.forEach(event => {
                  if (event.author === 'system') {
                    event.author = userUuid;
                    needsFix = true;
                    debugLog('log', '[AUTO-ENABLE] Fixed system author in event:', event.eventId);
                  }
                });

                // Fix vector clock if it has "system" entries
                if (group.vectorClock && group.vectorClock['system']) {
                  const systemCount = group.vectorClock['system'];
                  delete group.vectorClock['system'];
                  group.vectorClock[userUuid] = (group.vectorClock[userUuid] || 0) + systemCount;
                  needsFix = true;
                  debugLog('log', '[AUTO-ENABLE] Fixed system in vector clock for group:', group.name, 'new clock:', group.vectorClock);
                }

                if (needsFix) {
                  debugLog('log', '[AUTO-ENABLE] Repaired event-log for group:', group.name);
                }
              }

              if (!group.eventLog) {
                debugLog('log', '[AUTO-ENABLE] Enabling event-log for group:', group.name);
                // Migrate to event-log system
                this.migrateGroupToEventLog(group);
                this.$set(group, 'useEventLog', true);
                debugLog('log', '[AUTO-ENABLE] After migration:', {
                  name: group.name,
                  hasEventLog: !!group.eventLog,
                  useEventLog: group.useEventLog,
                  eventLogLength: group.eventLog?.length || 0
                });
              }
            });
            this.saveData();
          };

          const waitForData = (attempt = 0) => {
            if (this.loadFailed) {
              debugLog('warn', '[AUTO-ENABLE] Skipping event-log migration due to load failure.');
              return;
            }
            if (!this.dataLoaded) {
              if (attempt < 10) {
                return setTimeout(() => waitForData(attempt + 1), 200);
              }
              debugLog('warn', '[AUTO-ENABLE] Skipping event-log migration: data not loaded.');
              return;
            }
            runAutoEnable();
          };

          setTimeout(() => waitForData(0), 1000);
        } else {
          debugLog('log', '[AUTO-ENABLE] Event-log auto-enable is disabled');
        }
        // Initialize sharing
        this.fixOptions();
        sharing.applyConfig();
        // Initialize Smart Sync for offline recovery
        this.initSmartSync();
        // Subscribe to all shared groups on startup
        if (Array.isArray(this.data.groups)) {
          this.data.groups.forEach(g => {
            if (g.shared && g.groupTopic && g.groupKey) {
              try {
                debugLog('log', '[INIT] Subscribing to shared group:', g.name, g.groupId);
                // Don't request updates on startup - Smart Sync will handle it
                sharing.subscribeGroup(g, false);
              } catch (e) {
                debugLog('warn', '[INIT] Failed to subscribe to group:', g.name, e);
              }
            }
          });
        }
        // Register service worker only on allowed schemes (https or http on localhost)
        if ('serviceWorker' in navigator) {
          const isLocalhost = ['localhost', '127.0.0.1', '::1'].includes(location.hostname);
          const isAllowed = location.protocol === 'https:' || (location.protocol === 'http:' && isLocalhost);
          if (isAllowed) {
            navigator.serviceWorker.register('sw.js').catch((e) => debugLog('warn', 'SW register failed:', e));
          } else {
            debugLog('warn', 'Skipping Service Worker on protocol:', location.protocol);
          }
        }
        this.handleBookmarkletAdd();
        this.appInitialized = true;
      },
        methods: {
        // ===== BROWSER EXTENSION INTEGRATION =====

        initializeExtension() {
          debugLog('log', 'Initializing browser extension support...');

          // Listen for extension ready event
          if (!this._onExtensionReady) {
            this._onExtensionReady = (event) => {
              debugLog('log', 'MyBookmarks Extension is ready!', event.detail);
              this.extensionAvailable = true;
              this.extensionVersion = event.detail.version;

              // Enrich existing links with favicons when extension becomes available
              if (this.data.options?.links?.autoFetchFavicon) {
                debugLog('log', 'Extension ready - enriching existing links with favicons');
                this.enrichExistingLinksWithFavicons();
              }

              // Schedule CardDAV auto-sync if configured
              try { this.scheduleCardDavAutoSync(); } catch {}
            };
          }
          window.removeEventListener('mybookmarks-extension-ready', this._onExtensionReady);
          window.addEventListener('mybookmarks-extension-ready', this._onExtensionReady);

          // Check if extension is available on load with a delay
          setTimeout(() => {
            debugLog('log', 'Checking for MyBookmarksExtension object:', typeof window.MyBookmarksExtension);

            if (window.MyBookmarksExtension) {
              debugLog('log', 'MyBookmarksExtension found, checking availability...');
              this.checkExtensionAvailable().then(available => {
                debugLog('log', 'Extension availability check result:', available);
              if (available) {
                debugLog('log', 'MyBookmarks Extension detected and verified!');
                this.extensionAvailable = true;

                  // Enrich existing links with favicons
                  if (this.data.options?.links?.autoFetchFavicon) {
                    debugLog('log', 'Extension available - enriching existing links with favicons');
                    this.enrichExistingLinksWithFavicons();
                  }

                  // Schedule CardDAV auto-sync
                  try { this.scheduleCardDavAutoSync(); } catch {}
                }
              }).catch(err => {
                debugLog('error', 'Error checking extension availability:', err);
              });
            } else {
              debugLog('log', 'MyBookmarksExtension object not found');
            }
          }, 500);
        },

        async checkExtensionAvailable() {
          return await MB.Extension.checkAvailability();
        },

        async importBookmarksFromBrowser() {
          try {
            const hasExtension = await this.checkExtensionAvailable();
            if (!hasExtension) {
              alert(this.getTranslation('extension.installHint') || 'Bitte installiere die MyBookmarks-Erweiterung aus local2/extensions/');
              return;
            }

            const bookmarksData = await MB.Extension.getBookmarks();
            debugLog('log', 'Received bookmarks data:', bookmarksData);

            // Handle the response structure from the extension
            let bookmarksRoot;
            if (bookmarksData.success && bookmarksData.bookmarks) {
              bookmarksRoot = bookmarksData.bookmarks;
            } else if (bookmarksData) {
              bookmarksRoot = bookmarksData;
            } else {
              throw new Error('No bookmarks data received from extension');
            }

            const imported = { groups: [], linkCount: 0 };

            const processBookmark = (bookmark, parentGroup = null) => {
              if (!bookmark) return;

              if (bookmark.children && Array.isArray(bookmark.children)) {
                // It's a folder
                const group = {
                  uuid: this.generateUUID(),
                  id: this.getNextId(),
                  name: bookmark.title || bookmark.text || 'Imported Folder',
                  links: [],
                  deleted: false,
                  collapsed: false,
                  keywords: '',
                  urlPlaceholders: [],
                  color: '',
                  emoji: ''
                };

                if (parentGroup) {
                  // Nested folder - add as a subgroup (note: might need different handling)
                  debugLog('log', 'Nested folder found:', group.name);
                } else {
                  // Top-level folder - add to groups
                  this.data.groups.push(group);
                  imported.groups.push(group);
                }

                // Process children
                bookmark.children.forEach(child => processBookmark(child, group));
              } else if (bookmark.links && Array.isArray(bookmark.links)) {
                // It's a group with links array (our format)
                bookmark.links.forEach(link => {
                  if (link.url) {
                    const newLink = {
                      uuid: this.generateUUID(),
                      id: this.getNextId(),
                      text: link.text || link.title || link.url,
                      url: link.url,
                      urlPlaceholders: [],
                      keywords: '',
                      shortcut: '',
                      emoji: '',
                      deleted: false
                    };
                    if (parentGroup) {
                      parentGroup.links.push(newLink);
                      imported.linkCount++;
                    }
                  }
                });
              } else if (bookmark.url) {
                // It's a direct link
                const link = {
                  uuid: this.generateUUID(),
                  id: this.getNextId(),
                  text: bookmark.text || bookmark.title || bookmark.url,
                  url: bookmark.url,
                  urlPlaceholders: [],
                  keywords: '',
                  shortcut: '',
                  emoji: '',
                  deleted: false
                };
                if (parentGroup) {
                  parentGroup.links.push(link);
                  imported.linkCount++;
                }
              }
            };

            // Process the bookmarks tree
            if (Array.isArray(bookmarksRoot)) {
              bookmarksRoot.forEach(bookmark => processBookmark(bookmark));
            } else if (bookmarksRoot && typeof bookmarksRoot === 'object') {
              // Single root object
              processBookmark(bookmarksRoot);
            } else {
              throw new Error('Invalid bookmarks format');
            }

            this.saveData();
            const msg = (this.getTranslation('extension.imported') || '{count} Lesezeichen in {groups} Gruppen importiert!')
              .replace('{count}', imported.linkCount)
              .replace('{groups}', imported.groups.length);
            alert(msg);
          } catch (error) {
            debugLog('error', 'Fehler beim Importieren der Lesezeichen:', error);
            const msg = (this.getTranslation('extension.error') || 'Fehler: {message}')
              .replace('{message}', error.message);
            alert(msg);
          }
        },

        getFaviconText(key) {
          const type = this.genericEditConfig?.type === 'group' ? 'group' : 'link';
          const fallbackMap = {
            upload: { link: 'Upload favicon', group: 'Upload group icon' },
            remove: { link: 'Remove', group: 'Remove icon' },
            invalidFile: { link: 'Please select an image file', group: 'Please select an image file' },
            tooLarge: { link: 'Image is too large (max 256KB)', group: 'Image is too large (max 256KB)' },
            readError: { link: 'Could not read image file', group: 'Could not read image file' },
            uploaded: { link: 'Favicon uploaded', group: 'Group icon updated' }
          };
          const fallback = (fallbackMap[key] && fallbackMap[key][type]) || '';
          return this.getTranslation(`${type}.favicon.${key}`) || fallback;
        },

        // Handle favicon upload in link/group edit dialog
        onFaviconFileSelected(event) {
          try {
            const file = event?.target?.files?.[0];
            if (!file) return;
            if (!file.type || !file.type.startsWith('image/')) {
              this.showToast(this.getFaviconText('invalidFile'), 'warning');
              event.target.value = '';
              return;
            }
            // Optional size limit ~256KB
            if (file.size > 256 * 1024) {
              this.showToast(this.getFaviconText('tooLarge'), 'warning');
              // still allow, or block? We'll allow but warn
            }
            const reader = new FileReader();
            reader.onload = () => {
              const dataUrl = reader.result;
              if (typeof dataUrl === 'string' && dataUrl.startsWith('data:')) {
                this.$set(this.genericEditData, 'favicon', dataUrl);
                this.$set(this.genericEditData, 'faviconError', false);
                this.$set(this.genericEditData, 'faviconLoading', false);
                this.$set(this.genericEditData, 'faviconSource', 'upload');
                this.$set(this.genericEditData, 'faviconRuleId', null);
                this.showToast(this.getFaviconText('uploaded'), 'success');
              } else {
                this.showToast(this.getFaviconText('readError'), 'error');
              }
              try { event.target.value = ''; } catch {}
            };
            reader.onerror = () => {
              this.showToast(this.getFaviconText('readError'), 'error');
              try { event.target.value = ''; } catch {}
            };
            reader.readAsDataURL(file);
          } catch (e) {
            this.showToast(this.getFaviconText('readError'), 'error');
          }
        },
        clearEditedFavicon() {
          if (!this.genericEditData) return;
          this.$set(this.genericEditData, 'favicon', '');
          this.$set(this.genericEditData, 'faviconError', false);
          this.$set(this.genericEditData, 'faviconLoading', false);
          this.$set(this.genericEditData, 'faviconSource', null);
          this.$set(this.genericEditData, 'faviconRuleId', null);
        },

        // Clear extension (companion) caches like metadata cache
        clearExtensionCache() {
          if (!this.extensionAvailable) {
            this.showToast(this.getTranslation('extension.notAvailable') || 'Extension not available', 'warning');
            return;
          }
          return new Promise((resolve) => {
            let resolved = false;
            const handler = (event) => {
              if (!event || !event.data || event.source !== window) return;
              if (event.data.type === 'CLEAR_CACHE_RESPONSE') {
                resolved = true;
                window.removeEventListener('message', handler);
                const ok = event.data.result && event.data.result.success;
                if (ok) {
                  this.showToast((this.getTranslation('extension.cacheCleared') || 'Extension cache cleared') + (event.data.result.cleared !== undefined ? ` (${event.data.result.cleared})` : ''), 'success');
                  // After clearing extension cache, also clear local favicons and re-fetch if enabled
                  if (this.extensionAvailable && this.data.options?.links?.autoFetchFavicon) {
                    try {
                      let clearedIcons = 0;
                      (this.data.groups || []).forEach(g => {
                        (g.links || []).forEach(l => {
                          if (l && l.url) {
                            if (l.favicon) { this.$set(l, 'favicon', null); clearedIcons++; }
                            if (l.faviconError) this.$set(l, 'faviconError', false);
                            if (l.faviconLoading) this.$set(l, 'faviconLoading', false);
                          }
                        });
                      });
                      if (clearedIcons > 0) this.saveData();
                      this.showToast(this.getTranslation('extension.refetchFavicons') || 'Re-fetching favicons…', 'info');
                      setTimeout(() => { try { this.enrichExistingLinksWithFavicons(); } catch {} }, 50);
                    } catch {}
                  }
                } else {
                  const err = (event.data.result && event.data.result.error) || 'Unknown error';
                  this.showToast((this.getTranslation('extension.cacheClearFailed') || 'Failed to clear extension cache') + ': ' + err, 'error');
                }
                resolve();
              }
            };
            window.addEventListener('message', handler);
            // Send request
            try {
              window.postMessage({ type: 'CLEAR_EXTENSION_CACHE' }, '*');
            } catch (e) {
              window.removeEventListener('message', handler);
              this.showToast((this.getTranslation('extension.cacheClearFailed') || 'Failed to clear extension cache') + ': ' + e.message, 'error');
              resolve();
            }
            // Fallback timeout
            setTimeout(() => {
              if (!resolved) {
                window.removeEventListener('message', handler);
                this.showToast(this.getTranslation('extension.cacheClearFailed') || 'Failed to clear extension cache', 'error');
                resolve();
              }
            }, 4000);
          });
        },

        // --- CardDAV Sync (gated by extension availability) ---
      async syncCardDavNow() {
        if (!this.extensionAvailable || !window.MyBookmarksExtension || typeof window.MyBookmarksExtension.davRequest !== 'function') {
          alert(this.getTranslation('carddav.extensionRequired') || 'Browser extension with CardDAV support required');
          return;
        }
        if ((this.data.options?.sync?.backend||'') !== 'carddav') {
          alert(this.getTranslation('carddav.notEnabled') || 'CardDAV is disabled in options');
          return;
        }
        try {
          debugLog('log', '[CardDAV] Manual read sync triggered');
          showAppToast(this.getTranslation('carddav.syncStarted') || 'CardDAV sync started', 'info');

          const opts = this.data.options?.carddav || {};
          let serverUrl = (opts.serverUrl || '').trim();
          if (!serverUrl) {
            alert((this.getTranslation('carddav.addressbookPathMissing') || 'Please configure Server URL and Addressbook Path in Options'));
            return;
          }
          const auth = MB.CardDAV.buildBasicAuthHeader(opts.username || '', opts.password || '');
          // Push auth to extension for header injection
          try { await MB.Extension.setDavAuth(serverUrl, opts.username || '', opts.password || ''); } catch {}

          // Resolve addressbook URL with robust discovery (Nextcloud/SabreDAV)
          // Priority: explicit addressbookPath > stored addressbookUrl > discovery
          let addressbookUrl = '';
          if (opts.addressbookPath && opts.addressbookPath.trim()) {
            addressbookUrl = MB.CardDAV.joinUrl(serverUrl, opts.addressbookPath.trim());
            // Persist the derived URL so future runs keep using it
            this.$set(this.data.options.carddav, 'addressbookUrl', addressbookUrl);
            this.saveData();
          } else {
            addressbookUrl = (opts.addressbookUrl || '').trim();
            if (!addressbookUrl) {
              // Try well-known redirect first
              try { serverUrl = await MB.CardDAV.followWellKnown(serverUrl) || serverUrl; } catch {}
              // Try common DAV bases
              const candidates = ['/', '/remote.php/dav/', '/dav/', '/carddav/']
                .map(p => MB.CardDAV.joinUrl(serverUrl, p));
              let baseDav = null;
              for (const base of candidates) {
                try {
                  const rel = await MB.CardDAV.getCurrentUserPrincipal(base, auth);
                  debugLog('log', `[CardDAV] Probe base ${base} -> principal rel:`, rel);
                  if (rel) { baseDav = base; break; }
                } catch {}
              }
              if (!baseDav) {
                // Last resort: assume Nextcloud base
                baseDav = MB.CardDAV.joinUrl(serverUrl, '/remote.php/dav/');
              }

              // Derive principal
              let principalRel = null;
              try { principalRel = await MB.CardDAV.getCurrentUserPrincipal(baseDav, auth); } catch {}
              let principalUrl = principalRel ? MB.CardDAV.joinUrl(baseDav, principalRel) : null;

              // If still unknown, try constructing principal from username (Nextcloud/SabreDAV)
              if (!principalUrl && opts.username) {
                principalUrl = MB.CardDAV.joinUrl(baseDav, `/principals/users/${encodeURIComponent(opts.username)}/`);
              }

              // Get addressbook-home-set; fallback to default path
              let homeRel = null;
              try { if (principalUrl) homeRel = await MB.CardDAV.getAddressbookHome(principalUrl, auth); } catch {}
              let homeUrl = homeRel ? MB.CardDAV.joinUrl(baseDav, homeRel) : null;
              if (!homeUrl && opts.username) {
                homeUrl = MB.CardDAV.joinUrl(baseDav, `/addressbooks/users/${encodeURIComponent(opts.username)}/`);
              }
              if (!homeUrl) throw new Error('addressbook-home-set not found');
              if (!homeUrl.endsWith('/')) homeUrl += '/';
              debugLog('log', '[CardDAV] homeUrl resolved to:', homeUrl);

              // List or create addressbook
              let books = await MB.CardDAV.listAddressbooks(homeUrl, auth);
              debugLog('log', `[CardDAV] Found ${books.length} addressbooks at homeUrl`);
              let pick = books.find(b => (b.displayname||'').toLowerCase() === 'mybookmarks') || books.find(b => (b.displayname||'').toLowerCase() === 'contacts') || books[0];
              if (!pick && opts.createAddressbookIfMissing) {
                try { const created = await MB.CardDAV.mkcolAddressbook(homeUrl, 'MyBookmarks', auth); pick = created; debugLog('log', '[CardDAV] Created addressbook MyBookmarks at', created.href); } catch (e) { debugLog('warn', '[CardDAV] MKCOL MyBookmarks failed', e); }
              }
              // Fallback: probe typical Nextcloud default addressbook "contacts/"
              if (!pick && opts.username) {
                const contactsHref = MB.CardDAV.joinUrl(homeUrl, 'contacts/');
                try {
                  const probe = await MB.CardDAV.propfind(contactsHref, 0,
                    `<?xml version="1.0"?><D:propfind xmlns:D="DAV:"><D:prop><D:resourcetype/><D:displayname/></D:prop></D:propfind>`, auth);
                  if (probe.ok) {
                    const x = MB.CardDAV.parseXml(probe.bodyText||'');
                    const rt = x.getElementsByTagNameNS('DAV:','resourcetype')[0];
                    const isAB = !!(rt && (rt.getElementsByTagNameNS('urn:ietf:params:xml:ns:carddav','addressbook')[0]));
                    if (isAB) {
                      pick = { href: contactsHref, displayname: (x.getElementsByTagNameNS('DAV:','displayname')[0]?.textContent || 'contacts') };
                    }
                  }
                } catch (e) { debugLog('warn','[CardDAV] probe contacts/ failed', e); }
              }
              if (!pick) throw new Error('No addressbook found');
              addressbookUrl = MB.CardDAV.joinUrl(baseDav, pick.href || '');
              this.$set(this.data.options.carddav, 'addressbookUrl', addressbookUrl);
              this.saveData();
            }
          }

          debugLog('log', '[CardDAV] Using addressbookUrl:', addressbookUrl);

          // Incremental or initial sync via sync-collection
          const prevToken = (this.data.options?.carddav?.syncToken || '').trim();
          let changes = [];
          let deletions = [];
          let nextToken = '';
          try {
            const r = await MB.CardDAV.syncCollection(addressbookUrl, prevToken || null, auth);
            changes = r.changes; deletions = r.deletions; nextToken = r.nextToken;
          } catch (err) {
            debugLog('warn', '[CardDAV] sync-collection failed; falling back to full query', err);
          }
          if (!prevToken && changes.length === 0 && (!nextToken || nextToken.length === 0)) {
            changes = await MB.CardDAV.addressbookQueryAll(addressbookUrl, auth);
          }

          // Merge into local data
          let createdGroups = 0, updatedLinks = 0, createdLinks = 0;
          const ensureGroupByName = (name) => {
            let g = (this.data.groups || []).find(x => (x.name||'') === name);
            if (!g) { g = this.getNewGroupTemplate(name); this.data.groups.push(g); createdGroups++; }
            return g;
          };

          // Apply deletions by href
          const removeByHref = (href) => {
            for (const g of (this.data.groups||[])) {
              if (!Array.isArray(g.links)) continue;
              g.links = g.links.filter(l => !(l.carddav && l.carddav.href === href));
            }
          };
          deletions.forEach(d => { try { removeByHref(d.href); } catch {} });

          for (const it of changes) {
            const card = MB.CardDAV.parseVCard(it.vcard || '');
            const uid = card.uid || this.generateUUID();
            const linkObj = {
              uuid: uid,
              text: card.fn || card.url || uid,
              url: card.url || '',
              keywords: (card.mbKeywords || (Array.isArray(card.categories) ? card.categories.join(', ') : '') || ''),
              infoHtml: card.note || '',
              emoji: card.mbMeta?.emoji || '',
              deleted: false,
              carddav: { href: it.href, etag: it.etag, lastSyncedAt: Date.now() }
            };
            const categories = Array.isArray(card.categories) ? card.categories : ['Imported'];
            for (const cat of categories) {
              const group = ensureGroupByName(cat || 'Imported');
              const existing = (group.links || []).find(l => l.uuid === uid) || (group.links || []).find(l => l.carddav && l.carddav.href === it.href) || (group.links || []).find(l => l.url && card.url && l.url === card.url);
              if (existing) {
                existing.text = linkObj.text;
                existing.url = linkObj.url;
                existing.keywords = linkObj.keywords;
                existing.infoHtml = linkObj.infoHtml;
                existing.emoji = linkObj.emoji;
                existing.carddav = linkObj.carddav;
                updatedLinks++;
              } else {
                if (!group.links) this.$set(group, 'links', []);
                group.links.push(linkObj);
                createdLinks++;
              }
            }
          }

          if (nextToken) {
            this.$set(this.data.options.carddav, 'syncToken', nextToken);
            this.$set(this.data.options.carddav, 'lastSyncAt', Date.now());
            this.$set(this.data.options.carddav, 'addressbookUrl', addressbookUrl);
          }
          this.saveData();
          debugLog('log', `[CardDAV] Merge done. Groups+${createdGroups} Links+${createdLinks} Updated+${updatedLinks} Deleted+${deletions.length}`);
          showAppToast(`CardDAV: +${createdLinks}, ~${updatedLinks}, -${deletions.length}, groups +${createdGroups}`, 'success');

          // Optional: upload local changes after read sync
          await this.syncCardDavUpload(addressbookUrl, auth);
        } catch (e) {
          debugLog('error', '[CardDAV] Sync failed', e);
          const msg = (this.getTranslation('carddav.syncFailed') || 'CardDAV sync failed: {message}')
            .replace('{message}', e?.message || String(e));
          showAppToast(msg, 'error');
        }
      },

      // Generic sync/test routing
      async syncNowGeneric() {
        try {
          const backend = this.data.options?.sync?.backend || (this.data.options?.carddav?.enabled ? 'carddav' : null);
          const adapter = MB.SyncAdapters.get(backend);
          if (!adapter) throw new Error('No sync backend selected');
          await adapter.syncNow(this);
        } catch (e) {
          showAppToast((this.getTranslation('carddav.syncFailed')||'Sync failed: {message}').replace('{message}', e?.message||String(e)), 'error');
        }
      },
      async testConnectionGeneric() {
        try {
          const backend = this.data.options?.sync?.backend || (this.data.options?.carddav?.enabled ? 'carddav' : null);
          const adapter = MB.SyncAdapters.get(backend);
          if (!adapter) throw new Error('No sync backend selected');
          const r = await adapter.testConnection(this);
          if (r?.ok || (r?.status>=200 && r?.status<300)) showAppToast('Connection OK', 'success'); else throw new Error('Status '+(r?.status||'??'));
        } catch (e) {
          showAppToast('Connection failed: '+(e?.message||String(e)), 'error');
        }
      },
      isFieldDisabled(sectionKey, fieldKey) {
        const backend = this.data.options?.sync?.backend || '';
        if (sectionKey === 'carddav') return backend !== 'carddav';
        if (sectionKey === 'bookmarks') return backend !== 'nc-bookmarks';
        return false;
      },

      // NC Folder Picker
      async openNcFolderPicker() {
        this.ncFolders = [];
        this.ncFoldersLoading = true;
        this.ncFolderSelected = this.data.options?.bookmarks?.rootFolderId || 0;
        const modal = bootstrap.Modal.getOrCreateInstance(document.getElementById('ncFolderPickerModal'));
        modal.show();
        try { await this.loadNcFolders(); } catch {} finally { this.ncFoldersLoading = false; }
      },
      async loadNcFolders() {
        try {
          const bk = this.data.options?.bookmarks||{};
          const serverUrl = (bk.serverUrl||'').trim(); if (!serverUrl) throw new Error('No serverUrl');
          await MB.Extension.setDavAuth(serverUrl, bk.username||'', bk.password||'');
          const auth = MB.CardDAV.buildBasicAuthHeader(bk.username||'', bk.password||'');
          const url = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
          const res = await MB.Extension.davRequest({ method:'GET', url, headers:{ 'Accept':'application/json', 'OCS-APIREQUEST':'true', 'X-Requested-With':'XMLHttpRequest', 'Authorization':auth }, username: bk.username||'', password: bk.password||'' });
          if (!res.ok) throw new Error('Status '+res.status);
          let parsed = null; try { parsed = JSON.parse(res.bodyText||'[]'); } catch {}
          let arr = Array.isArray(parsed) ? parsed : (parsed && Array.isArray(parsed.data) ? parsed.data : []);
          this.ncFolders = arr;
        } catch (e) {
          showAppToast('Folder list failed: '+(e?.message||String(e)), 'error');
        }
      },
      applyNcFolderSelection() {
        const id = Number(this.ncFolderSelected||0);
        this.$set(this.data.options.bookmarks, 'rootFolderId', id);
        this.saveData();
        const modal = bootstrap.Modal.getInstance(document.getElementById('ncFolderPickerModal'));
        modal && modal.hide();
        showAppToast('Root folder set to #'+id, 'success');
      },
      async testCardDavConnection() {
        try {
          const opts = this.data.options?.carddav || {};
          const serverUrl = (opts.serverUrl||'').trim();
          const path = (opts.addressbookPath||'').trim();
          if (!serverUrl || !path) { alert('Bitte Server-URL und Adressbuch-Pfad setzen'); return; }
          const auth = MB.CardDAV.buildBasicAuthHeader(opts.username||'', opts.password||'');
          await MB.Extension.setDavAuth(serverUrl, opts.username||'', opts.password||'');

          const addressbookUrl = MB.CardDAV.joinUrl(serverUrl, path);
          const results = [];
          results.push({ step: 'well-known', url: MB.CardDAV.joinUrl(serverUrl,'/.well-known/carddav') });
          try { const r = await MB.CardDAV.request({ method:'GET', url: results[0].url, headers:{} }); results[0].status = r.status; results[0].www = (r.headers||{})['www-authenticate']||''; } catch(e){ results[0].error = e.message; }

          // PROPFIND Depth:0 on addressbook
          const prop0 = { step:'propfind-0', url: addressbookUrl };
          try { const r = await MB.CardDAV.propfind(addressbookUrl, 0, `<?xml version="1.0"?><D:propfind xmlns:D="DAV:"><D:prop><D:resourcetype/></D:prop></D:propfind>`, auth); prop0.status=r.status; prop0.www=(r.headers||{})['www-authenticate']||''; } catch(e){ prop0.error=e.message; }
          results.push(prop0);

          // REPORT addressbook-query
          const rep = { step:'report', url: addressbookUrl };
          try { const rs = await MB.CardDAV.addressbookQueryAll(addressbookUrl, auth); rep.status=200; rep.count=rs.length; } catch(e){ rep.error=e.message; }
          results.push(rep);

          const lines = results.map(x=>`${x.step}: ${x.status||''} ${x.error||''} ${x.count!==undefined?('items='+x.count):''} ${x.www?('WWW-Auth='+x.www):''} url=${x.url}`);
          debugLog('log', '[CardDAV][Test]', results);
          alert(lines.join('\n'));
        } catch (e) {
          alert('Test fehlgeschlagen: ' + (e?.message||String(e)));
        }
      },

      // Upload local changes (create/update/delete) strictly via CardDAV
      async syncCardDavUpload(addressbookUrl, authHeader) {
        try {
          // Aggregate links by UUID across groups, collect categories (group names)
          const aggregated = new Map(); // uuid -> { linkRef, categories:Set, occurrences:[], deleted }
          for (const g of (this.data.groups || [])) {
            for (const l of (g.links || [])) {
              const uuid = l.uuid || (l.carddav && l.carddav.href) || null;
              if (!uuid) continue;
              if (!aggregated.has(uuid)) aggregated.set(uuid, { link: l, categories: new Set(), occ: [], deleted: !!l.deleted });
              const entry = aggregated.get(uuid);
              entry.occ.push({ group: g, link: l });
              if (g.name) entry.categories.add(g.name);
              // If any occurrence is marked deleted, treat as deleted
              if (l.deleted) entry.deleted = true;
            }
          }

          // Helper: compute stable hash for change detection
          const computeHash = (link, categories) => {
            const payload = {
              text: link.text||'', url: link.url||'', keywords: link.keywords||'', infoHtml: link.infoHtml||'', emoji: link.emoji||'',
              categories: Array.from(categories).sort()
            };
            try { return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))); } catch { return JSON.stringify(payload); }
          };

          let created = 0, updated = 0, removed = 0, skipped = 0;

          for (const [uuid, entry] of aggregated.entries()) {
            const categories = entry.categories;
            const link = entry.link; // use first occurrence as source
            const href = link.carddav?.href;
            const etag = link.carddav?.etag;
            const lastHash = link.carddav?.lastHash || '';
            const nextHash = computeHash(link, categories);

            if (entry.deleted) {
              if (href) {
                const delRes = await MB.CardDAV.delete(href, authHeader, etag);
                if (delRes.ok || delRes.status === 404) {
                  // Clear metadata on all occurrences
                  entry.occ.forEach(({link}) => { this.$set(link, 'carddav', null); });
                  removed++;
                } else {
                  skipped++;
                }
              }
              continue;
            }

            // Build vCard model
            const model = {
              uid: link.uuid,
              fn: link.text || link.url || link.uuid,
              url: link.url || '',
              categories: Array.from(categories),
              note: link.infoHtml || '',
              keywords: link.keywords || '',
              meta: { emoji: link.emoji || '', updatedAt: Date.now() }
            };
            const vcard = MB.CardDAV.buildVCard(model);

            if (!href) {
              // Create new card
              const targetHref = MB.CardDAV.joinUrl(addressbookUrl, (link.uuid || uuid) + '.vcf');
              const putRes = await MB.CardDAV.put(targetHref, vcard, authHeader, null, '*');
              if (putRes.ok || putRes.status === 201 || putRes.status === 200) {
                const newEtag = putRes.headers?.etag || '';
                entry.occ.forEach(({link}) => { this.$set(link, 'carddav', { href: targetHref, etag: newEtag, lastSyncedAt: Date.now(), lastHash: nextHash }); });
                created++;
              } else {
                skipped++;
              }
              continue;
            }

            // Update existing if changed
            if (lastHash && lastHash === nextHash) { skipped++; continue; }

            const putRes = await MB.CardDAV.put(href, vcard, authHeader, etag || null, null);
            if (putRes.ok) {
              const newEtag = putRes.headers?.etag || '';
              entry.occ.forEach(({link}) => { this.$set(link, 'carddav', { href, etag: newEtag, lastSyncedAt: Date.now(), lastHash: nextHash }); });
              updated++;
            } else if (putRes.status === 412) {
              // Conflict: fetch server version and prefer server for URL; union categories/keywords; keep client FN if server has no meta timestamp
              try {
                const getRes = await MB.CardDAV.get(href, authHeader);
                if (getRes.ok) {
                  const serverCard = MB.CardDAV.parseVCard(getRes.bodyText || '');
                  const serverMetaTs = serverCard.mbMeta?.updatedAt || 0;
                  const clientTs = model.meta.updatedAt;
                  const resolved = {
                    uid: model.uid,
                    fn: (clientTs > serverMetaTs ? model.fn : (serverCard.fn || model.fn)),
                    url: (serverCard.url || model.url), // server-first URL
                    categories: Array.from(new Set([...(serverCard.categories||[]), ...model.categories])),
                    note: (clientTs > serverMetaTs ? model.note : (serverCard.note || model.note)),
                    keywords: Array.from(new Set([...(model.keywords||'').split(',').map(s=>s.trim()).filter(Boolean), ...((serverCard.mbKeywords||'').split(',').map(s=>s.trim()).filter(Boolean))])).join(', '),
                    meta: { emoji: model.meta.emoji || serverCard.mbMeta?.emoji || '', updatedAt: Date.now() }
                  };
                  const mergedVcf = MB.CardDAV.buildVCard(resolved);
                  const retry = await MB.CardDAV.put(href, mergedVcf, authHeader, null, null); // drop If-Match to accept latest
                  if (retry.ok) {
                    const newEtag = retry.headers?.etag || '';
                    entry.occ.forEach(({link}) => { this.$set(link, 'carddav', { href, etag: newEtag, lastSyncedAt: Date.now(), lastHash: nextHash }); });
                    updated++;
                  } else {
                    skipped++;
                  }
                } else {
                  skipped++;
                }
              } catch { skipped++; }
            } else {
              skipped++;
            }
          }

          this.saveData();
          debugLog('log', `[CardDAV] Upload done. +${created} ~${updated} -${removed} =${skipped}`);
          showAppToast(`CardDAV upload: +${created}, ~${updated}, -${removed}`, 'success');
        } catch (e) {
          debugLog('error', '[CardDAV] Upload failed', e);
          showAppToast((this.getTranslation('carddav.syncFailed') || 'CardDAV sync failed: {message}').replace('{message}', e?.message || String(e)), 'error');
        }
      },

        async enrichLinkWithMetadata(link) {
          if (!window.MyBookmarksExtension) return false;

          try {
            const metadata = await window.MyBookmarksExtension.fetchMetadata(link.url);
            if (metadata.title && !link.text) link.text = metadata.title;
            if (metadata.favicon) link.favicon = metadata.favicon;
            if (metadata.description) link.description = metadata.description;
            return true;
          } catch (error) {
            debugLog('error', 'Error fetching metadata:', error);
            return false;
          }
        },

        showExtensionNotInstalledHint() {
          alert(this.getTranslation('extension.installHint') || 'Bitte installiere die MyBookmarks-Erweiterung aus local2/extensions/');
        },

        async enrichExistingLinksWithFavicons() {
          // Silent enrichment of links with favicons when extension becomes available
          if (!this.extensionAvailable || !window.MyBookmarksExtension) return;

          debugLog('log', 'Starting silent favicon enrichment for existing links');

          const linksToEnrich = [];
          this.data.groups.forEach(group => {
            group.links.forEach(link => {
              // Only enrich links that have a URL but no base64 favicon yet
              const fav = link && link.favicon ? String(link.favicon) : '';
              const isBase64 = fav.startsWith('data:');
              if (link.url && !link.deleted && !isBase64 && !link.faviconError) {
                linksToEnrich.push(link);
              }
            });
          });

          if (linksToEnrich.length === 0) {
            debugLog('log', 'No links need favicon enrichment');
            return;
          }

          debugLog('log', `Enriching ${linksToEnrich.length} links with favicons`);

          for (const link of linksToEnrich) {
            try {
              await this.tryFetchAndSetFavicon(link, link.url);
              // Small delay to avoid overwhelming the extension
              await new Promise(r => setTimeout(r, 100));
            } catch (error) {
              debugLog('warn', 'Error enriching link with favicon:', error);
            }
          }

          this.saveData();
          debugLog('log', 'Favicon enrichment complete');
        },

        async enrichAllLinksWithMetadata() {
          const hasExtension = await this.checkExtensionAvailable();
          if (!hasExtension) {
            alert('Bitte installiere die MyBookmarks Browser-Erweiterung aus local2/extensions/');
            return;
          }

          const linksToEnrich = [];
          this.data.groups.forEach(group => {
            group.links.forEach(link => {
              if (link.url && !link.deleted && !link.favicon) {
                linksToEnrich.push(link);
              }
            });
          });

          if (linksToEnrich.length === 0) {
            alert(this.getTranslation('extension.allHaveMetadata') || 'Alle Links haben bereits Metadaten!');
            return;
          }

          const confirmMsg = (this.getTranslation('extension.fetchMetadataConfirm') || 'Metadaten für {count} Links abrufen?')
            .replace('{count}', linksToEnrich.length);
          if (!confirm(confirmMsg)) return;

          let enriched = 0;
          for (const link of linksToEnrich) {
            try {
              if (await this.enrichLinkWithMetadata(link)) enriched++;
              await new Promise(r => setTimeout(r, 200));
            } catch (error) {
              debugLog('error', 'Fehler beim Anreichern des Links:', error);
            }
          }

          this.saveData();
          const msg = (this.getTranslation('extension.enriched') || '{count} Links mit Metadaten angereichert!')
            .replace('{count}', enriched);
          alert(msg);
        },

        // Get all links from all groups
        getAllLinks() {
          const links = [];
          if (this.data.groups) {
            this.data.groups.forEach(group => {
              if (group.links) {
                group.links.forEach(link => {
                  if (link.uuid) {
                    links.push({
                      ...link,
                      groupName: group.name,
                      groupUuid: group.uuid
                    });
                  }
                });
              }
            });
          }
          return links;
        },
        
        // Get all Group > Keyword combinations
        getGroupKeywords() {
          const results = [];
          const seenCombos = new Set();
          
          if (this.data.groups) {
            this.data.groups.forEach(group => {
              const groupKeywords = new Set();
              
              // Collect all keywords from all links in this group
              if (group.links) {
                group.links.forEach(link => {
                  if (link.keywords) {
                    const keywords = typeof link.keywords === 'string' 
                      ? link.keywords.split(',').map(k => k.trim()).filter(k => k)
                      : [];
                    keywords.forEach(kw => groupKeywords.add(kw));
                  }
                });
              }
              
              // Add keywords from group itself if it has any
              if (group.keywords) {
                const keywords = typeof group.keywords === 'string' 
                  ? group.keywords.split(',').map(k => k.trim()).filter(k => k)
                  : [];
                keywords.forEach(kw => groupKeywords.add(kw));
              }
              
              // Create entries for each unique keyword in this group
              groupKeywords.forEach(keyword => {
                const slug = this.keywordSlug(keyword);
                const comboKey = `${group.uuid}-${slug}`;
                
                if (!seenCombos.has(comboKey)) {
                  seenCombos.add(comboKey);
                  results.push({
                    key: comboKey,
                    groupName: group.name.substring(0, 20) + (group.name.length > 20 ? '...' : ''),
                    keyword: keyword,
                    selector: `.keyword-badge[data-group-uuid='${group.uuid}'][data-keyword='${slug}']`
                  });
                }
              });
            });
          }
          
          return results;
        },
        
        // Get all Group > Link > Keyword combinations
        getGroupLinkKeywords() {
          const results = [];
          if (this.data.groups) {
            this.data.groups.forEach(group => {
              if (group.links) {
                group.links.forEach(link => {
                  if (link.uuid && link.keywords) {
                    const keywords = typeof link.keywords === 'string' 
                      ? link.keywords.split(',').map(k => k.trim()).filter(k => k)
                      : [];
                    keywords.forEach(keyword => {
                      const slug = this.keywordSlug(keyword);
                      results.push({
                        key: `${group.uuid}-${link.uuid}-${slug}`,
                        groupName: group.name.substring(0, 15) + (group.name.length > 15 ? '...' : ''),
                        linkText: (link.text || link.url).substring(0, 15) + ((link.text || link.url).length > 15 ? '...' : ''),
                        keyword: keyword,
                        selector: `.keyword-badge[data-group-uuid='${group.uuid}'][data-link-uuid='${link.uuid}'][data-keyword='${slug}']`
                      });
                    });
                  }
                });
              }
            });
          }
          return results;
        },
        
        // Extract color styles from custom CSS for a specific keyword
        getEffectiveCustomCssText() {
          // Always read the currently applied stylesheet first so behavior
          // is identical with open/closed CSS sidebar.
          const styleEl = document.getElementById('user-custom-css');
          const applied = styleEl && typeof styleEl.textContent === 'string'
            ? styleEl.textContent
            : '';
          if (applied) return applied;
          if (typeof this.data?.options?.customCss === 'string' && this.data.options.customCss) {
            return this.data.options.customCss;
          }
          if (typeof this.customCssDraft === 'string' && this.customCssDraft) {
            return this.customCssDraft;
          }
          return '';
        },
        
        // Extract color styles from custom CSS for a specific keyword
        getKeywordColorFromCustomCSS(keyword) {
          try {
            const customCss = this.getEffectiveCustomCssText();
            if (!customCss) return null;
            
            const slug = this.keywordSlug(keyword);
            if (!slug) return null;
            
            // Look for CSS rules that target this keyword
            const patterns = [
              new RegExp(`\\.mb-keyword-kw-${slug}\\s*\\{([^}]+)\\}`, 'gi'),
              new RegExp(`\\.keyword-badge\\[data-keyword=['"]?${slug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
              new RegExp(`\\[data-keyword=['"]?${slug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
            ];
            
            let styles = {};
            
            for (const pattern of patterns) {
              const matches = customCss.matchAll(pattern);
              for (const match of matches) {
                const rules = match[1];
                // Extract background-color
                const bgColorMatch = rules.match(/background-color\s*:\s*([^;!]+)/i);
                if (bgColorMatch) {
                  styles.backgroundColor = bgColorMatch[1].trim().replace(/!important/gi, '').trim();
                }
                // Extract background (for gradients)
                const bgMatch = rules.match(/background\s*:\s*([^;!]+)/i);
                if (bgMatch && !bgMatch[1].includes('none')) {
                  styles.background = bgMatch[1].trim().replace(/!important/gi, '').trim();
                }
                // Extract text color
                const colorMatch = rules.match(/(?<!background-)color\s*:\s*([^;!]+)/i);
                if (colorMatch) {
                  styles.color = colorMatch[1].trim().replace(/!important/gi, '').trim();
                }
              }
            }
            
            return styles;
          } catch (e) {
            debugLog('warn', 'Error extracting keyword color from CSS:', e);
            return null;
          }
        },
        
        // Get inline style object for keyword badges in the keyword cloud
        getKeywordInlineStyle(keyword) {
          const customStyles = this.getKeywordColorFromCustomCSS(keyword);
          if (!customStyles || Object.keys(customStyles).length === 0) {
            return null;
          }
          
          const style = {};
          if (customStyles.background) {
            style.background = customStyles.background;
          } else if (customStyles.backgroundColor) {
            style.backgroundColor = customStyles.backgroundColor;
          }
          if (customStyles.color) {
            style.color = customStyles.color;
          }
          
          return style;
        },
        
        // Collect all colors for a keyword from all contexts where it appears
        collectAllKeywordColors(keyword) {
          try {
            const colors = [];
            const customCss = this.getEffectiveCustomCssText();
            
            if (!customCss) return colors;
            
            const slug = this.keywordSlug(keyword);
            if (!slug) return colors;
            
            // Track which contexts have this keyword
            const contextsWithKeyword = [];
            
            // Find all groups that have this keyword
            this.data.groups.forEach(group => {
              if (!group.deleted && group.keywords && group.keywords.includes(keyword)) {
                contextsWithKeyword.push({
                  type: 'group',
                  uuid: group.uuid,
                  name: group.name
                });
              }
              
              // Find all links that have this keyword
              if (group.links) {
                group.links.forEach(link => {
                  if (!link.deleted && link.keywords && link.keywords.includes(keyword)) {
                    contextsWithKeyword.push({
                      type: 'link',
                      groupUuid: group.uuid,
                      linkUuid: link.uuid,
                      text: link.text
                    });
                  }
                });
              }
            });
            
            // Extract color for each context from CSS
            const escapedSlug = slug.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            
            contextsWithKeyword.forEach((ctx, idx) => {
              let color = null;
              
              if (ctx.type === 'group' && ctx.uuid) {
                // Look for group-specific keyword color
                const groupUuidEscaped = ctx.uuid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                
                // First try: specific keyword in specific group
                const specificPatterns = [
                  new RegExp(`\\[data-group-uuid=['"]?${groupUuidEscaped}['"]?\\]\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
                  new RegExp(`\\.keyword-badge\\[data-group-uuid=['"]?${groupUuidEscaped}['"]?\\]\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
                ];
                
                // Second try: ALL keywords in this group (fallback)
                const groupPatterns = [
                  new RegExp(`\\.keyword-badge\\[data-group-uuid=['"]?${groupUuidEscaped}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
                  new RegExp(`\\[data-group-uuid=['"]?${groupUuidEscaped}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
                ];
                
                const allPatterns = [...specificPatterns, ...groupPatterns];
                
                for (const pattern of allPatterns) {
                  if (color) break;
                  const matches = customCss.matchAll(pattern);
                  for (const match of matches) {
                    const rules = match[1];
                    const bgMatch = rules.match(/background\s*:\s*([^;!]+)/i);
                    if (bgMatch && !bgMatch[1].includes('gradient')) {
                      color = bgMatch[1].trim().replace(/!important/gi, '').trim();
                      break;
                    }
                    const bgColorMatch = rules.match(/background-color\s*:\s*([^;!]+)/i);
                    if (bgColorMatch) {
                      color = bgColorMatch[1].trim().replace(/!important/gi, '').trim();
                      break;
                    }
                  }
                }
              } else if (ctx.type === 'link' && ctx.linkUuid) {
                // Look for link-specific keyword color
                const linkUuidEscaped = ctx.linkUuid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                
                // First try: specific keyword on specific link
                const specificPatterns = [
                  new RegExp(`\\[data-link-uuid=['"]?${linkUuidEscaped}['"]?\\]\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
                  new RegExp(`\\.keyword-badge\\[data-link-uuid=['"]?${linkUuidEscaped}['"]?\\]\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
                ];
                
                // Second try: ALL keywords on this link (fallback)
                const linkPatterns = [
                  new RegExp(`\\.keyword-badge\\[data-link-uuid=['"]?${linkUuidEscaped}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
                  new RegExp(`\\[data-link-uuid=['"]?${linkUuidEscaped}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
                ];
                
                const allPatterns = [...specificPatterns, ...linkPatterns];
                
                for (const pattern of allPatterns) {
                  if (color) break;
                  const matches = customCss.matchAll(pattern);
                  for (const match of matches) {
                    const rules = match[1];
                    const bgMatch = rules.match(/background\s*:\s*([^;!]+)/i);
                    if (bgMatch && !bgMatch[1].includes('gradient')) {
                      color = bgMatch[1].trim().replace(/!important/gi, '').trim();
                      break;
                    }
                    const bgColorMatch = rules.match(/background-color\s*:\s*([^;!]+)/i);
                    if (bgColorMatch) {
                      color = bgColorMatch[1].trim().replace(/!important/gi, '').trim();
                      break;
                    }
                  }
                }
              }
              
              if (color) {
                colors.push(color);
              }
            });
            
            // FIRST check for general keyword color (as fallback for all contexts)
            let generalColor = null;
            const generalPatterns = [
              new RegExp(`\\.mb-keyword-kw-${escapedSlug}\\s*\\{([^}]+)\\}`, 'gi'),
              new RegExp(`\\.keyword-badge\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
              new RegExp(`\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
            ];
            
            for (const pattern of generalPatterns) {
              if (generalColor) break;
              const matches = customCss.matchAll(pattern);
              for (const match of matches) {
                const rules = match[1];
                const bgMatch = rules.match(/background\s*:\s*([^;!]+)/i);
                if (bgMatch) {
                  generalColor = bgMatch[1].trim().replace(/!important/gi, '').trim();
                  if (generalColor.includes('gradient')) {
                    generalColor = null; // Ignore gradients in general color
                  } else {
                    break;
                  }
                }
                const bgColorMatch = rules.match(/background-color\s*:\s*([^;!]+)/i);
                if (bgColorMatch && !generalColor) {
                  generalColor = bgColorMatch[1].trim().replace(/!important/gi, '').trim();
                  break;
                }
              }
            }
            
            // If we found a general color, use it for ALL contexts that don't have specific colors
            if (generalColor && contextsWithKeyword.length > 0) {
              // Add the general color once for each context
              contextsWithKeyword.forEach(() => {
                colors.push(generalColor);
              });
            } else if (generalColor) {
              // No specific contexts, but we have a general color
              colors.push(generalColor);
            }
            
            // Remove duplicates while preserving order
            return [...new Set(colors)];
          } catch (e) {
            debugLog('warn', 'Error collecting keyword colors:', e);
            return [];
          }
        },
        
        // Get gradient style for keyword badge in keyword bar (returns style string)
        getKeywordGradientStyle(keyword) {
          try {
            // Let "selected keyword" CSS rules fully control active badges.
            // Otherwise inline styles can override Visual CSS editor rules.
            if (this.isKeywordFilterActive(keyword)) {
              return '';
            }
            const colors = this.collectAllKeywordColors(keyword);
            
            if (colors.length === 0) {
              return '';
            } else if (colors.length === 1) {
              // Single color
              return `background-color: ${colors[0]} !important`;
            } else {
              // Multiple colors - create linear gradient
              const gradient = `linear-gradient(90deg, ${colors.join(', ')})`;
              return `background: ${gradient} !important`;
            }
          } catch (e) {
            debugLog('warn', 'Error creating keyword gradient:', e);
            return '';
          }
        },
        
        cssClassFromUuid(prefix, uuid) {
          try {
            const base = String(uuid || '').toLowerCase();
            const safe = base.replace(/[^a-z0-9_-]/g, '-');
            return `${prefix}-uuid-${safe}`;
          } catch { return `${prefix}-uuid-unknown`; }
        },
        async copyToClipboard(text) {
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
            } else {
              const ta = document.createElement('textarea');
              ta.value = text;
              document.body.appendChild(ta);
              ta.select();
              document.execCommand('copy');
              document.body.removeChild(ta);
            }
            debugLog('log', '[CSS] Copied to clipboard:', text);
          } catch (e) { debugLog('warn', '[CSS] Copy failed', e); }
        },
        async copyGroupCssClass(group) {
          if (!group) return;
          const cls = this.cssClassFromUuid('group', group.uuid);
          await this.copyToClipboard('.' + cls + ' { }');
        },
        async copyLinkCssClass(link) {
          if (!link) return;
          const cls = this.cssClassFromUuid('link', link.uuid);
          await this.copyToClipboard('.' + cls + ' { }');
        },
        
        // Copy Group UUID to clipboard
        async copyGroupUuid(group, event) {
          if (!group || !group.uuid) return;
          try {
            // Check if Shift key is pressed - if so, copy as CSS selector
            let textToCopy = group.uuid;
            if (event && event.shiftKey) {
              textToCopy = `[data-group-uuid="${group.uuid}"]`;
            }
            
            await this.copyToClipboard(textToCopy);
            
            // Show success feedback
            const btn = event ? event.target : null;
            if (btn) {
              const originalText = btn.textContent;
              btn.textContent = '✅';
              setTimeout(() => {
                btn.textContent = originalText;
              }, 1000);
            }
            
            // If CSS Editor is open and shift key pressed, insert at cursor
            if (event && event.shiftKey && this.cssSidebarVisible && this.$refs.cssTextarea) {
              this.insertTextAtCursor(textToCopy);
            }
          } catch (e) {
            debugLog('warn', 'Failed to copy UUID:', e);
          }
        },
        
        // Copy Link UUID to clipboard
        async copyLinkUuid(link, event) {
          if (!link || !link.uuid) return;
          try {
            // Check if Shift key is pressed - if so, copy as CSS selector
            let textToCopy = link.uuid;
            if (event && event.shiftKey) {
              textToCopy = `[data-link-uuid="${link.uuid}"]`;
            }
            
            await this.copyToClipboard(textToCopy);
            
            // Show success feedback
            const btn = event ? event.target : null;
            if (btn) {
              const originalText = btn.textContent;
              btn.textContent = '✅';
              setTimeout(() => {
                btn.textContent = originalText;
              }, 1000);
            }
            
            // If CSS Editor is open and shift key pressed, insert at cursor
            if (event && event.shiftKey && this.cssSidebarVisible && this.$refs.cssTextarea) {
              this.insertTextAtCursor(textToCopy);
            }
          } catch (e) {
            debugLog('warn', 'Failed to copy UUID:', e);
          }
        },
        
        // Insert text at cursor position in CSS editor
        insertTextAtCursor(text) {
          const textarea = this.$refs.cssTextarea;
          if (!textarea) return;
          
          const start = textarea.selectionStart;
          const end = textarea.selectionEnd;
          const currentText = this.customCssDraft || '';
          
          // Insert text at cursor position
          this.customCssDraft = currentText.substring(0, start) + text + currentText.substring(end);
          
          // Apply the CSS
          this.applyCustomCssFromTextarea(false);
          
          // Restore cursor position after Vue updates the textarea
          this.$nextTick(() => {
            textarea.focus();
            const newPosition = start + text.length;
            textarea.setSelectionRange(newPosition, newPosition);
          });
        },
        
        // Handle keydown events in CSS textarea
        handleCssKeydown(event) {
          // Handle Tab key
          if (event.key === 'Tab') {
            event.preventDefault();
            
            const textarea = event.target;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;
            
            if (event.shiftKey) {
              // Shift+Tab: Remove indentation
              if (start === end) {
                // No selection - remove up to 2 spaces before cursor
                const lineStart = text.lastIndexOf('\n', start - 1) + 1;
                const beforeCursor = text.substring(lineStart, start);
                const spacesToRemove = beforeCursor.match(/^( {1,2})/);
                
                if (spacesToRemove) {
                  const removeCount = spacesToRemove[1].length;
                  this.customCssDraft = text.substring(0, lineStart) + 
                                       text.substring(lineStart + removeCount);
                  this.$nextTick(() => {
                    textarea.setSelectionRange(start - removeCount, start - removeCount);
                  });
                }
              } else {
                // Selection - remove indentation from all selected lines
                const lineStart = text.lastIndexOf('\n', start - 1) + 1;
                const lineEnd = text.indexOf('\n', end);
                const endPos = lineEnd === -1 ? text.length : lineEnd;
                
                const selectedLines = text.substring(lineStart, endPos);
                const dedentedLines = selectedLines.split('\n').map(line => {
                  return line.replace(/^( {1,2})/, '');
                }).join('\n');
                
                const lengthDiff = selectedLines.length - dedentedLines.length;
                this.customCssDraft = text.substring(0, lineStart) + dedentedLines + text.substring(endPos);
                
                this.$nextTick(() => {
                  textarea.setSelectionRange(
                    Math.max(lineStart, start - (start === lineStart ? 0 : Math.min(2, lengthDiff))),
                    end - lengthDiff
                  );
                });
              }
            } else {
              // Tab: Add 2 spaces
              if (start === end) {
                // No selection - insert 2 spaces
                this.customCssDraft = text.substring(0, start) + '  ' + text.substring(end);
                this.$nextTick(() => {
                  textarea.setSelectionRange(start + 2, start + 2);
                });
              } else {
                // Selection - indent all selected lines
                const lineStart = text.lastIndexOf('\n', start - 1) + 1;
                const lineEnd = text.indexOf('\n', end);
                const endPos = lineEnd === -1 ? text.length : lineEnd;
                
                const selectedLines = text.substring(lineStart, endPos);
                const indentedLines = selectedLines.split('\n').map(line => '  ' + line).join('\n');
                
                this.customCssDraft = text.substring(0, lineStart) + indentedLines + text.substring(endPos);
                
                this.$nextTick(() => {
                  const addedSpaces = indentedLines.length - selectedLines.length;
                  textarea.setSelectionRange(
                    start + (start === lineStart ? 2 : 0),
                    end + addedSpaces
                  );
                });
              }
            }
            
            // Apply the CSS after modification
            this.applyCustomCssFromTextarea(false);
          }
        },
        
        keywordSlug(kw) {
          try { return String(kw||'').trim().toLowerCase().replace(/\s+/g,'-').replace(/[^a-z0-9_-]/g,'-'); } catch { return ''; }
        },
        keywordClass(kw) {
          const slug = this.keywordSlug(kw);
          return slug ? `mb-keyword-kw-${slug}` : 'mb-keyword-kw';
        },
        ensureCustomStyleEl() {
          let el = document.getElementById('user-custom-css');
          if (!el) {
            el = document.createElement('style');
            el.id = 'user-custom-css';
            document.head.appendChild(el);
          }
          return el;
        },
        applyCustomCss(css) {
          const el = this.ensureCustomStyleEl();
          el.textContent = css || '';
        },
        ensureVisualCssOptions() {
          if (!this.data.options) {
            this.$set(this.data, 'options', {});
          }

          const legacyRules = Array.isArray(this.data.options.visualCssRules) ? this.data.options.visualCssRules : [];
          const rawVisualCss = (this.data.options.visualCss && typeof this.data.options.visualCss === 'object' && !Array.isArray(this.data.options.visualCss))
            ? this.data.options.visualCss
            : {};

          const visualCssOptions = Object.assign({
            stateVersion: 0,
            rules: legacyRules,
            designTokens: [],
            selectedTemplate: null,
            customRuleSets: {},
            collapsedRules: [],
            designTokensCollapsed: false,
            sidebarWidth: 400,
            sidebarTopHeight: 300
          }, rawVisualCss);

          if (!Array.isArray(visualCssOptions.rules)) visualCssOptions.rules = legacyRules;
          if (!Array.isArray(visualCssOptions.designTokens)) visualCssOptions.designTokens = [];
          if (!visualCssOptions.customRuleSets || typeof visualCssOptions.customRuleSets !== 'object' || Array.isArray(visualCssOptions.customRuleSets)) {
            visualCssOptions.customRuleSets = {};
          }
          if (!Array.isArray(visualCssOptions.collapsedRules)) visualCssOptions.collapsedRules = [];
          visualCssOptions.designTokensCollapsed = !!visualCssOptions.designTokensCollapsed;
          const parsedStateVersion = parseInt(visualCssOptions.stateVersion, 10);
          visualCssOptions.stateVersion = Number.isFinite(parsedStateVersion) ? parsedStateVersion : 0;
          visualCssOptions.selectedTemplate = (typeof visualCssOptions.selectedTemplate === 'string' && visualCssOptions.selectedTemplate.trim())
            ? visualCssOptions.selectedTemplate.trim()
            : null;

          const parsedSidebarWidth = parseInt(visualCssOptions.sidebarWidth, 10);
          visualCssOptions.sidebarWidth = Number.isFinite(parsedSidebarWidth) ? parsedSidebarWidth : 400;
          const parsedSidebarTopHeight = parseInt(visualCssOptions.sidebarTopHeight, 10);
          visualCssOptions.sidebarTopHeight = Number.isFinite(parsedSidebarTopHeight) ? parsedSidebarTopHeight : 300;

          this.$set(this.data.options, 'visualCss', visualCssOptions);
          this.$set(this.data.options, 'visualCssRules', visualCssOptions.rules);
          return this.data.options.visualCss;
        },
        syncVisualCssStateToOptions(save = false) {
          const visualCssOptions = this.ensureVisualCssOptions();
          const deepClone = (value, fallback) => {
            try { return JSON.parse(JSON.stringify(value)); } catch { return fallback; }
          };

          const rules = Array.isArray(this.visualCssRules) ? this.visualCssRules : [];
          const tokens = Array.isArray(this.designTokens) ? this.designTokens : [];
          const ruleSets = (this.customRuleSets && typeof this.customRuleSets === 'object' && !Array.isArray(this.customRuleSets))
            ? this.customRuleSets
            : {};
          const collapsedRules = Array.isArray(this.collapsedRules) ? this.collapsedRules : [];
          const selectedTemplate = (typeof this.selectedVisualTemplate === 'string' && this.selectedVisualTemplate.trim())
            ? this.selectedVisualTemplate.trim()
            : null;
          const sidebarWidth = parseInt(this.cssSidebarWidth, 10);
          const sidebarTopHeight = parseInt(this.cssSidebarTopHeight, 10);

          this.$set(visualCssOptions, 'rules', deepClone(rules, []));
          this.$set(visualCssOptions, 'designTokens', deepClone(tokens, []));
          this.$set(visualCssOptions, 'selectedTemplate', selectedTemplate);
          this.$set(visualCssOptions, 'customRuleSets', deepClone(ruleSets, {}));
          this.$set(visualCssOptions, 'collapsedRules', deepClone(collapsedRules, []));
          this.$set(visualCssOptions, 'designTokensCollapsed', !!this.designTokensCollapsed);
          this.$set(visualCssOptions, 'sidebarWidth', Number.isFinite(sidebarWidth) ? sidebarWidth : 400);
          this.$set(visualCssOptions, 'sidebarTopHeight', Number.isFinite(sidebarTopHeight) ? sidebarTopHeight : 300);
          this.$set(visualCssOptions, 'stateVersion', 1);
          // Backwards compatibility: keep top-level visualCssRules aligned
          this.$set(this.data.options, 'visualCssRules', deepClone(rules, []));

          if (save) {
            this.saveData();
          }
        },
        syncVisualCssStateToLocalStorage() {
          try { localStorage.setItem('visualCssRules', JSON.stringify(this.visualCssRules || [])); } catch {}
          try {
            if (this.selectedVisualTemplate) {
              localStorage.setItem('selectedVisualTemplate', this.selectedVisualTemplate);
            } else {
              localStorage.removeItem('selectedVisualTemplate');
            }
          } catch {}
          try { localStorage.setItem('designTokens', JSON.stringify(this.designTokens || [])); } catch {}
          try { localStorage.setItem('customRuleSets', JSON.stringify(this.customRuleSets || {})); } catch {}
          try { localStorage.setItem('visualCssCollapsedRules', JSON.stringify(this.collapsedRules || [])); } catch {}
          try { localStorage.setItem('designTokensCollapsed', this.designTokensCollapsed ? '1' : '0'); } catch {}
          try { localStorage.setItem('cssSidebarWidth', String(this.cssSidebarWidth || 400)); } catch {}
          try { localStorage.setItem('cssSidebarTopHeight', String(this.cssSidebarTopHeight || 300)); } catch {}
        },
        applyVisualCssSidebarPreferences() {
          const visualCssOptions = this.ensureVisualCssOptions();
          const preferredWidth = parseInt(visualCssOptions.sidebarWidth, 10);
          if (Number.isFinite(preferredWidth)) {
            this.cssSidebarWidth = preferredWidth;
          } else {
            const localWidth = parseInt(localStorage.getItem('cssSidebarWidth'), 10);
            if (Number.isFinite(localWidth)) this.cssSidebarWidth = localWidth;
          }

          const preferredTopHeight = parseInt(visualCssOptions.sidebarTopHeight, 10);
          let resolvedTopHeight = null;
          const localTopHeight = parseInt(localStorage.getItem('cssSidebarTopHeight'), 10);
          if (Number.isFinite(localTopHeight) && localTopHeight !== 300) {
            resolvedTopHeight = localTopHeight;
          } else if (Number.isFinite(preferredTopHeight) && preferredTopHeight !== 300) {
            resolvedTopHeight = preferredTopHeight;
          } else {
            const legacyTopHeight = parseInt(localStorage.getItem('sidebarTopHeight'), 10);
            if (Number.isFinite(legacyTopHeight) && legacyTopHeight !== 300) {
              resolvedTopHeight = legacyTopHeight;
            }
          }
          if (!Number.isFinite(resolvedTopHeight)) {
            const containerHeight = Math.max(420, window.innerHeight - 100);
            resolvedTopHeight = Math.round(containerHeight * (2 / 3));
          }
          this.cssSidebarTopHeight = resolvedTopHeight;
          this.clampCssSidebarTopHeight();
        },
        openCssSidebar() {
          // Initialize Visual CSS Rules if not already loaded
          if (!this.visualCssRules || this.visualCssRules.length === 0) {
            this.loadVisualCssRules();
          }
          // Normalize potentially legacy property keys before rendering editor UI
          this.normalizeAllVisualRules();

          // Load custom rule sets
          this.loadCustomRuleSets();

          // Initialize available selectors
          this.initializeAvailableSelectors();

          // Check for legacy CSS migration
          this.checkAndMigrateLegacyCss();

          this.cssSidebarVisible = true;
          // Add class to body for layout adjustment
          document.body.classList.add('css-sidebar-open');
          this.applyVisualCssSidebarPreferences();
          document.body.style.marginRight = this.cssSidebarWidth + 'px';
          this.$nextTick(() => {
            this.clampCssSidebarTopHeight();
            this.ensureCssPropertyEditorFonts();
            if (this.cssPropertyEditor.ruleId && !this.cssPropertyEditorRule) {
              this.clearCssPropertyEditorSelection();
            }
          });
        },

        closeCssSidebar() {
          if (this.elementPickerActive) this.stopElementPicker();
          this.cssSidebarVisible = false;
          // Remove class from body to restore layout
          document.body.classList.remove('css-sidebar-open');
          document.body.style.marginRight = '';
        },

        // Visual CSS Editor Methods
        initializeAvailableSelectors() {
          this.visualCssAvailableSelectors = [
            { value: 'body', label: 'Body (Entire Page)', supportsGroup: false, supportsLink: false },
            { value: '.mb-app', label: 'Application Container', supportsGroup: false, supportsLink: false },
            { value: '.mb-titlebar', label: 'Title Bar', supportsGroup: false, supportsLink: false },
            { value: '.mb-toolbar', label: 'Toolbar', supportsGroup: false, supportsLink: false },
            { value: '.mb-toolbar__search', label: 'Search Bar', supportsGroup: false, supportsLink: false },
            { value: '.mb-keywords-cloud', label: 'Keywords Cloud', supportsGroup: false, supportsLink: false },
            { value: '.mb-keywords-cloud .mb-keyword.mb-keyword-active', label: 'Selected Keywords (Keyword Bar)', supportsGroup: false, supportsLink: false },
            { value: '.mb-keywords-cloud .mb-keyword.mb-keyword-active .mb-keyword-text', label: 'Selected Keyword Text', supportsGroup: false, supportsLink: false },
            { value: '.mb-keyword-suggestions, .mb-keyword-suggestions--overlay', label: 'Keyword Suggestions List', supportsGroup: false, supportsLink: false },
            { value: '.mb-keyword-suggestion', label: 'Keyword Suggestions Item', supportsGroup: false, supportsLink: false },
            { value: '.mb-groups-container', label: 'Groups Container', supportsGroup: false, supportsLink: false },
            { value: '.mb-group', label: 'Group', supportsGroup: true, supportsLink: false },
            { value: '.mb-group__header', label: 'Group Header', supportsGroup: true, supportsLink: false },
            { value: '.mb-group__name', label: 'Group Name', supportsGroup: true, supportsLink: false },
            { value: '.mb-group__actions', label: 'Group Actions', supportsGroup: true, supportsLink: false },
            { value: '.verticalDropZone', label: 'Group Column Dropzone (Vertical)', supportsGroup: false, supportsLink: false },
            { value: '.groupContainerDragAndDrop.group-drop-zone', label: 'Group Dropzone (Horizontal)', supportsGroup: false, supportsLink: false },
            { value: '.mb-links-container', label: 'Links Container', supportsGroup: true, supportsLink: false },
            { value: '.mb-link', label: 'Link', supportsGroup: true, supportsLink: true },
            { value: '.mb-link-separator', label: 'Sep.', supportsGroup: true, supportsLink: true },
            { value: '.mb-link-note', label: 'Note', supportsGroup: true, supportsLink: true },
            { value: '.linkVerticalDropZone', label: 'Link Column Dropzone (Vertical)', supportsGroup: true, supportsLink: false },
            { value: '.linkContainerDragAndDrop.link-drop-zone', label: 'Link Dropzone (Horizontal)', supportsGroup: true, supportsLink: false },
            { value: '.link-url-preview', label: 'Link URL', supportsGroup: true, supportsLink: true },
            { value: '.mb-link__icon', label: 'Link Icon', supportsGroup: true, supportsLink: true },
            { value: '.mb-link__actions', label: 'Link Actions', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover', label: 'Link Popover Container', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__title', label: 'Link Popover Title', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__url', label: 'Link Popover URL', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__meta', label: 'Link Popover Metadata', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__row', label: 'Link Popover Row', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__label', label: 'Link Popover Label', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__value', label: 'Link Popover Value', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__value--muted', label: 'Link Popover Relative Text', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__keywords', label: 'Link Popover Keywords', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__badge', label: 'Link Popover Keyword Badge', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__favicon', label: 'Link Popover Favicon', supportsGroup: true, supportsLink: true }
          ];
        },

        loadVisualCssRules() {
          const visualCssOptions = this.ensureVisualCssOptions();
          const optionStateVersion = parseInt(visualCssOptions.stateVersion, 10);
          const hasPersistedVisualCssState = Number.isFinite(optionStateVersion) && optionStateVersion >= 1;

          // Load tokens (prefer options, fallback localStorage for legacy data)
          let loadedTokens = [];
          if (hasPersistedVisualCssState || (Array.isArray(visualCssOptions.designTokens) && visualCssOptions.designTokens.length > 0)) {
            loadedTokens = Array.isArray(visualCssOptions.designTokens) ? visualCssOptions.designTokens : [];
          } else {
            try {
              const tok = localStorage.getItem('designTokens');
              const parsed = tok ? JSON.parse(tok) : [];
              loadedTokens = Array.isArray(parsed) ? parsed : [];
            } catch (e) {
              loadedTokens = [];
            }
          }
          this.designTokens = loadedTokens.map(t => ({
            name: this.normalizeTokenName((t?.name || '').toString()),
            value: (t?.value ?? '').toString()
          }));

          // Load selected template (prefer options, fallback localStorage for legacy data)
          if (hasPersistedVisualCssState) {
            this.selectedVisualTemplate = visualCssOptions.selectedTemplate || null;
          } else {
            const optionTemplate = (typeof visualCssOptions.selectedTemplate === 'string' && visualCssOptions.selectedTemplate.trim())
              ? visualCssOptions.selectedTemplate.trim()
              : null;
            if (optionTemplate) {
              this.selectedVisualTemplate = optionTemplate;
            } else {
              const storedTemplate = localStorage.getItem('selectedVisualTemplate');
              this.selectedVisualTemplate = storedTemplate ? storedTemplate : null;
            }
          }

          // Load rules (prefer options, fallback localStorage for legacy data)
          let loadedRules = [];
          const optionRules = Array.isArray(visualCssOptions.rules) ? visualCssOptions.rules : [];
          if (hasPersistedVisualCssState || optionRules.length > 0) {
            loadedRules = optionRules;
          } else {
            const storedRules = localStorage.getItem('visualCssRules');
            if (storedRules) {
              try {
                const parsedRules = JSON.parse(storedRules);
                loadedRules = Array.isArray(parsedRules) ? parsedRules : [];
              } catch (e) {
                debugLog('error', 'Failed to parse stored visual CSS rules:', e);
                loadedRules = [];
              }
            }
          }
          this.visualCssRules = loadedRules.map(rule => this.normalizeVisualRule(JSON.parse(JSON.stringify(rule))));

          // Keep options/localStorage in sync so full export includes editor state
          this.syncVisualCssStateToOptions(this.dataLoaded === true);
          this.syncVisualCssStateToLocalStorage();

          // Apply CSS only when visual editor state is active; otherwise keep existing custom CSS text
          const hasVisualState = this.visualCssRules.length > 0
            || !!this.selectedVisualTemplate
            || this.designTokens.length > 0;
          if (hasVisualState) {
            this.applyVisualCss();
          } else if (typeof this.data.options?.customCss === 'string') {
            this.applyCustomCss(this.data.options.customCss);
          }
        },

        checkAndMigrateLegacyCss() {
          // Check if there's legacy custom CSS to migrate
          // Only migrate once - check if migration was already attempted
          if (this.data.options?.visualCssMigrated) {
            return; // Migration already done or skipped
          }

          // Check if we already have visual CSS rules stored
          if (this.data.options?.visualCssRules && this.data.options.visualCssRules.length > 0) {
            // We have visual rules, no need to migrate
            return;
          }

          const legacyCss = this.data.options?.customCss;
          // Only migrate if we have legacy CSS AND no visual rules AND no previous migration
          if (legacyCss && legacyCss.trim() &&
              this.visualCssRules.length === 0 &&
              !legacyCss.includes('/* Template:') && // Don't migrate generated CSS
              !legacyCss.includes('/* User Rules')) {  // Don't migrate generated CSS
            this.showMigrationNotice = true;
            // Auto-migrate simple CSS rules if possible
            this.attemptCssMigration(legacyCss);

            // Mark as migrated to prevent future auto-migration
            if (!this.data.options) {
              this.data.options = {};
            }
            this.data.options.visualCssMigrated = true;
            this.saveData();
          }
        },

        nextVisualRuleId() {
          const now = Date.now();
          if (!Number.isFinite(this._visualCssRuleSeq)) {
            this._visualCssRuleSeq = now;
          } else {
            this._visualCssRuleSeq = Math.max(this._visualCssRuleSeq + 1, now);
          }
          while (Array.isArray(this.visualCssRules) && this.visualCssRules.some(r => r && r.id === this._visualCssRuleSeq)) {
            this._visualCssRuleSeq += 1;
          }
          return this._visualCssRuleSeq;
        },

        attemptCssMigration(cssText) {
          // Simple migration: Convert CSS text to visual rules
          // This is a basic implementation - can be enhanced
          const migrationRule = {
            id: this.nextVisualRuleId(),
            enabled: true,
            selector: {
              base: 'body',
              groupId: null,
              linkId: null,
              keywordSlug: null,
              hover: false,
              dragOver: false
            },
            groupId: null,
            linkId: null,
            properties: {
              custom: cssText
            },
            important: {},
            customCss: cssText
          };

          this.visualCssRules.push(migrationRule);
          this.saveVisualCss();
        },

        addNewCssRule() {
          const ruleCount = this.visualCssRules.length + 1;
          const newRule = {
            id: this.nextVisualRuleId(),
            name: `${this.getTranslation('css.visual.rule') || 'Regel'} ${ruleCount}`,
            enabled: true,
            selector: {
              base: '',
              groupId: null,
              linkId: null,
              keywordSlug: null,
              hover: false,
              dragOver: false
            },
            groupId: null,
            linkId: null,
            properties: {},
            important: {},
            customCss: ''
          };

          this.visualCssRules.push(newRule);

          // Load template properties for this rule if a template is selected
          if (this.selectedVisualTemplate && newRule.selector.base) {
            this.loadTemplatePropertiesForRule(newRule);
          }

          this.saveVisualCss();
        },

        toggleCssRule(rule) {
          rule.enabled = !rule.enabled;
          this.saveVisualCss();
        },

        moveCssRuleUp(index) {
          if (index <= 0) return;
          const [rule] = this.visualCssRules.splice(index, 1);
          this.visualCssRules.splice(index - 1, 0, rule);
          this.saveVisualCss();
        },

        moveCssRuleDown(index) {
          if (index < 0 || index >= this.visualCssRules.length - 1) return;
          const [rule] = this.visualCssRules.splice(index, 1);
          this.visualCssRules.splice(index + 1, 0, rule);
          this.saveVisualCss();
        },

        duplicateCssRule(rule) {
          // Create a deep copy to avoid shared references
          const duplicate = JSON.parse(JSON.stringify(rule));
          duplicate.id = this.nextVisualRuleId();
          duplicate.name = (rule.name || this.getTranslation('css.visual.rule') || 'Regel') + ' ' + (this.getTranslation('css.visual.copy') || 'Kopie');

          const index = this.visualCssRules.indexOf(rule);
          this.visualCssRules.splice(index + 1, 0, duplicate);
          this.saveVisualCss();
        },

        deleteCssRule(rule) {
          const index = this.visualCssRules.indexOf(rule);
          if (index > -1) {
            if (String(this.cssPropertyEditor?.ruleId) === String(rule?.id)) {
              this.clearCssPropertyEditorSelection();
            }
            this.visualCssRules.splice(index, 1);
            // Remove from collapsed list if present
            const ci = this.collapsedRules.indexOf(rule.id);
            if (ci > -1) this.collapsedRules.splice(ci, 1);
            this.saveCollapsedRules();
            this.saveVisualCss();
          }
        },

        startEditingRuleName(rule) {
          this.editingRuleId = rule.id;
          this.editingRuleName = rule.name || `${this.getTranslation('css.visual.rule') || 'Regel'} ${this.visualCssRules.indexOf(rule) + 1}`;
          this.$nextTick(() => {
            const input = this.$refs.ruleNameInput;
            if (input && Array.isArray(input)) {
              input[0].focus();
              input[0].select();
            } else if (input) {
              input.focus();
              input.select();
            }
          });
        },
        saveRuleName(rule) {
          if (this.editingRuleName && this.editingRuleName.trim()) {
            rule.name = this.editingRuleName.trim();
            this.saveVisualCss();
          }
          this.cancelEditingRuleName();
        },
        cancelEditingRuleName() {
          this.editingRuleId = null;
          this.editingRuleName = '';
        },
        toggleRuleCollapse(rule) {
          const index = this.collapsedRules.indexOf(rule.id);
          if (index > -1) {
            this.collapsedRules.splice(index, 1);
          } else {
            this.collapsedRules.push(rule.id);
          }
          this.saveCollapsedRules();
        },
        isRuleCollapsed(rule) {
          return this.collapsedRules.includes(rule.id);
        },
        expandAllRules() {
          this.collapsedRules = [];
          this.saveCollapsedRules();
        },
        collapseAllRules() {
          this.collapsedRules = this.visualCssRules.map(rule => rule.id);
          this.saveCollapsedRules();
        },
        clearAllCssSettings() {
          // Ask for confirmation
          if (!confirm(this.getTranslation('css.visual.clearAllConfirm') || 'Möchten Sie wirklich ALLE CSS-Einstellungen löschen?\n\nDies entfernt:\n• Alle CSS-Regeln\n• Das ausgewählte Template\n• Alle gespeicherten Regel-Sätze\n\nDiese Aktion kann nicht rückgängig gemacht werden!')) {
            return;
          }

          // Clear all CSS rules
          this.visualCssRules = [];

          // Clear selected template
          this.selectedVisualTemplate = null;

          // Clear selected rule set
          this.selectedRuleSetName = null;

          // Clear all saved rule sets
          this.customRuleSets = {};

          // Clear from localStorage
          localStorage.removeItem('visualCssRules');
          localStorage.removeItem('selectedVisualTemplate');
          localStorage.removeItem('customRuleSets');

          // Clear the applied CSS
          this.applyCustomCss('');

          // Save the empty state
          this.saveVisualCss();

          // Show success message
          this.showToast(this.getTranslation('css.visual.clearedAll') || 'Alle CSS-Einstellungen wurden gelöscht', 'success');
        },

        clearRuleProperties(rule) {
          // Clear all properties
          rule.properties = {};

          // Clear custom CSS
          rule.customCss = '';

          // Clear important flags
          rule.important = {};

          // Save the changes
          this.saveVisualCss();

          // Show success message
          this.showToast(this.getTranslation('css.visual.propertiesCleared') || 'Eigenschaften gelöscht', 'success');
        },

        updateRuleSelector(rule) {
          // Reset group and link when selector changes
          const selectorInfo = this.visualCssAvailableSelectors.find(s => s.value === rule.selector);
          if (selectorInfo) {
            if (!selectorInfo.supportsGroup) {
              rule.groupId = null;
              rule.linkId = null;
            }
            if (!selectorInfo.supportsLink) {
              rule.linkId = null;
            }
          }
        },

        updateRuleGroup(rule) {
          // Reset link when group changes
          rule.linkId = null;
        },

        

        removePropertyFromRule(rule, property) {
          this.$delete(rule.properties, property);
        },

        selectorUsesHoverState(selectorObj) {
          if (!selectorObj || typeof selectorObj !== 'object') return false;
          if (!selectorObj.hover) return false;
          const base = String(selectorObj.base || '').trim();
          if (!base) return false;
          // `link-hover` already has :hover in its mapping.
          if (base === 'link-hover') return false;
          return true;
        },

        selectorUsesDragOverState(selectorObj) {
          if (!selectorObj || typeof selectorObj !== 'object') return false;
          if (!selectorObj.dragOver) return false;
          const base = String(selectorObj.base || '').trim();
          if (!base) return false;
          return true;
        },

        appendHoverToSelector(selectorText) {
          const text = String(selectorText || '').trim();
          if (!text) return text;

          return text
            .split(',')
            .map((rawPart) => {
              const part = String(rawPart || '').trim();
              if (!part) return '';
              if (/:hover\b/i.test(part)) return part;

              // Keep pseudo-elements at the end: `.x::before` -> `.x:hover::before`
              const pseudoElementMatch = part.match(/(::[a-z0-9_-]+)\s*$/i);
              if (pseudoElementMatch) {
                const pseudoElement = pseudoElementMatch[1];
                const withoutPseudoElement = part.slice(0, -pseudoElement.length).trim();
                return `${withoutPseudoElement}:hover${pseudoElement}`;
              }

              return `${part}:hover`;
            })
            .filter(Boolean)
            .join(', ');
        },

        appendDragOverToSelector(selectorText) {
          const text = String(selectorText || '').trim();
          if (!text) return text;

          return text
            .split(',')
            .map((rawPart) => {
              const part = String(rawPart || '').trim();
              if (!part) return '';
              if (part.includes('.drag-over-active')) return part;

              // Keep pseudo-elements at the end: `.x::before` -> `.x.drag-over-active::before`
              const pseudoElementMatch = part.match(/(::[a-z0-9_-]+)\s*$/i);
              if (pseudoElementMatch) {
                const pseudoElement = pseudoElementMatch[1];
                const withoutPseudoElement = part.slice(0, -pseudoElement.length).trim();
                return `${withoutPseudoElement}.drag-over-active${pseudoElement}`;
              }

              return `${part}.drag-over-active`;
            })
            .filter(Boolean)
            .join(', ');
        },

        generateCssSelector(rule) {
          // Ensure selector is an object
          const selectorObj = this.getRuleSelector(rule);

          debugLog('log', 'generateCssSelector - rule:', JSON.stringify(rule));
          debugLog('log', 'generateCssSelector - selectorObj:', JSON.stringify(selectorObj));
          debugLog('log', 'generateCssSelector - groupId type:', typeof selectorObj.groupId, 'value:', selectorObj.groupId);

          // Map base selector to actual CSS selector
          const baseSelectorMap = {
            'app': '.mb-app',
            'header': '.mb-titlebar',
            'toolbar': '.mb-toolbar',
            'footer': '.mb-footer',
            'groups-links-container': '.mb-groups-links-container',
            'surface-panel': '.mb-surface-panel',
            'muted-text': '.text-muted',
            'modal': '.modal-content',
            'modal-header': '.modal-header',
            'modal-body': '.modal-body',
            'modal-footer': '.modal-footer',
            'css-sidebar': '.css-sidebar',
            'feature-sidebar': '.feature-sidebar',
            'sidebar-header': '.sidebar-header',
            'sidebar-top-section': '.sidebar-top-section',
            'sidebar-bottom-section': '.sidebar-bottom-section',
            'sidebar-divider': '.sidebar-divider',
            'card': '.card',
            'card-header': '.card-header',
            'list-group-item': '.list-group-item',
            'table': '.table',
            'table-header': '.table thead th',
            'table-cell': '.table tbody td',
            'form-control': '.form-control',
            'form-select': '.form-select',
            'input-group-text': '.input-group-text',
            'form-check-input': '.form-check-input',
            'dropdown-menu': '.dropdown-menu',
            'dropdown-item': '.dropdown-item',
            'context-menu': '.mb-context-menu',
            'context-menu-item': '.mb-context-menu-list > li',
            'alert-info': '.alert-info',
            'alert-warning': '.alert-warning',
            'groups': '.mb-group',
            'group-header': '.mb-group__header',
            'group-title': '.mb-group__title',
            'group-body': '.mb-group__body',  // Group content area
            'vertical-dropzone': '.verticalDropZone',
            'group-horizontal-dropzone': '.groupContainerDragAndDrop.group-drop-zone',
            'links': '.mb-link',
            'separators': '.mb-link-separator',
            'notes': '.mb-link-note',
            'link-hover': '.mb-link:hover',
            'link-anchor': '.mb-link__anchor',
            'link-url': '.link-url-preview',
            'link-icon': '.mb-link__icon',
            'link-vertical-dropzone': '.linkVerticalDropZone',
            'link-horizontal-dropzone': '.linkContainerDragAndDrop.link-drop-zone',
            'link-popover': '.link-detail-popover',
            'link-popover-title': '.link-detail-popover__title',
            'link-popover-url': '.link-detail-popover__url',
            'link-popover-meta': '.link-detail-popover__meta',
            'link-popover-row': '.link-detail-popover__row',
            'link-popover-label': '.link-detail-popover__label',
            'link-popover-value': '.link-detail-popover__value',
            'link-popover-value-muted': '.link-detail-popover__value--muted',
            'link-popover-keywords': '.link-detail-popover__keywords',
            'link-popover-badge': '.link-detail-popover__badge',
            'link-popover-favicon': '.link-detail-popover__favicon',
            // Keyword selectors
            'keywords': '.mb-keyword',  // Keywords in keyword bar
            'keywords-selected': '.mb-keywords-cloud .mb-keyword.mb-keyword-active',
            'keyword-selected-text': '.mb-keywords-cloud .mb-keyword.mb-keyword-active .mb-keyword-text',
            'keyword-by-name': '.mb-keyword',
            'keywords-hierarchical': '.keyword-badge',  // All keyword badges (common class)
            'keyword-suggestions': '.mb-keyword-suggestions, .mb-keyword-suggestions--overlay',
            'keyword-suggestion-item': '.mb-keyword-suggestion',
            'body': 'body'
          };

          let baseSelector = baseSelectorMap[selectorObj.base] || selectorObj.base || '*';
          let fullSelector = baseSelector;
          const hasScopedGroup = selectorObj.groupId !== null
            && selectorObj.groupId !== undefined
            && selectorObj.groupId !== ''
            && selectorObj.groupId !== 'null';
          const hasScopedLink = selectorObj.linkId !== null
            && selectorObj.linkId !== undefined
            && selectorObj.linkId !== ''
            && selectorObj.linkId !== 'null';
          const groups = Array.isArray(this.data?.groups) ? this.data.groups : [];
          const scopedGroup = hasScopedGroup
            ? groups.find(g =>
              g.id === selectorObj.groupId ||
              g.uuid === selectorObj.groupId ||
              g.id === parseInt(selectorObj.groupId))
            : null;

          // Guard against missing target entities: never fallback to global selectors.
          if (hasScopedGroup && !scopedGroup) {
            return '';
          }
          if (hasScopedLink) {
            if (!scopedGroup) return '';
            const scopedLinks = Array.isArray(scopedGroup.links) ? scopedGroup.links : [];
            const scopedLink = scopedLinks.find(l =>
              l.id === selectorObj.linkId ||
              l.uuid === selectorObj.linkId ||
              l.id === parseInt(selectorObj.linkId));
            if (!scopedLink) return '';
          }

          // Handle different selector types
          if (selectorObj.base === 'keyword-by-name') {
            if (selectorObj.keywordSlug) {
              // Use the slug directly since it's already stored
              const slug = selectorObj.keywordSlug;
              // Use the mb-keyword-kw-{slug} class that's already added to keywords
              fullSelector = `.mb-keyword-kw-${slug}`;
            } else {
              fullSelector = baseSelector;
            }
          } else if (selectorObj.base && selectorObj.base.startsWith('badges-')) {
            // Special handling for badge selectors
            if (selectorObj.groupId) {
              const group = this.data.groups.find(g =>
                g.id === selectorObj.groupId ||
                g.uuid === selectorObj.groupId ||
                g.id === parseInt(selectorObj.groupId)
              );
              if (group) {
                // For badge selectors, scope to specific group
                fullSelector = `.mb-group[data-uuid="${group.uuid}"] ${baseSelector}`;

                // If link-specific badge and link is selected
                if ((selectorObj.base === 'badges-link' || selectorObj.base === 'badges-link-keywords') && selectorObj.linkId) {
                  const link = group.links.find(l =>
                    l.id === selectorObj.linkId ||
                    l.uuid === selectorObj.linkId ||
                    l.id === parseInt(selectorObj.linkId)
                  );
                  if (link) {
                    const linkUuid = link.uuid || link.id;
                    fullSelector = `.mb-group[data-uuid="${group.uuid}"] .mb-link[data-uuid="${linkUuid}"] ${baseSelector}`;
                  }
                }
              }
            }
          } else if (selectorObj.base === 'keywords-hierarchical') {
            // Hierarchical keyword selector - scopes based on group/link selection
            if (selectorObj.keywordSlug) {
              // Specific keyword selected
              fullSelector = `.mb-keyword-kw-${selectorObj.keywordSlug}`;
            } else {
              // All keywords
              fullSelector = baseSelector;
            }

            // Apply hierarchical scoping
            if (selectorObj.groupId && selectorObj.linkId) {
              // Scope to specific link
              const group = this.data.groups.find(g =>
                g.id === selectorObj.groupId ||
                g.uuid === selectorObj.groupId ||
                g.id === parseInt(selectorObj.groupId)
              );
              if (group) {
                const link = group.links.find(l =>
                  l.id === selectorObj.linkId ||
                  l.uuid === selectorObj.linkId ||
                  l.id === parseInt(selectorObj.linkId)
                );
                if (link) {
                  const linkUuid = link.uuid || link.id;
                  fullSelector = `.mb-group[data-uuid="${group.uuid}"] .mb-link[data-uuid="${linkUuid}"] ${fullSelector}`;
                }
              }
            } else if (selectorObj.groupId) {
              // Scope to specific group
              const group = this.data.groups.find(g =>
                g.id === selectorObj.groupId ||
                g.uuid === selectorObj.groupId ||
                g.id === parseInt(selectorObj.groupId)
              );
              if (group) {
                fullSelector = `.mb-group[data-uuid="${group.uuid}"] ${fullSelector}`;
              }
            }
          } else if (selectorObj.base === 'keywords-in-group') {
            // Keywords within a specific group
            if (selectorObj.keywordSlug) {
              // Specific keyword in group
              fullSelector = `.mb-keyword-kw-${selectorObj.keywordSlug}`;
              if (selectorObj.groupId) {
                const group = this.data.groups.find(g =>
                  g.id === selectorObj.groupId ||
                  g.uuid === selectorObj.groupId ||
                  g.id === parseInt(selectorObj.groupId)
                );
                if (group) {
                  fullSelector = `.mb-group[data-uuid="${group.uuid}"] ${fullSelector}`;
                }
              }
            } else if (selectorObj.groupId) {
              // All keywords in group
              const group = this.data.groups.find(g =>
                g.id === selectorObj.groupId ||
                g.uuid === selectorObj.groupId ||
                g.id === parseInt(selectorObj.groupId)
              );
              if (group) {
                fullSelector = `.mb-group[data-uuid="${group.uuid}"] ${baseSelector}`;
              }
            } else {
              // All keywords in all groups
              fullSelector = baseSelector;
            }
          } else if (selectorObj.base === 'keywords-in-link') {
            // Keywords within a specific link
            if (selectorObj.keywordSlug) {
              // Specific keyword in link
              fullSelector = `.mb-keyword-kw-${selectorObj.keywordSlug}`;
              if (selectorObj.groupId && selectorObj.linkId) {
                const group = this.data.groups.find(g =>
                  g.id === selectorObj.groupId ||
                  g.uuid === selectorObj.groupId ||
                  g.id === parseInt(selectorObj.groupId)
                );
                if (group) {
                  const link = group.links.find(l =>
                    l.id === selectorObj.linkId ||
                    l.uuid === selectorObj.linkId ||
                    l.id === parseInt(selectorObj.linkId)
                  );
                  if (link) {
                    const linkUuid = link.uuid || link.id;
                    fullSelector = `.mb-group[data-uuid="${group.uuid}"] .mb-link[data-uuid="${linkUuid}"] ${fullSelector}`;
                  }
                }
              }
            } else if (selectorObj.groupId && selectorObj.linkId) {
              // All keywords in specific link
              const group = this.data.groups.find(g =>
                g.id === selectorObj.groupId ||
                g.uuid === selectorObj.groupId ||
                g.id === parseInt(selectorObj.groupId)
              );
              if (group) {
                const link = group.links.find(l =>
                  l.id === selectorObj.linkId ||
                  l.uuid === selectorObj.linkId ||
                  l.id === parseInt(selectorObj.linkId)
                );
                if (link) {
                  const linkUuid = link.uuid || link.id;
                  fullSelector = `.mb-group[data-uuid="${group.uuid}"] .mb-link[data-uuid="${linkUuid}"] ${baseSelector}`;
                }
              }
            }
          } else if (selectorObj.groupId && selectorObj.groupId !== null && selectorObj.groupId !== 'null') {
            // Regular group-specific selector
            const group = this.data.groups.find(g =>
              g.id === selectorObj.groupId ||
              g.uuid === selectorObj.groupId ||
              g.id === parseInt(selectorObj.groupId)
            );

            if (group) {
              const groupUuid = group.uuid;

              // If this rule targets the group element itself, don't append a descendant
              if (baseSelector === '.mb-group') {
                fullSelector = `.mb-group[data-uuid="${groupUuid}"]`;
              } else {
                fullSelector = `.mb-group[data-uuid="${groupUuid}"] ${baseSelector}`;
              }

              // Link-specific targeting
              if (selectorObj.linkId && selectorObj.linkId !== null && selectorObj.linkId !== 'null') {
                const link = group.links.find(l =>
                  l.id === selectorObj.linkId ||
                  l.uuid === selectorObj.linkId ||
                  l.id === parseInt(selectorObj.linkId)
                );
                if (link) {
                  const linkUuid = link.uuid || link.id;
                  const linkBase = `.mb-group[data-uuid="${groupUuid}"] .mb-link[data-uuid="${linkUuid}"]`;
                  if (baseSelector === '.mb-link') {
                    // Target the link element itself
                    fullSelector = linkBase;
                  } else if (baseSelector === '.mb-link:hover') {
                    // Hover state of the link element itself
                    fullSelector = `${linkBase}:hover`;
                  } else {
                    // Target child within the link (anchor/url/icon/etc.)
                    fullSelector = `${linkBase} ${baseSelector}`;
                  }
                }
              }
            }
          }

          if (this.selectorUsesDragOverState(selectorObj)) {
            fullSelector = this.appendDragOverToSelector(fullSelector);
          }
          if (this.selectorUsesHoverState(selectorObj)) {
            fullSelector = this.appendHoverToSelector(fullSelector);
          }

          return fullSelector;
        },

        generateFullCss() {
          let css = '';
          const declarationPattern = /^\s*([a-zA-Z_-][a-zA-Z0-9_-]*)\s*:\s*(.+?)\s*;?\s*$/;
          const splitImportant = (rawValue) => {
            const valueText = String(rawValue ?? '').trim();
            const hasInlineImportant = /\s*!important\s*$/i.test(valueText);
            const cleanValue = valueText.replace(/\s*!important\s*$/i, '').trim();
            return { cleanValue, hasInlineImportant };
          };
          const appendDeclaration = (target, rawProperty, rawValue, options = {}) => {
            const propertyName = String(rawProperty ?? '').trim();
            if (!propertyName) return;
            const { cleanValue, hasInlineImportant } = splitImportant(rawValue);
            if (!cleanValue) return;
            const useImportant = !!(options.forceImportant || options.explicitImportant || hasInlineImportant);
            target.push(`  ${propertyName}: ${cleanValue}${useImportant ? ' !important' : ''};`);
          };
          const appendDeclarationLine = (target, line, options = {}) => {
            const match = String(line || '').match(declarationPattern);
            if (!match) return;
            appendDeclaration(target, match[1], match[2], options);
          };
          const forceUserRuleImportant = !!this.selectedVisualTemplate;

          // Inject design tokens as CSS variables on :root
          if (this.designTokens && this.designTokens.length > 0) {
            css += ':root{\n';
            for (const t of this.designTokens) {
              if (!t || !t.name) continue;
              const name = this.normalizeTokenName(String(t.name));
              const value = (t.value ?? '').toString().trim();
              if (!name || !value) continue;
              css += `  --${name}: ${value};\n`;
            }
            css += '}\n\n';
          }

          // First, generate CSS from the selected template (base layer)
          if (this.selectedVisualTemplate) {
            const templateRules = this.getCurrentTemplate();
            css += '/* Template: ' + this.selectedVisualTemplate + ' */\n';

            for (const rule of templateRules) {
              if (!rule.enabled || !rule.selector) continue;

              const selector = this.generateCssSelector(rule);
              if (!selector || !String(selector).trim()) continue;
              const properties = [];

              for (const [prop, value] of Object.entries(rule.properties)) {
                appendDeclaration(properties, prop, value);
              }

              if (properties.length > 0) {
                css += `${selector} {\n${properties.join('\n')}\n}\n`;
              }
            }
          }

          // Then, generate CSS from user rules (override layer)
          if (this.visualCssRules.length > 0) {
            css += '\n/* User Rules (Override Template) */\n';

            for (const rule of this.visualCssRules) {
              if (!rule.enabled || !rule.selector) continue;
              const selObj = this.getRuleSelector(rule);
              // Skip rules without a selected element ("-- Element wählen --")
              if (!selObj.base) continue;

              const selector = this.generateCssSelector(rule);
              if (!selector || !String(selector).trim()) continue;
              const properties = [];
              let mirrorLinkAnchorColor = null;
              let hasBackgroundColorOverride = false;
              let hasExplicitBackgroundImage = false;
              const trackBackgroundIntent = (rawProperty, rawValue) => {
                const normalizedProperty = this.normalizeCssPropertyName(rawProperty);
                if (!normalizedProperty) return;
                const { cleanValue } = splitImportant(rawValue);
                if (!cleanValue) return;
                if (normalizedProperty === 'background-color') {
                  hasBackgroundColorOverride = true;
                } else if (normalizedProperty === 'background-image') {
                  hasExplicitBackgroundImage = true;
                }
              };

              for (const [prop, value] of Object.entries(rule.properties)) {
                if (!value) continue;
                const normalizedProp = this.normalizeCssPropertyName(prop);
                if (rule.disabled && (rule.disabled[prop] || (normalizedProp && rule.disabled[normalizedProp]))) continue;
                if (prop === 'custom') {
                  // Treat as inline properties inside this selector (one per line)
                  const customLines = String(value).split('\n').filter(line => line.trim());
                  for (const line of customLines) {
                    const customMatch = String(line || '').match(declarationPattern);
                    if (customMatch) {
                      trackBackgroundIntent(customMatch[1], customMatch[2]);
                    }
                    appendDeclarationLine(properties, line, { forceImportant: forceUserRuleImportant });
                  }
                } else {
                  trackBackgroundIntent(normalizedProp || prop, value);
                  const explicitImportant = !!(rule.important && (rule.important[prop] || (normalizedProp && rule.important[normalizedProp])));
                  appendDeclaration(properties, prop, value, {
                    forceImportant: forceUserRuleImportant,
                    explicitImportant
                  });
                  if (normalizedProp === 'color') {
                    mirrorLinkAnchorColor = {
                      value,
                      explicitImportant
                    };
                  }
                }
              }

              // Add custom CSS properties if present (legacy support)
              if (rule.customCss) {
                const customLines = rule.customCss.split('\n').filter(line => line.trim());
                for (const line of customLines) {
                  const customMatch = String(line || '').match(declarationPattern);
                  if (customMatch) {
                    trackBackgroundIntent(customMatch[1], customMatch[2]);
                  }
                  appendDeclarationLine(properties, line, { forceImportant: forceUserRuleImportant });
                }
              }

              // Dark template commonly sets gradient backgrounds via `background`.
              // If user sets only background-color, clear inherited background images so color is visible.
              if (this.selectedVisualTemplate && hasBackgroundColorOverride && !hasExplicitBackgroundImage) {
                appendDeclaration(properties, 'background-image', 'none', { forceImportant: forceUserRuleImportant });
              }

              if (properties.length > 0) {
                css += `${selector} {\n${properties.join('\n')}\n}\n`;
              }
              if ((selObj.base === 'links' || selObj.base === 'link-hover') && mirrorLinkAnchorColor) {
                const anchorProperties = [];
                appendDeclaration(anchorProperties, 'color', mirrorLinkAnchorColor.value, {
                  forceImportant: forceUserRuleImportant,
                  explicitImportant: mirrorLinkAnchorColor.explicitImportant
                });
                if (anchorProperties.length > 0) {
                  css += `${selector} .mb-link__anchor {\n${anchorProperties.join('\n')}\n}\n`;
                }
              }
            }
          }

          return css;
        },

        saveVisualCss() {
          this.normalizeAllVisualRules();
          debugLog('log', 'Saving Visual CSS Rules:', JSON.stringify(this.visualCssRules));
          debugLog('log', 'Selected Template:', this.selectedVisualTemplate);

          // Keep localStorage and exportable options in sync
          this.syncVisualCssStateToOptions(false);
          this.syncVisualCssStateToLocalStorage();

          // Generate and apply CSS live
          this.applyVisualCss();
        },

        applyVisualCss() {
          const css = this.generateFullCss();
          this.applyCustomCss(css);

          // Also save to data.options for persistence
          if (!this.data.options) {
            this.data.options = {};
          }
          this.syncVisualCssStateToOptions(false);
          this.data.options.visualCssRules = this.visualCssRules;
          this.data.options.customCss = css; // Keep for backwards compatibility
          this.syncVisualCssStateToLocalStorage();
          this.saveData();
        },

        // Persist/restore Design Tokens collapsed state
        toggleDesignTokensCollapse() {
          this.designTokensCollapsed = !this.designTokensCollapsed;
          this.saveDesignTokensCollapsed();
        },
        saveDesignTokensCollapsed() {
          this.syncVisualCssStateToOptions(true);
          try { localStorage.setItem('designTokensCollapsed', this.designTokensCollapsed ? '1' : '0'); } catch {}
        },
        loadDesignTokensCollapsed() {
          const visualCssOptions = this.ensureVisualCssOptions();
          const optionStateVersion = parseInt(visualCssOptions.stateVersion, 10);
          const hasPersistedVisualCssState = Number.isFinite(optionStateVersion) && optionStateVersion >= 1;

          if (hasPersistedVisualCssState) {
            this.designTokensCollapsed = !!visualCssOptions.designTokensCollapsed;
          } else {
            try {
              const v = localStorage.getItem('designTokensCollapsed');
              this.designTokensCollapsed = v === '1';
            } catch {
              this.designTokensCollapsed = false;
            }
          }
          this.syncVisualCssStateToOptions(this.dataLoaded === true);
          this.syncVisualCssStateToLocalStorage();
        },

        // Persist/restore collapsed state of rule cards
        saveCollapsedRules() {
          this.syncVisualCssStateToOptions(true);
          try {
            localStorage.setItem('visualCssCollapsedRules', JSON.stringify(this.collapsedRules || []));
          } catch (e) { /* ignore */ }
        },
        loadCollapsedRules() {
          const visualCssOptions = this.ensureVisualCssOptions();
          const optionStateVersion = parseInt(visualCssOptions.stateVersion, 10);
          const hasPersistedVisualCssState = Number.isFinite(optionStateVersion) && optionStateVersion >= 1;

          if (hasPersistedVisualCssState && Array.isArray(visualCssOptions.collapsedRules)) {
            this.collapsedRules = JSON.parse(JSON.stringify(visualCssOptions.collapsedRules));
          } else {
            try {
              const stored = localStorage.getItem('visualCssCollapsedRules');
              const arr = stored ? JSON.parse(stored) : [];
              if (Array.isArray(arr)) this.collapsedRules = arr;
            } catch (e) {
              this.collapsedRules = [];
            }
          }
          this.syncVisualCssStateToOptions(this.dataLoaded === true);
          this.syncVisualCssStateToLocalStorage();
        },

        copyCssToClipboard() {
          const css = this.generateFullCss();
          navigator.clipboard.writeText(css).then(() => {
            alert('CSS wurde in die Zwischenablage kopiert!');
          }).catch(err => {
            debugLog('error', 'Failed to copy CSS:', err);
            alert('Fehler beim Kopieren des CSS');
          });
        },

        // Element Picker
        startElementPicker(rule) {
          if (this.elementPickerActive && this.currentPickerRule && this.currentPickerRule.id === rule.id) {
            return this.stopElementPicker();
          }
          this.currentPickerRule = rule;
          this.elementPickerActive = true;
          document.addEventListener('mouseover', this.onPickerMouseOver, true);
          document.addEventListener('mouseout', this.onPickerMouseOut, true);
          document.addEventListener('click', this.onPickerClick, true);
          this.showToast(this.getTranslation('css.visual.pickerActive') || 'Element-Picker aktiv: Klicke ein Element im Inhalt (Shift+Klick = Link Hover)', 'info');
        },
        stopElementPicker() {
          this.elementPickerActive = false;
          this.currentPickerRule = null;
          document.removeEventListener('mouseover', this.onPickerMouseOver, true);
          document.removeEventListener('mouseout', this.onPickerMouseOut, true);
          document.removeEventListener('click', this.onPickerClick, true);
          this.clearPickerHighlight();
        },
        onPickerMouseOver(e) {
          if (!this.elementPickerActive) return;
          const t = e.target;
          if (t.closest('.mb-css-sidebar')) return; // ignore sidebar
          this.highlightElement(t);
        },
        onPickerMouseOut(e) {
          if (!this.elementPickerActive) return;
          // optional: keep highlight on current element
        },
        onPickerClick(e) {
          if (!this.elementPickerActive) return;
          const t = e.target;
          if (t.closest('.mb-css-sidebar')) return;
          e.preventDefault();
          e.stopPropagation();
          try {
            const base = this.detectBaseForElement(t, e);
            const pickedRule = this.currentPickerRule;
            if (base && pickedRule) {
              // Update base
              // Pass a flag to avoid auto-adding template properties when picking
              const evt = { target: { value: base }, fromPicker: true };
              this.updateRuleBase(pickedRule, evt);
              // Ensure dropdown reflects pick
              this.$nextTick(() => {
                if (!pickedRule) return;
                const refKey = 'baseSelector-' + pickedRule.id;
                const el = this.$refs[refKey];
                if (el) {
                  if (Array.isArray(el) && el[0]) el[0].value = base;
                  else el.value = base;
                }
              });
              // Optionally detect group/link IDs
              const groupEl = t.closest('.mb-group');
              if (groupEl && groupEl.dataset && groupEl.dataset.uuid) {
                const gevt = { target: { value: groupEl.dataset.uuid } };
                this.updateRuleGroupId(pickedRule, gevt);
              }
              const linkEl = t.closest('.mb-link');
              if (linkEl && linkEl.dataset && linkEl.dataset.uuid) {
                const levt = { target: { value: linkEl.dataset.uuid } };
                this.updateRuleLinkId(pickedRule, levt);
              }
              // Auto-fill keyword slug when picking keyword-specific selectors
              if (base === 'keyword-by-name' || base === 'keywords-hierarchical') {
                const slug = this.detectKeywordSlugForElement(t);
                if (slug) {
                  const kevt = { target: { value: slug } };
                  this.updateRuleKeywordSlug(pickedRule, kevt);
                }
              }
              this.showToast((this.getTranslation('css.visual.picked') || 'Ausgewählt') + ': ' + base, 'success');
            }
          } finally {
            this.stopElementPicker();
          }
        },
        highlightElement(el) {
          this.clearPickerHighlight();
          this.lastHighlightedEl = el;
          this.lastHighlightedOutline = el.style.outline;
          el.style.outline = '2px solid #0d6efd';
          el.style.outlineOffset = '2px';
        },
        clearPickerHighlight() {
          if (this.lastHighlightedEl) {
            this.lastHighlightedEl.style.outline = this.lastHighlightedOutline || '';
            this.lastHighlightedEl.style.outlineOffset = '';
            this.lastHighlightedEl = null;
            this.lastHighlightedOutline = null;
          }
        },
        detectKeywordSlugForElement(el) {
          if (!el || typeof el.closest !== 'function') return '';
          const keywordEl = el.closest('[data-keyword], [class*="mb-keyword-kw-"]');
          if (!keywordEl) return '';

          const datasetKeyword = String(keywordEl?.dataset?.keyword || '').trim();
          if (datasetKeyword) return this.keywordSlug(datasetKeyword);

          const className = String(keywordEl.className || '');
          const classMatch = className.match(/\bmb-keyword-kw-([a-z0-9_-]+)\b/i);
          if (classMatch && classMatch[1]) return this.keywordSlug(classMatch[1]);

          const labelEl = keywordEl.querySelector('.mb-keyword-text');
          const textFallback = String((labelEl && labelEl.textContent) || keywordEl.textContent || '').trim();
          if (!textFallback) return '';
          return this.keywordSlug(textFallback);
        },
        detectBaseForElement(el, event = null) {
          if (event && event.shiftKey && el.closest('.mb-link')) {
            return 'link-hover';
          }
          // Check most specific targets first; body last
          const candidates = [
            { base: 'link-popover-favicon', sel: '.link-detail-popover__favicon' },
            { base: 'link-popover-badge', sel: '.link-detail-popover__badge' },
            { base: 'link-popover-keywords', sel: '.link-detail-popover__keywords' },
            { base: 'link-popover-value-muted', sel: '.link-detail-popover__value--muted' },
            { base: 'link-popover-value', sel: '.link-detail-popover__value' },
            { base: 'link-popover-label', sel: '.link-detail-popover__label' },
            { base: 'link-popover-row', sel: '.link-detail-popover__row' },
            { base: 'link-popover-meta', sel: '.link-detail-popover__meta' },
            { base: 'link-popover-url', sel: '.link-detail-popover__url' },
            { base: 'link-popover-title', sel: '.link-detail-popover__title' },
            { base: 'link-popover', sel: '.link-detail-popover' },
            { base: 'link-vertical-dropzone', sel: '.linkVerticalDropZone' },
            { base: 'link-horizontal-dropzone', sel: '.linkContainerDragAndDrop, .link-drop-zone' },
            { base: 'vertical-dropzone', sel: '.verticalDropZone' },
            { base: 'group-horizontal-dropzone', sel: '.groupContainerDragAndDrop, .group-drop-zone' },
            { base: 'keyword-selected-text', sel: '.mb-keywords-cloud .mb-keyword.mb-keyword-active .mb-keyword-text' },
            { base: 'keywords-selected', sel: '.mb-keywords-cloud .mb-keyword.mb-keyword-active' },
            { base: 'keyword-by-name', sel: '.mb-keywords-cloud .mb-keyword[class*="mb-keyword-kw-"]' },
            { base: 'keyword-suggestion-item', sel: '.mb-keyword-suggestion' },
            { base: 'keyword-suggestions', sel: '.mb-keyword-suggestions, .mb-keyword-suggestions--overlay' },
            { base: 'keywords-hierarchical', sel: '.keyword-badge' },
            { base: 'context-menu-item', sel: '.mb-context-menu-list > li' },
            { base: 'context-menu', sel: '.mb-context-menu' },
            { base: 'dropdown-item', sel: '.dropdown-item' },
            { base: 'dropdown-menu', sel: '.dropdown-menu' },
            { base: 'form-check-input', sel: '.form-check-input' },
            { base: 'input-group-text', sel: '.input-group-text' },
            { base: 'form-select', sel: '.form-select' },
            { base: 'form-control', sel: '.form-control' },
            { base: 'table-header', sel: '.table thead th' },
            { base: 'table-cell', sel: '.table tbody td' },
            { base: 'table', sel: '.table' },
            { base: 'list-group-item', sel: '.list-group-item' },
            { base: 'card-header', sel: '.card-header' },
            { base: 'card', sel: '.card' },
            { base: 'alert-warning', sel: '.alert-warning' },
            { base: 'alert-info', sel: '.alert-info' },
            { base: 'surface-panel', sel: '.mb-surface-panel' },
            { base: 'muted-text', sel: '.text-muted' },
            { base: 'sidebar-divider', sel: '.sidebar-divider' },
            { base: 'sidebar-bottom-section', sel: '.sidebar-bottom-section' },
            { base: 'sidebar-top-section', sel: '.sidebar-top-section' },
            { base: 'sidebar-header', sel: '.sidebar-header' },
            { base: 'feature-sidebar', sel: '.feature-sidebar' },
            { base: 'css-sidebar', sel: '.css-sidebar' },
            { base: 'modal-header', sel: '.modal-header' },
            { base: 'modal-body', sel: '.modal-body' },
            { base: 'modal-footer', sel: '.modal-footer' },
            { base: 'modal', sel: '.modal-content' },
            { base: 'link-anchor', sel: '.mb-link__anchor' },
            { base: 'link-url', sel: '.link-url-preview, .mb-link__url' },
            { base: 'link-icon', sel: '.mb-link__icon' },
            { base: 'separators', sel: '.mb-link-separator, .mb-link-separator-row' },
            { base: 'notes', sel: '.mb-link-note, .mb-link-note-row' },
            { base: 'links', sel: '.mb-link' },
            { base: 'group-title', sel: '.mb-group__title' },
            { base: 'group-header', sel: '.mb-group__header' },
            { base: 'group-body', sel: '.mb-group__body' },
            { base: 'groups', sel: '.mb-group' },
            { base: 'groups-links-container', sel: '.mb-groups-links-container, .mainContainer' },
            { base: 'toolbar', sel: '.mb-toolbar' },
            { base: 'header', sel: '.mb-titlebar' },
            { base: 'footer', sel: '.mb-footer' },
            { base: 'app', sel: '#app, .mb-app' },
            { base: 'keywords', sel: '.mb-keyword' },
            { base: 'body', sel: 'body' }
          ];
          for (const c of candidates) {
            if (el.closest(c.sel)) return c.base;
          }
          return '';
        },

        

        exportVisualCssRules() {
          const dataStr = JSON.stringify(this.visualCssRules, null, 2);
          const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

          const exportName = 'visual-css-rules-' + new Date().toISOString().slice(0, 10) + '.json';

          const linkElement = document.createElement('a');
          linkElement.setAttribute('href', dataUri);
          linkElement.setAttribute('download', exportName);
          linkElement.click();
        },

        importVisualCssRules(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const rules = JSON.parse(e.target.result);
              if (Array.isArray(rules)) {
                this.visualCssRules = rules.map((rule) => this.normalizeVisualRule(JSON.parse(JSON.stringify(rule))));
                this.saveVisualCss();
                alert('CSS rules imported successfully!');
              } else {
                alert('Invalid rules file format');
              }
            } catch (err) {
              alert('Failed to import rules: ' + err.message);
            }
          };
          reader.readAsText(file);
        },

        // Helper methods for Visual CSS Editor
        canSelectGroup(rule) {
          // Get the selector object
          const selector = this.getRuleSelector(rule);

          // Can select group if base selector supports groups
          const groupSupportingSelectors = [
            'groups', 'group-header', 'group-title', 'group-body',
            'links', 'separators', 'notes', 'link-hover', 'link-anchor', 'link-url', 'link-icon',
            'link-vertical-dropzone', 'link-horizontal-dropzone',
            'link-popover', 'link-popover-title', 'link-popover-url', 'link-popover-meta',
            'link-popover-row', 'link-popover-label', 'link-popover-value', 'link-popover-value-muted',
            'link-popover-keywords', 'link-popover-badge', 'link-popover-favicon',
            'badges-group', 'badges-group-linkcount', 'badges-group-keywords',
            'badges-link', 'badges-link-keywords',
            'keywords-hierarchical'  // New hierarchical keyword selector
            // keyword-by-name removed - no group selection needed
          ];

          // Don't show group selector for global selectors
          const canSelect = groupSupportingSelectors.includes(selector.base);

          debugLog('log', 'canSelectGroup:', {
            base: selector.base,
            canSelect: canSelect,
            supportingSelectors: groupSupportingSelectors
          });

          return canSelect;
        },

        canSelectLink(rule) {
          // Get the selector object
          const selector = this.getRuleSelector(rule);

          // Can select link if:
          // 1. A group is selected AND the base selector supports link selection
          const linkSupportingSelectors = [
            'links', 'separators', 'notes', 'link-hover', 'link-anchor', 'link-url', 'link-icon',
            'link-popover', 'link-popover-title', 'link-popover-url', 'link-popover-meta',
            'link-popover-row', 'link-popover-label', 'link-popover-value', 'link-popover-value-muted',
            'link-popover-keywords', 'link-popover-badge', 'link-popover-favicon',
            'badges-link', 'badges-link-keywords',
            'keywords-hierarchical'  // Can optionally select link for more specific targeting
          ];

          return selector.groupId && linkSupportingSelectors.includes(selector.base);
        },

        getLinksForRule(rule) {
          const selector = this.getRuleSelector(rule);
          if (!selector.groupId) return [];

          // Find group by id or uuid
          const group = this.data.groups.find(g =>
            g.id === selector.groupId ||
            g.uuid === selector.groupId
          );

          const links = group ? group.links.filter(l => !l.deleted) : [];
          if (selector.base === 'separators') {
            return links.filter((link) => this.isSeparatorLink(link));
          }
          if (selector.base === 'notes') {
            return links.filter((link) => this.isNoteLink(link));
          }
          if (selector.base === 'links') {
            return links.filter((link) => !this.isSeparatorLink(link) && !this.isNoteLink(link));
          }
          return links;
        },
        getCssRuleLinkLabel(link) {
          if (!link || typeof link !== 'object') return '';
          const isSeparator = !!(this.isSeparatorLink && this.isSeparatorLink(link));
          const isNote = !!(this.isNoteLink && this.isNoteLink(link));
          const text = String(link.text || '').trim();
          if (isSeparator) {
            const idLabel = String(link.uuid || link.id || '').trim();
            const baseLabel = text || idLabel || (this.getTranslation('link.separator.defaultLabel') || 'Separator');
            return baseLabel;
          }
          if (isNote) {
            const idLabel = String(link.uuid || link.id || '').trim();
            const baseLabel = text || idLabel || (this.getTranslation('link.note.defaultLabel') || 'Note');
            return baseLabel;
          }
          const effectiveText = (typeof this.getEffectiveLinkText === 'function')
            ? String(this.getEffectiveLinkText(link) || '').trim()
            : '';
          if (effectiveText) return effectiveText;
          if (text) return text;
          const effectiveUrl = (typeof this.getEffectiveLinkUrl === 'function')
            ? String(this.getEffectiveLinkUrl(link) || '').trim()
            : '';
          if (effectiveUrl) return effectiveUrl;
          const url = String(link.url || '').trim();
          if (url) return url;
          return String(link.uuid || link.id || '').trim();
        },

        getSelectorInfo(selectorValue) {
          return this.visualCssAvailableSelectors.find(s => s.value === selectorValue) || {};
        },

        normalizeCssPropertyName(property) {
          if (property === undefined || property === null) return '';
          let normalized = String(property).trim();
          if (!normalized) return '';
          if (normalized.toLowerCase() === 'custom') return 'custom';
          normalized = normalized.replace(/\s*!important\s*$/i, '').trim();
          // Preserve CSS variables as-is (lowercased for consistency)
          if (normalized.startsWith('--')) {
            normalized = normalized.toLowerCase().replace(/[:;]+$/g, '');
            normalized = normalized.replace(/[^a-z0-9_-]/g, '');
            return normalized;
          }
          normalized = normalized.replace(/[:;]+$/g, '');
          // Convert camelCase and spaced keys to kebab-case
          normalized = normalized
            .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
            .replace(/[_\s]+/g, '-')
            .replace(/-+/g, '-')
            .replace(/^-|-$/g, '')
            .toLowerCase();
          normalized = normalized.replace(/[^a-z0-9-]/g, '');
          normalized = normalized.replace(/-+/g, '-').replace(/^-|-$/g, '');
          return normalized;
        },

        normalizeCssPropertyAlias(property) {
          const normalized = this.normalizeCssPropertyName(property);
          if (!normalized) return '';
          if (normalized.startsWith('--')) return normalized;
          return normalized.replace(/-/g, '');
        },

        findEquivalentPropertyKey(properties, property) {
          if (!properties || typeof properties !== 'object') return '';
          const target = this.normalizeCssPropertyName(property);
          if (!target) return '';
          const targetAlias = this.normalizeCssPropertyAlias(target);
          for (const key of Object.keys(properties)) {
            const normalizedKey = this.normalizeCssPropertyName(key);
            if (normalizedKey === target) return key;
            const aliasKey = this.normalizeCssPropertyAlias(normalizedKey);
            if (targetAlias && aliasKey && aliasKey === targetAlias) return key;
          }
          return '';
        },

        areObjectsShallowEqual(a, b) {
          const objA = (a && typeof a === 'object') ? a : {};
          const objB = (b && typeof b === 'object') ? b : {};
          const keysA = Object.keys(objA);
          const keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (const key of keysA) {
            if (!Object.prototype.hasOwnProperty.call(objB, key)) return false;
            if (objA[key] !== objB[key]) return false;
          }
          return true;
        },

        normalizeRuleProperties(rule) {
          if (!rule || typeof rule !== 'object') return;

          const srcProps = (rule.properties && typeof rule.properties === 'object' && !Array.isArray(rule.properties))
            ? rule.properties
            : {};
          const srcImportant = (rule.important && typeof rule.important === 'object' && !Array.isArray(rule.important))
            ? rule.important
            : {};
          const srcDisabled = (rule.disabled && typeof rule.disabled === 'object' && !Array.isArray(rule.disabled))
            ? rule.disabled
            : {};

          const nextProps = {};
          const nextImportant = {};
          const nextDisabled = {};
          const aliasToCanonical = {};

          for (const rawKey of Object.keys(srcProps)) {
            const normalizedKey = this.normalizeCssPropertyName(rawKey);
            if (!normalizedKey) continue;
            const aliasKey = this.normalizeCssPropertyAlias(normalizedKey) || normalizedKey;
            const value = srcProps[rawKey];
            let canonicalKey = aliasToCanonical[aliasKey];

            if (!canonicalKey) {
              canonicalKey = normalizedKey;
              aliasToCanonical[aliasKey] = canonicalKey;
            } else if (canonicalKey !== normalizedKey) {
              const canonicalHasHyphen = canonicalKey.includes('-');
              const candidateHasHyphen = normalizedKey.includes('-');
              if (!canonicalHasHyphen && candidateHasHyphen) {
                const previousCanonical = canonicalKey;
                canonicalKey = normalizedKey;
                aliasToCanonical[aliasKey] = canonicalKey;
                if (Object.prototype.hasOwnProperty.call(nextProps, previousCanonical)
                    && !Object.prototype.hasOwnProperty.call(nextProps, canonicalKey)) {
                  nextProps[canonicalKey] = nextProps[previousCanonical];
                }
                delete nextProps[previousCanonical];
              }
            }

            if (!Object.prototype.hasOwnProperty.call(nextProps, canonicalKey)) {
              nextProps[canonicalKey] = value;
            } else {
              const currentValue = nextProps[canonicalKey];
              const currentEmpty = currentValue === '' || currentValue === null || currentValue === undefined;
              const newEmpty = value === '' || value === null || value === undefined;
              if (currentEmpty && !newEmpty) nextProps[canonicalKey] = value;
            }
          }

          for (const rawKey of Object.keys(srcImportant)) {
            const normalizedKey = this.normalizeCssPropertyName(rawKey);
            const aliasKey = this.normalizeCssPropertyAlias(normalizedKey) || normalizedKey;
            const canonicalKey = aliasToCanonical[aliasKey] || normalizedKey;
            if (!normalizedKey || !Object.prototype.hasOwnProperty.call(nextProps, canonicalKey)) continue;
            const boolVal = !!srcImportant[rawKey];
            if (!Object.prototype.hasOwnProperty.call(nextImportant, canonicalKey)) {
              nextImportant[canonicalKey] = boolVal;
            } else {
              nextImportant[canonicalKey] = nextImportant[canonicalKey] || boolVal;
            }
          }

          for (const rawKey of Object.keys(srcDisabled)) {
            const normalizedKey = this.normalizeCssPropertyName(rawKey);
            const aliasKey = this.normalizeCssPropertyAlias(normalizedKey) || normalizedKey;
            const canonicalKey = aliasToCanonical[aliasKey] || normalizedKey;
            if (!normalizedKey || !Object.prototype.hasOwnProperty.call(nextProps, canonicalKey)) continue;
            const boolVal = !!srcDisabled[rawKey];
            if (!Object.prototype.hasOwnProperty.call(nextDisabled, canonicalKey)) {
              nextDisabled[canonicalKey] = boolVal;
            } else {
              nextDisabled[canonicalKey] = nextDisabled[canonicalKey] || boolVal;
            }
          }

          const propsChanged = !this.areObjectsShallowEqual(srcProps, nextProps);
          const importantChanged = !this.areObjectsShallowEqual(srcImportant, nextImportant);
          const disabledChanged = !this.areObjectsShallowEqual(srcDisabled, nextDisabled);

          if (!propsChanged && !importantChanged && !disabledChanged) {
            return false;
          }

          if (this.$set) {
            this.$set(rule, 'properties', nextProps);
            this.$set(rule, 'important', nextImportant);
            this.$set(rule, 'disabled', nextDisabled);
          } else {
            rule.properties = nextProps;
            rule.important = nextImportant;
            rule.disabled = nextDisabled;
          }
          return true;
        },

        normalizeVisualRule(rule) {
          if (!rule || typeof rule !== 'object') return rule;

          if (typeof rule.selector === 'string') {
            rule.selector = {
              base: rule.selector,
              groupId: rule.groupId || null,
              linkId: rule.linkId || null,
              keywordSlug: null,
              hover: false,
              dragOver: false
            };
          }
          if (!rule.selector || typeof rule.selector !== 'object') {
            rule.selector = {
              base: '',
              groupId: null,
              linkId: null,
              keywordSlug: null,
              hover: false,
              dragOver: false
            };
          }
          if (!Object.prototype.hasOwnProperty.call(rule.selector, 'keywordSlug')) {
            rule.selector.keywordSlug = null;
          }
          if (!Object.prototype.hasOwnProperty.call(rule.selector, 'hover')) {
            rule.selector.hover = false;
          }
          if (!Object.prototype.hasOwnProperty.call(rule.selector, 'dragOver')) {
            rule.selector.dragOver = false;
          }
          if (rule.selector.base === 'link-hover' && rule.selector.hover) {
            rule.selector.hover = false;
          }

          this.normalizeRuleProperties(rule);
          return rule;
        },

        normalizeAllVisualRules() {
          if (!Array.isArray(this.visualCssRules)) return;
          const seenRuleIds = new Set();
          this.visualCssRules.forEach((rule) => {
            this.normalizeVisualRule(rule);
            if (!rule || typeof rule !== 'object') return;

            let ruleId = rule.id;
            if (ruleId === undefined || ruleId === null || ruleId === '') {
              rule.id = this.nextVisualRuleId();
              ruleId = rule.id;
            }

            while (seenRuleIds.has(String(ruleId))) {
              rule.id = this.nextVisualRuleId();
              ruleId = rule.id;
            }
            seenRuleIds.add(String(ruleId));
          });
        },

        formatPropertyName(property) {
          // Convert CSS property names to readable format
          const normalizedProperty = this.normalizeCssPropertyName(property);
          const propertyMap = {
            'custom': 'Custom CSS',
            'background': 'Background',
            'background-color': 'Background Color',
            'backgroundcolor': 'Background Color',
            'color': 'Text Color',
            'font-family': 'Font Family',
            'font-size': 'Font Size',
            'font-weight': 'Font Weight',
            'border': 'Border',
            'border-color': 'Border Color',
            'bordercolor': 'Border Color',
            'border-radius': 'Border Radius',
            'outline-color': 'Outline Color',
            'outlinecolor': 'Outline Color',
            'padding': 'Padding',
            'margin': 'Margin',
            'display': 'Display',
            'opacity': 'Opacity',
            'text-decoration': 'Text Decoration',
            'text-transform': 'Text Transform',
            'box-shadow': 'Box Shadow',
            'width': 'Width',
            'height': 'Height'
          };
          if (propertyMap[normalizedProperty]) return propertyMap[normalizedProperty];
          if (normalizedProperty.startsWith('--')) return normalizedProperty;
          return normalizedProperty.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        },

        getCssEnumOptions(enumType) {
          const map = {
            'border-style': ['none', 'solid', 'dashed', 'dotted', 'double', 'groove', 'ridge', 'inset', 'outset'],
            'outline-style': ['none', 'solid', 'dashed', 'dotted', 'double', 'groove', 'ridge', 'inset', 'outset'],
            'text-align': ['left', 'center', 'right', 'justify', 'start', 'end'],
            'text-decoration': ['none', 'underline', 'overline', 'line-through', 'underline overline'],
            'font-weight': ['100', '200', '300', '400', '500', '600', '700', '800', '900', 'normal', 'bold', 'bolder', 'lighter'],
            'display': ['block', 'inline', 'inline-block', 'flex', 'inline-flex', 'grid', 'inline-grid', 'none']
          };
          return map[enumType] || [];
        },

        getCssPropertySchema(property) {
          const normalized = this.normalizeCssPropertyName(property);
          if (!normalized || normalized === 'custom' || normalized.startsWith('--')) {
            return { kind: 'raw' };
          }

          if (normalized === 'font-family') {
            return { kind: 'font-family' };
          }

          if (normalized === 'font-weight') {
            return { kind: 'enum', options: this.getCssEnumOptions('font-weight') };
          }

          if (normalized === 'text-align') {
            return { kind: 'enum', options: this.getCssEnumOptions('text-align') };
          }

          if (normalized === 'text-decoration') {
            return { kind: 'enum', options: this.getCssEnumOptions('text-decoration') };
          }

          if (normalized === 'display') {
            return { kind: 'enum', options: this.getCssEnumOptions('display') };
          }

          if (normalized === 'opacity') {
            return { kind: 'number', min: 0, max: 1, step: 0.01 };
          }

          if (normalized === 'box-shadow') {
            return { kind: 'shadow' };
          }

          if (normalized === 'padding' || normalized === 'margin') {
            return {
              kind: 'spacing',
              units: normalized === 'margin'
                ? ['px', 'rem', 'em', '%', 'auto']
                : ['px', 'rem', 'em', '%']
            };
          }

          if (
            normalized === 'border'
            || normalized === 'outline'
            || /^border-(top|right|bottom|left)$/.test(normalized)
          ) {
            return { kind: 'border' };
          }

          if (
            normalized === 'font-size'
            || normalized === 'width'
            || normalized === 'height'
            || normalized === 'outline-width'
            || normalized === 'outline-offset'
            || normalized === 'border-width'
            || /^border-(top|right|bottom|left)-width$/.test(normalized)
            || normalized === 'border-radius'
            || /^border-(top|right|bottom|left)-(left|right)-radius$/.test(normalized)
          ) {
            const keywords = [];
            let units = ['px', 'rem', 'em'];
            if (normalized === 'width' || normalized === 'height') {
              keywords.push('auto', 'fit-content', 'min-content', 'max-content');
              units = ['px', 'rem', 'em', '%', 'vw', 'vh'];
            } else if (normalized === 'font-size') {
              units = ['px', 'rem', 'em', '%'];
            } else if (normalized.includes('radius')) {
              units = ['px', 'rem', 'em', '%'];
            }
            if (normalized.includes('width') && normalized.startsWith('border')) {
              keywords.push('thin', 'medium', 'thick');
            }
            return {
              kind: 'length',
              units,
              keywords
            };
          }

          if (
            normalized === 'border-style'
            || normalized === 'outline-style'
            || /^border-(top|right|bottom|left)-style$/.test(normalized)
          ) {
            return { kind: 'enum', options: this.getCssEnumOptions('border-style') };
          }

          if (this.isColorProperty(normalized) || normalized === 'background') {
            return { kind: 'color' };
          }

          return { kind: 'raw' };
        },

        isCssPropertyEditorTarget(rule, property) {
          if (!rule || !property) return false;
          const editorRuleId = this.cssPropertyEditor?.ruleId;
          const editorProperty = this.normalizeCssPropertyName(this.cssPropertyEditor?.property || '');
          if (!editorRuleId || !editorProperty) return false;
          return String(rule.id) === String(editorRuleId)
            && this.normalizeCssPropertyName(property) === editorProperty;
        },

        isCssPropertyEditorSectionExpanded(sectionKey) {
          return this.cssPropertyEditorExpandedSections[sectionKey] !== false;
        },

        toggleCssPropertyEditorSection(sectionKey) {
          this.$set(this.cssPropertyEditorExpandedSections, sectionKey, !this.isCssPropertyEditorSectionExpanded(sectionKey));
        },

        clearCssPropertyEditorSelection() {
          this.cssPropertyEditor = {
            ruleId: null,
            property: '',
            rawValue: '',
            useRawValue: false,
            important: false,
            model: {}
          };
        },

        openCssPropertyEditor(rule, property) {
          if (!rule || !property) return;
          const normalizedProperty = this.normalizeCssPropertyName(property);
          if (!normalizedProperty || normalizedProperty === 'custom') return;
          this.$set(this.cssPropertyEditor, 'ruleId', rule.id);
          this.$set(this.cssPropertyEditor, 'property', normalizedProperty);
          this.cssPropertyEditorExpandedSections = { basic: true, value: true, advanced: true };
          this.ensureCssPropertyEditorFonts();
          this.resetCssPropertyEditorDraft();
        },

        resetCssPropertyEditorDraft() {
          const rule = this.cssPropertyEditorRule;
          const property = this.normalizeCssPropertyName(this.cssPropertyEditor?.property || '');
          if (!rule || !property) return;
          const key = this.findEquivalentPropertyKey(rule.properties, property) || property;
          const rawValue = String(rule?.properties?.[key] ?? '');
          const schema = this.getCssPropertySchema(property);
          const parsed = this.parseCssPropertyEditorDraft(schema, rawValue);

          this.$set(this.cssPropertyEditor, 'rawValue', rawValue);
          this.$set(this.cssPropertyEditor, 'important', this.getPropertyImportant(rule, property));
          this.$set(this.cssPropertyEditor, 'model', parsed.model);
          this.$set(this.cssPropertyEditor, 'useRawValue', schema.kind === 'raw' || !parsed.success);
        },

        createDefaultCssPropertyEditorModel(schema) {
          const kind = schema?.kind || 'raw';
          if (kind === 'color') {
            return { color: '#000000', alpha: 1, tokenName: '' };
          }
          if (kind === 'font-family') {
            return { fontFamily: '', fontFamilyCustom: '' };
          }
          if (kind === 'enum') {
            return { enumValue: (schema.options || [])[0] || '' };
          }
          if (kind === 'number') {
            return { numberValue: Number.isFinite(schema.min) ? schema.min : 0 };
          }
          if (kind === 'length') {
            return { lengthValue: 0, lengthUnit: (schema.units || ['px'])[0], lengthKeyword: '' };
          }
          if (kind === 'spacing') {
            const unit = (schema.units || ['px'])[0];
            return {
              spacingLinked: true,
              spacing: {
                top: { value: 0, unit },
                right: { value: 0, unit },
                bottom: { value: 0, unit },
                left: { value: 0, unit }
              }
            };
          }
          if (kind === 'border') {
            return { border: { width: 1, unit: 'px', style: 'solid', color: '#000000', alpha: 1 } };
          }
          if (kind === 'shadow') {
            return {
              shadow: {
                offsetX: 0,
                offsetY: 2,
                blur: 8,
                spread: 0,
                color: '#000000',
                alpha: 0.25,
                inset: false
              }
            };
          }
          return {};
        },

        parseCssPropertyEditorDraft(schema, rawValue) {
          const kind = schema?.kind || 'raw';
          const raw = String(rawValue || '').trim();
          const model = this.createDefaultCssPropertyEditorModel(schema);
          if (!raw) return { success: true, model };

          if (kind === 'color') {
            const varMatch = raw.match(/^var\(\s*--([a-z0-9_-]+)\s*\)$/i);
            if (varMatch) {
              model.tokenName = this.normalizeTokenName(varMatch[1]);
              return { success: true, model };
            }
            const hex = this.getValidHexColor(raw);
            if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(raw)) {
              model.color = hex;
              model.alpha = 1;
              model.tokenName = '';
              return { success: true, model };
            }
            const rgbaMatch = raw.match(/^rgba?\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)(?:\s*,\s*([0-9.]+))?\s*\)$/i);
            if (rgbaMatch) {
              const r = Math.max(0, Math.min(255, parseFloat(rgbaMatch[1]) || 0));
              const g = Math.max(0, Math.min(255, parseFloat(rgbaMatch[2]) || 0));
              const b = Math.max(0, Math.min(255, parseFloat(rgbaMatch[3]) || 0));
              const a = rgbaMatch[4] !== undefined ? Math.max(0, Math.min(1, parseFloat(rgbaMatch[4]) || 0)) : 1;
              model.color = '#' + [r, g, b].map((n) => Math.round(n).toString(16).padStart(2, '0')).join('');
              model.alpha = a;
              model.tokenName = '';
              return { success: true, model };
            }
            return { success: false, model };
          }

          if (kind === 'font-family') {
            model.fontFamilyCustom = raw;
            model.fontFamily = raw;
            return { success: true, model };
          }

          if (kind === 'enum') {
            if ((schema.options || []).includes(raw)) {
              model.enumValue = raw;
              return { success: true, model };
            }
            return { success: false, model };
          }

          if (kind === 'number') {
            const parsed = parseFloat(raw);
            if (!Number.isFinite(parsed)) return { success: false, model };
            model.numberValue = parsed;
            return { success: true, model };
          }

          if (kind === 'length') {
            if ((schema.keywords || []).includes(raw)) {
              model.lengthKeyword = raw;
              return { success: true, model };
            }
            const m = raw.match(/^(-?\d*\.?\d+)([a-z%]+)?$/i);
            if (!m) return { success: false, model };
            model.lengthValue = parseFloat(m[1]);
            model.lengthUnit = m[2] || model.lengthUnit || 'px';
            model.lengthKeyword = '';
            return { success: true, model };
          }

          if (kind === 'spacing') {
            const tokens = raw.split(/\s+/).filter(Boolean);
            if (!tokens.length || tokens.length > 4) return { success: false, model };
            const expanded = [];
            if (tokens.length === 1) expanded.push(tokens[0], tokens[0], tokens[0], tokens[0]);
            if (tokens.length === 2) expanded.push(tokens[0], tokens[1], tokens[0], tokens[1]);
            if (tokens.length === 3) expanded.push(tokens[0], tokens[1], tokens[2], tokens[1]);
            if (tokens.length === 4) expanded.push(tokens[0], tokens[1], tokens[2], tokens[3]);
            const sides = ['top', 'right', 'bottom', 'left'];
            for (let i = 0; i < sides.length; i += 1) {
              const side = sides[i];
              const token = expanded[i];
              if (token === 'auto') {
                model.spacing[side] = { value: 0, unit: 'auto' };
                continue;
              }
              const parsed = token.match(/^(-?\d*\.?\d+)([a-z%]+)?$/i);
              if (!parsed) return { success: false, model };
              model.spacing[side] = {
                value: parseFloat(parsed[1]),
                unit: parsed[2] || model.spacing[side].unit || 'px'
              };
            }
            model.spacingLinked = sides.every((side) =>
              model.spacing[side].value === model.spacing.top.value && model.spacing[side].unit === model.spacing.top.unit
            );
            return { success: true, model };
          }

          if (kind === 'border') {
            const tokens = raw.split(/\s+/).filter(Boolean);
            if (!tokens.length) return { success: false, model };
            const styles = this.getCssEnumOptions('border-style');
            let widthToken = '';
            let styleToken = '';
            let colorToken = '';
            tokens.forEach((token) => {
              if (!styleToken && styles.includes(token)) {
                styleToken = token;
                return;
              }
              if (!widthToken && /^(-?\d*\.?\d+)([a-z%]+)?$/i.test(token)) {
                widthToken = token;
                return;
              }
              if (!widthToken && ['thin', 'medium', 'thick'].includes(token)) {
                widthToken = token;
                return;
              }
              colorToken += (colorToken ? ' ' : '') + token;
            });
            if (widthToken) {
              if (['thin', 'medium', 'thick'].includes(widthToken)) {
                const map = { thin: 1, medium: 3, thick: 5 };
                model.border.width = map[widthToken] || 1;
                model.border.unit = 'px';
              } else {
                const wm = widthToken.match(/^(-?\d*\.?\d+)([a-z%]+)?$/i);
                if (wm) {
                  model.border.width = parseFloat(wm[1]);
                  model.border.unit = wm[2] || 'px';
                }
              }
            }
            if (styleToken) model.border.style = styleToken;
            if (colorToken) {
              const hex = this.getValidHexColor(colorToken);
              const rgbaMatch = colorToken.match(/^rgba?\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)(?:\s*,\s*([0-9.]+))?\s*\)$/i);
              if (rgbaMatch) {
                const r = Math.max(0, Math.min(255, parseFloat(rgbaMatch[1]) || 0));
                const g = Math.max(0, Math.min(255, parseFloat(rgbaMatch[2]) || 0));
                const b = Math.max(0, Math.min(255, parseFloat(rgbaMatch[3]) || 0));
                model.border.color = '#' + [r, g, b].map((n) => Math.round(n).toString(16).padStart(2, '0')).join('');
                model.border.alpha = rgbaMatch[4] !== undefined ? Math.max(0, Math.min(1, parseFloat(rgbaMatch[4]) || 0)) : 1;
              } else if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(colorToken)) {
                model.border.color = hex;
                model.border.alpha = 1;
              } else {
                return { success: false, model };
              }
            }
            return { success: true, model };
          }

          if (kind === 'shadow') {
            const rawNoInset = raw.replace(/\binset\b/g, '').trim();
            const colorMatch = rawNoInset.match(/(rgba?\([^)]*\)|#[0-9a-fA-F]{3,8})\s*$/);
            let core = rawNoInset;
            if (colorMatch) {
              core = rawNoInset.slice(0, colorMatch.index).trim();
              const colorRaw = colorMatch[1];
              if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(colorRaw)) {
                model.shadow.color = this.getValidHexColor(colorRaw);
                model.shadow.alpha = 1;
              } else {
                const rgbaMatch = colorRaw.match(/^rgba?\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)(?:\s*,\s*([0-9.]+))?\s*\)$/i);
                if (rgbaMatch) {
                  const r = Math.max(0, Math.min(255, parseFloat(rgbaMatch[1]) || 0));
                  const g = Math.max(0, Math.min(255, parseFloat(rgbaMatch[2]) || 0));
                  const b = Math.max(0, Math.min(255, parseFloat(rgbaMatch[3]) || 0));
                  model.shadow.color = '#' + [r, g, b].map((n) => Math.round(n).toString(16).padStart(2, '0')).join('');
                  model.shadow.alpha = rgbaMatch[4] !== undefined ? Math.max(0, Math.min(1, parseFloat(rgbaMatch[4]) || 0)) : 1;
                }
              }
            }
            const parts = core.split(/\s+/).filter(Boolean);
            if (parts.length < 2) return { success: false, model };
            const num = (value) => {
              const m = String(value || '').match(/^(-?\d*\.?\d+)([a-z%]+)?$/i);
              return m ? parseFloat(m[1]) : null;
            };
            const x = num(parts[0]);
            const y = num(parts[1]);
            const blur = parts[2] !== undefined ? num(parts[2]) : 0;
            const spread = parts[3] !== undefined ? num(parts[3]) : 0;
            if (x === null || y === null || blur === null || spread === null) return { success: false, model };
            model.shadow.offsetX = x;
            model.shadow.offsetY = y;
            model.shadow.blur = blur;
            model.shadow.spread = spread;
            model.shadow.inset = /\binset\b/.test(raw);
            return { success: true, model };
          }

          return { success: false, model };
        },

        onCssPropertyEditorModelChange() {
          const nextValue = this.getCssPropertyEditorPreviewValue();
          this.$set(this.cssPropertyEditor, 'rawValue', nextValue);
          this.applyCssPropertyEditorDraft();
        },

        onCssPropertyEditorRawInput() {
          if (!this.cssPropertyEditor.useRawValue) this.cssPropertyEditor.useRawValue = true;
          this.applyCssPropertyEditorDraft();
        },

        onCssPropertyEditorRawModeToggle() {
          if (!this.cssPropertyEditor.useRawValue) {
            const property = this.normalizeCssPropertyName(this.cssPropertyEditor?.property || '');
            if (property) {
              const schema = this.getCssPropertySchema(property);
              const parsed = this.parseCssPropertyEditorDraft(schema, this.cssPropertyEditor.rawValue);
              if (parsed.success) {
                this.$set(this.cssPropertyEditor, 'model', parsed.model);
              } else {
                this.$set(this.cssPropertyEditor, 'useRawValue', true);
                this.showToast(this.getTranslation('css.visual.invalidCssValue') || 'Invalid CSS value', 'warning');
                return;
              }
            }
            this.onCssPropertyEditorModelChange();
            return;
          }
          this.applyCssPropertyEditorDraft();
        },

        onCssPropertyEditorImportantToggle() {
          this.applyCssPropertyEditorDraft();
        },

        onCssPropertyEditorColorInput(colorHex) {
          this.cssPropertyEditor.model.tokenName = '';
          this.cssPropertyEditor.model.color = colorHex;
          this.onCssPropertyEditorModelChange();
        },

        onCssPropertyEditorTokenChange() {
          if (this.cssPropertyEditor.model.tokenName) {
            this.cssPropertyEditor.model.alpha = 1;
          }
          this.onCssPropertyEditorModelChange();
        },

        onCssPropertyEditorBorderColorInput(colorHex) {
          this.cssPropertyEditor.model.border.color = colorHex;
          this.onCssPropertyEditorModelChange();
        },

        onCssPropertyEditorShadowColorInput(colorHex) {
          this.cssPropertyEditor.model.shadow.color = colorHex;
          this.onCssPropertyEditorModelChange();
        },

        onCssPropertyEditorSpacingLinked() {
          if (this.cssPropertyEditor.model.spacingLinked) {
            ['right', 'bottom', 'left'].forEach((side) => {
              this.cssPropertyEditor.model.spacing[side].value = this.cssPropertyEditor.model.spacing.top.value;
              this.cssPropertyEditor.model.spacing[side].unit = this.cssPropertyEditor.model.spacing.top.unit;
            });
          }
          this.onCssPropertyEditorModelChange();
        },

        onCssPropertyEditorSpacingInput(side) {
          if (this.cssPropertyEditor.model.spacingLinked && side === 'top') {
            ['right', 'bottom', 'left'].forEach((otherSide) => {
              this.cssPropertyEditor.model.spacing[otherSide].value = this.cssPropertyEditor.model.spacing.top.value;
              this.cssPropertyEditor.model.spacing[otherSide].unit = this.cssPropertyEditor.model.spacing.top.unit;
            });
          }
          this.onCssPropertyEditorModelChange();
        },

        getCssPropertyEditorPreviewValue() {
          const property = this.normalizeCssPropertyName(this.cssPropertyEditor?.property || '');
          if (!property) return '';
          if (this.cssPropertyEditor.useRawValue) return String(this.cssPropertyEditor.rawValue || '').trim();

          const schema = this.getCssPropertySchema(property);
          const model = this.cssPropertyEditor.model || {};
          if (schema.kind === 'color') {
            if (model.tokenName) return `var(--${this.normalizeTokenName(model.tokenName)})`;
            const hex = this.getValidHexColor(model.color || '#000000');
            const alpha = Number.isFinite(model.alpha) ? Math.max(0, Math.min(1, model.alpha)) : 1;
            if (alpha >= 0.999) return hex;
            const rgb = hex.replace('#', '');
            const r = parseInt(rgb.substring(0, 2), 16);
            const g = parseInt(rgb.substring(2, 4), 16);
            const b = parseInt(rgb.substring(4, 6), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha.toFixed(2).replace(/0+$/, '').replace(/\.$/, '')})`;
          }
          if (schema.kind === 'font-family') {
            const custom = String(model.fontFamilyCustom || '').trim();
            const selected = String(model.fontFamily || '').trim();
            const source = custom || selected;
            if (!source) return '';
            if (source.startsWith('var(') || source.includes(',')) return source;
            if (/\s/.test(source) && !/^["'].*["']$/.test(source)) return `"${source}"`;
            return source;
          }
          if (schema.kind === 'enum') {
            return String(model.enumValue || '').trim();
          }
          if (schema.kind === 'number') {
            if (!Number.isFinite(model.numberValue)) return '';
            const v = Number(model.numberValue);
            return String(v);
          }
          if (schema.kind === 'length') {
            const keyword = String(model.lengthKeyword || '').trim();
            if (keyword) return keyword;
            if (!Number.isFinite(model.lengthValue)) return '';
            const unit = String(model.lengthUnit || 'px').trim() || 'px';
            return `${Number(model.lengthValue)}${unit}`;
          }
          if (schema.kind === 'spacing') {
            const fmt = (sideObj) => {
              if (!sideObj) return '0px';
              if (String(sideObj.unit) === 'auto') return 'auto';
              const value = Number(sideObj.value);
              if (!Number.isFinite(value)) return '0px';
              return `${value}${sideObj.unit || 'px'}`;
            };
            if (model.spacingLinked) {
              return fmt(model.spacing?.top);
            }
            return [
              fmt(model.spacing?.top),
              fmt(model.spacing?.right),
              fmt(model.spacing?.bottom),
              fmt(model.spacing?.left)
            ].join(' ');
          }
          if (schema.kind === 'border') {
            const width = Number(model.border?.width);
            const widthPart = Number.isFinite(width) ? `${width}${model.border?.unit || 'px'}` : '';
            const stylePart = String(model.border?.style || '').trim();
            const colorHex = this.getValidHexColor(model.border?.color || '#000000');
            const alpha = Number.isFinite(model.border?.alpha) ? Math.max(0, Math.min(1, model.border.alpha)) : 1;
            let colorPart = colorHex;
            if (alpha < 0.999) {
              const rgb = colorHex.replace('#', '');
              const r = parseInt(rgb.substring(0, 2), 16);
              const g = parseInt(rgb.substring(2, 4), 16);
              const b = parseInt(rgb.substring(4, 6), 16);
              colorPart = `rgba(${r}, ${g}, ${b}, ${alpha.toFixed(2).replace(/0+$/, '').replace(/\.$/, '')})`;
            }
            return [widthPart, stylePart, colorPart].filter(Boolean).join(' ').trim();
          }
          if (schema.kind === 'shadow') {
            const shadow = model.shadow || {};
            const x = Number.isFinite(shadow.offsetX) ? shadow.offsetX : 0;
            const y = Number.isFinite(shadow.offsetY) ? shadow.offsetY : 0;
            const blur = Number.isFinite(shadow.blur) ? shadow.blur : 0;
            const spread = Number.isFinite(shadow.spread) ? shadow.spread : 0;
            const colorHex = this.getValidHexColor(shadow.color || '#000000');
            const alpha = Number.isFinite(shadow.alpha) ? Math.max(0, Math.min(1, shadow.alpha)) : 1;
            let colorPart = colorHex;
            if (alpha < 0.999) {
              const rgb = colorHex.replace('#', '');
              const r = parseInt(rgb.substring(0, 2), 16);
              const g = parseInt(rgb.substring(2, 4), 16);
              const b = parseInt(rgb.substring(4, 6), 16);
              colorPart = `rgba(${r}, ${g}, ${b}, ${alpha.toFixed(2).replace(/0+$/, '').replace(/\.$/, '')})`;
            }
            return `${shadow.inset ? 'inset ' : ''}${x}px ${y}px ${blur}px ${spread}px ${colorPart}`.trim();
          }
          return String(this.cssPropertyEditor.rawValue || '').trim();
        },

        isCssPropertyEditorDraftValid() {
          const property = this.normalizeCssPropertyName(this.cssPropertyEditor?.property || '');
          if (!property) return false;
          const value = this.getCssPropertyEditorPreviewValue();
          if (!value) return true;
          const stripped = this.stripImportant(value);
          if (this.hasVarFunction(stripped)) {
            const vars = this.extractVarNames(stripped);
            if (vars.length && !vars.every((n) => this.tokenExists(n))) return false;
          }
          return this.cssSupports(property, stripped);
        },

        getCssPropertyEditorValidationHint() {
          const value = this.getCssPropertyEditorPreviewValue();
          if (this.hasVarFunction(value)) {
            const vars = this.extractVarNames(value);
            const missing = vars.filter((n) => !this.tokenExists(n));
            if (missing.length) {
              return (this.getTranslation('css.visual.missingTokens') || 'Missing tokens') + ': ' + missing.join(', ');
            }
          }
          return this.getTranslation('css.visual.invalidCssValue') || 'Invalid CSS value';
        },

        applyCssPropertyEditorDraft() {
          const rule = this.cssPropertyEditorRule;
          const property = this.normalizeCssPropertyName(this.cssPropertyEditor?.property || '');
          if (!rule || !property) return;
          const value = this.getCssPropertyEditorPreviewValue();

          const key = this.findEquivalentPropertyKey(rule.properties, property) || property;
          this.$set(rule.properties, key, value);

          if (!rule.important || typeof rule.important !== 'object' || Array.isArray(rule.important)) {
            this.$set(rule, 'important', {});
          }
          this.$set(rule.important, key, !!this.cssPropertyEditor.important);
          this.saveVisualCss();
        },

        async ensureCssPropertyEditorFonts() {
          if (this.cssPropertyEditorFontsLoaded) return;
          const defaults = [
            { label: 'System UI', value: 'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif' },
            { label: 'Arial', value: 'Arial, sans-serif' },
            { label: 'Helvetica', value: '"Helvetica Neue", Helvetica, Arial, sans-serif' },
            { label: 'Verdana', value: 'Verdana, Geneva, sans-serif' },
            { label: 'Tahoma', value: 'Tahoma, Geneva, sans-serif' },
            { label: 'Trebuchet MS', value: '"Trebuchet MS", Helvetica, sans-serif' },
            { label: 'Times New Roman', value: '"Times New Roman", Times, serif' },
            { label: 'Georgia', value: 'Georgia, serif' },
            { label: 'Garamond', value: 'Garamond, serif' },
            { label: 'Courier New', value: '"Courier New", Courier, monospace' },
            { label: 'Monaco', value: 'Monaco, "Lucida Console", monospace' },
            { label: 'Inter', value: 'Inter, "Segoe UI", Arial, sans-serif' },
            { label: 'Roboto', value: 'Roboto, "Segoe UI", Arial, sans-serif' },
            { label: 'Open Sans', value: '"Open Sans", "Segoe UI", Arial, sans-serif' },
            { label: 'Lato', value: 'Lato, "Segoe UI", Arial, sans-serif' },
            { label: 'Poppins', value: 'Poppins, "Segoe UI", Arial, sans-serif' }
          ];

          const merged = new Map(defaults.map((font) => [font.value, font]));
          if (typeof window !== 'undefined' && typeof window.queryLocalFonts === 'function') {
            try {
              const localFonts = await window.queryLocalFonts();
              (localFonts || []).forEach((font) => {
                const family = String(font?.family || '').trim();
                if (!family) return;
                const value = /\s/.test(family) ? `"${family}"` : family;
                if (!merged.has(value)) merged.set(value, { label: family, value });
              });
            } catch (error) {
              debugLog('warn', 'Local font discovery skipped:', error);
            }
          }

          this.cssPropertyEditorFonts = Array.from(merged.values()).sort((a, b) => a.label.localeCompare(b.label));
          this.cssPropertyEditorFontsLoaded = true;
        },

        isColorProperty(property) {
          // Only treat explicit color properties as color inputs
          // Examples: color, background-color, border-top-color, outline-color
          const normalizedProperty = this.normalizeCssPropertyName(property);
          if (!normalizedProperty || normalizedProperty.startsWith('--')) return false;
          return normalizedProperty === 'color'
            || normalizedProperty.endsWith('-color')
            || (normalizedProperty !== 'color' && normalizedProperty.endsWith('color'));
        },

        validateProperty(rule, property) {
          // Validate CSS property value and persist
          const normalizedProperty = this.normalizeCssPropertyName(property);
          const key = this.findEquivalentPropertyKey(rule.properties, normalizedProperty) || normalizedProperty;
          const value = (rule?.properties?.[key] || '').toString();
          // Keep empty properties; removal is explicit via delete button to avoid surprising UI jumps.
          // Trigger re-render to apply is-invalid class; do not auto-remove invalid entries
          this.$forceUpdate();
          this.saveVisualCss();
        },

        // Tokens
        addDesignToken() {
          this.designTokens.push({ name: 'token', value: '#3b82f6' });
          this.saveDesignTokens();
        },
        removeDesignToken(idx) {
          this.designTokens.splice(idx, 1);
          this.saveDesignTokens();
        },
        saveDesignTokens() {
          // Normalize all tokens before saving (store without leading --)
          this.designTokens = (this.designTokens || []).map(t => {
            const name = this.normalizeTokenName(t?.name || '');
            const value = (t?.value ?? '').toString();
            return { name, value };
          });
          localStorage.setItem('designTokens', JSON.stringify(this.designTokens));
          // Apply immediately so token changes are reflected live
          this.applyVisualCss();
        },
        normalizeTokenName(raw) {
          const s = (raw || '').toString().trim().toLowerCase();
          // Remove any leading dashes users might paste
          const noPrefix = s.replace(/^[-]+/, '');
          // Allow only a-z, 0-9, '-', '_'
          const cleaned = noPrefix.replace(/[^a-z0-9_-]/g, '');
          if (!cleaned) return 'token';
          return cleaned;
        },
        onTokenNameInput(token, event) {
          const sanitized = this.normalizeTokenName(event.target.value);
          event.target.value = sanitized; // reflect immediately in input
          token.name = sanitized;
          this.saveDesignTokens();
        },
        onTokenValueInput(token, event) {
          token.value = (event.target.value || '').toString();
          this.saveDesignTokens();
        },
        applyTokenToProperty(rule, prop, tokenName) {
          if (!tokenName) return;
          const name = this.normalizeTokenName(tokenName);
          const normalizedProperty = this.normalizeCssPropertyName(prop);
          const key = this.findEquivalentPropertyKey(rule.properties, normalizedProperty) || normalizedProperty;
          this.$set(rule.properties, key, `var(--${name})`);
          if (this.isCssPropertyEditorTarget(rule, normalizedProperty)) {
            this.$set(this.cssPropertyEditor, 'rawValue', `var(--${name})`);
            this.resetCssPropertyEditorDraft();
          }
          this.saveVisualCss();
        },

        removeProperty(rule, property) {
          // Remove a CSS property from a rule
          const normalizedProperty = this.normalizeCssPropertyName(property);
          const key = this.findEquivalentPropertyKey(rule.properties, normalizedProperty) || normalizedProperty;
          delete rule.properties[key];
          // Also remove the important flag for this property
          if (rule.important && rule.important[key]) {
            delete rule.important[key];
          }
          // Also remove disabled state for this property
          if (rule.disabled && rule.disabled[key]) {
            delete rule.disabled[key];
          }
          if (this.isCssPropertyEditorTarget(rule, normalizedProperty)) {
            this.clearCssPropertyEditorSelection();
          }
          this.saveVisualCss();
        },

        // Presets
        applyPresetToRule(rule, event) {
          const pid = event.target.value;
          if (!pid) return;
          const preset = this.cssPresets.find(p => p.id === pid);
          if (!preset) return;
          if (!rule.properties) this.$set(rule, 'properties', {});
          Object.entries(preset.properties).forEach(([k, v]) => {
            const normalizedKey = this.normalizeCssPropertyName(k);
            if (!normalizedKey) return;
            this.$set(rule.properties, normalizedKey, v);
          });
          this.normalizeRuleProperties(rule);
          // reset select
          event.target.value = '';
          this.saveVisualCss();
          this.showToast((this.getTranslation('css.visual.presetApplied') || 'Preset angewendet') + ': ' + preset.name, 'success');
        },

        isPropertyInRule(rule, property) {
          if (!rule || !rule.properties) return false;
          return !!this.findEquivalentPropertyKey(rule.properties, property);
        },

        addPropertyToRule(rule, event) {
          // Add a new CSS property to a rule
          this.normalizeRuleProperties(rule);

          const selectEl = event?.target || null;
          const selectedValue = selectEl?.value || '';
          const resetSelect = () => {
            if (!selectEl) return;
            this.$nextTick(() => {
              // Keep selector on placeholder after add without re-triggering logic
              selectEl.selectedIndex = 0;
              selectEl.value = '';
            });
          };

          const property = this.normalizeCssPropertyName(selectedValue);
          if (!property) {
            resetSelect();
            return;
          }

          if (!rule.properties || typeof rule.properties !== 'object' || Array.isArray(rule.properties)) {
            this.$set(rule, 'properties', {});
          }

          // Guard against duplicate change events fired by browsers/UI re-renders.
          const ruleGuardKey = String(rule?.id || rule?.uuid || 'rule');
          const now = Date.now();
          if (!this._propertyAddRuleGuard) this._propertyAddRuleGuard = {};
          if (this._propertyAddRuleGuard[ruleGuardKey] && (now - this._propertyAddRuleGuard[ruleGuardKey]) < 250) {
            resetSelect();
            return;
          }
          this._propertyAddRuleGuard[ruleGuardKey] = now;

          // Re-normalize right before duplicate check to collapse legacy/equivalent keys
          this.normalizeRuleProperties(rule);

          const targetAlias = this.normalizeCssPropertyAlias(property) || property;
          const equivalentKeys = Object.keys(rule.properties || {}).filter((rawKey) => {
            const normalizedKey = this.normalizeCssPropertyName(rawKey);
            if (!normalizedKey) return false;
            if (normalizedKey === property) return true;
            const aliasKey = this.normalizeCssPropertyAlias(normalizedKey);
            return !!(aliasKey && targetAlias && aliasKey === targetAlias);
          });

          // Property already exists (or legacy alias exists): collapse to one canonical key.
          if (equivalentKeys.length > 0) {
            const firstNonEmptyValue = equivalentKeys
              .map((key) => rule.properties[key])
              .find((val) => !(val === '' || val === null || val === undefined));
            const mergedValue = firstNonEmptyValue !== undefined
              ? firstNonEmptyValue
              : (rule.properties[equivalentKeys[0]] ?? '');

            const hasImportant = !!(rule.important && equivalentKeys.some((key) => !!rule.important[key]));
            const hasDisabled = !!(rule.disabled && equivalentKeys.some((key) => !!rule.disabled[key]));

            if (!rule.important || typeof rule.important !== 'object' || Array.isArray(rule.important)) {
              this.$set(rule, 'important', {});
            }
            if (!rule.disabled || typeof rule.disabled !== 'object' || Array.isArray(rule.disabled)) {
              this.$set(rule, 'disabled', {});
            }

            this.$set(rule.properties, property, mergedValue);
            this.$set(rule.important, property, hasImportant);
            this.$set(rule.disabled, property, hasDisabled);

            equivalentKeys.forEach((rawKey) => {
              if (rawKey === property) return;
              this.$delete(rule.properties, rawKey);
              this.$delete(rule.important, rawKey);
              this.$delete(rule.disabled, rawKey);
            });

            this.normalizeRuleProperties(rule);
            this.showToast(this.getTranslation('css.visual.propertyAlreadyExists') || `Die Eigenschaft "${property}" existiert bereits in dieser Regel`, 'warning');
            this.saveVisualCss();
            resetSelect();
            return;
          }

          if (!rule.important || typeof rule.important !== 'object' || Array.isArray(rule.important)) {
            this.$set(rule, 'important', {});
          }
          if (!rule.disabled || typeof rule.disabled !== 'object' || Array.isArray(rule.disabled)) {
            this.$set(rule, 'disabled', {});
          }

          // Do not set default values; start empty for all properties
          this.$set(rule.properties, property, '');

          // Do not pre-set !important; user opts in manually
          this.normalizeRuleProperties(rule);
          this.saveVisualCss();
          resetSelect();
        },

        getValidHexColor(value) {
          // Return a safe hex color for the color picker without mutating rule state
          const v = (value || '').trim();
          const hex6 = /^#([0-9a-fA-F]{6})$/;
          if (hex6.test(v)) return v;
          // Accept 3-digit hex by expanding
          const hex3 = /^#([0-9a-fA-F]{3})$/;
          if (hex3.test(v)) {
            const m = v.substring(1);
            return '#' + m[0]+m[0] + m[1]+m[1] + m[2]+m[2];
          }
          // Fallback swatch color; does not change actual property value
          return '#000000';
        },

        onColorPickerChange(rule, property, event) {
          const val = event.target.value;
          const normalizedProperty = this.normalizeCssPropertyName(property);
          const key = this.findEquivalentPropertyKey(rule.properties, normalizedProperty) || normalizedProperty;
          this.$set(rule.properties, key, val);
          if (this.isCssPropertyEditorTarget(rule, normalizedProperty)) {
            this.$set(this.cssPropertyEditor, 'rawValue', val);
            this.resetCssPropertyEditorDraft();
          }
          this.saveVisualCss();
        },

        getPropertyImportant(rule, property) {
          // Check if a property is marked as important
          const normalizedProperty = this.normalizeCssPropertyName(property);
          const key = this.findEquivalentPropertyKey(rule.properties, normalizedProperty) || normalizedProperty;
          if (!rule.important) {
            rule.important = {};
          }
          return rule.important[key] || false;
        },

        togglePropertyImportant(rule, property) {
          // Toggle the important flag for a property
          const normalizedProperty = this.normalizeCssPropertyName(property);
          const key = this.findEquivalentPropertyKey(rule.properties, normalizedProperty) || normalizedProperty;
          if (!rule.important) {
            rule.important = {};
          }
          rule.important[key] = !rule.important[key];
          if (this.isCssPropertyEditorTarget(rule, normalizedProperty)) {
            this.$set(this.cssPropertyEditor, 'important', !!rule.important[key]);
          }
          this.saveVisualCss();
        },

        // ===== CSS Validation Helpers =====
        stripImportant(v) {
          return (v || '').toString().replace(/\s*!important\s*$/i, '').trim();
        },
        hasVarFunction(v) {
          return /var\(\s*--[a-z0-9_-]+\s*\)/i.test(v || '');
        },
        extractVarNames(v) {
          const out = []; const re = /var\(\s*(--[a-z0-9_-]+)\s*\)/ig; let m;
          const s = (v || '').toString();
          while ((m = re.exec(s)) !== null) out.push(m[1]);
          return out;
        },
        tokenExists(name) {
          const n = (name || '').replace(/^--+/, '').toLowerCase();
          return (this.designTokens || []).some(t => (t?.name || '').toLowerCase() === n);
        },
        cssSupports(prop, value) {
          try { if (window.CSS && CSS.supports) return CSS.supports(prop, value); } catch {}
          // Fallback test element
          try {
            const el = document.createElement('div');
            el.style[prop] = value;
            return !!el.style[prop];
          } catch { return false; }
        },
        isPropertyValid(rule, prop) {
          try {
            const normalizedProperty = this.normalizeCssPropertyName(prop);
            const key = this.findEquivalentPropertyKey(rule?.properties, normalizedProperty) || normalizedProperty;
            const raw = (rule?.properties?.[key] || '').toString();
            if (!raw.trim()) return true; // empty is handled elsewhere
            const v = this.stripImportant(raw);
            // If var() used, ensure referenced tokens exist (all of them)
            if (this.hasVarFunction(v)) {
              const vars = this.extractVarNames(v);
              if (vars.length && !vars.every(n => this.tokenExists(n))) return false;
            }
            return this.cssSupports(this.normalizeCssPropertyName(key), v);
          } catch { return true; }
        },
        isTokenValueValid(value) {
          const v = (value || '').toString().trim();
          if (!v) return false;
          // Accept common contexts: background (very permissive) or color
          if (this.cssSupports('background', v)) return true;
          if (this.cssSupports('color', v)) return true;
          // As a fallback, width can validate length/percentage values
          if (this.cssSupports('width', v)) return true;
          return false;
        },
        getPropertyValidationHint(rule, prop) {
          try {
            const normalizedProperty = this.normalizeCssPropertyName(prop);
            const key = this.findEquivalentPropertyKey(rule?.properties, normalizedProperty) || normalizedProperty;
            const raw = (rule?.properties?.[key] || '').toString();
            const v = this.stripImportant(raw);
            if (this.hasVarFunction(v)) {
              const vars = this.extractVarNames(v);
              const missing = (vars || []).filter(n => !this.tokenExists(n));
              if (missing.length) {
                const list = missing.join(', ');
                return (this.getTranslation('css.visual.missingTokens') || 'Fehlende Tokens') + ': ' + list;
              }
            }
            return this.getTranslation('css.visual.invalidCssValue') || 'Ungültiger CSS-Wert';
          } catch { return this.getTranslation('css.visual.invalidCssValue') || 'Ungültiger CSS-Wert'; }
        },
        getTokenValidationHint(value) {
          // Provide a helpful generic hint for token values
          return this.getTranslation('css.visual.invalidTokenValue') || 'Ungültiger Token-Wert (z. B. #rrggbb, rgb(), linear-gradient(), var(--name))';
        },

        // Rule search helper: match by name and any property key/value
        matchesRuleSearch(rule) {
          const q = (this.rulesFilterQuery || '').toString().trim().toLowerCase();
          if (!q) return true;
          // Name
          if ((rule.name || '').toString().toLowerCase().includes(q)) return true;
          // Properties (keys and values)
          try {
            const props = rule.properties || {};
            for (const [k, v] of Object.entries(props)) {
              if ((k || '').toString().toLowerCase().includes(q)) return true;
              if ((v || '').toString().toLowerCase().includes(q)) return true;
            }
          } catch {}
          // Custom CSS field (legacy)
          if ((rule.customCss || '').toString().toLowerCase().includes(q)) return true;
          return false;
        },

        isPropertyDisabled(rule, property) {
          const normalizedProperty = this.normalizeCssPropertyName(property);
          const key = this.findEquivalentPropertyKey(rule?.properties, normalizedProperty) || normalizedProperty;
          if (!rule.disabled) return false;
          return !!rule.disabled[key];
        },
        togglePropertyDisabled(rule, property) {
          const normalizedProperty = this.normalizeCssPropertyName(property);
          const key = this.findEquivalentPropertyKey(rule?.properties, normalizedProperty) || normalizedProperty;
          if (!rule.disabled) {
            // Use Vue.set to keep reactivity if available
            this.$set ? this.$set(rule, 'disabled', {}) : (rule.disabled = {});
          }
          const current = !!rule.disabled[key];
          this.$set ? this.$set(rule.disabled, key, !current) : (rule.disabled[key] = !current);
          this.saveVisualCss();
        },

        getRuleSelector(rule) {
          // Ensure rule.selector is always an object
          if (!rule.selector || typeof rule.selector === 'string') {
            // Create a new selector object for this rule
            rule.selector = {
              base: typeof rule.selector === 'string' ? rule.selector : '',
              groupId: rule.groupId || null,
              linkId: rule.linkId || null,
              keywordSlug: null,
              hover: false,
              dragOver: false
            };
          }
          // Ensure the selector has all required properties
          if (!rule.selector.hasOwnProperty('keywordSlug')) {
            rule.selector.keywordSlug = null;
          }
          if (!rule.selector.hasOwnProperty('hover')) {
            rule.selector.hover = false;
          }
          if (!rule.selector.hasOwnProperty('dragOver')) {
            rule.selector.dragOver = false;
          }
          return rule.selector;
        },

        updateRuleHover(rule, event) {
          const selector = this.getRuleSelector(rule);
          selector.hover = !!event.target.checked;

          // `link-hover` already encodes :hover in its base selector.
          if (selector.base === 'link-hover' && selector.hover) {
            selector.hover = false;
          }

          if (this.selectedVisualTemplate && selector.base) {
            this.loadTemplatePropertiesForRule(rule);
          }

          this.saveVisualCss();
        },

        updateRuleDragOver(rule, event) {
          const selector = this.getRuleSelector(rule);
          selector.dragOver = !!event.target.checked;

          if (this.selectedVisualTemplate && selector.base) {
            this.loadTemplatePropertiesForRule(rule);
          }

          this.saveVisualCss();
        },

        updateRuleBase(rule, event) {
          const baseValue = event.target.value;
          // Ensure selector is an object and create a new one to avoid shared references
          if (!rule.selector || typeof rule.selector === 'string') {
            rule.selector = {
              base: '',
              groupId: null,
              linkId: null,
              keywordSlug: null,
              hover: false,
              dragOver: false
            };
          }
          const oldBase = rule.selector.base;
          const previousGroupId = rule.selector.groupId;
          const previousLinkId = rule.selector.linkId;
          const previousKeywordSlug = rule.selector.keywordSlug;
          const previousHover = !!rule.selector.hover;
          const previousDragOver = !!rule.selector.dragOver;

          // Update the base value
          rule.selector.base = baseValue;

          // Decide whether to keep or reset dependent selections based on new base
          const groupSupportingSelectors = [
            'groups', 'group-header', 'group-title', 'group-body',
            'links', 'separators', 'notes', 'link-hover', 'link-anchor', 'link-url', 'link-icon',
            'link-vertical-dropzone', 'link-horizontal-dropzone',
            'link-popover', 'link-popover-title', 'link-popover-url', 'link-popover-meta',
            'link-popover-row', 'link-popover-label', 'link-popover-value', 'link-popover-value-muted',
            'link-popover-keywords', 'link-popover-badge', 'link-popover-favicon',
            'badges-group', 'badges-group-linkcount', 'badges-group-keywords',
            'badges-link', 'badges-link-keywords',
            'keywords-hierarchical'
          ];
          const linkSupportingSelectors = [
            'links', 'separators', 'notes', 'link-hover', 'link-anchor', 'link-url', 'link-icon',
            'link-popover', 'link-popover-title', 'link-popover-url', 'link-popover-meta',
            'link-popover-row', 'link-popover-label', 'link-popover-value', 'link-popover-value-muted',
            'link-popover-keywords', 'link-popover-badge', 'link-popover-favicon',
            'badges-link', 'badges-link-keywords',
            'keywords-hierarchical'
          ];
          const keywordSupportingSelectors = [
            'keyword-by-name', 'keywords-hierarchical'
          ];

          const keepGroup = groupSupportingSelectors.includes(baseValue);
          const keepLink = linkSupportingSelectors.includes(baseValue);
          const keepKeyword = keywordSupportingSelectors.includes(baseValue);

          // Apply keeping rules
          rule.selector.groupId = keepGroup ? previousGroupId : null;
          // Link only meaningful if base supports link AND we still have a group
          rule.selector.linkId = (keepLink && (keepGroup ? previousGroupId : null)) ? previousLinkId : null;
          rule.selector.keywordSlug = keepKeyword ? previousKeywordSlug : null;
          rule.selector.hover = (!baseValue || baseValue === 'link-hover') ? false : previousHover;
          rule.selector.dragOver = !!baseValue && previousDragOver;

          // Keep legacy fields in sync
          rule.groupId = rule.selector.groupId;
          rule.linkId = rule.selector.linkId;

          // Do NOT clear user properties on base change.
          // We keep user-entered properties and merge template defaults below if selected.
          if (this.selectedVisualTemplate && baseValue) {
            this.loadTemplatePropertiesForRule(rule);
          }

          // Do not auto-add any properties upon selector changes

          this.saveVisualCss();
        },

        onBaseSelectorChange(rule) {
          // Ensure selector is an object
          this.getRuleSelector(rule);

          // Reset dependent selections when base changes
          rule.selector.groupId = null;
          rule.selector.linkId = null;
          rule.groupId = null;
          rule.linkId = null;

          // Do not auto-add any properties upon selector changes

          this.saveVisualCss();
        },

        loadTemplatePropertiesForRule(rule) {
          // Get template rules
          const templateRules = this.getCurrentTemplate();
          const selector = this.getRuleSelector(rule);

          // Get the actual CSS selector for this base
          const baseSelectorMap = {
            'app': '.mb-app',
            'header': '.mb-titlebar',
            'toolbar': '.mb-toolbar',
            'footer': '.mb-footer',
            'groups-links-container': '.mb-groups-links-container',
            'surface-panel': '.mb-surface-panel',
            'muted-text': '.text-muted',
            'modal': '.modal-content',
            'modal-header': '.modal-header',
            'modal-body': '.modal-body',
            'modal-footer': '.modal-footer',
            'css-sidebar': '.css-sidebar',
            'feature-sidebar': '.feature-sidebar',
            'sidebar-header': '.sidebar-header',
            'sidebar-top-section': '.sidebar-top-section',
            'sidebar-bottom-section': '.sidebar-bottom-section',
            'sidebar-divider': '.sidebar-divider',
            'card': '.card',
            'card-header': '.card-header',
            'list-group-item': '.list-group-item',
            'table': '.table',
            'table-header': '.table thead th',
            'table-cell': '.table tbody td',
            'form-control': '.form-control',
            'form-select': '.form-select',
            'input-group-text': '.input-group-text',
            'form-check-input': '.form-check-input',
            'dropdown-menu': '.dropdown-menu',
            'dropdown-item': '.dropdown-item',
            'context-menu': '.mb-context-menu',
            'context-menu-item': '.mb-context-menu-list > li',
            'alert-info': '.alert-info',
            'alert-warning': '.alert-warning',
            'groups': '.mb-group',
            'group-header': '.mb-group__header',
            'group-title': '.mb-group__title',
            'group-body': '.mb-group__body',
            'vertical-dropzone': '.verticalDropZone',
            'group-horizontal-dropzone': '.groupContainerDragAndDrop.group-drop-zone',
            'links': '.mb-link',
            'separators': '.mb-link-separator',
            'notes': '.mb-link-note',
            'link-hover': '.mb-link:hover',
            'link-anchor': '.mb-link__anchor',
            'link-url': '.link-url-preview',
            'link-icon': '.mb-link__icon',
            'link-vertical-dropzone': '.linkVerticalDropZone',
            'link-horizontal-dropzone': '.linkContainerDragAndDrop.link-drop-zone',
            'link-popover': '.link-detail-popover',
            'link-popover-title': '.link-detail-popover__title',
            'link-popover-url': '.link-detail-popover__url',
            'link-popover-meta': '.link-detail-popover__meta',
            'link-popover-row': '.link-detail-popover__row',
            'link-popover-label': '.link-detail-popover__label',
            'link-popover-value': '.link-detail-popover__value',
            'link-popover-value-muted': '.link-detail-popover__value--muted',
            'link-popover-keywords': '.link-detail-popover__keywords',
            'link-popover-badge': '.link-detail-popover__badge',
            'link-popover-favicon': '.link-detail-popover__favicon',
            'keywords': '.mb-keyword',
            'keywords-selected': '.mb-keywords-cloud .mb-keyword.mb-keyword-active',
            'keyword-selected-text': '.mb-keywords-cloud .mb-keyword.mb-keyword-active .mb-keyword-text',
            'keywords-hierarchical': '.keyword-badge',
            'keyword-suggestions': '.mb-keyword-suggestions, .mb-keyword-suggestions--overlay',
            'keyword-suggestion-item': '.mb-keyword-suggestion',
            'keyword-by-name': '.mb-keyword',
            'body': 'body',
            // Additional mappings for better template matching
            'titlebar': '.mb-titlebar',
            'titlebar-title': '.mb-titlebar__title',
            'btn': '.btn',
            'btn-primary': '.btn-primary',
            'btn-secondary': '.btn-secondary',
            'btn-success': '.btn-success',
            'btn-danger': '.btn-danger'
          };

          const baseTargetSelector = baseSelectorMap[selector.base] || selector.base;
          let targetSelector = baseTargetSelector;
          if (this.selectorUsesDragOverState(selector)) {
            targetSelector = this.appendDragOverToSelector(targetSelector);
          }
          if (this.selectorUsesHoverState(selector)) {
            targetSelector = this.appendHoverToSelector(targetSelector);
          }

          // Collect all matching CSS properties from template
          const aggregatedProperties = {};

          // Search through all template rules for matching selectors
          for (const tRule of templateRules) {
            let matches = false;

            // Check if template rule selector matches our target
            if (tRule.selector === targetSelector) {
              matches = true;
            } else if (tRule.selector === baseTargetSelector) {
              matches = true;
            } else if (tRule.selector === selector.base) {
              matches = true;
            } else if (tRule.selector === `.${selector.base}`) {
              matches = true;
            } else if (targetSelector && tRule.selector) {
              // Check various matching patterns
              const normalizeSelectorForMatch = (value) => String(value || '').replace(/[#.]/g, '').trim();
              const normalizedTarget = normalizeSelectorForMatch(targetSelector);
              const normalizedBaseTarget = normalizeSelectorForMatch(baseTargetSelector);
              const normalizedTemplate = normalizeSelectorForMatch(tRule.selector);

              // Direct match after normalization
              if ((normalizedTarget && normalizedTemplate === normalizedTarget)
                || (normalizedBaseTarget && normalizedTemplate === normalizedBaseTarget)) {
                matches = true;
              }
              // Check if template selector contains our target (for nested selectors)
              else if (tRule.selector.includes(targetSelector)) {
                matches = true;
              } else if (baseTargetSelector && tRule.selector.includes(baseTargetSelector)) {
                matches = true;
              }
              // Check for class/id variations
              else if ((normalizedTarget && (tRule.selector === `.${normalizedTarget}` || tRule.selector === `#${normalizedTarget}`))
                       || (normalizedBaseTarget && (tRule.selector === `.${normalizedBaseTarget}` || tRule.selector === `#${normalizedBaseTarget}`))) {
                matches = true;
              }
            }

            // Special case for hierarchical selectors
            if (!matches && targetSelector) {
              // Check if this is a parent/child relationship
              // E.g., .mb-group should also get properties from body if it's a child
              if (tRule.selector === 'body' || tRule.selector === '#app') {
                // These are parent containers, inherit some properties
                const inheritableProps = ['font-family', 'font-size', 'color', 'line-height'];
                for (const prop of inheritableProps) {
                  if (tRule.properties && tRule.properties[prop]) {
                    aggregatedProperties[prop] = tRule.properties[prop];
                  }
                }
              }
            }

            if (matches && tRule.properties) {
              // Aggregate all properties from matching rules
              // Later rules override earlier ones
              for (const [prop, value] of Object.entries(tRule.properties)) {
                const normalizedProp = this.normalizeCssPropertyName(prop);
                if (!normalizedProp) continue;
                aggregatedProperties[normalizedProp] = value;
              }
            }
          }

          // Merge aggregated template properties into the rule
          // If the rule already has user properties, keep them and only add missing ones
          if (Object.keys(aggregatedProperties).length > 0) {
            debugLog('log', 'Loading template properties for', selector.base, ':', aggregatedProperties);

            if (!rule.properties || Object.keys(rule.properties).length === 0) {
              // No user props yet: take the template defaults fully
              rule.properties = {};
              for (const [prop, value] of Object.entries(aggregatedProperties)) {
                const normalizedProp = this.normalizeCssPropertyName(prop);
                if (!normalizedProp) continue;
                rule.properties[normalizedProp] = value;
              }
            } else {
              // Already has user props: only add missing keys from template
              for (const [prop, value] of Object.entries(aggregatedProperties)) {
                const normalizedProp = this.normalizeCssPropertyName(prop);
                if (!normalizedProp) continue;
                if (!(normalizedProp in rule.properties)) {
                  rule.properties[normalizedProp] = value;
                }
              }
            }
            this.normalizeRuleProperties(rule);
          }
        },

        updateRuleGroupId(rule, event) {
          const rawValue = event.target.value;
          let groupId = null;

          if (rawValue && rawValue !== 'null' && rawValue !== '') {
            // Check if it's a UUID (contains dashes) or a numeric ID
            if (rawValue.includes('-')) {
              // It's a UUID, keep as string
              groupId = rawValue;
            } else if (!isNaN(rawValue)) {
              // It's a numeric ID
              groupId = parseInt(rawValue);
            } else {
              // Keep as is
              groupId = rawValue;
            }
          }

          debugLog('log', 'updateRuleGroupId - Raw value:', rawValue, 'Type:', typeof rawValue, 'Parsed groupId:', groupId, 'Type after parse:', typeof groupId);

          // Ensure selector is an object
          const selector = this.getRuleSelector(rule);

          // Update the selector
          selector.groupId = groupId;
          selector.linkId = null; // Reset link when group changes

          // Also update root level for backward compatibility
          rule.groupId = groupId;
          rule.linkId = null;

          debugLog('log', 'Group updated:', {
            ruleId: rule.id,
            groupId: groupId,
            selector: selector,
            fullRule: JSON.stringify(rule)
          });

          this.saveVisualCss();
        },

        updateRuleLinkId(rule, event) {
          const rawValue = event.target.value;
          let linkId = null;

          if (rawValue && rawValue !== 'null' && rawValue !== '') {
            // Check if it's a UUID (contains dashes) or a numeric ID
            if (rawValue.includes('-')) {
              // It's a UUID, keep as string
              linkId = rawValue;
            } else if (!isNaN(rawValue)) {
              // It's a numeric ID
              linkId = parseInt(rawValue);
            } else {
              // Keep as is
              linkId = rawValue;
            }
          }

          // Ensure selector is an object
          const selector = this.getRuleSelector(rule);

          // Update the selector
          selector.linkId = linkId;

          // Also update root level for backward compatibility
          rule.linkId = linkId;

          this.saveVisualCss();
        },

        updateRuleKeywordSlug(rule, event) {
          const keywordSlug = event.target.value;

          // Ensure selector is an object
          const selector = this.getRuleSelector(rule);

          // Update the selector with keyword slug
          selector.keywordSlug = keywordSlug;

          this.saveVisualCss();
        },

        getAllUniqueKeywords() {
          // Get all unique keywords from groups and links
          const set = new Set();
          (this.data.groups || []).forEach(g => {
            if (g.deleted) return;

            // Add group keywords
            if (g.keywords) {
              this.parseKeywords(g.keywords).forEach(k => set.add(k));
            }

            // Add link keywords
            (g.links || []).forEach(l => {
              if (!l.deleted && l.keywords) {
                this.parseKeywords(l.keywords).forEach(k => set.add(k));
              }
            });
          });

          // Return sorted array
          return Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        },

        getKeywordsForRule(rule) {
          const selector = this.getRuleSelector(rule);

          debugLog('log', 'getKeywordsForRule - selector:', JSON.stringify(selector));

          // For keyword-by-name, return all keywords
          if (selector.base === 'keyword-by-name') {
            return this.getAllUniqueKeywords();
          }

          // For hierarchical keywords, filter based on selected group/link
          if (selector.base === 'keywords-hierarchical') {
            // If a specific link is selected, return only that link's keywords
            if (selector.groupId && selector.linkId) {
              const group = this.data.groups.find(g =>
                !g.deleted && (
                  g.id === selector.groupId ||
                  g.uuid === selector.groupId ||
                  g.id === parseInt(selector.groupId)
                )
              );

              if (group) {
                const link = group.links.find(l =>
                  !l.deleted && (
                    l.id === selector.linkId ||
                    l.uuid === selector.linkId ||
                    l.id === parseInt(selector.linkId)
                  )
                );

                if (link && link.keywords) {
                  debugLog('log', 'getKeywordsForRule - Returning keywords for specific link:', link.text);
                  return this.parseKeywords(link.keywords).sort((a, b) =>
                    a.toLowerCase().localeCompare(b.toLowerCase())
                  );
                }
              }
              return [];
            }

            // If only a group is selected, return all keywords from group AND its links
            if (selector.groupId) {
              const group = this.data.groups.find(g =>
                !g.deleted && (
                  g.id === selector.groupId ||
                  g.uuid === selector.groupId ||
                  g.id === parseInt(selector.groupId)
                )
              );

              if (group) {
                const set = new Set();

                // Add group's own keywords
                if (group.keywords) {
                  debugLog('log', 'getKeywordsForRule - Adding group keywords:', group.keywords);
                  this.parseKeywords(group.keywords).forEach(k => set.add(k));
                }

                // Add keywords from all links in this group
                (group.links || []).forEach(l => {
                  if (!l.deleted && l.keywords) {
                    debugLog('log', 'getKeywordsForRule - Adding link keywords:', l.text, l.keywords);
                    this.parseKeywords(l.keywords).forEach(k => set.add(k));
                  }
                });

                const result = Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
                debugLog('log', 'getKeywordsForRule - Total keywords for group:', result);
                return result;
              }
              return [];
            }

            // No group or link selected - return all keywords
            return this.getAllUniqueKeywords();
          }

          // For keywords-in-group, return keywords that appear in group badges
          if (selector.base === 'keywords-in-group') {
            if (selector.groupId) {
              const group = this.data.groups.find(g =>
                !g.deleted && (
                  g.id === selector.groupId ||
                  g.uuid === selector.groupId ||
                  g.id === parseInt(selector.groupId)
                )
              );

              if (group) {
                // For a specific group, return both group keywords AND all link keywords
                // because both appear as badges in the group header
                const set = new Set();

                // Add group's own keywords
                if (group.keywords) {
                  this.parseKeywords(group.keywords).forEach(k => set.add(k));
                }

                // Also add keywords from all links in this group
                // because they also appear as badges in the group
                (group.links || []).forEach(l => {
                  if (!l.deleted && l.keywords) {
                    this.parseKeywords(l.keywords).forEach(k => set.add(k));
                  }
                });

                return Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
              }
              return []; // No keywords in this group
            }
            // No group selected - return all group keywords (not link keywords)
            const set = new Set();
            (this.data.groups || []).forEach(g => {
              if (!g.deleted && g.keywords) {
                this.parseKeywords(g.keywords).forEach(k => set.add(k));
              }
            });
            return Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
          }

          // For keywords-in-link, return keywords from links
          if (selector.base === 'keywords-in-link') {
            if (selector.groupId && selector.linkId) {
              // Specific link selected - return only that link's keywords
              const group = this.data.groups.find(g =>
                !g.deleted && (
                  g.id === selector.groupId ||
                  g.uuid === selector.groupId ||
                  g.id === parseInt(selector.groupId)
                )
              );

              if (group) {
                const link = group.links.find(l =>
                  !l.deleted && (
                    l.id === selector.linkId ||
                    l.uuid === selector.linkId ||
                    l.id === parseInt(selector.linkId)
                  )
                );

                if (link && link.keywords) {
                  // Return ONLY this link's keywords
                  return this.parseKeywords(link.keywords).sort((a, b) =>
                    a.toLowerCase().localeCompare(b.toLowerCase())
                  );
                }
              }
              return []; // No keywords in this link
            } else if (selector.groupId) {
              // Group selected but no link - return all keywords from all links in this group
              const group = this.data.groups.find(g =>
                !g.deleted && (
                  g.id === selector.groupId ||
                  g.uuid === selector.groupId ||
                  g.id === parseInt(selector.groupId)
                )
              );

              debugLog('log', 'getKeywordsForRule - Looking for group:', selector.groupId);
              debugLog('log', 'getKeywordsForRule - Found group:', group ? group.name : 'NOT FOUND');

              if (group) {
                debugLog('log', 'getKeywordsForRule - Group has keywords:', group.keywords);
                debugLog('log', 'getKeywordsForRule - Group has', (group.links || []).length, 'links');

                const set = new Set();
                (group.links || []).forEach(l => {
                  debugLog('log', 'getKeywordsForRule - Checking link:', l.text, 'deleted:', l.deleted, 'keywords:', l.keywords);
                  if (!l.deleted && l.keywords) {
                    const keywords = this.parseKeywords(l.keywords);
                    debugLog('log', 'getKeywordsForRule - Parsed link keywords:', l.text, keywords);
                    keywords.forEach(k => set.add(k));
                  }
                });
                const result = Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
                debugLog('log', 'getKeywordsForRule - Final keywords for links in group:', result);
                return result;
              }
              return [];
            }

            // No group or link selected - return all link keywords from all groups
            const set = new Set();
            (this.data.groups || []).forEach(g => {
              if (!g.deleted) {
                (g.links || []).forEach(l => {
                  if (!l.deleted && l.keywords) {
                    this.parseKeywords(l.keywords).forEach(k => set.add(k));
                  }
                });
              }
            });
            return Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
          }

          // Default: return empty array
          return [];
        },

        onGroupChange(rule) {
          // Deprecated - use updateRuleGroupId instead
          this.updateRuleGroupId(rule, { target: { value: rule.selector.groupId } });
        },

        getCurrentTemplate() {
          // Get the currently selected template definition
          const templates = {
            'dark-mode': [
              // ===== WICHTIGER HINWEIS =====
              // Dieses Template enthält ALLE CSS-Regeln aus dem alten Dark Mode Template
              // Viele Selektoren sind nicht im Dropdown verfügbar, funktionieren aber trotzdem

              // Body & Main Container
              {
                id: Date.now() + 1,
                enabled: true,
                selector: 'body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1a1a1a',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 2,
                enabled: true,
                selector: '.mb-app',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1a1a1a'
                }
              },
              // Title Bar
              {
                id: Date.now() + 3,
                enabled: true,
                selector: '.mb-titlebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #2c2c2c 0%, #1f1f1f 100%)',
                  'border-bottom': '1px solid #444'
                }
              },
              {
                id: Date.now() + 4,
                enabled: true,
                selector: '.mb-titlebar__title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f0f0f0',
                  'text-shadow': '2px 2px 4px rgba(0, 0, 0, 0.5)'
                }
              },
              // Toolbar
              {
                id: Date.now() + 5,
                enabled: true,
                selector: '.mb-toolbar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-bottom': '1px solid #333'
                }
              },
              {
                id: Date.now() + 5_1,
                enabled: true,
                selector: '.mb-toolbar .btn',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '4px 8px',
                  'font-size': '13px'
                }
              },
              // Groups
              {
                id: Date.now() + 6,
                enabled: true,
                selector: '.mb-group',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'margin-bottom': '8px',
                  'border-radius': '8px'
                }
              },
              {
                id: Date.now() + 6_1,
                enabled: true,
                selector: '.mb-group__body',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-left-radius': '0',
                  'border-top-right-radius': '0',
                  'border-bottom-left-radius': '8px',
                  'border-bottom-right-radius': '8px'
                }
              },
              {
                id: Date.now() + 7,
                enabled: true,
                selector: '.mb-group__header',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #2f2f2f 0%, #252525 100%)',
                  'border-bottom': '1px solid #3a3a3a'
                }
              },
              {
                id: Date.now() + 8,
                enabled: true,
                selector: '.mb-group__title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f0f0f0'
                }
              },
              // Links
              {
                id: Date.now() + 9,
                enabled: true,
                selector: '.mb-link',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'transparent'
                }
              },
              {
                id: Date.now() + 10,
                enabled: true,
                selector: '.mb-link__url',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#6cb2ff'
                }
              },
              {
                id: Date.now() + 10_1,
                enabled: true,
                selector: '.link-detail-popover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(15, 23, 42, 0.94)',
                  'color': '#e2e8f0',
                  'border': '1px solid rgba(148, 163, 184, 0.25)',
                  'box-shadow': '0 24px 60px rgba(15, 23, 42, 0.45)',
                  'backdrop-filter': 'blur(12px)'
                }
              },
              {
                id: Date.now() + 10_2,
                enabled: true,
                selector: '.link-detail-popover__badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(59, 130, 246, 0.25)',
                  'color': '#bfdbfe'
                }
              },
              {
                id: Date.now() + 10_3,
                enabled: true,
                selector: '.link-detail-popover__favicon',
                groupId: null,
                linkId: null,
                properties: {
                  'box-shadow': '0 3px 8px rgba(15, 23, 42, 0.45)'
                }
              },
              // Keywords
              {
                id: Date.now() + 11,
                enabled: true,
                selector: '.keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a5f7d',
                  'color': '#e0e0e0',
                  'border': '1px solid #4a7f9d'
                }
              },
              {
                id: Date.now() + 11_1,
                enabled: true,
                selector: '.mb-keyword-suggestions, .mb-keyword-suggestions--overlay',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252b33',
                  'border': '1px solid #4a5565',
                  'color': '#e6e8eb',
                  'box-shadow': '0 12px 24px rgba(0, 0, 0, 0.45)'
                }
              },
              {
                id: Date.now() + 11_2,
                enabled: true,
                selector: '.mb-keyword-suggestion',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'transparent',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 11_21,
                enabled: true,
                selector: '.mb-keyword-suggestion + .mb-keyword-suggestion',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top': '1px solid #465063'
                }
              },
              {
                id: Date.now() + 11_3,
                enabled: true,
                selector: '.mb-keyword-suggestion:hover, .mb-keyword-suggestion:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a424f',
                  'color': '#ffffff'
                }
              },
              // Buttons
              {
                id: Date.now() + 12,
                enabled: true,
                selector: '.btn-primary',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a9eff',
                  'border-color': '#3a8eef',
                  'color': '#fff'
                }
              },
              {
                id: Date.now() + 13,
                enabled: true,
                selector: '.btn-secondary',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#555',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              // Forms
              {
                id: Date.now() + 14,
                enabled: true,
                selector: '.form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 15,
                enabled: true,
                selector: '.form-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              // Modals
              {
                id: Date.now() + 16,
                enabled: true,
                selector: '.modal-content',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0',
                  'border': '1px solid #444'
                }
              },
              {
                id: Date.now() + 17,
                enabled: true,
                selector: '.modal-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-bottom': '1px solid #444'
                }
              },
              {
                id: Date.now() + 18,
                enabled: true,
                selector: '.modal-footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-top': '1px solid #444'
                }
              },
              // Duplicates dialog (ensure consistent dark styling)
              {
                id: Date.now() + 18_1,
                enabled: true,
                selector: '#duplicatesModal .card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 18_2,
                enabled: true,
                selector: '#duplicatesModal .card-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'border-bottom': '1px solid #3a3a3a'
                }
              },
              {
                id: Date.now() + 18_3,
                enabled: true,
                selector: '#duplicatesModal .list-group-item',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'color': '#e0e0e0',
                  'border-color': '#333'
                }
              },
              {
                id: Date.now() + 18_4,
                enabled: true,
                selector: '#duplicatesModal .badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a',
                  'color': '#e0e0e0',
                  'border': '1px solid #444'
                }
              },
              // Zusätzliche wichtige Dark Mode Regeln
              {
                id: Date.now() + 19,
                enabled: true,
                selector: '.groupContainer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'margin-bottom': '8px',
                  'border-radius': '8px'
                }
              },
              {
                id: Date.now() + 20,
                enabled: true,
                selector: '.groupContainerHeader',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #2f2f2f 0%, #252525 100%)',
                  'border-bottom': '1px solid #3a3a3a'
                }
              },
              {
                id: Date.now() + 21,
                enabled: true,
                selector: '.linkContainer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'transparent',
                  'border-bottom': '1px solid #333'
                }
              },
              {
                id: Date.now() + 22,
                enabled: true,
                selector: '.linkContainer:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333'
                }
              },
              {
                id: Date.now() + 23,
                enabled: true,
                selector: '.linkText a',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#6cb2ff'
                }
              },
              {
                id: Date.now() + 24,
                enabled: true,
                selector: '.linkText a:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9cc9ff',
                  'text-decoration': 'none'
                }
              },
              {
                id: Date.now() + 25,
                enabled: true,
                selector: '.mb-css-sidebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-left': '1px solid #444'
                }
              },
              {
                id: Date.now() + 26,
                enabled: true,
                selector: '.alert-info',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e3a5f',
                  'color': '#9cc9ff',
                  'border-color': '#2e4a6f'
                }
              },
              {
                id: Date.now() + 27,
                enabled: true,
                selector: '::-webkit-scrollbar',
                groupId: null,
                linkId: null,
                properties: {
                  'width': '12px',
                  'height': '12px'
                }
              },
              {
                id: Date.now() + 28,
                enabled: true,
                selector: '::-webkit-scrollbar-track',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#1a1a1a'
                }
              },
              {
                id: Date.now() + 29,
                enabled: true,
                selector: '::-webkit-scrollbar-thumb',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#444',
                  'border-radius': '6px'
                }
              },
              {
                id: Date.now() + 30,
                enabled: true,
                selector: '::-webkit-scrollbar-thumb:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#555'
                }
              },
              // Große CSS-Blöcke als Custom CSS
              {
                id: Date.now() + 31,
                enabled: true,
                selector: '.mb-group-info-section',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#232323',
                  'border': '1px solid #3a3a3a',
                  'border-radius': '4px'
                },
                customCss: `/* Weitere Dark Mode Styles für Info-Bereich */
.mb-group-info-header {
  background-color: #2a2a2a;
  color: #e0e0e0;
}
.mb-group-info-header:hover {
  background-color: #333;
}
.mb-group-info-label,
.group-info-section .text-info {
  color: #6cb2ff;
}
.mb-group-info-content {
  background-color: #1f1f1f;
  color: #e0e0e0;
  border: 1px solid #3a3a3a;
}`
              },
              // Kontextmenüs und Submenüs - mit !important für höhere Spezifität
              {
                id: Date.now() + 32,
                enabled: true,
                selector: '.context-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important',
                  'box-shadow': '0 4px 12px rgba(0, 0, 0, 0.5) !important'
                }
              },
              {
                id: Date.now() + 321,
                enabled: true,
                selector: '.mb-context-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important',
                  'box-shadow': '0 4px 12px rgba(0, 0, 0, 0.5) !important'
                }
              },
              {
                id: Date.now() + 3211,
                enabled: true,
                selector: '.context-menu ul',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': 'none !important'
                }
              },
              {
                id: Date.now() + 3212,
                enabled: true,
                selector: '.mb-context-menu ul',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': 'none !important'
                }
              },
              {
                id: Date.now() + 322,
                enabled: true,
                selector: '.context-menu ul li',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'background-color': 'transparent !important'
                }
              },
              {
                id: Date.now() + 323,
                enabled: true,
                selector: '.mb-context-menu li',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'background-color': 'transparent !important'
                }
              },
              {
                id: Date.now() + 324,
                enabled: true,
                selector: '.context-menu ul li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 325,
                enabled: true,
                selector: '.mb-context-menu li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 3251,
                enabled: true,
                selector: '.context-menu li.disabled',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#666666 !important',
                  'opacity': '0.5 !important'
                }
              },
              {
                id: Date.now() + 3252,
                enabled: true,
                selector: '.mb-context-menu li.disabled',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#666666 !important',
                  'opacity': '0.5 !important'
                }
              },
              {
                id: Date.now() + 326,
                enabled: true,
                selector: '.context-menu .separator',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-color': '#444 !important'
                }
              },
              {
                id: Date.now() + 3261,
                enabled: true,
                selector: '.mb-context-menu-separator',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top': '1px solid #444 !important'
                }
              },
              {
                id: Date.now() + 327,
                enabled: true,
                selector: '.context-submenu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important',
                  'box-shadow': '0 2px 8px rgba(0, 0, 0, 0.4) !important'
                }
              },
              {
                id: Date.now() + 328,
                enabled: true,
                selector: '.mb-context-submenu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important',
                  'box-shadow': '0 2px 8px rgba(0, 0, 0, 0.4) !important'
                }
              },
              {
                id: Date.now() + 329,
                enabled: true,
                selector: '.context-submenu li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 330,
                enabled: true,
                selector: '.mb-context-submenu li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 3301,
                enabled: true,
                selector: '.context-menu.context-menu-visible',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important'
                }
              },
              {
                id: Date.now() + 3302,
                enabled: true,
                selector: '.mb-context-menu.context-menu-visible',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important'
                }
              },
              {
                id: Date.now() + 3303,
                enabled: true,
                selector: '.context-menu .submenu',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'background-color': 'transparent !important'
                }
              },
              {
                id: Date.now() + 3304,
                enabled: true,
                selector: '.context-menu .submenu:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              // Toolbar Buttons
              {
                id: Date.now() + 33,
                enabled: true,
                selector: '.mb-toolbar .btn',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 331,
                enabled: true,
                selector: '.mb-toolbar .btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#444 !important',
                  'color': '#ffffff !important',
                  'border-color': '#555 !important',
                  'box-shadow': 'none !important'
                }
              },
              {
                id: Date.now() + 332,
                enabled: true,
                selector: '.mb-toolbar .btn:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important',
                  'border-color': '#555 !important',
                  'box-shadow': '0 0 0 0.2rem rgba(255, 255, 255, 0.1) !important'
                }
              },
              {
                id: Date.now() + 333,
                enabled: true,
                selector: '.mb-toolbar .btn:active',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'color': '#ffffff !important',
                  'border-color': '#444 !important'
                }
              },
              {
                id: Date.now() + 334,
                enabled: true,
                selector: '.btn-toolbar .btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#444 !important',
                  'color': '#ffffff !important',
                  'border-color': '#555 !important',
                  'box-shadow': 'none !important'
                }
              },
              {
                id: Date.now() + 335,
                enabled: true,
                selector: '.mb-tools .btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#444 !important',
                  'color': '#ffffff !important',
                  'border-color': '#555 !important',
                  'box-shadow': 'none !important'
                }
              },
              {
                id: Date.now() + 336,
                enabled: true,
                selector: '.mb-toolbar .btn-outline-secondary:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#444 !important',
                  'color': '#ffffff !important',
                  'border-color': '#555 !important'
                }
              },
              {
                id: Date.now() + 337,
                enabled: true,
                selector: '.mb-toolbar .btn-outline-primary:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a5f7d !important',
                  'color': '#ffffff !important',
                  'border-color': '#4a7f9d !important'
                }
              },
              {
                id: Date.now() + 338,
                enabled: true,
                selector: '.mb-toolbar .btn-success:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2d5a2d !important',
                  'color': '#ffffff !important',
                  'border-color': '#3d6a3d !important',
                  'box-shadow': 'none !important'
                }
              },
              {
                id: Date.now() + 339,
                enabled: true,
                selector: '.mb-toolbar .btn-danger:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#5a2d2d !important',
                  'color': '#ffffff !important',
                  'border-color': '#6a3d3d !important',
                  'box-shadow': 'none !important',
                  'opacity': '1 !important'
                }
              },
              // Keywords Bar
              {
                id: Date.now() + 34,
                enabled: true,
                selector: '.mb-keyword-bar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-top': '1px solid #333',
                  'border-bottom': '1px solid #333',
                  'padding': '8px 12px'
                }
              },
              {
                id: Date.now() + 341,
                enabled: true,
                selector: '.mb-keyword-label',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0',
                  'border': '1px solid #3a3a3a',
                  'border-right': 'none',
                  'padding': '6px 12px',
                  'font-weight': '600',
                  'font-size': '12px',
                  'letter-spacing': '0.5px'
                }
              },
              {
                id: Date.now() + 342,
                enabled: true,
                selector: '.mb-keyword-label:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333',
                  'border-color': '#4a9eff',
                  'border-right': 'none'
                }
              },
              {
                id: Date.now() + 343,
                enabled: true,
                selector: '.mb-keywords-cloud',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'padding': '12px',
                  'border-radius': '8px',
                  'margin': '8px 0'
                }
              },
              {
                id: Date.now() + 344,
                enabled: true,
                selector: '.keyword-container',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'border': '1px solid #3a3a3a',
                  'border-left': 'none',
                  'border-radius': '0 8px 8px 0'
                }
              },
              {
                id: Date.now() + 345,
                enabled: true,
                selector: '.mb-keyword-bar .keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a5f7d',
                  'color': '#e0e0e0',
                  'border': '1px solid #4a7f9d',
                  'margin': '2px'
                }
              },
              {
                id: Date.now() + 346,
                enabled: true,
                selector: '.mb-keyword-bar .keyword-badge:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a7f9d',
                  'transform': 'scale(1.05)'
                }
              },
              // Footer
              {
                id: Date.now() + 35,
                enabled: true,
                selector: 'footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1f1f1f',
                  'color': '#e0e0e0',
                  'border-top': '1px solid #444'
                },
                customCss: `footer a {
  color: #6cb2ff !important;
}
footer a:hover {
  color: #9cc9ff !important;
}`
              },
              // Global Options Dialog
              {
                id: Date.now() + 36,
                enabled: true,
                selector: '#optionsModal .modal-content',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 361,
                enabled: true,
                selector: '#optionsModal .modal-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-bottom': '1px solid #444'
                }
              },
              {
                id: Date.now() + 362,
                enabled: true,
                selector: '#optionsModal .modal-footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-top': '1px solid #444'
                }
              },
              {
                id: Date.now() + 363,
                enabled: true,
                selector: '#optionsModal .nav-tabs',
                groupId: null,
                linkId: null,
                properties: {
                  'border-bottom': '1px solid #444'
                }
              },
              {
                id: Date.now() + 364,
                enabled: true,
                selector: '#optionsModal .nav-link',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ca3af',
                  'background-color': 'transparent',
                  'border-color': 'transparent'
                }
              },
              {
                id: Date.now() + 365,
                enabled: true,
                selector: '#optionsModal .nav-link:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 366,
                enabled: true,
                selector: '#optionsModal .nav-link.active',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0',
                  'background-color': '#333',
                  'border-color': '#444 #444 #333'
                }
              },
              {
                id: Date.now() + 367,
                enabled: true,
                selector: '#optionsModal .form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 368,
                enabled: true,
                selector: '#optionsModal .form-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 369,
                enabled: true,
                selector: '#optionsModal .form-check-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 370,
                enabled: true,
                selector: '#optionsModal .form-check-input:checked',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a9eff',
                  'border-color': '#4a9eff'
                }
              },
              {
                id: Date.now() + 371,
                enabled: true,
                selector: '#optionsModal .list-group-item',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 372,
                enabled: true,
                selector: '#optionsModal .card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 373,
                enabled: true,
                selector: '#optionsModal .card-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'border-bottom': '1px solid #444'
                }
              },
              // Edit Dialogs (Group & Link)
              {
                id: Date.now() + 37,
                enabled: true,
                selector: '.mb-edit-modal-body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 371,
                enabled: true,
                selector: '.mb-edit-modal-title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f0f0f0',
                  'font-size': '1.25rem'
                }
              },
              {
                id: Date.now() + 372,
                enabled: true,
                selector: '.mb-edit-modal-footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-top': '1px solid #444',
                  'padding': '1rem'
                }
              },
              {
                id: Date.now() + 373,
                enabled: true,
                selector: '.mb-edit-filter-container',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#232323',
                  'padding': '0.75rem',
                  'border-radius': '0.25rem',
                  'margin-bottom': '1rem'
                }
              },
              {
                id: Date.now() + 374,
                enabled: true,
                selector: '.mb-edit-filter-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 375,
                enabled: true,
                selector: '.mb-edit-filter-input:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'border-color': '#4a9eff',
                  'box-shadow': '0 0 0 0.2rem rgba(74, 158, 255, 0.25)'
                }
              },
              {
                id: Date.now() + 376,
                enabled: true,
                selector: '.mb-edit-section',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border': '1px solid #3a3a3a',
                  'border-radius': '0.25rem',
                  'margin-bottom': '1rem'
                }
              },
              {
                id: Date.now() + 377,
                enabled: true,
                selector: '.mb-edit-section-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#f0f0f0',
                  'padding': '0.5rem 0.75rem',
                  'border-bottom': '1px solid #3a3a3a',
                  'font-weight': '500'
                }
              },
              {
                id: Date.now() + 378,
                enabled: true,
                selector: '.mb-edit-section-body',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '0.75rem',
                  'background-color': '#1f1f1f',
                  'border-radius': '0 0 0.25rem 0.25rem'
                }
              },
              {
                id: Date.now() + 379,
                enabled: true,
                selector: '.mb-edit-text-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 380,
                enabled: true,
                selector: '.mb-edit-url-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 381,
                enabled: true,
                selector: '.mb-edit-number-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 382,
                enabled: true,
                selector: '.mb-edit-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 383,
                enabled: true,
                selector: '.mb-edit-checkbox',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 384,
                enabled: true,
                selector: '.mb-edit-checkbox:checked',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a9eff',
                  'border-color': '#4a9eff'
                }
              },
              {
                id: Date.now() + 385,
                enabled: true,
                selector: '.mb-edit-save-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a9eff',
                  'border-color': '#3a8eef',
                  'color': '#fff'
                }
              },
              {
                id: Date.now() + 386,
                enabled: true,
                selector: '.mb-edit-save-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a8eef',
                  'border-color': '#2a7edf'
                }
              },
              {
                id: Date.now() + 387,
                enabled: true,
                selector: '.mb-edit-cancel-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#555',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 388,
                enabled: true,
                selector: '.mb-edit-cancel-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#666',
                  'border-color': '#555'
                }
              },
              {
                id: Date.now() + 389,
                enabled: true,
                selector: '.mb-edit-reset-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'transparent',
                  'border-color': '#666',
                  'color': '#aaa'
                }
              },
              {
                id: Date.now() + 390,
                enabled: true,
                selector: '.mb-edit-reset-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333',
                  'border-color': '#777',
                  'color': '#e0e0e0'
                }
              },
              // Search Bar Container
              {
                id: Date.now() + 391,
                enabled: true,
                selector: '.mb-toolbar__search',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'border-radius': '6px',
                  'padding': '4px'
                }
              },
              {
                id: Date.now() + 392,
                enabled: true,
                selector: '.mb-toolbar__search .form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 393,
                enabled: true,
                selector: '.mb-toolbar__search .form-control:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-color': '#4a9eff',
                  'box-shadow': '0 0 0 0.2rem rgba(74, 158, 255, 0.25)',
                  'color': '#f0f0f0'
                }
              },
              {
                id: Date.now() + 394,
                enabled: true,
                selector: '.mb-toolbar__search .input-group-text',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333',
                  'border-color': '#444',
                  'color': '#9ca3af'
                }
              },
              // Group Title Header Container Hover
              {
                id: Date.now() + 395,
                enabled: true,
                selector: '.groupContainerHeader:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #333b47 0%, #2d3440 100%)',
                  'transition': 'background 0.2s ease'
                }
              },
              {
                id: Date.now() + 396,
                enabled: true,
                selector: '.mb-group__header:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #333b47 0%, #2d3440 100%)',
                  'transition': 'background 0.2s ease'
                }
              },
              {
                id: Date.now() + 3961,
                enabled: true,
                selector: '.groupContainer.mb-group:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2c333d !important'
                }
              },
              {
                id: Date.now() + 3962,
                enabled: true,
                selector: '.groupContainer.mb-group:hover .mb-group__header',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #333b47 0%, #2d3440 100%) !important'
                }
              },
              {
                id: Date.now() + 3963,
                enabled: true,
                selector: '.groupContainer.mb-group:hover .mb-group__body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2b3139 !important'
                }
              },
              {
                id: Date.now() + 3964,
                enabled: true,
                selector: '.groupContainer.mb-group:hover .mb-group-resize-handle',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'transparent !important',
                  'border-top-color': 'transparent !important'
                }
              },
              {
                id: Date.now() + 3965,
                enabled: true,
                selector: '.groupContainer.mb-group:hover .mb-group-resize-handle::before',
                groupId: null,
                linkId: null,
                properties: {
                  'opacity': '0 !important'
                }
              },
              // Custom CSS Sidebar Containers
              {
                id: Date.now() + 397,
                enabled: true,
                selector: '.generated-css-section',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 398,
                enabled: true,
                selector: '.generated-css-section h6',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f0f0f0',
                  'border-bottom': '1px solid #333',
                  'padding-bottom': '8px',
                  'margin-bottom': '12px'
                }
              },
              {
                id: Date.now() + 399,
                enabled: true,
                selector: '.generated-css-section .css-output',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#0d0d0d',
                  'color': '#6cb2ff',
                  'border': '1px solid #333',
                  'padding': '12px',
                  'border-radius': '4px',
                  'font-family': 'Monaco, Menlo, Consolas, monospace'
                }
              },
              {
                id: Date.now() + 400,
                enabled: true,
                selector: '.selector-preview',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border': '1px solid #444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 401,
                enabled: true,
                selector: '.selector-preview code',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#6cb2ff',
                  'background-color': '#0d0d0d',
                  'padding': '4px 8px',
                  'border-radius': '3px',
                  'font-size': '13px'
                }
              },
              {
                id: Date.now() + 402,
                enabled: true,
                selector: '.selector-preview small',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ca3af'
                }
              },
              // Force dark mode for Bootstrap bg-light classes
              {
                id: Date.now() + 403,
                enabled: true,
                selector: '.generated-css-section.bg-light',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e !important',
                  'color': '#e0e0e0 !important'
                }
              },
              {
                id: Date.now() + 404,
                enabled: true,
                selector: '.selector-preview.bg-light',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e !important',
                  'color': '#e0e0e0 !important'
                }
              },
              {
                id: Date.now() + 405,
                enabled: true,
                selector: '.selector-preview .text-muted',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ca3af !important'
                }
              },
              // Keywords Bar and Cloud - More specific selectors
              {
                id: Date.now() + 406,
                enabled: true,
                selector: '.mb-keywords-cloud',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525 !important',
                  'padding': '12px',
                  'border-radius': '8px',
                  'margin': '8px 0'
                }
              },
              {
                id: Date.now() + 407,
                enabled: true,
                selector: '.mb-keywords-cloud .keyword-container',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #3a3a3a',
                  'border-radius': '0 8px 8px 0',
                  'padding': '4px 8px'
                }
              },
              {
                id: Date.now() + 408,
                enabled: true,
                selector: '.mb-keywords-cloud .mb-keyword-label',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333 !important',
                  'color': '#e0e0e0 !important',
                  'border': '1px solid #444',
                  'border-right': 'none'
                }
              },
              {
                id: Date.now() + 409,
                enabled: true,
                selector: '.mb-keywords-cloud .keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a5f7d !important',
                  'color': '#e0e0e0 !important',
                  'border': '1px solid #4a7f9d'
                }
              },
              {
                id: Date.now() + 410,
                enabled: true,
                selector: '.mb-keywords-cloud .keyword-badge:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a7f9d !important',
                  'color': '#fff !important',
                  'transform': 'scale(1.05)'
                }
              },
              // CSS Sidebar itself
              {
                id: Date.now() + 411,
                enabled: true,
                selector: '.mb-css-sidebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1a1a1a !important',
                  'color': '#e0e0e0',
                  'border-left': '2px solid #444'
                }
              },
              {
                id: Date.now() + 412,
                enabled: true,
                selector: '.mb-css-sidebar .css-rule-card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 413,
                enabled: true,
                selector: '.mb-css-sidebar .form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e !important',
                  'color': '#e0e0e0 !important',
                  'border-color': '#444 !important'
                }
              },
              {
                id: Date.now() + 414,
                enabled: true,
                selector: '.mb-css-sidebar .form-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e !important',
                  'color': '#e0e0e0 !important',
                  'border-color': '#444 !important'
                }
              },
              {
                id: Date.now() + 415,
                enabled: true,
                selector: '.mb-css-sidebar .btn-outline-secondary',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ca3af',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 416,
                enabled: true,
                selector: '.mb-css-sidebar .btn-outline-secondary:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333',
                  'color': '#e0e0e0',
                  'border-color': '#555'
                }
              },
              // Action Buttons - Make them white/light
              {
                id: Date.now() + 417,
                enabled: true,
                selector: '.mb-css-sidebar-close',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'background-color': 'transparent !important',
                  'opacity': '0.8'
                }
              },
              {
                id: Date.now() + 418,
                enabled: true,
                selector: '.mb-css-sidebar-close:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important',
                  'opacity': '1',
                  'transform': 'scale(1.1)'
                }
              },
              {
                id: Date.now() + 419,
                enabled: true,
                selector: '.mb-group-menu-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'fill': '#e0e0e0 !important',
                  'opacity': '0.7'
                }
              },
              {
                id: Date.now() + 420,
                enabled: true,
                selector: '.mb-group-menu-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important',
                  'fill': '#ffffff !important',
                  'opacity': '1',
                  'transform': 'scale(1.1)'
                }
              },
              {
                id: Date.now() + 421,
                enabled: true,
                selector: '.mb-link-menu-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'fill': '#e0e0e0 !important',
                  'opacity': '0.7'
                }
              },
              {
                id: Date.now() + 422,
                enabled: true,
                selector: '.mb-link-menu-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important',
                  'fill': '#ffffff !important',
                  'opacity': '1',
                  'transform': 'scale(1.1)'
                }
              },
              {
                id: Date.now() + 423,
                enabled: true,
                selector: '.mb-group-add-link-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'fill': '#e0e0e0 !important',
                  'opacity': '0.7'
                }
              },
              {
                id: Date.now() + 424,
                enabled: true,
                selector: '.mb-group-add-link-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#4a9eff !important',
                  'fill': '#4a9eff !important',
                  'opacity': '1',
                  'transform': 'scale(1.1)'
                }
              },
              // Other action icons
              {
                id: Date.now() + 425,
                enabled: true,
                selector: '.actionIcon',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#d0d0d0 !important',
                  'fill': '#d0d0d0 !important'
                }
              },
              {
                id: Date.now() + 426,
                enabled: true,
                selector: '.actionIcon:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important',
                  'fill': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 427,
                enabled: true,
                selector: '.actionIconLink',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#c0c0c0 !important',
                  'fill': '#c0c0c0 !important'
                }
              },
              {
                id: Date.now() + 428,
                enabled: true,
                selector: '.actionIconLink:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important',
                  'fill': '#ffffff !important'
                }
              },
              // Close button (X) in modals
              {
                id: Date.now() + 429,
                enabled: true,
                selector: '.btn-close',
                groupId: null,
                linkId: null,
                properties: {
                  'filter': 'invert(1) grayscale(100%) brightness(200%)',
                  'opacity': '0.8'
                }
              },
              {
                id: Date.now() + 430,
                enabled: true,
                selector: '.btn-close:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'opacity': '1'
                }
              },
              // Dropdown Menus and Submenus (Bootstrap overrides)
              {
                id: Date.now() + 431,
                enabled: true,
                selector: '.dropdown-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important',
                  'box-shadow': '0 4px 12px rgba(0, 0, 0, 0.5) !important'
                }
              },
              {
                id: Date.now() + 432,
                enabled: true,
                selector: '.dropdown-item',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'background-color': 'transparent !important'
                }
              },
              {
                id: Date.now() + 433,
                enabled: true,
                selector: '.dropdown-item:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 434,
                enabled: true,
                selector: '.dropdown-item:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important',
                  'outline': 'none !important'
                }
              },
              {
                id: Date.now() + 435,
                enabled: true,
                selector: '.dropdown-item:active',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a4a4a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 436,
                enabled: true,
                selector: '.dropdown-divider',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-color': '#444 !important'
                }
              },
              {
                id: Date.now() + 437,
                enabled: true,
                selector: '.dropdown-submenu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important'
                }
              },
              {
                id: Date.now() + 438,
                enabled: true,
                selector: '.dropdown-submenu .dropdown-item',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important'
                }
              },
              {
                id: Date.now() + 439,
                enabled: true,
                selector: '.dropdown-submenu .dropdown-item:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              // Snapshots dropdown specific
              {
                id: Date.now() + 440,
                enabled: true,
                selector: '.mb-snapshots-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important'
                }
              },
              {
                id: Date.now() + 441,
                enabled: true,
                selector: '.mb-snapshots-menu .dropdown-item',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important'
                }
              },
              {
                id: Date.now() + 442,
                enabled: true,
                selector: '.mb-snapshots-menu .dropdown-item:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important'
                }
              },
              // Context menu submenu arrows
              {
                id: Date.now() + 443,
                enabled: true,
                selector: '.context-menu .submenu::after',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ca3af !important'
                }
              },
              {
                id: Date.now() + 444,
                enabled: true,
                selector: '.context-menu .submenu:hover::after',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important'
                }
              },
              // Bootstrap dropdown toggle
              {
                id: Date.now() + 445,
                enabled: true,
                selector: '.dropdown-toggle',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important'
                }
              },
              {
                id: Date.now() + 446,
                enabled: true,
                selector: '.dropdown-toggle:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 447,
                enabled: true,
                selector: '.dropdown-toggle::after',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-color': '#e0e0e0 !important'
                }
              },
              // Harmonized dark foundation (shared selector set with minimal)
              {
                id: Date.now() + 500,
                enabled: true,
                selector: 'body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1f2329',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 501,
                enabled: true,
                selector: '.mb-app',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'transparent',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 502,
                enabled: true,
                selector: '.mb-titlebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #2b3139 0%, #252b33 100%)',
                  'border-bottom': '1px solid #3f4754'
                }
              },
              {
                id: Date.now() + 503,
                enabled: true,
                selector: '.mb-titlebar__title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f3f4f6',
                  'text-shadow': 'none'
                }
              },
              {
                id: Date.now() + 504,
                enabled: true,
                selector: '.mb-toolbar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038',
                  'border-bottom': '1px solid #3f4754'
                }
              },
              {
                id: Date.now() + 505,
                enabled: true,
                selector: '.mb-group',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2c333d',
                  'border': '1px solid #454f5e',
                  'border-radius': '10px'
                }
              },
              {
                id: Date.now() + 506,
                enabled: true,
                selector: '.mb-group__header',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #333b47 0%, #2d3440 100%)',
                  'border-bottom': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 507,
                enabled: true,
                selector: '.mb-group__body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2b3139'
                }
              },
              {
                id: Date.now() + 508,
                enabled: true,
                selector: '.mb-link',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 509,
                enabled: true,
                selector: '.mb-link:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#353d49'
                }
              },
              {
                id: Date.now() + 510,
                enabled: true,
                selector: '.mb-link__url',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#8fb8ff'
                }
              },
              {
                id: Date.now() + 511,
                enabled: true,
                selector: '.mb-modal',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038',
                  'color': '#e6e8eb',
                  'border': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 512,
                enabled: true,
                selector: '.modal-content',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038',
                  'color': '#e6e8eb',
                  'border': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 513,
                enabled: true,
                selector: '.modal-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#323a45',
                  'border-bottom': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 514,
                enabled: true,
                selector: '.modal-footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#323a45',
                  'border-top': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 515,
                enabled: true,
                selector: '.modal-body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 515_1,
                enabled: true,
                selector: '#shortcutManagerModal .mb-shortcut-manager-section',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2b323c',
                  'border-color': '#4a5565',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 515_2,
                enabled: true,
                selector: '#shortcutManagerModal .mb-shortcut-global-card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#242a32',
                  'border-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 515_3,
                enabled: true,
                selector: '#shortcutManagerModal .mb-shortcut-target-tree',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#242a32',
                  'border-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 515_4,
                enabled: true,
                selector: '#shortcutManagerModal .mb-shortcut-target-group',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 515_5,
                enabled: true,
                selector: '#shortcutManagerModal .mb-shortcut-manager-section .border-top',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-color': '#4a5565 !important'
                }
              },
              {
                id: Date.now() + 516,
                enabled: true,
                selector: '.form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#242a32',
                  'color': '#eef2f7',
                  'border-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 517,
                enabled: true,
                selector: '.form-control:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#282f38',
                  'color': '#f5f7fa',
                  'border-color': '#78a6ff',
                  'box-shadow': '0 0 0 0.2rem rgba(120, 166, 255, 0.25)'
                }
              },
              {
                id: Date.now() + 518,
                enabled: true,
                selector: '.form-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#242a32',
                  'color': '#eef2f7',
                  'border-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 519,
                enabled: true,
                selector: '.form-select:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#282f38',
                  'color': '#f5f7fa',
                  'border-color': '#78a6ff',
                  'box-shadow': '0 0 0 0.2rem rgba(120, 166, 255, 0.25)'
                }
              },
              {
                id: Date.now() + 520,
                enabled: true,
                selector: '.input-group-text',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#313844',
                  'color': '#c3c9d3',
                  'border-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 521,
                enabled: true,
                selector: '.form-check-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#242a32',
                  'border-color': '#5a6577'
                }
              },
              {
                id: Date.now() + 522,
                enabled: true,
                selector: '.form-check-input:checked',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#78a6ff',
                  'border-color': '#78a6ff'
                }
              },
              {
                id: Date.now() + 523,
                enabled: true,
                selector: '.table',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e5e7eb',
                  'border-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 524,
                enabled: true,
                selector: '.table th',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#323a45',
                  'color': '#d7dde7',
                  'border-bottom': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 525,
                enabled: true,
                selector: '.table td',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top': '1px solid #434d5d'
                }
              },
              {
                id: Date.now() + 5251,
                enabled: true,
                selector: '.mb-placeholder-table',
                groupId: null,
                linkId: null,
                properties: {
                  '--bs-table-bg': '#2a3038',
                  '--bs-table-color': '#e6e8eb',
                  '--bs-table-border-color': '#4a5565',
                  '--bs-table-striped-bg': '#2f3742',
                  '--bs-table-hover-bg': '#353d49',
                  '--bs-table-hover-color': '#f3f4f6'
                }
              },
              {
                id: Date.now() + 5252,
                enabled: true,
                selector: '.mb-placeholder-table > :not(caption) > * > *',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038',
                  'color': '#e6e8eb',
                  'border-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 5253,
                enabled: true,
                selector: '.mb-placeholder-table thead th',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#323a45',
                  'color': '#d7dde7',
                  'border-bottom': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 5254,
                enabled: true,
                selector: '.mb-placeholder-table .form-check-label',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#d7dde7'
                }
              },
              {
                id: Date.now() + 5255,
                enabled: true,
                selector: '.mb-placeholder-table code',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#b9d3ff',
                  'background-color': '#242a32',
                  'padding': '0.1rem 0.35rem',
                  'border-radius': '0.2rem'
                }
              },
              {
                id: Date.now() + 5256,
                enabled: true,
                selector: '.mb-placeholder-table .btn-link',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ec5ff'
                }
              },
              {
                id: Date.now() + 5257,
                enabled: true,
                selector: '.mb-placeholder-table .btn-link:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#c8e0ff'
                }
              },
              {
                id: Date.now() + 526,
                enabled: true,
                selector: '.table-hover tbody tr:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#353d49'
                }
              },
              {
                id: Date.now() + 527,
                enabled: true,
                selector: '.card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2b323c',
                  'border-color': '#4a5565',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 528,
                enabled: true,
                selector: '.card-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333b47',
                  'border-bottom': '1px solid #4a5565',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 529,
                enabled: true,
                selector: '.list-group-item',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038',
                  'color': '#e6e8eb',
                  'border-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 530,
                enabled: true,
                selector: '.dropdown-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2b323c !important',
                  'border': '1px solid #4a5565 !important'
                }
              },
              {
                id: Date.now() + 531,
                enabled: true,
                selector: '.dropdown-item',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e5e7eb !important'
                }
              },
              {
                id: Date.now() + 532,
                enabled: true,
                selector: '.dropdown-item:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a424f !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 533,
                enabled: true,
                selector: '.dropdown-divider',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-color': '#4a5565 !important'
                }
              },
              {
                id: Date.now() + 534,
                enabled: true,
                selector: '.mb-context-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2b323c !important',
                  'border': '1px solid #4a5565 !important',
                  'color': '#e6e8eb !important'
                }
              },
              {
                id: Date.now() + 535,
                enabled: true,
                selector: '.mb-context-menu-list > li',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 536,
                enabled: true,
                selector: '.mb-context-menu-list > li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a424f'
                }
              },
              {
                id: Date.now() + 537,
                enabled: true,
                selector: '.mb-context-submenu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2b323c !important',
                  'border': '1px solid #4a5565 !important'
                }
              },
              {
                id: Date.now() + 538,
                enabled: true,
                selector: '.mb-context-submenu > li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a424f'
                }
              },
              {
                id: Date.now() + 539,
                enabled: true,
                selector: '.mb-context-menu-separator',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 540,
                enabled: true,
                selector: '.alert-info',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#233547',
                  'color': '#c5d9f8',
                  'border-color': '#3f5d82'
                }
              },
              {
                id: Date.now() + 541,
                enabled: true,
                selector: '.alert-warning',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a3e26',
                  'color': '#f9e7b0',
                  'border-color': '#7b6741'
                }
              },
              {
                id: Date.now() + 542,
                enabled: true,
                selector: '.bg-light',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#313844 !important',
                  'color': '#e6e8eb !important'
                }
              },
              {
                id: Date.now() + 543,
                enabled: true,
                selector: '.bg-white',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038 !important',
                  'color': '#e6e8eb !important'
                }
              },
              {
                id: Date.now() + 544,
                enabled: true,
                selector: '.text-muted',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#a8b0bb !important'
                }
              },
              {
                id: Date.now() + 5441,
                enabled: true,
                selector: '.modal .form-text:not(.text-warning):not(.text-danger):not(.text-success):not(.text-info)',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#a8b0bb !important'
                }
              },
              {
                id: Date.now() + 5442,
                enabled: true,
                selector: '.modal .mb-edit-field-help:not(.text-warning):not(.text-danger):not(.text-success):not(.text-info)',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#a8b0bb !important'
                }
              },
              {
                id: Date.now() + 545,
                enabled: true,
                selector: '.mb-surface-panel',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2f3641',
                  'border-color': '#4a5565',
                  'color': '#e5e7eb'
                }
              },
              {
                id: Date.now() + 546,
                enabled: true,
                selector: '.mb-import-keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a4352 !important',
                  'color': '#e5e7eb !important',
                  'border': '1px solid #5a6577'
                }
              },
              {
                id: Date.now() + 547,
                enabled: true,
                selector: '.mb-bookmarklet-prefix',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#313844',
                  'color': '#c3c9d3',
                  'border-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 548,
                enabled: true,
                selector: '.mb-css-sidebar .css-rule-card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2b323c',
                  'border-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 549,
                enabled: true,
                selector: 'footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252b33',
                  'color': '#c2c9d4',
                  'border-top': '1px solid #454f5e'
                }
              },
              // Additional dark coverage for bright legacy UI elements
              {
                id: Date.now() + 550,
                enabled: true,
                selector: '.btn-outline-secondary',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2f3641 !important',
                  'color': '#d7dde7 !important',
                  'border-color': '#505b6b !important'
                }
              },
              {
                id: Date.now() + 551,
                enabled: true,
                selector: '.btn-outline-secondary:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3b4452 !important',
                  'color': '#f5f7fa !important',
                  'border-color': '#657284 !important'
                }
              },
              {
                id: Date.now() + 552,
                enabled: true,
                selector: '.btn-outline-secondary:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'box-shadow': '0 0 0 0.2rem rgba(120, 166, 255, 0.25) !important',
                  'border-color': '#78a6ff !important'
                }
              },
              {
                id: Date.now() + 553,
                enabled: true,
                selector: '.input-group-sm .form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#242a32 !important',
                  'color': '#eef2f7 !important',
                  'border-color': '#4a5565 !important'
                }
              },
              {
                id: Date.now() + 554,
                enabled: true,
                selector: '.input-group-sm .form-control:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#282f38 !important',
                  'color': '#f5f7fa !important',
                  'border-color': '#78a6ff !important',
                  'box-shadow': '0 0 0 0.2rem rgba(120, 166, 255, 0.25) !important'
                }
              },
              {
                id: Date.now() + 555,
                enabled: true,
                selector: '.input-group-sm .form-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#242a32 !important',
                  'color': '#eef2f7 !important',
                  'border-color': '#4a5565 !important'
                }
              },
              {
                id: Date.now() + 556,
                enabled: true,
                selector: '.input-group-sm .form-select:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#282f38 !important',
                  'color': '#f5f7fa !important',
                  'border-color': '#78a6ff !important',
                  'box-shadow': '0 0 0 0.2rem rgba(120, 166, 255, 0.25) !important'
                }
              },
              {
                id: Date.now() + 557,
                enabled: true,
                selector: '.input-group-sm .btn-outline-secondary',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#313844 !important',
                  'color': '#d7dde7 !important',
                  'border-color': '#505b6b !important'
                }
              },
              {
                id: Date.now() + 558,
                enabled: true,
                selector: '.input-group-sm .btn-outline-secondary:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3c4553 !important',
                  'color': '#ffffff !important',
                  'border-color': '#657284 !important'
                }
              },
              {
                id: Date.now() + 559,
                enabled: true,
                selector: '.addLinkContainer .form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#242a32 !important',
                  'color': '#eef2f7 !important',
                  'border-color': '#4a5565 !important'
                }
              },
              {
                id: Date.now() + 560,
                enabled: true,
                selector: '.addLinkContainer .form-control:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#282f38 !important',
                  'color': '#f5f7fa !important',
                  'border-color': '#78a6ff !important',
                  'box-shadow': '0 0 0 0.2rem rgba(120, 166, 255, 0.25) !important'
                }
              },
              {
                id: Date.now() + 561,
                enabled: true,
                selector: '.css-sidebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1f242c !important',
                  'border-left': '1px solid #454f5e',
                  'box-shadow': '-4px 0 14px rgba(0, 0, 0, 0.45)'
                }
              },
              {
                id: Date.now() + 562,
                enabled: true,
                selector: '.css-sidebar .sidebar-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2c333d !important',
                  'border-bottom': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 563,
                enabled: true,
                selector: '.css-sidebar .sidebar-top-section',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2b323c !important',
                  'border': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 564,
                enabled: true,
                selector: '.css-sidebar .sidebar-divider',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a424f !important'
                }
              },
              {
                id: Date.now() + 565,
                enabled: true,
                selector: '.css-sidebar .sidebar-divider::before',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#69778b !important'
                }
              },
              {
                id: Date.now() + 566,
                enabled: true,
                selector: '.css-sidebar .sidebar-divider:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#465061 !important'
                }
              },
              {
                id: Date.now() + 567,
                enabled: true,
                selector: '.css-sidebar .sidebar-bottom-section',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038 !important',
                  'border': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 568,
                enabled: true,
                selector: '.css-sidebar .editor-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#323a45 !important',
                  'border-bottom': '1px solid #4a5565',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 569,
                enabled: true,
                selector: '.css-sidebar .editor-content',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 570,
                enabled: true,
                selector: '.css-sidebar .sidebar-content',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 571,
                enabled: true,
                selector: '.css-sidebar-resize-handle::before',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#6f7c90 !important'
                }
              },
              {
                id: Date.now() + 572,
                enabled: true,
                selector: '.css-sidebar-resize-handle:hover::before',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#8ea4c4 !important'
                }
              },
              {
                id: Date.now() + 573,
                enabled: true,
                selector: '.feature-sidebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1f242c !important',
                  'border-left': '1px solid #454f5e',
                  'box-shadow': '-4px 0 14px rgba(0, 0, 0, 0.45)'
                }
              },
              {
                id: Date.now() + 574,
                enabled: true,
                selector: '.feature-sidebar .sidebar-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2c333d !important',
                  'border-bottom': '1px solid #4a5565',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 575,
                enabled: true,
                selector: '.feature-sidebar .sidebar-content',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038 !important',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 576,
                enabled: true,
                selector: '.feature-section-title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f3f4f6'
                }
              },
              {
                id: Date.now() + 577,
                enabled: true,
                selector: '.feature-list li strong',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 578,
                enabled: true,
                selector: '.options-section',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2b323c',
                  'border-color': '#4a5565'
                }
              },
              {
                id: Date.now() + 579,
                enabled: true,
                selector: '.options-section-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333b47',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 580,
                enabled: true,
                selector: '.options-section-header:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3b4452'
                }
              },
              {
                id: Date.now() + 581,
                enabled: true,
                selector: '.options-section-body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a3038',
                  'color': '#e6e8eb'
                }
              },
              {
                id: Date.now() + 582,
                enabled: true,
                selector: '.info-popup',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2b323c',
                  'color': '#e6e8eb',
                  'border': '1px solid #4a5565'
                }
              },
              {
                id: Date.now() + 583,
                enabled: true,
                selector: '.link-edit-favicon-placeholder',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#353d49 !important',
                  'border': '1px dashed #6b778a !important'
                }
              },
              {
                id: Date.now() + 584,
                enabled: true,
                selector: '.border',
                groupId: null,
                linkId: null,
                properties: {
                  'border-color': '#4a5565 !important'
                }
              },
              {
                id: Date.now() + 585,
                enabled: true,
                selector: '.toast-notification',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#2d3748',
                  'border': '1px solid #4a5565',
                  'box-shadow': '0 6px 18px rgba(0, 0, 0, 0.45)'
                }
              },
              {
                id: Date.now() + 586,
                enabled: true,
                selector: '.toast-title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f3f4f6'
                }
              },
              {
                id: Date.now() + 587,
                enabled: true,
                selector: '.toast-body',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#d1d7e0'
                }
              },
              {
                id: Date.now() + 588,
                enabled: true,
                selector: '.toast-close',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#c7cfdb'
                }
              },
              {
                id: Date.now() + 589,
                enabled: true,
                selector: '.toast-progress',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.15)'
                }
              },
              {
                id: Date.now() + 590,
                enabled: true,
                selector: '.linkContainerListItem a',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#b9d3ff !important'
                }
              },
              {
                id: Date.now() + 591,
                enabled: true,
                selector: '.linkContainerListItem:hover a',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#d7e7ff !important'
                }
              },
              {
                id: Date.now() + 592,
                enabled: true,
                selector: '.mb-link__anchor',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#b9d3ff !important'
                }
              },
              {
                id: Date.now() + 593,
                enabled: true,
                selector: '.mb-link__anchor:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#d7e7ff !important'
                }
              },
              {
                id: Date.now() + 594,
                enabled: true,
                selector: '.link-url-preview',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#aeb8c6 !important'
                }
              },
              {
                id: Date.now() + 595,
                enabled: true,
                selector: '.addLinkContainer',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(43, 50, 60, 0.95) 0%, rgba(38, 45, 54, 0.98) 100%) !important',
                  'border-top': '1px solid #4a5565 !important'
                }
              },
              {
                id: Date.now() + 596,
                enabled: true,
                selector: '.addLinkContainer:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(49, 57, 68, 0.98) 0%, rgba(43, 50, 60, 1) 100%) !important'
                }
              },
              {
                id: Date.now() + 597,
                enabled: true,
                selector: '.addLinkContainer::before',
                groupId: null,
                linkId: null,
                properties: {
                  'opacity': '0.55',
                  'background': 'linear-gradient(90deg, transparent 0%, rgba(142, 164, 196, 0.55) 50%, transparent 100%) !important'
                }
              },
              {
                id: Date.now() + 598,
                enabled: true,
                selector: '.addLinkContainer .btn-success',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3b82f6',
                  'border-color': '#3b82f6',
                  'color': '#ffffff'
                }
              },
              {
                id: Date.now() + 599,
                enabled: true,
                selector: '.addLinkContainer .btn-success:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2f6fd3',
                  'border-color': '#2f6fd3'
                }
              },
              {
                id: Date.now() + 600,
                enabled: true,
                selector: '.groupContainer::after',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(255, 255, 255, 0.06) 0%, rgba(255, 255, 255, 0.01) 100%)'
                }
              }
            ],
            'minimal': [
              // Groups kompakt
              {
                id: Date.now() + 1,
                enabled: true,
                selector: '.mb-group',
                groupId: null,
                linkId: null,
                properties: {
                  'margin-bottom': '4px',
                  'border-radius': '8px',
                  'border': '1px solid #e0e0e0'
                }
              },
              {
                id: Date.now() + 1_1,
                enabled: true,
                selector: '.mb-group__body',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-left-radius': '0',
                  'border-top-right-radius': '0',
                  'border-bottom-left-radius': '8px',
                  'border-bottom-right-radius': '8px'
                }
              },
              {
                id: Date.now() + 2,
                enabled: true,
                selector: '.mb-group__header',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '6px 10px',
                  'background': '#f8f9fa'
                }
              },
              // Links kompakt
              {
                id: Date.now() + 3,
                enabled: true,
                selector: '.mb-link',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '4px 10px'
                }
              },
              {
                id: Date.now() + 3_1,
                enabled: true,
                selector: '.link-detail-popover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#ffffff',
                  'color': '#212529',
                  'border': '1px solid #dee2e6',
                  'box-shadow': '0 18px 40px rgba(33, 37, 41, 0.08)'
                }
              },
              {
                id: Date.now() + 3_2,
                enabled: true,
                selector: '.link-detail-popover__badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#e9ecef',
                  'color': '#495057'
                }
              },
              {
                id: Date.now() + 3_3,
                enabled: true,
                selector: '.link-detail-popover__favicon',
                groupId: null,
                linkId: null,
                properties: {
                  'box-shadow': '0 2px 6px rgba(0, 0, 0, 0.08)'
                }
              },
              // Toolbar kompakt
              {
                id: Date.now() + 4,
                enabled: true,
                selector: '.mb-toolbar',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '8px'
                }
              },
              {
                id: Date.now() + 5,
                enabled: true,
                selector: '.mb-toolbar .btn',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '4px 8px',
                  'font-size': '13px'
                }
              },
              // Keywords klein
              {
                id: Date.now() + 6,
                enabled: true,
                selector: '.keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '4px 8px',
                  'font-size': '12px',
                  'background-color': '#e9ecef',
                  'color': '#212529',
                  'border': '1px solid #dee2e6'
                }
              },
              {
                id: Date.now() + 6_1,
                enabled: true,
                selector: '.mb-keyword-suggestions, .mb-keyword-suggestions--overlay',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'border': '1px solid #d9dee6',
                  'color': '#1f2933',
                  'box-shadow': '0 10px 20px rgba(31, 41, 51, 0.12)'
                }
              },
              {
                id: Date.now() + 6_2,
                enabled: true,
                selector: '.mb-keyword-suggestion',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'transparent',
                  'color': '#1f2933'
                }
              },
              {
                id: Date.now() + 6_21,
                enabled: true,
                selector: '.mb-keyword-suggestion + .mb-keyword-suggestion',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top': '1px solid #d9dee6'
                }
              },
              {
                id: Date.now() + 6_3,
                enabled: true,
                selector: '.mb-keyword-suggestion:hover, .mb-keyword-suggestion:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#eef3fa',
                  'color': '#111827'
                }
              },
              // Footer kompakt
              {
                id: Date.now() + 7,
                enabled: true,
                selector: 'footer',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '8px',
                  'font-size': '12px'
                }
              },
              // Duplicates dialog (ensure readable light styling)
              {
                id: Date.now() + 8,
                enabled: true,
                selector: '#duplicatesModal .card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'border': '1px solid #e0e0e0'
                }
              },
              {
                id: Date.now() + 9,
                enabled: true,
                selector: '#duplicatesModal .card-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f8f9fa',
                  'border-bottom': '1px solid #e9ecef'
                }
              },
              {
                id: Date.now() + 10,
                enabled: true,
                selector: '#duplicatesModal .list-group-item',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'color': '#212529',
                  'border-color': '#e9ecef'
                }
              },
              {
                id: Date.now() + 11,
                enabled: true,
                selector: '#duplicatesModal .badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#e9ecef',
                  'color': '#212529',
                  'border': '1px solid #dee2e6'
                }
              },
              // Harmonized minimal foundation (shared selector set with dark)
              {
                id: Date.now() + 100,
                enabled: true,
                selector: 'body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f4f6f8',
                  'color': '#1f2933'
                }
              },
              {
                id: Date.now() + 101,
                enabled: true,
                selector: '.mb-app',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'transparent',
                  'color': '#1f2933'
                }
              },
              {
                id: Date.now() + 102,
                enabled: true,
                selector: '.mb-titlebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #ffffff 0%, #f2f4f7 100%)',
                  'border-bottom': '1px solid #d9dee6'
                }
              },
              {
                id: Date.now() + 103,
                enabled: true,
                selector: '.mb-titlebar__title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#1f2933',
                  'text-shadow': 'none'
                }
              },
              {
                id: Date.now() + 104,
                enabled: true,
                selector: '.mb-toolbar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#fdfdfd',
                  'border-bottom': '1px solid #d9dee6'
                }
              },
              {
                id: Date.now() + 105,
                enabled: true,
                selector: '.mb-group',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'border': '1px solid #dce2ea',
                  'border-radius': '10px'
                }
              },
              {
                id: Date.now() + 106,
                enabled: true,
                selector: '.mb-group__header',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#f7f9fc',
                  'border-bottom': '1px solid #dce2ea'
                }
              },
              {
                id: Date.now() + 107,
                enabled: true,
                selector: '.mb-group__body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff'
                }
              },
              {
                id: Date.now() + 108,
                enabled: true,
                selector: '.mb-link',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#1f2933'
                }
              },
              {
                id: Date.now() + 109,
                enabled: true,
                selector: '.mb-link:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f3f6fb'
                }
              },
              {
                id: Date.now() + 110,
                enabled: true,
                selector: '.mb-link__url',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#1d4ed8'
                }
              },
              {
                id: Date.now() + 111,
                enabled: true,
                selector: '.mb-modal',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'color': '#1f2933',
                  'border': '1px solid #d9dee6'
                }
              },
              {
                id: Date.now() + 112,
                enabled: true,
                selector: '.modal-content',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'color': '#1f2933',
                  'border': '1px solid #d9dee6'
                }
              },
              {
                id: Date.now() + 113,
                enabled: true,
                selector: '.modal-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f7f9fc',
                  'border-bottom': '1px solid #d9dee6'
                }
              },
              {
                id: Date.now() + 114,
                enabled: true,
                selector: '.modal-footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f7f9fc',
                  'border-top': '1px solid #d9dee6'
                }
              },
              {
                id: Date.now() + 115,
                enabled: true,
                selector: '.modal-body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'color': '#1f2933'
                }
              },
              {
                id: Date.now() + 116,
                enabled: true,
                selector: '.form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'color': '#1f2933',
                  'border-color': '#c9d1dc'
                }
              },
              {
                id: Date.now() + 117,
                enabled: true,
                selector: '.form-control:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'color': '#111827',
                  'border-color': '#7aa2f7',
                  'box-shadow': '0 0 0 0.2rem rgba(122, 162, 247, 0.2)'
                }
              },
              {
                id: Date.now() + 118,
                enabled: true,
                selector: '.form-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'color': '#1f2933',
                  'border-color': '#c9d1dc'
                }
              },
              {
                id: Date.now() + 119,
                enabled: true,
                selector: '.form-select:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'color': '#111827',
                  'border-color': '#7aa2f7',
                  'box-shadow': '0 0 0 0.2rem rgba(122, 162, 247, 0.2)'
                }
              },
              {
                id: Date.now() + 120,
                enabled: true,
                selector: '.input-group-text',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f3f6fb',
                  'color': '#4b5563',
                  'border-color': '#c9d1dc'
                }
              },
              {
                id: Date.now() + 121,
                enabled: true,
                selector: '.form-check-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'border-color': '#9aa6b7'
                }
              },
              {
                id: Date.now() + 122,
                enabled: true,
                selector: '.form-check-input:checked',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2563eb',
                  'border-color': '#2563eb'
                }
              },
              {
                id: Date.now() + 123,
                enabled: true,
                selector: '.table',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#1f2933',
                  'border-color': '#d9dee6'
                }
              },
              {
                id: Date.now() + 124,
                enabled: true,
                selector: '.table th',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f5f7fb',
                  'color': '#374151',
                  'border-bottom': '1px solid #d9dee6'
                }
              },
              {
                id: Date.now() + 125,
                enabled: true,
                selector: '.table td',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top': '1px solid #e4e9f0'
                }
              },
              {
                id: Date.now() + 126,
                enabled: true,
                selector: '.table-hover tbody tr:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#eef3fa'
                }
              },
              {
                id: Date.now() + 127,
                enabled: true,
                selector: '.card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'border-color': '#d9dee6',
                  'color': '#1f2933'
                }
              },
              {
                id: Date.now() + 128,
                enabled: true,
                selector: '.card-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f7f9fc',
                  'border-bottom': '1px solid #d9dee6',
                  'color': '#1f2933'
                }
              },
              {
                id: Date.now() + 129,
                enabled: true,
                selector: '.list-group-item',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'color': '#1f2933',
                  'border-color': '#d9dee6'
                }
              },
              {
                id: Date.now() + 130,
                enabled: true,
                selector: '.dropdown-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'border': '1px solid #d9dee6'
                }
              },
              {
                id: Date.now() + 131,
                enabled: true,
                selector: '.dropdown-item',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#1f2933'
                }
              },
              {
                id: Date.now() + 132,
                enabled: true,
                selector: '.dropdown-item:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#eef3fa',
                  'color': '#111827'
                }
              },
              {
                id: Date.now() + 133,
                enabled: true,
                selector: '.dropdown-divider',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-color': '#d9dee6'
                }
              },
              {
                id: Date.now() + 134,
                enabled: true,
                selector: '.mb-context-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'border': '1px solid #d9dee6',
                  'color': '#1f2933'
                }
              },
              {
                id: Date.now() + 135,
                enabled: true,
                selector: '.mb-context-menu-list > li',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#1f2933'
                }
              },
              {
                id: Date.now() + 136,
                enabled: true,
                selector: '.mb-context-menu-list > li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#eef3fa'
                }
              },
              {
                id: Date.now() + 137,
                enabled: true,
                selector: '.mb-context-submenu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'border': '1px solid #d9dee6'
                }
              },
              {
                id: Date.now() + 138,
                enabled: true,
                selector: '.mb-context-submenu > li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#eef3fa'
                }
              },
              {
                id: Date.now() + 139,
                enabled: true,
                selector: '.mb-context-menu-separator',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top': '1px solid #d9dee6'
                }
              },
              {
                id: Date.now() + 140,
                enabled: true,
                selector: '.alert-info',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#e8f1ff',
                  'color': '#1e3a8a',
                  'border-color': '#bfd3ff'
                }
              },
              {
                id: Date.now() + 141,
                enabled: true,
                selector: '.alert-warning',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#fff8e6',
                  'color': '#8a5300',
                  'border-color': '#f1ddb0'
                }
              },
              {
                id: Date.now() + 142,
                enabled: true,
                selector: '.bg-light',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f5f7fa !important',
                  'color': '#1f2933 !important'
                }
              },
              {
                id: Date.now() + 143,
                enabled: true,
                selector: '.bg-white',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff !important',
                  'color': '#1f2933 !important'
                }
              },
              {
                id: Date.now() + 144,
                enabled: true,
                selector: '.text-muted',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#6b7280 !important'
                }
              },
              {
                id: Date.now() + 145,
                enabled: true,
                selector: '.mb-surface-panel',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f7f9fc',
                  'border-color': '#d9dee6',
                  'color': '#1f2933'
                }
              },
              {
                id: Date.now() + 146,
                enabled: true,
                selector: '.mb-import-keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#e5eaf2 !important',
                  'color': '#1f2933 !important',
                  'border': '1px solid #d1d8e3'
                }
              },
              {
                id: Date.now() + 147,
                enabled: true,
                selector: '.mb-bookmarklet-prefix',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f3f6fb',
                  'color': '#4b5563',
                  'border-color': '#c9d1dc'
                }
              },
              {
                id: Date.now() + 148,
                enabled: true,
                selector: '.mb-css-sidebar .css-rule-card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'border-color': '#d9dee6'
                }
              },
              {
                id: Date.now() + 149,
                enabled: true,
                selector: 'footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f7f9fc',
                  'color': '#4b5563',
                  'border-top': '1px solid #d9dee6'
                }
              }
            ],
            'colorful': [
              // Body mit Gradient Background
              {
                id: Date.now() + 1,
                enabled: true,
                selector: 'body',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(120deg, #a1c4fd 0%, #c2e9fb 100%)',
                  'min-height': '100vh',
                  'position': 'relative'
                }
              },
              {
                id: Date.now() + 2,
                enabled: true,
                selector: '.mb-app',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'transparent'
                }
              },
              // Title Bar mit Glaseffekt
              {
                id: Date.now() + 3,
                enabled: true,
                selector: '.mb-titlebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(255, 255, 255, 0.95) 100%)',
                  'backdrop-filter': 'blur(20px) saturate(180%)',
                  'border-bottom': 'none',
                  'box-shadow': '0 8px 32px rgba(31, 38, 135, 0.15)'
                }
              },
              {
                id: Date.now() + 4,
                enabled: true,
                selector: '.mb-titlebar__title',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f64f59 100%)',
                  '-webkit-background-clip': 'text',
                  '-webkit-text-fill-color': 'transparent',
                  'background-clip': 'text',
                  'font-weight': '700',
                  'letter-spacing': '-0.5px'
                }
              },
              // Groups mit Glaseffekt
              {
                id: Date.now() + 5,
                enabled: true,
                selector: '.mb-group',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.9)',
                  'backdrop-filter': 'blur(10px) saturate(150%)',
                  'border': '1px solid rgba(255, 255, 255, 0.8)',
                  'box-shadow': '0 4px 24px rgba(31, 38, 135, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08)',
                  'margin-bottom': '16px',
                  'border-radius': '16px',
                  'overflow': 'hidden',
                  'transition': 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
                }
              },
              {
                id: Date.now() + 5_1,
                enabled: true,
                selector: '.mb-group__body',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-left-radius': '0',
                  'border-top-right-radius': '0',
                  'border-bottom-left-radius': '16px',
                  'border-bottom-right-radius': '16px'
                }
              },
              {
                id: Date.now() + 6,
                enabled: true,
                selector: '.mb-group__header',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(161, 196, 253, 0.2) 0%, rgba(194, 233, 251, 0.2) 100%)',
                  'border-bottom': '1px solid rgba(255, 255, 255, 0.6)',
                  'padding': '12px 16px'
                }
              },
              {
                id: Date.now() + 7,
                enabled: true,
                selector: '.mb-group__title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#2d3561',
                  'font-weight': '600',
                  'font-size': '16px'
                }
              },
              // Links
              {
                id: Date.now() + 8,
                enabled: true,
                selector: '.mb-link',
                groupId: null,
                linkId: null,
                properties: {
                  'transition': 'all 0.2s ease',
                  'padding': '8px 16px'
                }
              },
              {
                id: Date.now() + 9,
                enabled: true,
                selector: '.mb-link__url',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#5e72e4',
                  'font-weight': '500',
                  'text-decoration': 'none',
                  'transition': 'all 0.2s ease'
                }
              },
              {
                id: Date.now() + 9_1,
                enabled: true,
                selector: '.link-detail-popover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.95)',
                  'color': '#1f2933',
                  'border': '1px solid rgba(255, 255, 255, 0.6)',
                  'box-shadow': '0 28px 60px rgba(58, 66, 125, 0.25)',
                  'backdrop-filter': 'blur(16px) saturate(160%)'
                }
              },
              {
                id: Date.now() + 9_2,
                enabled: true,
                selector: '.link-detail-popover__badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(102, 126, 234, 0.25)',
                  'color': '#3d3a7a'
                }
              },
              {
                id: Date.now() + 9_3,
                enabled: true,
                selector: '.link-detail-popover__favicon',
                groupId: null,
                linkId: null,
                properties: {
                  'box-shadow': '0 4px 12px rgba(95, 111, 255, 0.35)'
                }
              },
              // Keywords mit Gradient
              {
                id: Date.now() + 10,
                enabled: true,
                selector: '.keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  'color': 'white',
                  'border': 'none',
                  'padding': '4px 10px',
                  'border-radius': '20px',
                  'font-size': '11px',
                  'font-weight': '600',
                  'letter-spacing': '0.3px',
                  'transition': 'all 0.2s ease'
                }
              },
              {
                id: Date.now() + 10_1,
                enabled: true,
                selector: '.mb-keyword-suggestions, .mb-keyword-suggestions--overlay',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.96)',
                  'border': '1px solid rgba(102, 126, 234, 0.25)',
                  'color': '#2d3561',
                  'box-shadow': '0 14px 30px rgba(95, 111, 255, 0.22)',
                  'backdrop-filter': 'blur(10px) saturate(140%)'
                }
              },
              {
                id: Date.now() + 10_2,
                enabled: true,
                selector: '.mb-keyword-suggestion',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'transparent',
                  'color': '#2d3561'
                }
              },
              {
                id: Date.now() + 10_21,
                enabled: true,
                selector: '.mb-keyword-suggestion + .mb-keyword-suggestion',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top': '1px solid rgba(102, 126, 234, 0.22)'
                }
              },
              {
                id: Date.now() + 10_3,
                enabled: true,
                selector: '.mb-keyword-suggestion:hover, .mb-keyword-suggestion:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(102, 126, 234, 0.16) 0%, rgba(118, 75, 162, 0.16) 100%)',
                  'color': '#1f244a'
                }
              },
              // Buttons mit Gradient
              {
                id: Date.now() + 11,
                enabled: true,
                selector: '.btn',
                groupId: null,
                linkId: null,
                properties: {
                  'border-radius': '8px',
                  'font-weight': '500',
                  'transition': 'all 0.2s ease',
                  'text-transform': 'none',
                  'letter-spacing': '0.2px'
                }
              },
              {
                id: Date.now() + 12,
                enabled: true,
                selector: '.btn-primary',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  'border': 'none',
                  'color': 'white',
                  'box-shadow': '0 4px 12px rgba(102, 126, 234, 0.25)'
                }
              },
              {
                id: Date.now() + 13,
                enabled: true,
                selector: '.btn-success',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
                  'border': 'none',
                  'color': 'white'
                }
              },
              {
                id: Date.now() + 14,
                enabled: true,
                selector: '.btn-danger',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #eb3349 0%, #f45c43 100%)',
                  'border': 'none',
                  'color': 'white'
                }
              },
              // Toolbar
              {
                id: Date.now() + 15,
                enabled: true,
                selector: '.mb-toolbar',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(255, 255, 255, 0.95) 100%)',
                  'backdrop-filter': 'blur(20px) saturate(150%)',
                  'border-bottom': '1px solid rgba(255, 255, 255, 0.8)',
                  'box-shadow': '0 2px 8px rgba(0, 0, 0, 0.04)',
                  'padding': '12px'
                }
              },
              // Forms
              {
                id: Date.now() + 16,
                enabled: true,
                selector: '.form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.9)',
                  'border': '1px solid rgba(102, 126, 234, 0.2)',
                  'border-radius': '8px',
                  'color': '#2d3561',
                  'transition': 'all 0.2s ease'
                }
              },
              {
                id: Date.now() + 17,
                enabled: true,
                selector: '.form-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.9)',
                  'border': '1px solid rgba(102, 126, 234, 0.2)',
                  'border-radius': '8px',
                  'color': '#2d3561',
                  'transition': 'all 0.2s ease'
                }
              },
              // Modals
              {
                id: Date.now() + 18,
                enabled: true,
                selector: '.modal-content',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.98)',
                  'backdrop-filter': 'blur(20px)',
                  'border': 'none',
                  'border-radius': '16px',
                  'box-shadow': '0 20px 60px rgba(0, 0, 0, 0.15)'
                }
              },
              {
                id: Date.now() + 19,
                enabled: true,
                selector: '.modal-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%)',
                  'border-bottom': '1px solid rgba(102, 126, 234, 0.1)',
                  'border-radius': '16px 16px 0 0'
                }
              },
              {
                id: Date.now() + 20,
                enabled: true,
                selector: '.modal-footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(0, 0, 0, 0.02)',
                  'border-top': '1px solid rgba(102, 126, 234, 0.1)',
                  'border-radius': '0 0 16px 16px'
                }
              }
            ],
          };

          return templates[this.selectedVisualTemplate] || [];
        },

        loadVisualTemplate() {
          // Just change the template, don't modify any rules
          // Template serves as base layer, user rules stay intact
          this.syncVisualCssStateToOptions(false);
          this.syncVisualCssStateToLocalStorage();
          // Apply CSS with new template as base layer
          this.applyVisualCss();
        },

        // Toast Notification Helper
        showToast(message, type = 'success') {
          // Use global toast function
          if (window.showAppToast) {
            window.showAppToast(message, type);
          }
        },

        // Rule Set Management Methods
        saveRuleSet() {
          const name = prompt(this.getTranslation('css.visual.ruleSetName') || 'Name für Regel-Satz:');
          if (!name) return;
          this.normalizeAllVisualRules();

          // Save current rules to custom sets (without template)
          this.customRuleSets[name] = {
            name: name,
            rules: JSON.parse(JSON.stringify(this.visualCssRules)),
            createdAt: Date.now()
          };

          // Save to localStorage
          localStorage.setItem('customRuleSets', JSON.stringify(this.customRuleSets));

          // Reset selection to the saved set
          this.selectedRuleSetName = name;
          this.syncVisualCssStateToOptions(true);
          this.syncVisualCssStateToLocalStorage();

          this.showToast(this.getTranslation('css.visual.ruleSetSaved') || 'Regel-Satz gespeichert!', 'success');
        },

        loadRuleSet(name) {
          if (!this.customRuleSets[name]) return;

          const ruleSet = this.customRuleSets[name];

          // Load the rules (template stays as it was)
          this.visualCssRules = JSON.parse(JSON.stringify(ruleSet.rules || []))
            .map((rule) => this.normalizeVisualRule(rule));

          // Save and apply
          this.saveVisualCss();

          this.showToast(this.getTranslation('css.visual.ruleSetLoaded') || 'Regel-Satz geladen', 'success');
        },

        deleteRuleSet(name) {
          if (!this.customRuleSets[name]) return;

          if (!confirm(this.getTranslation('css.visual.deleteRuleSetConfirm') || 'Möchten Sie den Regel-Satz "' + name + '" wirklich löschen?')) {
            return;
          }

          delete this.customRuleSets[name];

          // Clear selection
          if (this.selectedRuleSetName === name) {
            this.selectedRuleSetName = null;
          }

          // Save to localStorage
          localStorage.setItem('customRuleSets', JSON.stringify(this.customRuleSets));
          this.syncVisualCssStateToOptions(true);
          this.syncVisualCssStateToLocalStorage();

          this.showToast(this.getTranslation('css.visual.ruleSetDeleted') || 'Regel-Satz gelöscht', 'success');
        },

        loadCustomRuleSets() {
          const visualCssOptions = this.ensureVisualCssOptions();
          const optionStateVersion = parseInt(visualCssOptions.stateVersion, 10);
          const hasPersistedVisualCssState = Number.isFinite(optionStateVersion) && optionStateVersion >= 1;

          if (hasPersistedVisualCssState) {
            const optionRuleSets = (visualCssOptions.customRuleSets && typeof visualCssOptions.customRuleSets === 'object' && !Array.isArray(visualCssOptions.customRuleSets))
              ? visualCssOptions.customRuleSets
              : {};
            this.customRuleSets = JSON.parse(JSON.stringify(optionRuleSets));
          } else {
            // Load saved rule sets from localStorage (legacy)
            const saved = localStorage.getItem('customRuleSets');
            if (saved) {
              try {
                this.customRuleSets = JSON.parse(saved);
              } catch (e) {
                debugLog('error', 'Failed to load custom rule sets:', e);
                this.customRuleSets = {};
              }
            } else {
              this.customRuleSets = {};
            }
          }
          this.syncVisualCssStateToOptions(this.dataLoaded === true);
          this.syncVisualCssStateToLocalStorage();
        },

        openFeatureSidebar() {
          this.featureSidebarVisible = true;
        },
        
        saveCssTemplate() {
          if (!this.newTemplateName.trim()) return;
          
          // Initialize templates array if needed
          if (!this.data.options) this.$set(this.data, 'options', {});
          if (!this.data.options.cssTemplates) this.$set(this.data.options, 'cssTemplates', []);
          
          // Generate unique ID
          const templateId = 'tpl_' + Date.now();
          
          // Create new template
          const newTemplate = {
            id: templateId,
            name: this.newTemplateName.trim(),
            css: this.customCssDraft || '',
            createdAt: new Date().toISOString()
          };
          
          // Check if template with same name exists
          const existingIndex = this.data.options.cssTemplates.findIndex(t => t.name === newTemplate.name);
          if (existingIndex >= 0) {
            // Replace existing template
            const confirmMsg = this.getTranslation('css.templates.overwriteConfirm', [newTemplate.name])
              .replace('{0}', newTemplate.name);
            if (confirm(confirmMsg)) {
              this.$set(this.data.options.cssTemplates, existingIndex, newTemplate);
            } else {
              return;
            }
          } else {
            // Add new template
            this.data.options.cssTemplates.push(newTemplate);
          }
          
          // Update local list
          this.cssTemplates = [...this.data.options.cssTemplates];
          
          // Save to storage
          this.saveData();
          
          // Reset dialog
          this.showSaveTemplateDialog = false;
          this.newTemplateName = '';
          
          // Select the new template
          this.selectedTemplateId = templateId;
          
          // Show success notification
          // Template saved
          debugLog('log', 'CSS Template saved:', newTemplate.name);
        },
        
        loadCssTemplate() {
          if (!this.selectedTemplateId) {
            // Clear selection
            this.customCssDraft = '';
            this.applyCustomCss('');
            return;
          }
          
          // Find selected template
          const template = this.cssTemplates.find(t => t.id === this.selectedTemplateId);
          if (template) {
            this.customCssDraft = template.css;
            this.applyCustomCss(template.css);
            
            // Log template loading
            debugLog('log', 'CSS Template loaded:', template.name);
          }
        },
        
        // CSS Sidebar resize methods
        getCssSidebarContainerHeight() {
          const container = this.$refs?.cssSidebarSplitContainer;
          if (container && Number.isFinite(container.clientHeight) && container.clientHeight > 0) {
            return container.clientHeight;
          }
          return Math.max(420, window.innerHeight - 100);
        },
        clampCssSidebarTopHeight() {
          const containerHeight = this.getCssSidebarContainerHeight();
          const minTop = 180;
          const minBottom = 180;
          const maxTop = Math.max(minTop, containerHeight - minBottom - 8);
          const next = Number.isFinite(this.cssSidebarTopHeight) ? this.cssSidebarTopHeight : Math.round(containerHeight * (2 / 3));
          this.cssSidebarTopHeight = Math.min(Math.max(next, minTop), maxTop);
        },
        startCssSidebarResize(event) {
          this.isCssSidebarResizing = true;
          this.clampCssSidebarTopHeight();
          this.cssSidebarStartY = event.clientY;
          this.cssSidebarStartHeight = this.cssSidebarTopHeight;
          
          // Add event listeners
          document.addEventListener('mousemove', this.handleCssSidebarResize);
          document.addEventListener('mouseup', this.endCssSidebarResize);
          
          // Prevent text selection during resize
          event.preventDefault();
        },
        
        handleCssSidebarResize(event) {
          if (!this.isCssSidebarResizing) return;
          
          const deltaY = event.clientY - this.cssSidebarStartY;
          const newHeight = this.cssSidebarStartHeight + deltaY;
          this.cssSidebarTopHeight = newHeight;
          this.clampCssSidebarTopHeight();
        },
        
        endCssSidebarResize() {
          this.isCssSidebarResizing = false;
          this.clampCssSidebarTopHeight();
          
          // Remove event listeners
          document.removeEventListener('mousemove', this.handleCssSidebarResize);
          document.removeEventListener('mouseup', this.endCssSidebarResize);
          
          // Save the height to localStorage
          localStorage.setItem('cssSidebarTopHeight', this.cssSidebarTopHeight.toString());
          this.syncVisualCssStateToOptions(true);
          this.syncVisualCssStateToLocalStorage();
        },
        
        // CSS Sidebar Width Resize Methods
        startCssSidebarWidthResize(event) {
          this.isCssSidebarWidthResizing = true;
          this.cssSidebarStartX = event.clientX;
          this.cssSidebarStartWidth = this.cssSidebarWidth;
          
          // Add event listeners
          document.addEventListener('mousemove', this.handleCssSidebarWidthResize);
          document.addEventListener('mouseup', this.endCssSidebarWidthResize);
          
          // Prevent text selection during resize
          event.preventDefault();
        },
        
        handleCssSidebarWidthResize(event) {
          if (!this.isCssSidebarWidthResizing) return;

          const deltaX = this.cssSidebarStartX - event.clientX; // Negative because we're resizing from the left edge
          const newWidth = this.cssSidebarStartWidth + deltaX;

          // Constrain width between 300px and 80% of window width
          const minWidth = 300;
          const maxWidth = window.innerWidth * 0.8;

          this.cssSidebarWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);

          // Update body margin when resizing
          if (document.body.classList.contains('css-sidebar-open')) {
            document.body.style.marginRight = this.cssSidebarWidth + 'px';
          }
        },
        
        endCssSidebarWidthResize() {
          this.isCssSidebarWidthResizing = false;
          
          // Remove event listeners
          document.removeEventListener('mousemove', this.handleCssSidebarWidthResize);
          document.removeEventListener('mouseup', this.endCssSidebarWidthResize);
          
          // Save the width to localStorage
          localStorage.setItem('cssSidebarWidth', this.cssSidebarWidth.toString());
          this.syncVisualCssStateToOptions(true);
          this.syncVisualCssStateToLocalStorage();
        },
        applyCustomCssFromTextarea(reset) {
          if (reset) {
            this.customCssDraft = '';
          }
          this.applyCustomCss(this.customCssDraft || '');
          // Force re-render of keywords to apply new gradient colors
          this.$forceUpdate();
        },
        saveCustomCss() {
          if (!this.data.options) this.$set(this.data, 'options', {});
          this.$set(this.data.options, 'customCss', this.customCssDraft || '');
          this.saveData();
          // Don't close sidebar - user may want to continue editing
        },
        revertCustomCss() {
          this.customCssDraft = this.data.options?.customCss || '';
          this.applyCustomCss(this.customCssDraft);
          // Don't close sidebar - user may want to continue editing
        },
        appendHook(sel) {
          try {
            const snippet = `${sel} {\n  \n}\n`;
            this.customCssDraft = (this.customCssDraft && this.customCssDraft.trim().length)
              ? (this.customCssDraft.replace(/\s*$/, '') + "\n\n" + snippet)
              : snippet;
            this.applyCustomCssFromTextarea(false);
          } catch (e) { debugLog('warn', 'appendHook failed', e); }
        },

        // Insert CSS Hooks for quick styling
        insertCssHooks(hookType) {
          let hooks = '';
          let selectors = [];

          switch(hookType) {
            case 'sidebar':
              selectors = [
                '.mb-css-sidebar',
                '.css-sidebar-resize-handle',
                '.mb-css-sidebar-header',
                '.mb-css-sidebar-title',
                '.sidebar-split-container',
                '.sidebar-top-section',
                '.mb-css-sidebar-help-content',
                '.sidebar-divider',
                '.sidebar-bottom-section',
                '.editor-header',
                '.mb-css-editor'
              ];
              hooks = `/* CSS Sidebar Styling */\n`;
              break;
            case 'groups':
              selectors = [
                '.groupContainer',
                '.groupContainerHeader',
                '.groupTitle',
                '.groupLinkCount',
                '.mb-group-info-section'
              ];
              hooks = `/* Group Styling */\n`;
              break;
            case 'links':
              selectors = [
                '.linkContainer',
                '.linkContainerListItem',
                '.linkText',
                '.linkText a',
                '.link-favicon'
              ];
              hooks = `/* Link Styling */\n`;
              break;
            case 'toolbar':
              selectors = [
                '.mb-toolbar',
                '.btn-toolbar',
                '.mb-toolbar__search',
                '.mb-toolbar__search input'
              ];
              hooks = `/* Toolbar Styling */\n`;
              break;
            case 'menus':
              selectors = [
                '.mb-context-menu',
                '.mb-context-menu ul',
                '.mb-context-menu ul li',
                '.mb-context-menu-separator',
                '.mb-context-submenu',
                '.mb-context-submenu-item',
                '.mb-context-submenu::after'
              ];
              hooks = `/* Context Menus Styling */\n`;
              break;
            case 'feature-sidebar':
              selectors = [
                '.mb-feature-sidebar',
                '.mb-feature-sidebar-header',
                '.mb-feature-sidebar-title',
                '.mb-feature-sidebar-content',
                '.feature-section',
                '.feature-card'
              ];
              hooks = `/* Feature Sidebar Styling */\n`;
              break;
            case 'all':
              return this.insertCssHooks('sidebar') + '\n' +
                     this.insertCssHooks('groups') + '\n' +
                     this.insertCssHooks('links') + '\n' +
                     this.insertCssHooks('toolbar') + '\n' +
                     this.insertCssHooks('menus') + '\n' +
                     this.insertCssHooks('feature-sidebar');
          }

          // Generate CSS rules with placeholders
          selectors.forEach(sel => {
            hooks += `${sel} {\n  /* Add your styles here */\n}\n\n`;
          });

          return hooks;
        },

        // Quick insert CSS hooks via button
        quickInsertCssHooks(hookType) {
          const hooks = this.insertCssHooks(hookType);
          if (hooks) {
            // Insert at cursor or append to end
            const textarea = this.$refs.cssTextarea;
            if (textarea) {
              const start = textarea.selectionStart;
              const end = textarea.selectionEnd;
              const text = this.customCssDraft || '';

              // Insert hooks at cursor position
              this.customCssDraft = text.substring(0, start) + hooks + text.substring(end);

              // Apply the CSS
              this.applyCustomCssFromTextarea(false);

              // Restore cursor position after Vue updates the textarea
              this.$nextTick(() => {
                textarea.focus();
                const newPosition = start + hooks.length;
                textarea.setSelectionRange(newPosition, newPosition);
              });
            } else {
              // Fallback: append to end
              this.customCssDraft = (this.customCssDraft || '') + '\n\n' + hooks;
              this.applyCustomCssFromTextarea(false);
            }
          }
        },
        
        insertCssSelector(event) {
          const selector = event.target.value;
          if (!selector) return;
          
          // Clean up selector for placeholders
          let cleanSelector = selector;
          if (selector.includes('...')) {
            // Replace placeholders with example values or prompt user
            if (selector.includes('uuid-...')) {
              cleanSelector = selector.replace('...', 'YOUR-UUID-HERE');
            } else if (selector.includes("data-keyword='...'")) {
              cleanSelector = selector.replace('...', 'your-keyword');
            } else if (selector.includes("data-group-uuid='...'")) {
              cleanSelector = selector.replace('...', 'YOUR-GROUP-UUID');
            } else if (selector.includes("data-link-uuid='...'")) {
              cleanSelector = selector.replace('...', 'YOUR-LINK-UUID');
            } else if (selector.includes("data-link-count='5'")) {
              // This one is already specific, no change needed
            } else if (selector.includes('mb-keyword-kw-...')) {
              cleanSelector = selector.replace('...', 'your-keyword');
            }
          }
          
          // Check if selector already exists in the CSS
          const currentCss = this.customCssDraft || '';
          const textarea = this.$refs.cssTextarea;
          
          // Create regex to find the selector (escape special characters)
          const escapedSelector = cleanSelector.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const selectorRegex = new RegExp(`^\\s*${escapedSelector}\\s*\\{`, 'gm');
          const existingMatch = selectorRegex.exec(currentCss);
          
          if (existingMatch) {
            // Selector already exists - jump to it
            if (textarea) {
              // Find the line number and position
              const position = existingMatch.index;
              
              // Set cursor position to the existing selector
              textarea.selectionStart = position;
              textarea.selectionEnd = position + existingMatch[0].length;
              textarea.focus();
              
              // Scroll to make it visible
              const lineHeight = parseInt(window.getComputedStyle(textarea).lineHeight);
              const lines = currentCss.substring(0, position).split('\n').length - 1;
              textarea.scrollTop = lines * lineHeight - (textarea.clientHeight / 2);
              
              // Sync the highlighted container
              this.syncScroll();
              
              // Selector already exists
              debugLog('log', this.getTranslation('css.selectorExists') || 'CSS selector already exists! Jumped to line.');
            }
            
            // Reset dropdown
            event.target.value = '';
            return;
          }
          
          // Always add comments for complex selectors
          let snippet;
          const parts = cleanSelector.match(/(\.[a-zA-Z-]+|\[[^\]]+\])/g);
          
          // Always add comments for better readability
          if (parts && parts.length >= 1) {
            // Create a commented version for readability
            let comments = '/* ';
            const commentParts = [];
            
            parts.forEach((part, i) => {
              if (part.includes('data-group-uuid')) {
                // Extract UUID and find group name
                const uuidMatch = part.match(/data-group-uuid=['"]([^'"]+)['"]/);
                if (uuidMatch) {
                  const uuid = uuidMatch[1];
                  const group = this.data.groups?.find(g => g.uuid === uuid);
                  const groupName = group ? group.name : 'Unknown';
                  commentParts.push(`Group: ${groupName}`);
                }
              } else if (part.includes('data-link-uuid')) {
                // Extract UUID and find link name
                const uuidMatch = part.match(/data-link-uuid=['"]([^'"]+)['"]/);
                if (uuidMatch) {
                  const uuid = uuidMatch[1];
                  let linkName = 'Unknown';
                  // Search through all groups for the link
                  if (this.data.groups) {
                    for (const group of this.data.groups) {
                      const link = group.links?.find(l => l.uuid === uuid);
                      if (link) {
                        linkName = link.text || link.url;
                        break;
                      }
                    }
                  }
                  commentParts.push(`Link: ${linkName.substring(0, 25)}${linkName.length > 25 ? '...' : ''}`);
                }
              } else if (part.includes('data-keyword')) {
                const keywordMatch = part.match(/data-keyword=['"]([^'"]+)['"]/);
                if (keywordMatch) {
                  commentParts.push(`Keyword: ${keywordMatch[1]}`);
                }
              } else if (part.includes('data-link-count')) {
                const countMatch = part.match(/data-link-count=['"]([^'"]+)['"]/);
                if (countMatch) {
                  commentParts.push(`Count: ${countMatch[1]}`);
                }
              }
            });
            
            if (commentParts.length > 0) {
              comments += commentParts.join(' → ') + ' */\n';
              snippet = `${comments}${cleanSelector} {\n  \n}\n`;
            } else {
              snippet = `${cleanSelector} {\n  \n}\n`;
            }
          } else {
            snippet = `${cleanSelector} {\n  \n}\n`;
          }
          
          // Add to CSS draft
          if (this.$refs.cssTextarea) {
            const textarea = this.$refs.cssTextarea;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = this.customCssDraft || '';
            
            // If cursor is at a position, insert there
            if (start !== undefined && end !== undefined) {
              this.customCssDraft = text.substring(0, start) + snippet + text.substring(end);
              // Set cursor position inside the new rule
              this.$nextTick(() => {
                const newPos = start + cleanSelector.length + 3; // Position after " {\n  "
                textarea.selectionStart = newPos;
                textarea.selectionEnd = newPos;
                textarea.focus();
              });
            } else {
              // Otherwise append at the end
              this.customCssDraft = (text && text.trim().length)
                ? (text.replace(/\s*$/, '') + "\n\n" + snippet)
                : snippet;
            }
          } else {
            // Fallback if textarea ref not available
            this.customCssDraft = (this.customCssDraft && this.customCssDraft.trim().length)
              ? (this.customCssDraft.replace(/\s*$/, '') + "\n\n" + snippet)
              : snippet;
          }
          
          // Apply the CSS
          this.applyCustomCssFromTextarea(false);
          
          // Reset dropdown
          event.target.value = '';
        },
        
        // Insert selected color at cursor position in CSS editor
        insertColorAtCursor() {
          try {
            const textarea = this.$refs.cssTextarea;
            if (!textarea || !this.selectedColor) return;
            
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = this.customCssDraft || '';
            
            // Insert color at cursor position or replace selection
            const before = text.substring(0, start);
            const after = text.substring(end);
            
            // Format the color value
            const colorValue = this.selectedColor;
            
            // Update the text
            this.customCssDraft = before + colorValue + after;
            
            // Apply the CSS
            this.applyCustomCssFromTextarea(false);
            
            // Restore cursor position after Vue updates the textarea
            this.$nextTick(() => {
              textarea.focus();
              const newPosition = start + colorValue.length;
              textarea.setSelectionRange(newPosition, newPosition);
            });
          } catch (e) {
            debugLog('warn', 'Error inserting color:', e);
          }
        },
        
        // Handle CSS input and trigger highlighting
        onCssInput() {
          this.applyCustomCssFromTextarea(false);
          // Force Vue to update the highlighted display
          this.$forceUpdate();
        },
        
        // Sync scroll position between textarea and highlighted display
        syncScroll() {
          try {
            const textarea = this.$refs.cssTextarea;
            const highlightedContainer = this.$refs.highlightedContainer;
            if (textarea && highlightedContainer) {
              // Move the pre element inside the container using transform
              const pre = highlightedContainer.querySelector('.mb-css-highlighted-pre');
              if (pre) {
                pre.style.transform = `translate(${-textarea.scrollLeft}px, ${-textarea.scrollTop}px)`;
              }
            }
          } catch (e) {
            // Ignore scroll sync errors
          }
        },
        // Reuse share dialog for owner transfer
        openOwnerTransferDialog(group) {
          const g = group || this.contextGroup;
          if (!g || !this.isOwnerOfGroup(g)) { alert(this.getTranslation('error.onlyOwner')); return; }
          // Prepare share dialog in a special mode 'owner-transfer'
          this.shareDialog = {
            visible: true,
            mode: 'owner-transfer',
            group: g,
            selectedContacts: {},
          };
          // Refresh online status for all contacts so availability is accurate in dialog
          this.checkAllContactsStatus && this.checkAllContactsStatus();
          // Show modal
          const el = document.getElementById('shareModal');
          if (el) bootstrap.Modal.getOrCreateInstance(el).show();
        },
        
        async broadcastIdentityMigration(oldUuid, newUuid) {
          try {
            if (!oldUuid || !newUuid) return;
            const from = { oldUuid, newUuid, name: this.data.identity?.name||'' };
            const env = { v:1, type:'identity-migrate', ts:Date.now(), from, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
            // To contacts (pairwise)
            for (const c of (this.data.contacts||[])) {
              try { await sharing.sendToContact(c.uuid, env); } catch {}
            }
            // To groups
            for (const g of (this.data.groups||[])) {
              if (g.shared && g.groupTopic && g.groupKey) {
                try { await sharing.sendToGroup(g, Object.assign({ groupId: g.groupId }, env)); } catch {}
              }
            }
          } catch(e) { try { debugLog('warn', 'identity migrate broadcast failed', e); } catch {} }
        },
        
        async transferOwnership(group, newOwnerUuid) {
          try {
            if (!this.isOwnerOfGroup(group)) { alert(this.getTranslation('error.onlyOwner')); return; }
            const from = { uuid: this.data.identity?.uuid, name:this.data.identity?.name||'' };
            const env = { v:1, type:'owner-transfer', ts:Date.now(), from, groupId: group.groupId, newOwnerUuid, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
            await sharing.sendToGroup(group, env);
            // NOTE: Do not apply locally yet; wait for new owner's acceptance and roster broadcast
          } catch(e) { try { debugLog('warn', 'owner transfer failed', e); } catch {} }
        },
        // --- Conflict Resolution UI Methods ---
        showConflictResolutionNotification(message, duration = 5000) {
          this.conflictNotificationText = message;
          this.showConflictNotification = true;
          
          // Clear any existing timeout
          if (this.conflictNotificationTimeout) {
            clearTimeout(this.conflictNotificationTimeout);
          }
          
          // Auto-hide after duration
          this.conflictNotificationTimeout = setTimeout(() => {
            this.showConflictNotification = false;
            this.conflictNotificationText = '';
          }, duration);
        },
        
        // Role-based access helpers for sync settings
        isOwnerOfAnyGroup() {
          // Check if user is owner of at least one shared group
          return (this.data.groups || []).some(g => 
            g.shared && this.isOwnerOfGroup(g)
          );
        },
        
        isMemberOfAnyGroup() {
          // Check if user is member (not owner) of at least one shared group
          return (this.data.groups || []).some(g => 
            g.shared && !this.isOwnerOfGroup(g)
          );
        },
        
        isFieldAccessible(field) {
          // Check if field should be accessible based on role scope
          if (!field.roleScope || field.roleScope === 'all') {
            return true;
          }
          
          if (field.roleScope === 'owner') {
            return this.isOwnerOfAnyGroup();
          }
          
          if (field.roleScope === 'member') {
            return this.isMemberOfAnyGroup();
          }
          
          return true;
        },
        
        getRoleScopeBadgeText(roleScope) {
          switch(roleScope) {
            case 'all':
              return this.getTranslation('sync.role.all') || 'All';
            case 'owner':
              return this.getTranslation('sync.role.owner') || 'Owner';
            case 'member':
              return this.getTranslation('sync.role.member') || 'Member';
            default:
              return '';
          }
        },
        
        checkAndShowConflictNotifications() {
          // Check notification level setting
          const notificationLevel = this.data.options?.sync?.conflictNotificationLevel || 'minimal';
          
          // Don't show any notifications if set to silent
          if (notificationLevel === 'silent') {
            return;
          }
          
          // Check all groups for recent conflict resolutions
          for (const group of this.data.groups || []) {
            if (group.conflictNotifications?.length > 0) {
              const recentConflicts = group.conflictNotifications.filter(
                n => n.timestamp > Date.now() - 10000 // Last 10 seconds
              );
              
              if (recentConflicts.length > 0) {
                const latestConflict = recentConflicts[recentConflicts.length - 1];
                
                // For 'minimal' level, only show important conflicts
                if (notificationLevel === 'minimal') {
                  // Skip minor conflicts
                  if (latestConflict.operation === 'link-edit' && latestConflict.winner === 'local') {
                    continue; // User's own edits winning is not important
                  }
                }
                
                let message = '';
                
                switch (latestConflict.operation) {
                  case 'link-edit':
                    message = this.getTranslation('sync.conflict.linkEdit') || 
                             `Link edit conflict resolved (${latestConflict.winner} version kept)`;
                    break;
                  case 'link-add':
                    message = this.getTranslation('sync.conflict.linkAdd') || 
                             `Duplicate link prevented`;
                    break;
                  case 'link-delete':
                    message = this.getTranslation('sync.conflict.linkDelete') || 
                             `Link deletion conflict resolved`;
                    break;
                  default:
                    message = this.getTranslation('sync.conflict.generic') || 
                             `Sync conflict automatically resolved`;
                }
                
                this.showConflictResolutionNotification(message);
                
                // Mark as shown
                latestConflict.shown = true;
              }
            }
          }
        },
        
        // --- Event-Log Migration Helpers (Prepared for Future) ---
        migrateGroupToEventLog(group) {
          // Skip if already migrated
          if (group.eventLog) {
            debugLog('log', '[MIGRATION] Group already has event log', group.groupId);
            return false;
          }
          
          // Ensure group has a groupId (needed for event-log)
          if (!group.groupId) {
            // Use existing UUID or generate a new one
            group.groupId = group.uuid || this.generateUUID();
            if (!group.uuid) {
              group.uuid = group.groupId;
            }
          }
          
          // Ensure we have an identity UUID for event-log
          if (!this.data.identity?.uuid) {
            if (!this.data.identity) {
              this.$set(this.data, 'identity', { 
                uuid: this.generateUUID(),
                name: '', 
                pubKey: '', 
                privKey: '' 
              });
            } else {
              this.$set(this.data.identity, 'uuid', this.generateUUID());
            }
          }
          
          const author = this.data.identity.uuid;
          
          // Create initial snapshot event
          const migrationEvent = {
            eventId: 'migration-' + (group.uuid || this.generateUUID()),
            parentId: null,
            timestamp: Date.now(),
            author: author,
            vectorClock: { [author]: 1 },
            operation: {
              type: 'snapshot',
              data: {
                links: JSON.parse(JSON.stringify(group.links || [])),
                members: JSON.parse(JSON.stringify(group.members || [])),
                version: group.version || 0,
                name: group.name || '',
                color: group.color || '',
                keywords: group.keywords || '',
                urlPlaceholders: this.normalizePlaceholderList(group.urlPlaceholders || []),
                emoji: group.emoji || '',
                favicon: group.favicon || '',
                faviconSource: group.faviconSource || null,
                faviconRuleId: group.faviconRuleId || null,
                infoHtml: group.infoHtml || ''
              }
            }
          };
          
          // Initialize event log with migration event
          this.$set(group, 'eventLog', [migrationEvent]);
          this.$set(group, 'headEventId', migrationEvent.eventId);
          this.$set(group, 'vectorClock', { [author]: 1 });
          this.$set(group, 'snapshot', migrationEvent.operation.data);

          debugLog('log', '[MIGRATION] Migrated group to event-log system', {
            groupId: group.groupId,
            eventId: migrationEvent.eventId
          });
          
          return true;
        },
        
        // Enable event-log sync for a group (opt-in, owner only)
        enableEventLogSync(group) {
          if (!group.shared) {
            debugLog('warn', '[EVENT-LOG] Cannot enable event-log sync for non-shared group');
            return false;
          }
          
          // Only owner can enable event-log
          if (!this.isOwnerOfGroup(group)) {
            debugLog('warn', '[EVENT-LOG] Only owner can enable event-log sync');
            alert(this.getTranslation('error.eventlog.ownerOnly') || 'Only the owner can enable event-log for this group');
            return false;
          }
          
          // Migrate if needed
          if (!group.eventLog) {
            this.migrateGroupToEventLog(group);
          }
          
          // Mark as event-log enabled
          this.$set(group, 'useEventLog', true);
          
          debugLog('log', '[EVENT-LOG] Enabled event-log sync for group', group.groupId);
          this.saveData();
          
          // IMPORTANT: Notify all members about event-log activation
          if (sharing && group.shared && group.groupTopic) {
            try {
              const activationMessage = {
                v: 1,
                type: 'event-log-activation',
                ts: Date.now(),
                from: { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' },
                groupId: group.groupId,
                useEventLog: true,
                // Send complete event-log data
                eventLog: group.eventLog || [],
                snapshot: group.snapshot || null,
                headEventId: group.headEventId || null,
                vectorClock: group.vectorClock || {},
                migrationSnapshot: {
                  eventId: group.eventLog[0].eventId,
                  timestamp: group.eventLog[0].timestamp,
                  data: group.eventLog[0].operation.data
                },
                msgId: (Math.random().toString(36).slice(2) + Date.now())
              };
              
              debugLog('log', '[EVENT-LOG] Notifying members about event-log activation');
              sharing.sendToGroup(group, activationMessage);
            } catch (e) {
              debugLog('error', '[EVENT-LOG] Failed to notify members:', e);
            }
          }
          
          return true;
        },
        
        // Create event for operations (prepared for future use)
        createSyncEvent(group, operation) {
          if (!group.useEventLog) return null;
          
          const vectorClock = group.vectorClock || {};
          const myId = this.data.identity?.uuid || 'unknown';
          vectorClock[myId] = (vectorClock[myId] || 0) + 1;
          
          const event = {
            eventId: this.generateUUID(),
            parentId: group.headEventId || null,
            timestamp: Date.now(),
            author: myId,
            vectorClock: { ...vectorClock },
            operation: operation
          };
          
          return event;
        },
        
        // Helper method to send sync event to group members
        async sendSyncEventToMembers(group, event) {
          // Don't check useEventLog here - that's already done in createAndApplyEvent
          if (!group.groupTopic || !group.groupKey) {
            debugLog('warn', '[SYNC] Missing groupTopic or groupKey, cannot send sync');
            return;
          }
          if (typeof sharing === 'undefined' || !sharing) {
            debugLog('error', '[SYNC] Sharing module not available');
            return;
          }
          
          const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
          const syncEvent = {
            v: 1,
            type: 'sync-event',
            ts: Date.now(),
            from,
            groupId: group.groupId,
            event: event,
            // Don't include full eventLog and snapshot in every sync - too large
            // These are sent separately in group-update messages
            msgId: (Math.random().toString(36).slice(2) + Date.now())
          };
          
          debugLog('log', '[SYNC] Sending sync event to group members:', {
            groupId: group.groupId,
            eventType: event.operation?.type,
            eventId: event.eventId,
            hasGroupTopic: !!group.groupTopic,
            hasGroupKey: !!group.groupKey
          });
          
          try {
            await sharing.sendToGroup(group, syncEvent);
            debugLog('log', '[SYNC] Successfully sent sync event');
          } catch (error) {
            debugLog('error', '[SYNC] Error sending sync event:', error);
          }
        },
        
        // Helper method to create and apply event with sync
        createAndApplyEvent(group, operation, skipSync = false) {
          debugLog('log', '[EVENT-LOG] createAndApplyEvent called:', {
            groupName: group.name,
            groupId: group.groupId,
            useEventLog: group.useEventLog,
            hasEventLogManager: !!this.eventLogManager,
            operationType: operation.type,
            isShared: group.shared
          });
          
          if (!group.useEventLog || !this.eventLogManager) {
            debugLog('warn', '[EVENT-LOG] Cannot create event:', {
              useEventLog: group.useEventLog,
              hasEventLogManager: !!this.eventLogManager
            });
            return null;
          }
          
          const event = this.createSyncEvent(group, operation);
          if (!event) {
            debugLog('warn', '[EVENT-LOG] createSyncEvent returned null');
            return null;
          }
          
          debugLog('log', '[EVENT-LOG] Event created:', event);
          
          // Apply locally
          const added = this.eventLogManager.addEvent(event, group);
          if (!added) {
            debugLog('warn', '[EVENT-LOG] Failed to add event:', event);
            return null;
          }
          
          debugLog('log', '[EVENT-LOG] Created and applied event:', {
            type: operation.type,
            eventId: event.eventId,
            eventCount: group.eventLog?.length || 0,
            groupId: group.groupId,
            isShared: group.shared
          });
          
          // Send to members if group is shared
          if (!skipSync && group.shared && group.groupTopic) {
            this.sendSyncEventToMembers(group, event);
          }
          
          return event;
        },
        
        // --- Dark Mode ---
        toggleDarkMode() {
          this.isDarkMode = !this.isDarkMode;
          this.applyDarkMode();
          localStorage.setItem('darkMode', this.isDarkMode ? 'true' : 'false');
        },
        
        applyDarkMode() {
          if (this.isDarkMode) {
            document.documentElement.setAttribute('data-theme', 'dark');
          } else {
            document.documentElement.removeAttribute('data-theme');
          }
        },
        
        initDarkMode() {
          const savedDarkMode = localStorage.getItem('darkMode');
          if (savedDarkMode === 'true') {
            this.isDarkMode = true;
            this.applyDarkMode();
          }
        },
        
        // --- Color Customization ---
        initCustomColors() {
          // Apply colors from data.options.colors if available
          if (this.data.options?.colors) {
            this.applyCustomColors();
          } 
          // Fallback to old customColors for backward compatibility
          else if (this.data.options?.customColors) {
            this.customColors = Object.assign({}, this.data.options.customColors);
            this.applyCustomColors();
          } 
          // Fallback to localStorage for backward compatibility
          else {
            const savedColors = localStorage.getItem('customColors');
            if (savedColors) {
              try {
                this.customColors = JSON.parse(savedColors);
                this.applyCustomColors();
              } catch (e) {
                debugLog('error', 'Failed to load custom colors:', e);
              }
            }
          }
        },
        
        applyCustomColors() {
          debugLog('log', 'applyCustomColors called');
          const root = document.documentElement;
          
          // Generic approach: iterate through optionsDesign to find all color fields with cssVar
          Object.keys(this.optionsDesign).forEach(sectionKey => {
            const section = this.optionsDesign[sectionKey];
            if (section.fields) {
              Object.keys(section.fields).forEach(fieldKey => {
                const field = section.fields[fieldKey];
                
                // Check if this field has a CSS variable mapping
                if (field.cssVar && field.optionPath) {
                  // Get the value from data.options using the optionPath
                  const pathParts = field.optionPath.split('.');
                  let value = this.data.options;
                  for (const part of pathParts) {
                    value = value?.[part];
                  }
                  
                  // Parse JSON and generate full CSS if needed
                  let cssProperties = {};
                  
                  if (value && typeof value === 'string') {
                    try {
                      const jsonData = JSON.parse(value);
                      
                      // Generate CSS properties from JSON
                      if (jsonData.backgroundColor) {
                        cssProperties['background-color'] = jsonData.backgroundColor;
                      }
                      if (jsonData.color) {
                        cssProperties['color'] = jsonData.color;
                      }
                      if (jsonData.opacity && jsonData.opacity < 100) {
                        cssProperties['opacity'] = (jsonData.opacity / 100).toFixed(2);
                      }
                      if (jsonData.fontFamily) {
                        cssProperties['font-family'] = jsonData.fontFamily;
                      }
                      if (jsonData.fontSize && jsonData.fontSize !== '') {
                        cssProperties['font-size'] = jsonData.fontSize + (jsonData.fontSizeUnit || 'px');
                      }
                      if (jsonData.fontWeight) {
                        cssProperties['font-weight'] = jsonData.fontWeight;
                      }
                      if (jsonData.borderStyle && jsonData.borderStyle !== 'none') {
                        cssProperties['border-style'] = jsonData.borderStyle;
                        if (jsonData.borderWidth) {
                          cssProperties['border-width'] = jsonData.borderWidth + 'px';
                        }
                        if (jsonData.borderColor) {
                          cssProperties['border-color'] = jsonData.borderColor;
                        }
                      }
                      if (jsonData.borderRadius) {
                        cssProperties['border-radius'] = jsonData.borderRadius + 'px';
                      }
                      if (jsonData.padding) {
                        cssProperties['padding'] = jsonData.padding + 'px';
                      }
                      if (jsonData.margin) {
                        cssProperties['margin'] = jsonData.margin + 'px';
                      }
                      
                      // Store all properties as CSS variables with a prefix
                      const varPrefix = field.cssVar || `--custom-${fieldKey}`;
                      
                      // Set individual CSS variables for each property
                      Object.keys(cssProperties).forEach(prop => {
                        const varName = `${varPrefix}-${prop.replace(/-/g, '_')}`;
                        root.style.setProperty(varName, cssProperties[prop]);
                        debugLog('log', `Setting CSS var ${varName} to ${cssProperties[prop]}`);
                      });
                      
                      // Also set the main variable with the primary color for backward compatibility
                      if (field.cssVar && jsonData.backgroundColor) {
                        root.style.setProperty(field.cssVar, jsonData.backgroundColor);
                        debugLog('log', `Setting main CSS var ${field.cssVar} to ${jsonData.backgroundColor}`);
                      }
                      
                    } catch (e) {
                      // Not JSON, use as simple value
                      if (value && value.trim() !== '') {
                        root.style.setProperty(field.cssVar, value);
                        debugLog('log', `Setting CSS var ${field.cssVar} to ${value}`);
                      }
                    }
                  } else if (field.default) {
                    // Use default value if no custom value is set
                    root.style.setProperty(field.cssVar, field.default);
                  } else {
                    // Remove the CSS variable if no value and no default
                    root.style.removeProperty(field.cssVar);
                  }
                }
              });
            }
          });
          
          // Also check group and link designs for CSS variables
          if (this.groupDesign) {
            this.applyDesignColors(this.groupDesign, 'groups');
          }
          if (this.linkDesign) {
            this.applyDesignColors(this.linkDesign, 'links');
          }
        },
        
        applyDesignColors(design, optionPrefix) {
          const root = document.documentElement;
          Object.keys(design).forEach(sectionKey => {
            const section = design[sectionKey];
            if (section.fields) {
              Object.keys(section.fields).forEach(fieldKey => {
                const field = section.fields[fieldKey];
                if (field.cssVar && field.optionPath) {
                  const pathParts = field.optionPath.split('.');
                  let value = this.data.options;
                  for (const part of pathParts) {
                    value = value?.[part];
                  }
                  if (value && value.trim() !== '') {
                    root.style.setProperty(field.cssVar, value);
                  } else if (field.default) {
                    root.style.setProperty(field.cssVar, field.default);
                  } else {
                    root.style.removeProperty(field.cssVar);
                  }
                }
              });
            }
          });
        },
        
        resetColor(colorType) {
          const defaults = {
            background: '#fafbfc',
            toolbar: '#ffffff',
            titleBar: '#f8f9fa',
            titleText: '#1a1a1a',
            keywordContainer: '#f0f0f0'
          };
          
          if (defaults[colorType]) {
            // Reset to default value (website colors always have defaults)
            this.customColors[colorType] = defaults[colorType];
            this.applyCustomColors();
          } else {
            // Remove the color entirely (for group/link colors without defaults)
            this.customColors[colorType] = '';
            this.applyCustomColors();
          }
        },
        
        resetAllColors() {
          this.customColors = {
            background: '#fafbfc',
            toolbar: '#ffffff',
            titleBar: '#f8f9fa',
            titleText: '#1a1a1a',
            keywordContainer: '#f0f0f0'
          };
          this.applyCustomColors();
        },
        
        // --- Ownership helper ---
        isOwnerOfGroup(group) {
          try {
            if (!group) return false;
            const my = this.data?.identity?.uuid;
            if (!my) return false;
            if (group.ownerUuid && group.ownerUuid === my) return true;
            const members = Array.isArray(group.members) ? group.members : [];
            return members.some(m => m.role === 'owner' && m.uuid === my);
          } catch { return false; }
        },
        // Check if NTFY URL is configured
        hasNtfyUrl() {
          return this.data.options?.sharing?.ntfyServerUrl && this.data.options.sharing.ntfyServerUrl.trim();
        },
        hasConnectedContacts() {
          return Array.isArray(this.data?.contacts) && this.data.contacts.some(c => String(c?.uuid || '').trim());
        },
        shouldShowGroupSharingSection(group) {
          if (!this.hasNtfyUrl()) return false;
          if (this.hasConnectedContacts()) return true;
          return !!(group?.shared && this.isOwnerOfGroup(group));
        },
        // --- Permission helpers ---
        normalizeUrl(u) {
          try {
            if (!u) return '';
            const url = new URL(u, 'http://example.invalid');
            if (!url.protocol || (url.protocol !== 'http:' && url.protocol !== 'https:')) return (u||'').trim();
            let host = (url.hostname || '').toLowerCase();
            let proto = url.protocol.toLowerCase();
            let port = url.port;
            if ((proto === 'http:' && port === '80') || (proto === 'https:' && port === '443')) port = '';
            // drop tracking params
            try {
              ['utm_source','utm_medium','utm_campaign','utm_term','utm_content'].forEach(k=>url.searchParams.delete(k));
            } catch {}
            let path = url.pathname || '/';
            // remove trailing slash except root
            if (path.length > 1 && path.endsWith('/')) path = path.slice(0, -1);
            const qs = url.search || '';
            // ignore hash for normalization
            return `${proto}//${host}${port?(':'+port):''}${path}${qs}`;
          } catch { return (u||'').trim(); }
        },
        urlsEqual(a, b) { return this.normalizeUrl(a) === this.normalizeUrl(b); },
        getMyMemberEntry(group) {
          try {
            const my = this.data?.identity?.uuid; if (!my) return null;
            const members = Array.isArray(group?.members) ? group.members : [];
            return members.find(m => m.uuid === my) || null;
          } catch { return null; }
        },
        canAdd(group) {
          if (!group?.shared) return true; // local groups unrestricted
          if (this.isOwnerOfGroup(group)) return true;
          const me = this.getMyMemberEntry(group);
          // Safer default: deny unless explicitly granted by owner
          return !!(me && me.canAdd === true);
        },
        canEdit(group) {
          if (!group?.shared) return true;
          if (this.isOwnerOfGroup(group)) return true;
          const me = this.getMyMemberEntry(group);
          return !!(me && me.canEdit === true);
        },
        canDelete(group) {
          if (!group?.shared) return true;
          if (this.isOwnerOfGroup(group)) return true;
          const me = this.getMyMemberEntry(group);
          return !!(me && me.canDelete === true);
        },
        toggleMemberPerm(m, field) {
          const g = this.editGroup; if (!g) return;
          if (!this.isOwnerOfGroup(g)) return;
          if (!['canAdd','canEdit','canDelete'].includes(field)) return;
          const cur = !!m[field];
          this.$set(m, field, !cur);
          this.saveData();
          // Propagate roster immediately
          try {
            if (g.shared && g.groupTopic && g.groupKey) {
              const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
              sharing.sendToGroup(g, { v:1, type:'group-roster', ts:Date.now(), from, groupId: g.groupId, members: g.members||[] });
            }
          } catch {}
        },
        // --- Sharing: identity & contacts ---
        async generateIdentity() { await sharing.ensureIdentity(); alert('Identity ready'); },
        showMyContactQr() {
          try {
            const card = sharing.getContactCard();
            const url = 'data:application/json,' + encodeURIComponent(JSON.stringify(card));
            this.qrCodeUrl = JSON.stringify(card);
            const qrCodeDiv = document.getElementById('qrCodeDiv');
            if (qrCodeDiv) { qrCodeDiv.innerHTML = ''; new QRCode(qrCodeDiv, { text: JSON.stringify(card), width: 256, height: 256 }); }
            const modalElement = document.getElementById('qrCodeModal');
            if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).show();
          } catch (e) { alert('QR error'); }
        },
        async addContactFromCardPaste() {
          const txt = prompt('Paste contact card JSON');
          if (!txt) return;
          try { const card = JSON.parse(txt); await sharing.addContactFromCard(card); alert('Contact added'); } catch { alert('Invalid contact card'); }
        },
        openQuickConnectDialog() {
          this.contactsDialog.visible = true;
          this.contactsDialog.tab = 'quickconnect';
          this.qcDialog.mode = 'receive';  // Default to receive mode
          this.qcDialog.status = [];
          this.qcDialog.progress = 'idle';
          this.qcDialog.code = '';
          // Hook status updates
          sharing.setStatusHandler((evt) => {
            if (!this.qcDialog.visible) return;
            if (evt.phase === 'waiting') { this.qcAddStatus(`Waiting for offer on topic ${evt.topic}`); this.qcDialog.progress = 'waiting'; this.qcDialog.code = sharing.qcCode; }
            if (evt.phase === 'offer_sent') { this.qcAddStatus(`Offer sent on topic ${evt.topic}`); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'offer_received') { this.qcAddStatus('Offer received'); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'answer_sent') { this.qcAddStatus('Answer sent'); }
            if (evt.phase === 'final_sent') { this.qcAddStatus('Final sent (your card)'); this.qcDialog.progress = 'done'; this.qcAutoClose(); }
            if (evt.phase === 'final_received') { this.qcAddStatus('Final received (peer card)'); this.qcDialog.progress = 'done'; this.qcAutoClose(); }
            if (evt.phase === 'stopped') { this.qcAddStatus('Stopped'); this.qcDialog.progress = 'idle'; }
          });
        },
        qcAutoClose() { 
          setTimeout(()=>{ 
            try { 
              const modalElement=document.getElementById('contactsModal'); 
              if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).hide(); 
            } catch{} 
            this.contactsDialog.visible=false; 
          }, 800); 
        },
        openContactsDialog() {
          this.contactsDialog.visible = true;
          this.contactsDialog.tab = 'contacts';  // Default to contacts tab
          
          // Check online status for all contacts when dialog opens
          this.checkAllContactsStatus();
          
          const modalElement = document.getElementById('contactsModal');
          if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).show();
        },
        closeContactsDialog() {
          this.contactsDialog.visible = false;
          // Stop and reset Quick-Connect completely
          if (this.qcDialog.code || this.qcDialog.active) {
            this.qcCancel();
          }
          // Ensure complete reset
          this.qcDialog.code = '';
          this.qcDialog.active = false;
          this.qcDialog.progress = 'idle';
        },
        confirmRemoveContact(c) {
          if (!c) return;
          
          const warnings = [];
          
          // Check if contact is owner of shared groups
          const ownerGroups = (this.data.groups || []).filter(g => 
            g.shared && g.ownerUuid === c.uuid
          );
          if (ownerGroups.length > 0) {
            warnings.push(`${this.getTranslation('dialog.contacts.removeWarningOwner') || 'This contact owns'} ${ownerGroups.length} ${this.getTranslation('dialog.contacts.removeWarningGroups') || 'shared group(s) that will be deleted'}`);
          }
          
          // Check if contact is member of our shared groups
          const memberGroups = (this.data.groups || []).filter(g => 
            g.shared && g.ownerUuid === this.data.identity?.uuid && 
            g.members?.some(m => m.uuid === c.uuid)
          );
          if (memberGroups.length > 0) {
            warnings.push(`${this.getTranslation('dialog.contacts.removeWarningMember') || 'This contact is member of'} ${memberGroups.length} ${this.getTranslation('dialog.contacts.removeWarningYourGroups') || 'of your shared group(s)'}`);
          }
          
          let message = `${this.getTranslation('dialog.contacts.removeConfirm') || 'Remove contact'} "${c.name || c.uuid}"?`;
          if (warnings.length > 0) {
            message += '\n\n⚠️ ' + warnings.join('\n⚠️ ');
          }
          message += `\n\n${this.getTranslation('dialog.contacts.removeNote') || 'This contact will no longer be able to send you messages.'}`;
          
          if (confirm(message)) {
            this.removeContact(c);
          }
        },
        
        async removeContact(c) {
          if (!c) return;
          
          // 1. Remove member from all shared groups where we are owner
          const ownedGroups = (this.data.groups || []).filter(g => 
            g.shared && g.ownerUuid === this.data.identity?.uuid && 
            g.members?.some(m => m.uuid === c.uuid)
          );
          
          for (const group of ownedGroups) {
            debugLog('log', '[CONTACT] Removing member from owned group:', group.name);
            await this.removeMemberFromGroup(group, { uuid: c.uuid });
          }
          
          // 2. Remove shared groups where contact is owner
          const groupsToRemove = (this.data.groups || []).filter(g => 
            g.shared && g.ownerUuid === c.uuid
          );
          
          for (const group of groupsToRemove) {
            debugLog('log', '[CONTACT] Removing group where contact is owner:', group.name);
            // Unsubscribe from group topic
            try { 
              if (group.groupTopic) {
                sharing.ntfy.unsubscribe(group.groupTopic);
              }
            } catch {}
            // Remove group from local data
            const gIdx = this.data.groups.findIndex(g => g.uuid === group.uuid);
            if (gIdx >= 0) {
              this.data.groups.splice(gIdx, 1);
            }
          }
          
          // 3. Remove contact from list
          const idx = (this.data.contacts || []).findIndex(x => x.uuid === c.uuid);
          if (idx >= 0) this.data.contacts.splice(idx, 1);
          
          // 4. Unsubscribe from pairwise channel
          try { sharing.unsubscribePairwise && sharing.unsubscribePairwise(c); } catch {}
          
          // 5. Add to blocked list to prevent future messages
          if (!this.data.blockedContacts) this.$set(this.data, 'blockedContacts', []);
          if (!this.data.blockedContacts.includes(c.uuid)) {
            this.data.blockedContacts.push(c.uuid);
          }
          
          this.saveData();
          this.$forceUpdate();
        },
        openMembersModal(group) {
          if (!group.prefs) this.$set(group, 'prefs', { inbound: { perMember: {} } });
          if (!group.prefs.inbound) this.$set(group.prefs, 'inbound', { perMember: {} });
          if (!group.prefs.inbound.perMember) this.$set(group.prefs.inbound, 'perMember', {});
          this.editGroup = group;
          const modalElement = document.getElementById('membersModal');
          if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).show();
          this.hideMenus();
        },
        confirmRemoveMember(member) {
          const memberName = member.name || member.uuid;
          if (confirm(`Are you sure you want to remove "${memberName}" from this group?`)) {
            this.removeMemberFromGroup(member);
          }
        },
        
        // Show notification when member was removed while offline
        showRemovedFromGroupNotification(groupName, ownerName, groupId, removedAt) {
          this.removedGroupInfo = {
            groupName: groupName || 'Unknown Group',
            ownerName: ownerName || 'Unknown Owner',
            removedAt: removedAt || new Date(),
            groupId: groupId
          };
          
          // Show the modal
          const modalElement = document.getElementById('removedFromGroupModal');
          if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).show();
        },
        
        // Handle acknowledgment of removal
        acknowledgeGroupRemoval() {
          const groupId = this.removedGroupInfo.groupId;
          if (groupId) {
            // Remove the group from local storage
            const groupIndex = this.data.groups.findIndex(g => g.uuid === groupId);
            if (groupIndex !== -1) {
              this.data.groups.splice(groupIndex, 1);
              this.saveData();
              debugLog('log', '[SYNC] Removed group after member removal notification:', groupId);
            }
          }
          
          // Clear the info
          this.removedGroupInfo = {
            groupName: '',
            ownerName: '',
            removedAt: null,
            groupId: null
          };
        },
        toggleMemberInbound(m) {
          if (!this.editGroup?.prefs?.inbound?.perMember) return;
          const cur = this.editGroup.prefs.inbound.perMember[m.uuid] || 'unset';
          const next = cur==='allow' ? 'deny' : 'allow';
          this.$set(this.editGroup.prefs.inbound.perMember, m.uuid, next);
          this.saveData();
        },
        async removeMemberFromGroup(groupOrMember, memberParam) {
          // Handle two different call signatures:
          // 1. From members dialog: removeMemberFromGroup(member) - uses this.editGroup
          // 2. From removeContact: removeMemberFromGroup(group, member)
          let g, m;
          if (memberParam) {
            // Called with (group, member)
            g = groupOrMember;
            m = memberParam;
          } else {
            // Called with (member) - use editGroup
            g = this.editGroup;
            m = groupOrMember;
          }
          
          if (!g) return;
          if (!this.isOwnerOfGroup(g)) { 
            // Only show alert if called from UI (no memberParam)
            if (!memberParam) alert('Only the owner can remove members.'); 
            return; 
          }
          
          // Update local roster
          g.members = (g.members||[]).filter(x=>x.uuid!==m.uuid);
          
          // Check if group should no longer be shared
          // Unshare if: no members left, only owner remains, or no members with role 'member'
          const noMembers = !g.members || g.members.length === 0;
          const onlyOwnerRemains = g.members.length === 1 && g.members[0].role === 'owner';
          const noRegularMembers = g.members.length > 0 && !g.members.some(x => x.role === 'member');
          
          if (noMembers || onlyOwnerRemains || noRegularMembers) {
            debugLog('log', '[SHARE] Group no longer shared:', g.name, 
              noMembers ? '(no members)' : onlyOwnerRemains ? '(only owner remains)' : '(no regular members)');
            // Unshare the group
            g.shared = false;
            // Optionally clear sharing-related properties
            // Keep groupId, groupKey, groupTopic for potential re-sharing
            // But unsubscribe from the topic
            try {
              if (g.groupTopic && window.sharing) {
                window.sharing.ntfy.unsubscribe(g.groupTopic);
              }
            } catch (e) {
              debugLog('warn', '[SHARE] Failed to unsubscribe from topic:', e);
            }
          }
          
          this.saveData();
          
          try {
            // Notify removed member 1:1
            // For shared groups, we must use groupId (never fallback to local id)
            if (!g.groupId) {
              debugLog('error', '[REMOVE_MEMBER] No groupId for shared group:', g.name);
              return;
            }
            const env = { v:1, type:'group-member-removed', ts:Date.now(), from:{ uuid:this.data.identity?.uuid, name:this.data.identity?.name||'' }, groupId: g.groupId };
            await sharing.sendToContact(m.uuid, env);
          } catch (e) {
            debugLog('error', '[REMOVE_MEMBER] Failed to notify member:', e);
          }
          
          try {
            // Broadcast updated roster to remaining group
            await sharing.sendToGroup(g, { v:1, type:'group-roster', ts:Date.now(), from:{ uuid:this.data.identity?.uuid, name:this.data.identity?.name||'' }, groupId: g.groupId, members: g.members||[] });
          } catch {}
        },
        // Contact online status methods
        async checkContactOnlineStatus(contactUuid) {
          // Check if contact is online by attempting a ping
          try {
            // Store checking status
            this.$set(this.contactOnlineStatus, contactUuid, {
              online: false,
              checking: true,
              lastCheck: Date.now()
            });
            
            // Try to ping the contact
            const pingSuccess = await this.pingContact(contactUuid);
            
            // Update status
            this.$set(this.contactOnlineStatus, contactUuid, {
              online: pingSuccess,
              checking: false,
              lastCheck: Date.now()
            });
            
            return pingSuccess;
          } catch (e) {
            this.$set(this.contactOnlineStatus, contactUuid, {
              online: false,
              checking: false,
              lastCheck: Date.now()
            });
            return false;
          }
        },
        
        async pingContact(contactUuid) {
          // Proper ping/pong mechanism to check if contact is truly online
          try {
            const contact = (this.data.contacts || []).find(c => c.uuid === contactUuid);
            if (!contact) return false;
            
            // Check if contact has valid channel info
            if (!contact.kChannelB64 || !contact.topic) {
              return false;
            }
            
            // Generate unique ping ID
            const pingId = Math.random().toString(36).slice(2) + Date.now();
            
            // Create ping message
            const pingMessage = {
              type: 'ping',
              pingId: pingId,
              from: this.data.identity?.uuid,
              timestamp: Date.now()
            };
            
            // Create promise that will be resolved when pong is received
            const pongPromise = new Promise((resolve, reject) => {
              // Store resolver for the pong handler to use
              this.pendingPings[pingId] = { resolve, reject };
              
              // Set timeout for pong response
              const timeoutId = setTimeout(() => {
                if (this.pendingPings[pingId]) {
                  delete this.pendingPings[pingId];
                  resolve(false); // Timeout = offline
                }
              }, 3000); // 3 second timeout
              
              this.pendingPings[pingId].timeout = timeoutId;
            });
            
            // Send ping message
            try {
              await sharing.sendToContact(contactUuid, pingMessage);
              debugLog('log', '[PING/PONG] Sent ping to:', contactUuid, 'with ID:', pingId);
            } catch (e) {
              // Failed to send ping
              if (this.pendingPings[pingId]) {
                clearTimeout(this.pendingPings[pingId].timeout);
                delete this.pendingPings[pingId];
              }
              return false;
            }
            
            // Wait for pong response
            const result = await pongPromise;
            
            // Clean up timeout if still exists
            if (this.pendingPings[pingId]) {
              clearTimeout(this.pendingPings[pingId].timeout);
              delete this.pendingPings[pingId];
            }
            
            return result === true;
          } catch (e) {
            debugLog('error', '[PING/PONG] Failed to ping contact:', e);
            return false;
          }
        },
        
        isContactOnline(contactUuid) {
          const status = this.contactOnlineStatus[contactUuid];
          if (!status) {
            // Check status if not cached
            this.checkContactOnlineStatus(contactUuid);
            return false; // Assume offline until checked
          }
          
          // Re-check if status is older than the configured timeout
          const timeoutMs = (this.data.options?.sharing?.contactOnlineTimeoutSeconds || CONSTS.CONTACT_ONLINE_TIMEOUT_SEC) * 1000;
          if (Date.now() - status.lastCheck > timeoutMs) {
            this.checkContactOnlineStatus(contactUuid);
          }
          
          return status.online;
        },
        
        // Check online status for all contacts
        async checkAllContactsStatus() {
          if (!this.data.contacts || this.data.contacts.length === 0) return;
          
          // Check all contacts in parallel
          const checkPromises = this.data.contacts.map(contact => 
            this.checkContactOnlineStatus(contact.uuid)
          );
          
          try {
            await Promise.all(checkPromises);
            debugLog('log', 'Checked status for all contacts');
          } catch (e) {
            debugLog('error', 'Failed to check some contact statuses:', e);
          }
        },
        
        getContactStatusClass(contactUuid) {
          const status = this.contactOnlineStatus[contactUuid];
          if (!status) return 'online-indicator checking';
          if (status.checking) return 'online-indicator checking';
          return status.online ? 'online-indicator online' : 'online-indicator offline';
        },
        
        getContactStatusText(contactUuid) {
          const status = this.contactOnlineStatus[contactUuid];
          if (!status || status.checking) return this.getTranslation('dialog.contacts.checking') || 'checking...';
          // Now shows true online status via ping/pong mechanism
          return status.online ? 
            (this.getTranslation('dialog.contacts.online') || 'online') : 
            (this.getTranslation('dialog.contacts.offline') || 'offline');
        },
        
        getContactStatusTextClass(contactUuid) {
          const status = this.contactOnlineStatus[contactUuid];
          if (!status || status.checking) return 'contact-status-text';
          return status.online ? 'contact-status-text online' : 'contact-status-text offline';
        },
        
        // Format date for display using moment.js
        formatDate(dateValue) {
          if (!dateValue) return '';
          
          try {
            // Create moment object and validate
            const m = moment(dateValue);
            if (!m.isValid()) {
              return '';
            }
            
            // Use localized format (LLL = Month name, day, year, time)
            // In German: "15. Januar 2024 14:30"
            return m.format('LLL');
          } catch (e) {
            debugLog('error', 'Error formatting date:', e);
            return '';
          }
        },
        
        // Format time for messages using moment.js
        formatMessageTime(timeValue) {
          if (!timeValue) return '';
          
          try {
            const m = moment(timeValue);
            if (!m.isValid()) {
              return '';
            }
            
            // Use time format (HH:mm:ss)
            return m.format('LTS');
          } catch (e) {
            debugLog('error', 'Error formatting message time:', e);
            return '';
          }
        },
        
        async sendTestToContact(c) {
          // Check if contact is online first
          if (!this.isContactOnline(c.uuid)) {
            alert(this.getTranslation('dialog.contacts.cannotSendOffline') || 'Cannot send to offline contact');
            return;
          }
          
          try {
            const env = { v:1, type:'share', from:{ uuid:this.data.identity?.uuid, name:this.data.identity?.name||'' }, ts:Date.now(), note: this.getTranslation('quick.test.note'), selection:{ groups:[], links:[] }, mode:'merge', schemaVersion:1 };
            await sharing.sendToContact(c.uuid, env);
            // Removed alert - success already visible in UI
          } catch (e) { alert(this.getTranslation('quick.test.failed')); }
        },
        qcAddStatus(msg) { (this.qcDialog.status || (this.qcDialog.status=[])).push({ t: Date.now(), m: msg }); this.$nextTick(() => {
          const box = document.getElementById('qcStatusBox'); if (box) box.scrollTop = box.scrollHeight; });
        },
        async qcStartReceive() {
          // Setup status handler first
          this.setupQcStatusHandler();
          const ttl = this.data.options?.sharing?.quickCodeTtlSec || CONSTS.QUICK_CODE_TTL_SEC;
          const alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789';
          let code = '';
          for (let i = 0; i < 6; i++) code += alphabet[Math.floor(Math.random() * alphabet.length)];
          this.qcDialog.code = code;
          this.qcAddStatus(`Code: ${code} (valid ~${ttl}s)`);
          try { await sharing.quickCodeReceiveStart(code); } catch (e) { this.qcAddStatus('Error starting receive'); }
        },
        async qcStartSend() {
          // Setup status handler first
          this.setupQcStatusHandler();
          const code = (this.qcDialog.code || '').trim().toLowerCase();
          if (!code || code.length !== 6) { alert('Enter a 6-character code'); return; }
          try { await sharing.quickCodeSendOffer(code); this.qcAddStatus('Offer sent; waiting for answer'); }
          catch { this.qcAddStatus('Quick-Connect failed'); }
        },
        setupQcStatusHandler() {
          sharing.setStatusHandler((evt) => {
            if (evt.phase === 'waiting') { this.qcAddStatus(`Waiting for offer on topic ${evt.topic}`); this.qcDialog.progress = 'waiting'; this.qcDialog.code = sharing.qcCode; }
            if (evt.phase === 'offer_sent') { this.qcAddStatus(`Offer sent on topic ${evt.topic}`); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'offer_received') { this.qcAddStatus('Offer received from peer; generating answer'); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'answer_sent') { this.qcAddStatus('Answer sent; generating contact'); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'answer_received') { this.qcAddStatus('Answer received; generating contact'); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'final_sent') { this.qcAddStatus('Final sent (contact card)'); this.qcDialog.progress = 'done'; this.qcAutoClose(); }
            if (evt.phase === 'final_received') { this.qcAddStatus('Final received (peer card)'); this.qcDialog.progress = 'done'; this.qcAutoClose(); }
            if (evt.phase === 'stopped') { this.qcAddStatus('Stopped'); this.qcDialog.progress = 'idle'; }
          });
        },
        qcCancel() { 
          try { sharing.quickCodeStop(); } catch {} 
          this.qcAddStatus('Canceled'); 
          this.qcDialog.progress = 'idle'; 
          this.qcDialog.code = ''; // Reset the code input field
          this.qcDialog.active = false; // Reset active state
        },
        // --- Invitation Dialog ---
        showInvitationDialog(type, env) {
          this.invitationDialog.type = type;
          this.invitationDialog.env = env;
          this.invitationDialog.fromName = env.from?.name || env.from?.uuid || 'Unknown';
          
          if (type === 'group') {
            this.invitationDialog.groupName = env.groupName || 'Shared Group';
            this.invitationDialog.linkCount = (env.selection?.links || []).length;
            this.invitationDialog.preview = [];
          } else if (type === 'link') {
            // Check if it's a group share or just links
            if (env.selection?.groups?.length > 0) {
              // It's actually a group share via Share Group button
              const group = env.selection.groups[0];
              this.invitationDialog.groupName = group.name || 'Shared Group';
              this.invitationDialog.linkCount = (group.links || []).length;
              this.invitationDialog.preview = (group.links || []).slice(0, 10).map(l => ({
                text: l.text || l.url,
                url: l.url
              }));
            } else {
              // It's just shared links
              this.invitationDialog.groupName = '';
              this.invitationDialog.linkCount = 0;
              this.invitationDialog.preview = (env.selection?.links || []).slice(0, 10).map(l => ({
                text: l.text || l.url,
                url: l.url
              }));
            }
          }
          
          this.invitationDialog.visible = true;
          this.$nextTick(() => {
            const el = document.getElementById('invitationModal');
            if (el) bootstrap.Modal.getOrCreateInstance(el).show();
          });
        },
        
        async acceptInvitation() {
          try {
            const env = this.invitationDialog.env;
            debugLog('log', '[INVITE] Accepting invitation, type:', this.invitationDialog.type, 'env:', env);
            if (!env) {
              debugLog('log', '[INVITE] No envelope found');
              return;
            }
            
            if (this.invitationDialog.type === 'group') {
              // Mark as processed to prevent duplicates
              if (env.msgId && this.processedMsgIds) this.processedMsgIds.add(env.msgId);
              
              // Accept group invite: create or update shared group and subscribe
              debugLog('log', '[INVITE] Processing invitation with event-log data:', {
                hasEventLog: !!env.eventLog,
                eventLogCount: env.eventLog?.length || 0,
                hasSnapshot: !!env.snapshot,
                useEventLog: env.useEventLog
              });
              let g = (this.data.groups||[]).find(x=>x.groupId===env.groupId);
              if (!g) {
                // Create a completely new group object with deep copy to avoid reference issues
                g = JSON.parse(JSON.stringify({ 
                  uuid: this.generateUUID(),
                  name: env.groupName||'Shared Group', 
                  color:'', 
                  opacity:100, 
                  keywords:'', 
                  urlPlaceholders: this.normalizePlaceholderList(env.urlPlaceholders || []),
                  column: Math.max(0, ...(this.getGroupColumns()||[0])), 
                  index:(this.data.groups||[]).length, 
                  collapsed:false, 
                  shared:true, 
                  groupId: env.groupId, 
                  groupTopic: env.groupTopic, 
                  groupKey: env.groupKey,
                  // Include event-log data from invitation
                  useEventLog: env.useEventLog || false,
                  eventLog: env.eventLog || [],
                  snapshot: env.snapshot || null,
                  headEventId: env.headEventId || null,
                  vectorClock: env.vectorClock || {}
                }));
                // Ensure links is a new array
                g.links = [];
                if (!Array.isArray(this.data.groups)) this.$set(this.data, 'groups', []);
                // Use Vue's reactive method to add the group
                const newIndex = this.data.groups.length;
                this.$set(this.data.groups, newIndex, g);
              } else {
                // Group already exists (possibly re-adding after removal)
                this.$set(g, 'shared', true); 
                this.$set(g,'groupId', env.groupId); 
                this.$set(g,'groupTopic', env.groupTopic); 
                this.$set(g,'groupKey', env.groupKey);
                // Update event-log data from invitation if provided
                if (env.useEventLog) {
                  this.$set(g, 'useEventLog', true);
                  this.$set(g, 'eventLog', env.eventLog || []);
                  this.$set(g, 'snapshot', env.snapshot || null);
                  this.$set(g, 'headEventId', env.headEventId || null);
                  this.$set(g, 'vectorClock', env.vectorClock || {});
                }
                // Ensure links array is reactive
                if (!Array.isArray(g.links)) {
                  this.$set(g, 'links', []);
                }
              }
              
              // Enable event-log for shared groups if not already provided in invitation
              if (!g.eventLog && !env.useEventLog) {
                debugLog('log', '[EVENT-LOG] Enabling event-log for newly shared group:', g.name);
                this.migrateGroupToEventLog(g);
                this.$set(g, 'useEventLog', true);
              }
              
              // Apply roster if provided
              if (Array.isArray(env.members)) {
                const contacts = Array.isArray(this.data.contacts) ? this.data.contacts : [];
                const mapped = env.members.map(m=>{
                  const mm = Object.assign({}, m);
                  if (!mm.name || mm.name===mm.uuid) {
                    if (env.groupOwnerUuid && mm.uuid===env.groupOwnerUuid && env.from?.name) mm.name = env.from.name;
                    if ((!mm.name || mm.name===mm.uuid)) {
                      const c = contacts.find(x=>x.uuid===mm.uuid);
                      if (c && c.name) mm.name = c.name;
                    }
                  }
                  // Preserve permissions
                  mm.canAdd = m.canAdd;
                  mm.canEdit = m.canEdit;
                  mm.canDelete = m.canDelete;
                  return mm;
                });
                this.$set(g, 'members', mapped);
              }
              
              // Apply color and opacity
              if (typeof env.groupColor === 'string') this.$set(g, 'color', env.groupColor);
              if (typeof env.groupOpacity === 'number') this.$set(g, 'opacity', Math.max(0, Math.min(100, env.groupOpacity)));
              if (typeof env.groupOwnerUuid === 'string' && env.groupOwnerUuid) this.$set(g, 'ownerUuid', env.groupOwnerUuid);
              this.$set(g, 'urlPlaceholders', this.normalizePlaceholderList(env.urlPlaceholders || g.urlPlaceholders || []));
              
              // Import initial links with reactive properties
              if (!Array.isArray(g.links)) {
                this.$set(g, 'links', []);
              }
              g.links = []; // Clear existing links
              if (env.selection && Array.isArray(env.selection.links)) {
                const linkUuidMap = new Map();
                env.selection.links.forEach((l) => {
                  const originalUuid = l?.uuid || '';
                  const nextUuid = originalUuid || this.generateUUID();
                  if (originalUuid) linkUuidMap.set(originalUuid, nextUuid);
                });
                env.selection.links.forEach((l,i)=>{
                  const col = (typeof l.column==='number') ? l.column : 0;
                  const idx = (typeof l.index === 'number') ? l.index : i;
                  const newLink = { 
                    uuid: (l?.uuid && linkUuidMap.get(l.uuid)) ? linkUuidMap.get(l.uuid) : this.generateUUID(),
                    text: l.text || l.url, 
                    url: l.url, 
                    rawUrlInput: l.rawUrlInput || '',
                    urlPlaceholders: this.normalizePlaceholderList(l.urlPlaceholders || []),
                    keywords: l.keywords || '', 
                    infoHtml: this.sanitizeHtml(String(l.infoHtml || '')),
                    color: l.color || '',
                    refTargetUuid: (l?.refTargetUuid && linkUuidMap.has(l.refTargetUuid)) ? linkUuidMap.get(l.refTargetUuid) : (l.refTargetUuid || ''),
                    inheritSourceKeywords: l.inheritSourceKeywords !== false,
                    emoji: l.emoji || '',
                    shortcut: l.shortcut || '',
                    column: col, 
                    index: idx, 
                    editing: false, 
                    isMouseOver: false 
                  };
                  // Ensure reactive properties
                  this.$set(newLink, 'editing', false);
                  this.$set(newLink, 'isMouseOver', false);
                  g.links.push(newLink);
                });
              }
              
              // Ensure reactive UI properties
              if (g.isMouseOver===undefined) this.$set(g,'isMouseOver',false);
              if (g.editing===undefined) this.$set(g,'editing',false);
              
              // Default inbound prefs
              if (!g.prefs) this.$set(g,'prefs',{ inbound: { perMember: {} } });
              if (!g.prefs.inbound) this.$set(g.prefs,'inbound',{ perMember: {} });
              if (!g.prefs.inbound.perMember) this.$set(g.prefs.inbound,'perMember',{});
              
              this.saveData();
              
              // Subscribe to group - skip initial update request since we already have the data from the invite
              debugLog('log', '[INVITE] Accepted group invitation:', g.name, g.groupId);
              
              // If group was previously removed and re-added, we need to force re-subscription
              if (sharing.groupSubs && sharing.groupSubs.has(g.groupTopic)) {
                debugLog('log', '[INVITE] Group was already subscribed, forcing re-subscription');
                // Remove old subscription from map
                sharing.groupSubs.delete(g.groupTopic);
                // Unsubscribe from NTFY (in case subscription still exists)
                try {
                  sharing.ntfy.unsubscribe(g.groupTopic);
                } catch (e) {
                  debugLog('log', '[INVITE] Could not unsubscribe old subscription:', e);
                }
              }
              
              // Subscribe and request update immediately so owner sends full state
              sharing.applyConfig();
              sharing.subscribeGroup(g, false); // false = send update request automatically
              
              // Force update UI
              try { this.$forceUpdate(); } catch {}
              
              // After subscription is established, request an update to sync with latest state
              // This ensures we get any changes that happened while the invitation was pending
              setTimeout(() => {
                try {
                  const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
                  debugLog('log', '[INVITE] Sending delayed update request after invitation acceptance');
                  sharing.sendToGroup(g, { 
                    v: 1, 
                    type: 'group-update-request', 
                    ts: Date.now(), 
                    from, 
                    groupId: g.groupId, 
                    msgId: (Math.random().toString(36).slice(2) + Date.now()) 
                  });
                } catch(e) {
                  debugLog('warn', '[INVITE] Failed to send update request after invitation acceptance', e);
                }
              }, 500); // Shorter delay; subscribeGroup already requested update
              
            } else if (this.invitationDialog.type === 'link') {
              // Accept shared links or groups
              debugLog('log', '[INVITE] Processing shared links/groups');
              
              // Debug: Check state before applying share envelope
              debugLog('log', '[INVITE] Groups before applyShareEnvelope:', this.data.groups.map(g => ({
                name: g.name,
                uuid: g.uuid,
                linksCount: g.links?.length,
                firstLink: g.links?.[0]?.text
              })));
              
              await this.applyShareEnvelope(env);
              
              // Debug: Check state after applying share envelope
              debugLog('log', '[INVITE] Groups after applyShareEnvelope:', this.data.groups.map(g => ({
                name: g.name,
                uuid: g.uuid,
                linksCount: g.links?.length,
                firstLink: g.links?.[0]?.text
              })));
              
              // Extra debug: Check if links arrays are actually different objects
              if (this.data.groups.length >= 2) {
                const group1 = this.data.groups[0];
                const group2 = this.data.groups[1];
                debugLog('log', '[DEBUG] Group 1 links === Group 2 links?', group1.links === group2.links);
                debugLog('log', '[DEBUG] Group 1:', { name: group1.name, uuid: group1.uuid, links: group1.links });
                debugLog('log', '[DEBUG] Group 2:', { name: group2.name, uuid: group2.uuid, links: group2.links });
                
                // Check actual link content
                debugLog('log', '[DEBUG] Group 1 first link text:', group1.links[0]?.text);
                debugLog('log', '[DEBUG] Group 2 first link text:', group2.links[0]?.text);
                
                // Force check after a delay to see if something changes
                setTimeout(() => {
                  debugLog('log', '[DEBUG DELAYED] After 2 seconds:');
                  debugLog('log', '[DEBUG DELAYED] Group 1:', { 
                    name: this.data.groups[0].name, 
                    linksCount: this.data.groups[0].links.length,
                    firstLink: this.data.groups[0].links[0]?.text 
                  });
                  debugLog('log', '[DEBUG DELAYED] Group 2:', { 
                    name: this.data.groups[1].name, 
                    linksCount: this.data.groups[1].links.length,
                    firstLink: this.data.groups[1].links[0]?.text 
                  });
                }, 2000);
              }
            }
            
            // Close the dialog
            this.closeInvitationDialog();
            debugLog('log', '[INVITE] Invitation accepted successfully');
            
          } catch (e) { 
            debugLog('error', 'Failed to accept invitation:', e);
            alert('Failed to accept invitation');
          }
        },
        
        rejectInvitation() {
          debugLog('log', '[INVITE] Rejected invitation');
          // Mark as processed to prevent showing dialog again
          const env = this.invitationDialog.env;
          if (env && env.msgId && this.processedMsgIds) {
            this.processedMsgIds.add(env.msgId);
          }
          this.closeInvitationDialog();
        },
        
        closeInvitationDialog() {
          this.invitationDialog.visible = false;
          this.invitationDialog.env = null;
          const el = document.getElementById('invitationModal');
          if (el) {
            const modal = bootstrap.Modal.getInstance(el);
            if (modal) modal.hide();
          }
        },
        
        // Apply shared envelope (for link and group sharing)
        async applyShareEnvelope(env) {
          debugLog('log', '[SHARE] Applying share envelope:', env);
          const sel = env.selection || {};
          if (env.msgId && this.processedMsgIds && this.processedMsgIds.has(env.msgId)) {
            debugLog('log', '[SHARE] Skipping duplicate msgId:', env.msgId);
            return;
          }
          if (env.msgId && this.processedMsgIds) this.processedMsgIds.add(env.msgId);
          
          // Handle shared groups
          if (Array.isArray(sel.groups) && sel.groups.length) {
            debugLog('log', '[SHARE] Processing shared groups:', sel.groups.length);
            sel.groups.forEach(sharedGroup => {
              // IMPORTANT: For sent groups (not shared), always generate a new UUID
              // to prevent collision with existing groups
              // Only shared groups (with groupId) should maintain the same UUID across members
              const isSharedGroup = sharedGroup.shared && sharedGroup.groupId;
              debugLog('log', '[SHARE] Processing group:', sharedGroup.name, 'isShared:', isSharedGroup, 'originalUUID:', sharedGroup.uuid);
              let newGroupUUID = isSharedGroup ? (sharedGroup.uuid || this.generateUUID()) : this.generateUUID();
              debugLog('log', '[SHARE] New group UUID:', newGroupUUID, 'for group:', sharedGroup.name);
              
              // Check if a group with this UUID already exists
              const existingGroup = this.data.groups?.find(g => g.uuid === newGroupUUID);
              if (existingGroup) {
                debugLog('error', '[SHARE] CRITICAL: Group with UUID already exists!', newGroupUUID, existingGroup.name);
                // Force generate a new UUID if collision detected
                newGroupUUID = this.generateUUID();
                debugLog('log', '[SHARE] Generated new UUID to avoid collision:', newGroupUUID);
              }
              
              // Debug: Log all existing groups before adding
              debugLog('log', '[SHARE] Existing groups before add:', this.data.groups?.map(g => ({ 
                name: g.name, 
                uuid: g.uuid,
                column: g.column,
                index: g.index
              })));
              // Create a completely new group object to avoid any reference issues
              const g = JSON.parse(JSON.stringify({
                uuid: newGroupUUID,
                name: sharedGroup.name || `Shared from ${env.from?.name || env.from?.uuid || 'unknown'}`,
                color: sharedGroup.color || '',
                opacity: typeof sharedGroup.opacity === 'number' ? sharedGroup.opacity : 100,
                keywords: sharedGroup.keywords || '',
                urlPlaceholders: this.normalizePlaceholderList(sharedGroup.urlPlaceholders || []),
                column: Math.max(0, ...(this.getGroupColumns() || [0])),
                index: (this.data.groups || []).length,
                collapsed: false,
                links: [],
                // Include event-log data if available
                useEventLog: sharedGroup.useEventLog || false,
                eventLog: sharedGroup.eventLog || [],
                snapshot: sharedGroup.snapshot || null,
                headEventId: sharedGroup.headEventId || null,
                vectorClock: sharedGroup.vectorClock || {}
              }));
              
              // Add links from the shared group
              if (Array.isArray(sharedGroup.links)) {
                const linkUuidMap = new Map();
                sharedGroup.links.forEach((l) => {
                  const originalUuid = l?.uuid || '';
                  const nextUuid = isSharedGroup ? (originalUuid || this.generateUUID()) : this.generateUUID();
                  if (originalUuid) linkUuidMap.set(originalUuid, nextUuid);
                });
                sharedGroup.links.forEach((l, i) => {
                  // For sent groups, generate new UUIDs for links too
                  // Only shared groups should maintain the same link UUIDs
                  // Create a completely new object to avoid any reference issues
                  const sourceUuid = l?.uuid || '';
                  const mappedUuid = sourceUuid
                    ? (linkUuidMap.get(sourceUuid) || sourceUuid)
                    : this.generateUUID();
                  const mappedRefTargetUuid = (l?.refTargetUuid && linkUuidMap.has(l.refTargetUuid))
                    ? linkUuidMap.get(l.refTargetUuid)
                    : (l?.refTargetUuid || '');
                  const newLink = JSON.parse(JSON.stringify({
                    uuid: mappedUuid,
                    text: l.text || l.url,
                    url: l.url,
                    rawUrlInput: l.rawUrlInput || '',
                    urlPlaceholders: this.normalizePlaceholderList(l.urlPlaceholders || []),
                    keywords: l.keywords || '',
                    infoHtml: this.sanitizeHtml(String(l.infoHtml || '')),
                    color: l.color || '',
                    refTargetUuid: mappedRefTargetUuid,
                    inheritSourceKeywords: l.inheritSourceKeywords !== false,
                    shortcut: l.shortcut || '',
                    emoji: l.emoji || '',
                    column: typeof l.column === 'number' ? l.column : 0,
                    index: typeof l.index === 'number' ? l.index : i,
                    editing: false,
                    isMouseOver: false
                  }));
                  g.links.push(newLink);
                });
              }
              
              // Ensure reactive UI properties for group
              g.isMouseOver = false;
              g.editing = false;
              
              debugLog('log', '[SHARE] Adding group:', g.name, 'with', g.links.length, 'links', 'UUID:', g.uuid);
              if (!Array.isArray(this.data.groups)) this.$set(this.data, 'groups', []);
              // Use Vue's reactive method to add the group
              const newIndex = this.data.groups.length;
              this.$set(this.data.groups, newIndex, g);
              
              // Debug: Log all groups after adding
              debugLog('log', '[SHARE] Groups after add:', this.data.groups.map(grp => ({ 
                name: grp.name, 
                uuid: grp.uuid, 
                column: grp.column,
                index: grp.index,
                linksCount: grp.links?.length,
                firstLink: grp.links?.[0]?.text 
              })));
            });
          }
          
          // Handle shared links (create new group for them)
          else if (Array.isArray(sel.links) && sel.links.length) {
            debugLog('log', '[SHARE] Processing shared links:', sel.links.length);
            const name = `Shared from ${env.from?.name || env.from?.uuid || 'unknown'} ${moment(env.ts || Date.now()).format('LLL')}`;
            const g = { 
              uuid: this.generateUUID(),
              name, 
              color: '', 
              opacity: 100, 
              keywords: '', 
              urlPlaceholders: [],
              column: Math.max(0, ...(this.getGroupColumns() || [0])), 
              index: (this.data.groups || []).length, 
              collapsed: false, 
              links: [],
              isMouseOver: false,
              editing: false
            };
            const linkUuidMap = new Map();
            sel.links.forEach((l) => {
              const originalUuid = l?.uuid || '';
              const nextUuid = this.generateUUID();
              if (originalUuid) linkUuidMap.set(originalUuid, nextUuid);
            });
            sel.links.forEach((l, i) => g.links.push({ 
              uuid: (l?.uuid && linkUuidMap.get(l.uuid)) ? linkUuidMap.get(l.uuid) : this.generateUUID(),
              text: l.text || l.url, 
              url: l.url, 
              rawUrlInput: l.rawUrlInput || '',
              urlPlaceholders: this.normalizePlaceholderList(l.urlPlaceholders || []),
              keywords: l.keywords || '', 
              infoHtml: this.sanitizeHtml(String(l.infoHtml || '')),
              color: l.color || '',
              refTargetUuid: (l?.refTargetUuid && linkUuidMap.has(l.refTargetUuid)) ? linkUuidMap.get(l.refTargetUuid) : (l.refTargetUuid || ''),
              inheritSourceKeywords: l.inheritSourceKeywords !== false,
              shortcut: l.shortcut || '',
              emoji: l.emoji || '',
              column: 0, 
              index: i,
              editing: false,
              isMouseOver: false
            }));
            debugLog('log', '[SHARE] Adding group:', g.name, 'with', g.links.length, 'links', 'UUID:', g.uuid);
            if (!Array.isArray(this.data.groups)) this.$set(this.data, 'groups', []);
            // Use Vue's reactive method to add the group
            const newIndex = this.data.groups.length;
            this.$set(this.data.groups, newIndex, g);
          } else {
            debugLog('log', '[SHARE] No groups or links to process');
          }
          
          // Final debug: Check if groups are still correct after everything
          debugLog('log', '[SHARE] Final check - all groups:', this.data.groups.map(grp => ({ 
            name: grp.name, 
            uuid: grp.uuid, 
            groupId: grp.groupId,
            shared: grp.shared,
            linksCount: grp.links?.length,
            firstLink: grp.links?.[0]?.text 
          })));
          
          // Debug before saveData
          debugLog('log', '[SHARE] Before saveData - groups:', this.data.groups.map(g => ({
            name: g.name,
            uuid: g.uuid,
            linksCount: g.links?.length,
            firstLink: g.links?.[0]?.text
          })));
          
          this.saveData();
          
          // Debug after saveData
          debugLog('log', '[SHARE] After saveData - groups:', this.data.groups.map(g => ({
            name: g.name,
            uuid: g.uuid,
            linksCount: g.links?.length,
            firstLink: g.links?.[0]?.text
          })));
          
          // Debug before forceUpdate
          debugLog('log', '[SHARE] Before $forceUpdate - groups:', this.data.groups.length);
          
          // CRITICAL FIX: Force Vue to completely re-render by replacing the array
          // This ensures no cached computed properties or stale references persist
          const newGroupsArray = JSON.parse(JSON.stringify(this.data.groups));
          this.$set(this.data, 'groups', newGroupsArray);
          
          // Also force update all Vue internals
          this.$nextTick(() => {
            try { 
              this.$forceUpdate(); 
              
              // Debug after forceUpdate
              debugLog('log', '[SHARE] After $forceUpdate - groups:', this.data.groups.map(grp => ({ 
                name: grp.name, 
                uuid: grp.uuid,
                linksCount: grp.links?.length
              })));
              
              // Final verification after Vue's next tick
              this.$nextTick(() => {
                debugLog('log', '[SHARE] Final verification after next tick:');
                this.data.groups.forEach((g, idx) => {
                  debugLog('log', `  Group ${idx}: ${g.name} (UUID: ${g.uuid}) - Links: ${g.links?.length}, First: ${g.links?.[0]?.text}`);
                });
              });
            } catch(e) {
              debugLog('error', '[SHARE] $forceUpdate failed:', e);
            }
          });
        },
        // ---------- History / Undo-Redo ----------
        undo() {
          if (!this.historyPast.length) return;
          const current = this.getSavableData();
          const snapshot = this.historyPast.pop();
          this.historyFuture.push(current);
          this._applySnapshot(snapshot);
        },
        redo() {
          if (!this.historyFuture.length) return;
          const current = this.getSavableData();
          const snapshot = this.historyFuture.pop();
          this.historyPast.push(current);
          this._applySnapshot(snapshot);
        },
        async _applySnapshot(snap) {
          if (!snap) return;
          this.historyLock = true;
          try {
            const merged = Object.assign({}, JSON.parse(JSON.stringify(initialData)), snap);
            this.data.options = merged.options || this.data.options;
            this.data.groups = Array.isArray(merged.groups) ? merged.groups : [];
            this.fixOptions();
            (this.data.groups || []).forEach(g => {
              if (g.column === undefined || g.column === null) this.$set(g, 'column', 0);
              this.$set(g, 'urlPlaceholders', this.normalizePlaceholderList(g.urlPlaceholders || []));
              this.$set(g, 'editing', false);
              this.$set(g, 'isMouseOver', false);
              if (g.collapsed === undefined) this.$set(g, 'collapsed', false);
              this.$set(g, 'searchCollapsed', true);
              this.$set(g, 'newLinkText', '');
              this.$set(g, 'newLinkUrl', '');
              if (!Array.isArray(g.links)) this.$set(g, 'links', []);
              (g.links || []).forEach(l => {
                if (l.column === undefined || l.column === null) this.$set(l, 'column', 0);
                this.$set(l, 'urlPlaceholders', this.normalizePlaceholderList(l.urlPlaceholders || []));
                if (this.isReferenceLink(l) && l.inheritSourceKeywords === undefined) this.$set(l, 'inheritSourceKeywords', true);
                this.$set(l, 'editing', false);
                this.$set(l, 'isMouseOver', false);
              });
              this.getLinkColumns(g.links).forEach(col => this.reindexArr(g.links.filter(l => l.column === col)));
            });
            this.getGroupColumns().forEach(col => this.reindexArr(this.data.groups.filter(g => g.column === col)));
            if (typeof this.saveDataImmediate === 'function') await this.saveDataImmediate(); else this.saveData();
          } finally {
            this.historyLock = false;
          }
        },

        // ---------- Bookmarklet ----------
        handleBookmarkletAdd() {
          const p = new URLSearchParams(location.search);
          const url = p.get('add');
          if (!url) return;
          const title = p.get('title') || url;
          const g = (this.data.groups && this.data.groups[0]) || null;
          if (!g) return;
          this.openAddLinkDialog(g);
          this.$nextTick(() => {
            if (this.editLink) {
              this.editLink.url = url;
              this.editLink.text = title;
            }
          });
        },
        showBookmarkletHelp() {
          const hrefNoQuery = (location.href || '').replace(/[?#].*$/, '');
          let base = '';
          if (location.protocol === 'file:') {
            // Use file:/// path when opened from file
            base = hrefNoQuery;
          } else if (location.origin && location.origin !== 'null') {
            base = (location.origin + location.pathname).replace(/[?#].*$/, '');
          } else {
            // Fallback: use full href without query/hash
            base = hrefNoQuery;
          }
          base = base.replace(/[?#].*$/, '');
          // Clipboard-based bookmarklet: copy URL+title to clipboard (fallback prompt on failure)
          const js = "javascript:(async()=>{try{const d={url:location.href,title:document.title};await navigator.clipboard.writeText(JSON.stringify(d));alert('Copied URL + title to clipboard');}catch(e){prompt('Copy URL manually:',location.href)}})()";
          this.bookmarkletHref = js;
          const modalElement = document.getElementById('bookmarkletModal');
          if (!modalElement) return;
          const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
          modalInstance && modalInstance.show();
        },
        openPasteModal() {
          this.pasteContent = '';
          this.pasteHint = '';
          this.parsedLinks = null;
          this.detectedFormat = '';
          this.importGroupTitle = '';
          this.isFullExport = false;
          this.fullExportData = null;
          this.importCollapsedGroups = {}; // Reset collapsed state
          this.importDialogExpandedSections = { file: true, url: true, clipboard: true };
          const modalElement = document.getElementById('pasteClipboardModal');
          if (!modalElement) return;
          const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
          modalInstance && modalInstance.show();
        },
        async readFromClipboard() {
          try {
            const txt = (await navigator.clipboard.readText()) || '';
            if (!txt.trim()) { this.pasteHint = this.getTranslation('clipboard.empty'); return; }
            this.pasteContent = txt.trim();
            this.pasteHint = this.getTranslation('clipboard.readOk');
            this.parsePastedContent();
          } catch (e) {
            debugLog('warn', 'Clipboard read failed', e);
            this.pasteHint = this.getTranslation('clipboard.noPermission');
          }
        },
        
        handleFileUpload(event) {
          const file = event.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = (e) => {
            this.pasteContent = e.target.result;
            this.parsePastedContent();
          };
          reader.readAsText(file);
        },
        
        async fetchBrowserBookmarks() {
          this.fetchingBrowserBookmarks = true;
          this.browserBookmarksInfo = '';

          try {
            const bookmarksData = await MB.Extension.getBookmarks();
            debugLog('log', 'Received browser bookmarks:', bookmarksData);

            // Handle the response structure
            let bookmarksRoot;
            if (bookmarksData.success && bookmarksData.bookmarks) {
              bookmarksRoot = bookmarksData.bookmarks;
              // Show stats if available
              if (bookmarksData.stats) {
                debugLog('log', `Extension reports: ${bookmarksData.stats.links} links in ${bookmarksData.stats.folders} folders`);
              }
            } else if (bookmarksData) {
              bookmarksRoot = bookmarksData;
            } else {
              throw new Error('No bookmarks data received from extension');
            }

            debugLog('log', 'Processing bookmark structure:', bookmarksRoot);

            // Convert bookmarks to our format for the textarea
            const links = [];
            let folderCount = 0;
            let linkCount = 0;

            const extractLinks = (node, path = '') => {
              if (!node) return;

              // Handle the flattened structure where groups have both links AND children

              // First, process any links directly in this node
              if (node.links && Array.isArray(node.links) && node.links.length > 0) {
                // Use the node's path if available, otherwise use the title
                const groupPath = node.path || node.title || 'Folder';

                node.links.forEach(link => {
                  if (link.url) {
                    links.push({
                      text: link.text || link.title || link.url,
                      url: link.url,
                      path: groupPath  // Use the full path from the node
                    });
                    linkCount++;
                  }
                });
              }

              // Then process children (which are groups in the flattened structure)
              if (node.children && Array.isArray(node.children)) {
                node.children.forEach(child => {
                  folderCount++;
                  // Recursively process each child group
                  extractLinks(child, '');
                });
              }

              // Handle single link node (backwards compatibility)
              if (node.url && !node.links && !node.children) {
                links.push({
                  text: node.text || node.title || node.url,
                  url: node.url,
                  path: path
                });
                linkCount++;
              }
            };

            // Extract all links
            if (Array.isArray(bookmarksRoot)) {
              bookmarksRoot.forEach(node => extractLinks(node));
            } else {
              extractLinks(bookmarksRoot);
            }

            // Format as tab-separated for the textarea
            if (links.length > 0) {
              const formattedLinks = links.map(link => {
                // Include path info as comment if available
                const prefix = link.path ? `[${link.path}] ` : '';
                return `${prefix}${link.text}\t${link.url}`;
              }).join('\n');

              this.pasteContent = formattedLinks;
              this.parsePastedContent();

              // Show info about what was found
              this.browserBookmarksInfo = `Found ${linkCount} bookmarks in ${folderCount} folders`;
            } else {
              this.browserBookmarksInfo = 'No bookmarks found in browser';
            }

          } catch (error) {
            debugLog('error', 'Failed to fetch browser bookmarks:', error);
            this.browserBookmarksInfo = `Error: ${error.message}`;
          } finally {
            this.fetchingBrowserBookmarks = false;
          }
        },

        async fetchFromUrl() {
          if (!this.importUrl) return;

          this.fetchingUrl = true;
          this.urlFetchError = '';

          try {
            // Check if extension is available for secure fetching
            if (this.extensionAvailable) {
              debugLog('log', 'Using extension to fetch URL for import:', this.importUrl);

              // Request full HTML content and extracted links
              const metadata = await MB.Extension.fetchMetadata(this.importUrl, {
                includeHtml: true
              });

              // Check if this is a JSON endpoint or HTML page
              if (this.importUrl.endsWith('.json')) {
                // Try to parse the HTML as JSON (some servers return JSON with HTML content-type)
                try {
                  const jsonData = JSON.parse(metadata.html);
                  this.pasteContent = JSON.stringify(jsonData, null, 2);
                } catch {
                  // Not valid JSON, put the full HTML in the textarea for parsing
                  this.pasteContent = metadata.html;
                }
              } else {
                // HTML page - put the FULL HTML CONTENT in the textarea
                // The parsePastedContent function will extract links from it
                if (metadata.html) {
                  debugLog('log', `Got HTML content (${metadata.html.length} chars), letting parsePastedContent extract links`);
                  this.pasteContent = metadata.html;
                } else if (metadata.links && metadata.links.length > 0) {
                  // Fallback if no HTML but we have extracted links
                  debugLog('log', `No HTML but found ${metadata.links.length} pre-extracted links`);
                  const linkList = metadata.links.map(link => `${link.text || link.url}\t${link.url}`).join('\n');
                  this.pasteContent = linkList;
                } else {
                  // No content at all, create single link to the page
                  debugLog('warn', 'No HTML content or links found, creating single link');
                  this.pasteContent = `${metadata.title || this.importUrl}\t${this.importUrl}`;
                }
              }
              this.parsePastedContent();
            } else {
              // Extension not available - try direct fetch (will likely fail due to CORS)
              const response = await fetch(this.importUrl);

              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }

              const contentType = response.headers.get('content-type');
              let content = '';

              if (contentType && contentType.includes('application/json')) {
                const data = await response.json();
                content = JSON.stringify(data, null, 2);
              } else {
                content = await response.text();
              }

              this.pasteContent = content;
              this.parsePastedContent();
            }

          } catch (error) {
            debugLog('error', 'Failed to fetch from URL:', error);

            // Provide helpful error messages
            if (!this.extensionAvailable) {
              this.urlFetchError = this.getTranslation('import.extensionRequired') ||
                'Browser extension required for fetching URLs. Please install the MyBookmarks extension or use file upload.';
            } else if (error.message.includes('Extension needs enhancement')) {
              this.urlFetchError = error.message;
            } else if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
              this.urlFetchError = this.getTranslation('import.corsError') ||
                'Cannot fetch due to CORS policy. Try using the browser extension or download the file locally.';
            } else {
              this.urlFetchError = this.getTranslation('import.fetchError') ||
                `Failed to fetch: ${error.message}`;
            }
          } finally {
            this.fetchingUrl = false;
          }
        },
        
        parsePastedContent() {
          const txt = (this.pasteContent || '').trim();
          if (!txt) {
            this.parsedLinks = null;
            this.detectedFormat = '';
            this.isFullExport = false;
            return;
          }

          // Try to detect and parse format
          let links = [];
          this.isFullExport = false;
          this.parsedGroups = null; // Reset parsed groups

          // 1. First check if it's HTML content (most flexible parser)
          const hasHtmlTags = /<[a-z][\s\S]*>/i.test(txt);
          const hasLinks = /<a\s+[^>]*href[\s]*=/i.test(txt);
          const isLikelyHtml = hasHtmlTags || txt.includes('<!DOCTYPE') || txt.includes('<html');

          if (isLikelyHtml && hasLinks) {
            try {
              const htmlParser = new HTMLBookmarkParser({
                minLinksForGroup: 2,
                extractMetadata: true,
                extractKeywords: true,
                inferGroupNames: true
              });

              const parsedGroups = htmlParser.parse(txt);

              if (parsedGroups && parsedGroups.length > 0) {
                // Successfully parsed with groups
                let totalLinks = 0;
                parsedGroups.forEach(group => {
                  if (group.links && group.links.length > 0) {
                    totalLinks += group.links.length;
                    group.links.forEach(link => {
                      links.push({
                        text: link.text || link.url || 'Link',
                        url: link.url,
                        keywords: link.keywords || '',
                        groupName: group.name || 'Imported',
                        selected: true
                      });
                    });
                  }
                });

                if (totalLinks > 0) {
                  // Found links with groups
                  this.detectedFormat = parsedGroups.length > 1 ?
                    `HTML (${parsedGroups.length} groups, ${totalLinks} links)` :
                    `HTML (${totalLinks} links)`;
                  this.parsedGroups = parsedGroups;
                  debugLog('log', `[Import] HTMLBookmarkParser found ${parsedGroups.length} groups with ${totalLinks} links`);
                }
              }
            } catch (e) {
              debugLog('error', '[Import] HTMLBookmarkParser failed:', e);
              // Will fall through to other parsers
            }
          }

          // 2. If no HTML links found, try JSON (more structured)
          if (links.length === 0) {
            try {
            const data = JSON.parse(txt);
            if (Array.isArray(data)) {
              // JSON Array
              this.detectedFormat = 'JSON Array';
              links = data.map(item => ({
                url: item.url || item.href || item.link || '',
                text: item.text || item.title || item.name || '',
                keywords: item.keywords || item.tags || '',
                selected: true
              })).filter(l => l.url);
            } else if (data && typeof data === 'object') {
              // Single JSON Object
              this.detectedFormat = 'JSON Object';
              if (data.url || data.href || data.link) {
                links = [{
                  url: data.url || data.href || data.link,
                  text: data.text || data.title || data.name || '',
                  keywords: data.keywords || data.tags || '',
                  selected: true
                }];
              } else if (data.groups && Array.isArray(data.groups)) {
                // Check if it's a full export with settings
                if (data.options || data.identity || data.contacts || data.snapshots) {
                  this.detectedFormat = 'Full Bookmarks Export (with Settings)';
                  this.isFullExport = true;
                  this.fullExportData = data;
                } else {
                  this.detectedFormat = 'Bookmarks Export (Groups only)';
                }
                
                data.groups.forEach(group => {
                  if (group.links && Array.isArray(group.links)) {
                    group.links.forEach(link => {
                      if (!link.deleted) {
                        links.push({
                          url: link.url || '',
                          text: link.text || '',
                          keywords: link.keywords || '',
                          groupName: group.name,
                          selected: true
                        });
                      }
                    });
                  }
                });
              }
            }
          } catch (e) {
            // Not JSON, try other formats
          }
          
          // Try CSV if no JSON found (supports auto/manual separator and quoted fields)
          if (links.length === 0) {
            const csvResult = this.parseCsvLinks(txt);
            if (csvResult && csvResult.links.length > 0) {
              const delimiterLabel = csvResult.delimiter === '\t' ? '\\t' : csvResult.delimiter;
              this.detectedFormat = `CSV (${delimiterLabel})`;
              links = csvResult.links;
            }
          }
          }
          
          // Try tab-separated format (text\turl per line)
          if (links.length === 0) {
            const lines = txt.split('\n').filter(line => line.trim());
            const tabSeparatedLinks = [];

            for (const line of lines) {
              if (line.includes('\t')) {
                const parts = line.split('\t');
                if (parts.length >= 2) {
                  const url = parts[parts.length - 1].trim(); // Last part is URL
                  let text = parts.slice(0, -1).join('\t').trim(); // Everything else is text

                  // Extract folder path from text if present [Folder / Subfolder] Title or [Folder > Subfolder] Title
                  let groupName = '';
                  const pathMatch = text.match(/^\[([^\]]+)\]\s*(.*)$/);
                  if (pathMatch) {
                    const path = pathMatch[1];
                    text = pathMatch[2] || text;
                    // Use the full path as group name for hierarchical display
                    // Support both ' / ' and ' > ' as separators
                    groupName = path.trim();
                  }

                  // Validate URL
                  if (url && (url.startsWith('http://') || url.startsWith('https://') || url.includes('.'))) {
                    tabSeparatedLinks.push({
                      url: MB.Utils.ensureProtocol(url),
                      text: text || url,
                      keywords: '',
                      groupName: groupName,
                      selected: true
                    });
                  }
                }
              }
            }

            if (tabSeparatedLinks.length > 0) {
              this.detectedFormat = 'Tab-separated (text → URL)';
              links = tabSeparatedLinks;
              debugLog('log', `Parsed ${links.length} links from tab-separated format`);
            }
          }

          // Try plain URLs as last resort
          if (links.length === 0) {
            const urlRegex = /https?:\/\/[^\s]+/gi;
            const matches = txt.match(urlRegex);
            if (matches && matches.length > 0) {
              this.detectedFormat = 'Plain URLs';
              links = matches.map(url => ({
                url: url,
                text: '',
                keywords: '',
                selected: true
              }));
            }
          }
          
          this.parsedLinks = links.length > 0 ? links : null;
          if (!this.parsedLinks) {
            this.detectedFormat = '';
            this.pasteHint = this.getTranslation('clipboard.noLinksFound') || 'No valid links found';
          } else {
            this.pasteHint = '';
          }
        },

        getCsvSeparatorCharacter() {
          const raw = (this.importCsvSeparator || '').trim();
          if (!raw) return '';
          const normalized = raw.toLowerCase();
          if (normalized === '\\t' || normalized === 'tab') return '\t';
          return raw[0];
        },

        countDelimiterOutsideQuotes(line, delimiter) {
          if (!line || !delimiter) return 0;
          let inQuotes = false;
          let count = 0;
          for (let i = 0; i < line.length; i++) {
            const ch = line[i];
            if (ch === '"') {
              if (inQuotes && line[i + 1] === '"') {
                i++;
                continue;
              }
              inQuotes = !inQuotes;
              continue;
            }
            if (!inQuotes && ch === delimiter) {
              count++;
            }
          }
          return count;
        },

        detectCsvDelimiter(text) {
          const manual = this.getCsvSeparatorCharacter();
          if (manual) return manual;

          const lines = (text || '')
            .replace(/\r\n/g, '\n')
            .split('\n')
            .filter(line => line.trim())
            .slice(0, 25);
          if (lines.length === 0) return '';

          const candidates = [';', ',', '|'];
          let bestDelimiter = '';
          let bestScore = -1;

          candidates.forEach(delimiter => {
            let totalSeparators = 0;
            let linesWithSeparators = 0;
            lines.forEach(line => {
              const count = this.countDelimiterOutsideQuotes(line, delimiter);
              totalSeparators += count;
              if (count > 0) linesWithSeparators++;
            });
            const score = (linesWithSeparators * 10) + totalSeparators;
            if (score > bestScore) {
              bestScore = score;
              bestDelimiter = delimiter;
            }
          });

          return bestScore > 0 ? bestDelimiter : '';
        },

        parseCsvRows(text, delimiter) {
          if (!text || !delimiter) return [];
          const normalizedText = String(text).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
          const rows = [];
          let row = [];
          let field = '';
          let inQuotes = false;

          for (let i = 0; i < normalizedText.length; i++) {
            const ch = normalizedText[i];

            if (ch === '"') {
              if (inQuotes && normalizedText[i + 1] === '"') {
                field += '"';
                i++;
              } else {
                inQuotes = !inQuotes;
              }
              continue;
            }

            if (!inQuotes && ch === delimiter) {
              row.push(field.trim());
              field = '';
              continue;
            }

            if (!inQuotes && ch === '\n') {
              row.push(field.trim());
              if (row.some(cell => cell !== '')) {
                rows.push(row);
              }
              row = [];
              field = '';
              continue;
            }

            field += ch;
          }

          row.push(field.trim());
          if (row.some(cell => cell !== '')) {
            rows.push(row);
          }

          return rows;
        },

        isProbablyUrl(value) {
          const v = String(value || '').trim();
          if (!v) return false;
          if (/^javascript:/i.test(v)) return false;
          if (/^(https?:\/\/|ftp:\/\/|mailto:|www\.)/i.test(v)) return true;
          return /^[a-z0-9][a-z0-9-]*\.[a-z]{2,}(\/|$)/i.test(v) && !/\s/.test(v);
        },

        normalizeImportedUrl(value) {
          const raw = String(value || '').trim().replace(/^["']|["']$/g, '');
          if (!raw || /^javascript:/i.test(raw)) return '';

          let normalized = raw;
          if (!/^[a-z][a-z0-9+.-]*:/i.test(normalized)) {
            normalized = MB.Utils.ensureProtocol(normalized);
          }

          if (!/^(https?:\/\/|ftp:\/\/|mailto:)/i.test(normalized)) return '';

          try {
            new URL(normalized);
            return normalized;
          } catch (e) {
            return '';
          }
        },

        parseCsvLinks(text) {
          const delimiter = this.detectCsvDelimiter(text);
          if (!delimiter) return null;

          const rows = this.parseCsvRows(text, delimiter);
          if (!rows.length) return null;

          const maxColumns = Math.max(...rows.map(row => row.length));
          if (!maxColumns) return null;

          const normalizeHeader = (value) => String(value || '')
            .replace(/^\ufeff/, '')
            .toLowerCase()
            .trim()
            .replace(/[\s._-]+/g, '');
          const urlHeaderTokens = ['url', 'link', 'href', 'uri', 'website', 'webseite', 'adresse'];
          const titleHeaderTokens = ['title', 'titel', 'name', 'text', 'label', 'bezeichnung', 'beschreibung'];
          const keywordHeaderTokens = ['keywords', 'keyword', 'tags', 'tag', 'schlagwoerter', 'schlagworte', 'schlagwörter'];

          const headerRow = rows[0] || [];
          const findHeaderColumn = (tokens) => {
            for (let i = 0; i < maxColumns; i++) {
              const normalized = normalizeHeader(headerRow[i] || '');
              if (!normalized) continue;
              if (tokens.some(token => normalized === token || normalized.includes(token))) {
                return i;
              }
            }
            return -1;
          };

          let urlColumn = findHeaderColumn(urlHeaderTokens);
          let titleColumn = findHeaderColumn(titleHeaderTokens);
          const keywordsColumn = findHeaderColumn(keywordHeaderTokens);
          const hasKnownHeader = urlColumn >= 0 || titleColumn >= 0 || keywordsColumn >= 0;
          let startRow = hasKnownHeader ? 1 : 0;

          const findBestUrlColumn = (fromRow) => {
            let bestColumn = -1;
            let bestScore = -1;
            const maxRow = Math.min(rows.length, fromRow + 50);
            for (let col = 0; col < maxColumns; col++) {
              let score = 0;
              for (let i = fromRow; i < maxRow; i++) {
                const cell = String((rows[i] && rows[i][col]) || '').trim();
                if (!cell) continue;
                if (this.isProbablyUrl(cell)) {
                  score += 2;
                } else if (/^[a-z0-9.-]+\.[a-z]{2,}(\/|$)/i.test(cell) && !/\s/.test(cell)) {
                  score += 1;
                }
              }
              if (score > bestScore) {
                bestScore = score;
                bestColumn = col;
              }
            }
            return { bestColumn, bestScore };
          };

          if (urlColumn < 0) {
            const scanFromCurrentStart = findBestUrlColumn(startRow);
            const scanFromSecondRow = (!hasKnownHeader && rows.length > 1) ? findBestUrlColumn(1) : scanFromCurrentStart;
            const firstRowHasUrl = (rows[0] || []).some(cell => this.isProbablyUrl(cell));

            if (!hasKnownHeader && !firstRowHasUrl && scanFromSecondRow.bestScore > scanFromCurrentStart.bestScore) {
              startRow = 1;
            }

            const scan = startRow === 1 ? scanFromSecondRow : scanFromCurrentStart;
            if (scan.bestScore <= 0) return null;
            urlColumn = scan.bestColumn;
          }

          if (titleColumn < 0) {
            let bestTitleColumn = -1;
            let bestTitleScore = -1;
            const maxRow = Math.min(rows.length, startRow + 50);
            for (let col = 0; col < maxColumns; col++) {
              if (col === urlColumn) continue;
              let score = 0;
              for (let i = startRow; i < maxRow; i++) {
                const cell = String((rows[i] && rows[i][col]) || '').trim();
                if (!cell) continue;
                if (this.isProbablyUrl(cell)) {
                  score -= 2;
                } else {
                  score += 1;
                }
              }
              if (score > bestTitleScore) {
                bestTitleScore = score;
                bestTitleColumn = col;
              }
            }
            if (bestTitleScore > 0) {
              titleColumn = bestTitleColumn;
            }
          }

          const parsedLinks = [];
          for (let i = startRow; i < rows.length; i++) {
            const row = rows[i] || [];
            let rawUrl = String(row[urlColumn] || '').trim();

            if (!this.isProbablyUrl(rawUrl)) {
              const fallbackUrl = row.find(cell => this.isProbablyUrl(cell));
              if (fallbackUrl) rawUrl = String(fallbackUrl).trim();
            }

            const normalizedUrl = this.normalizeImportedUrl(rawUrl);
            if (!normalizedUrl) continue;

            let title = '';
            if (titleColumn >= 0 && titleColumn !== urlColumn) {
              title = String(row[titleColumn] || '').trim();
            }
            if (!title) {
              const fallbackTitle = row.find((cell, colIdx) =>
                colIdx !== urlColumn && cell && !this.isProbablyUrl(cell)
              );
              title = String(fallbackTitle || '').trim();
            }

            let keywords = '';
            if (keywordsColumn >= 0 && keywordsColumn !== urlColumn) {
              keywords = String(row[keywordsColumn] || '').trim();
            }

            parsedLinks.push({
              url: normalizedUrl,
              text: title,
              keywords,
              selected: true
            });
          }

          if (!parsedLinks.length) return null;

          return {
            links: parsedLinks,
            delimiter,
            urlColumn,
            titleColumn,
            startRow
          };
        },
        
        selectAllLinks() {
          if (this.parsedLinks) {
            this.parsedLinks.forEach(link => { link.selected = true; });
          }
        },
        
        deselectAllLinks() {
          if (this.parsedLinks) {
            this.parsedLinks.forEach(link => { link.selected = false; });
          }
        },
        
        getImportGroups() {
          if (!this.parsedLinks) return [];
          const groups = new Set();
          this.parsedLinks.forEach(link => {
            if (link.groupName) {
              groups.add(link.groupName);
            }
          });
          return Array.from(groups).sort();
        },

        getUniqueGroupNames() {
          if (!this.parsedLinks) return [];
          const groups = new Set();
          // Add empty string first for ungrouped links
          groups.add('');
          this.parsedLinks.forEach(link => {
            if (link.groupName) {
              groups.add(link.groupName);
            }
          });
          // Sort with empty string first, then alphabetically
          return Array.from(groups).sort((a, b) => {
            if (a === '') return -1;
            if (b === '') return 1;
            return a.localeCompare(b);
          });
        },

        getLinksForGroup(groupName) {
          if (!this.parsedLinks) return [];
          return this.parsedLinks.filter(link => (link.groupName || '') === groupName);
        },

        isImportDialogSectionExpanded(sectionKey) {
          if (this.importDialogExpandedSections[sectionKey] === undefined) {
            this.$set(this.importDialogExpandedSections, sectionKey, true);
          }
          return this.importDialogExpandedSections[sectionKey];
        },

        toggleImportDialogSection(sectionKey) {
          this.$set(this.importDialogExpandedSections, sectionKey, !this.isImportDialogSectionExpanded(sectionKey));
        },

        resetImportDialog() {
          // Clear all import-related data to free up memory
          // This is especially important for large link collections
          this.pasteContent = '';
          this.parsedLinks = null;
          this.parsedGroups = null;
          this.detectedFormat = '';
          this.isFullExport = false;
          this.fullExportData = null;
          this.pasteHint = '';
          this.importUrl = '';
          this.fetchingUrl = false;
          this.fetchMessage = '';
          this.browserBookmarks = null;
          this.selectedBookmarkFolders = [];
          this.importGroupTitle = '';
          this.importCollapsedGroups = {};
          this.importDialogExpandedSections = { file: true, url: true, clipboard: true };

          // Clear file input if exists
          if (this.$refs.fileInput) {
            this.$refs.fileInput.value = '';
          }

          debugLog('log', '[Import] Dialog reset - memory cleared');
        },

        isGroupSelected(groupName) {
          const links = this.getLinksForGroup(groupName);
          if (links.length === 0) return false;
          return links.every(link => link.selected);
        },

        toggleGroupSelection(groupName) {
          const links = this.getLinksForGroup(groupName);
          if (links.length === 0) return;

          const allSelected = links.every(link => link.selected);
          links.forEach(link => {
            link.selected = !allSelected;
          });
        },

        isImportGroupCollapsed(groupName) {
          return this.importCollapsedGroups[groupName] || false;
        },

        toggleImportGroupCollapse(groupName) {
          this.$set(this.importCollapsedGroups, groupName, !this.importCollapsedGroups[groupName]);
        },

        getGroupDisplayName(groupName) {
          // For browser bookmarks, show only the last part of the path as the main title
          if (groupName && groupName.includes(' / ')) {
            const parts = groupName.split(' / ');
            return parts[parts.length - 1];
          }
          return groupName || 'Unsorted';
        },

        getGroupFullPath(groupName) {
          // Show the full path only if it's a multi-level path (from browser bookmarks)
          if (groupName && groupName.includes(' / ')) {
            return groupName;
          }
          return ''; // Don't show path for single-level groups
        },
        
        getDefaultImportGroupTitle() {
          const now = new Date();
          const dateStr = moment(now).format('L'); // Localized date format
          const timeStr = moment(now).format('LT'); // Localized time format
          return `${this.getTranslation('import.defaultGroupTitle') || 'Import'} ${dateStr} ${timeStr}`;
        },
        
        confirmPasteAdd() {
          // Handle full export with settings - treat as database restore
          if (this.isFullExport && this.fullExportData) {
            const confirmMsg = this.getTranslation('import.fullExportConfirm') || 
                             'This will REPLACE your entire database (groups, settings, contacts, etc.).\n\n' +
                             'This is a restore operation - all UUIDs will be preserved.\n\n' +
                             'Continue?';
            
            if (confirm(confirmMsg)) {
              // Full database restore - preserve all UUIDs
              try {
                // Create backup snapshot before restore
                const backup = this.getSavableData();
                if (!this.data.snapshots) this.data.snapshots = [];
                this.data.snapshots.push({
                  timestamp: Date.now(),
                  label: 'Before Full Import Restore',
                  data: backup
                });
                
                // Complete database restore - preserve all UUIDs exactly as they are
                if (this.fullExportData.options) this.data.options = this.fullExportData.options;
                if (this.fullExportData.identity) this.data.identity = this.fullExportData.identity;
                if (this.fullExportData.contacts) this.data.contacts = this.fullExportData.contacts;
                if (this.fullExportData.snapshots) this.data.snapshots = this.fullExportData.snapshots;
                if (this.fullExportData.inbox) this.data.inbox = this.fullExportData.inbox;
                if (this.fullExportData.pendingNcDeletes) this.data.pendingNcDeletes = this.fullExportData.pendingNcDeletes;
                if (this.fullExportData.schemaVersion) this.data.schemaVersion = this.fullExportData.schemaVersion;
                
                // Restore groups with preserved UUIDs
                if (this.fullExportData.groups) {
                  this.data.groups = this.fullExportData.groups.map(g => ({
                    ...g,
                    // Preserve the UUID from the export - this is a restore operation
                    uuid: g.uuid, // Keep original UUID, don't generate new one
                    editing: false,
                    isMouseOver: false,
                    newLinkText: '',
                    newLinkUrl: '',
                    collapsed: this.data.options?.groups?.collapseGroupsOnStart || false,
                    searchCollapsed: true,
                    links: (g.links || []).map(l => ({
                      ...l,
                      // Preserve the UUID from the export - this is a restore operation
                      uuid: l.uuid, // Keep original UUID, don't generate new one
                      shortcut: l.shortcut || '',
                      editing: false,
                      isMouseOver: false
                    }))
                  }));
                }
                
                // Restore idSequence if present
                if (this.fullExportData.idSequence) {
                  this.data.idSequence = this.fullExportData.idSequence;
                }
                // Re-apply options defaults/migrations and restore Visual CSS editor state
                this.fixOptions();
                this.loadVisualCssRules();
                this.loadCustomRuleSets();
                this.loadCollapsedRules();
                this.loadDesignTokensCollapsed();
                this.applyVisualCssSidebarPreferences();

                this.saveData();
                this.updateSettings();
                
                // Close modal and refresh
                const modalElement = document.getElementById('pasteClipboardModal');
                const modalInstance = modalElement ? bootstrap.Modal.getInstance(modalElement) : null;
                modalInstance && modalInstance.hide();
                // Note: resetImportDialog() will be called automatically by the modal hidden event listener
                this.detectedFormat = '';
                this.isFullExport = false;
                this.fullExportData = null;
                return;
              } catch (error) {
                debugLog('error', 'Database restore failed:', error);
                alert(this.getTranslation('import.fullExportError') || 'Database restore failed. Check console for details.');
                return;
              }
            }
          }
          
          // Normal import - just add selected links
          if (!this.parsedLinks || this.parsedLinks.length === 0) {
            alert(this.getTranslation('clipboard.noLinksFound') || 'No links to import');
            return;
          }
          
          const selectedLinks = this.parsedLinks.filter(l => l.selected);
          if (selectedLinks.length === 0) {
            alert(this.getTranslation('clipboard.noSelection') || 'Please select at least one link');
            return;
          }
          
          // Group links by their groupName if available
          const linksByGroup = {};
          const noGroupLinks = [];
          
          selectedLinks.forEach(link => {
            if (link.groupName) {
              if (!linksByGroup[link.groupName]) {
                linksByGroup[link.groupName] = [];
              }
              linksByGroup[link.groupName].push(link);
            } else {
              noGroupLinks.push(link);
            }
          });
          
          // Process links with groupName - create groups as needed
          Object.entries(linksByGroup).forEach(([groupName, links]) => {
            // Check if group already exists
            let group = this.data.groups.find(g => g.name === groupName);
            
            if (!group) {
              // Create new group
              group = this.getNewGroupTemplate(groupName);
              // Apply default colors from settings
              group.color = this.data.options?.groups?.defaultGroupFormatting || '';
              group.titleFormatting = this.data.options?.groups?.defaultGroupTitleFormatting || '';
              group.linkFormatting = this.data.options?.groups?.defaultGroupLinkFormatting || '';
              
              // Find the column with the fewest groups
              const columns = this.getGroupColumns();
              let targetColumn = 0;
              if (columns.length > 0) {
                const groupsPerColumn = {};
                columns.forEach(col => groupsPerColumn[col] = 0);
                this.data.groups.forEach(g => {
                  if (groupsPerColumn[g.column] !== undefined) {
                    groupsPerColumn[g.column]++;
                  }
                });
                targetColumn = Object.keys(groupsPerColumn).reduce((a, b) => 
                  groupsPerColumn[a] <= groupsPerColumn[b] ? a : b
                );
              }
              group.column = parseInt(targetColumn);
              group.index = this.data.groups.length;
              if (!this.data.groups) this.data.groups = [];
              this.data.groups.push(group);
            }
            
            // Add links to the group
            links.forEach(link => {
              const newLink = {
                uuid: this.generateUUID(),
                url: link.url || '',
                text: link.text || '',
                urlPlaceholders: [],
                keywords: link.keywords || '',
                shortcut: '',
                column: 0,
                index: group.links ? group.links.length : 0,
                editing: false,
                isMouseOver: false
              };
              if (!group.links) group.links = [];
              group.links.push(newLink);
            });
          });
          
          // Process links without groupName
          if (noGroupLinks.length > 0) {
            let g = null;
            
            // Use specified title or generate default with date
            const groupTitle = this.importGroupTitle && this.importGroupTitle.trim() 
              ? this.importGroupTitle.trim() 
              : this.getDefaultImportGroupTitle();
            
            // Create new group with title
            const newGroup = this.getNewGroupTemplate(groupTitle);
            // Apply default colors from settings
            newGroup.color = this.data.options?.groups?.defaultGroupFormatting || '';
            newGroup.titleFormatting = this.data.options?.groups?.defaultGroupTitleFormatting || '';
            newGroup.linkFormatting = this.data.options?.groups?.defaultGroupLinkFormatting || '';
            newGroup.badgeFormatting = this.data.options?.groups?.defaultGroupBadgeFormatting || '';
            newGroup.pillFormatting = this.data.options?.groups?.defaultGroupPillFormatting || '';
            newGroup.pillColor = '';
            // Find the column with the fewest groups
            const columns = this.getGroupColumns();
            let targetColumn = 0;
            if (columns.length > 0) {
              const groupsPerColumn = {};
              columns.forEach(col => groupsPerColumn[col] = 0);
              this.data.groups.forEach(group => {
                if (groupsPerColumn[group.column] !== undefined) {
                  groupsPerColumn[group.column]++;
                }
              });
              targetColumn = Object.keys(groupsPerColumn).reduce((a, b) => 
                groupsPerColumn[a] <= groupsPerColumn[b] ? a : b
              );
            }
            newGroup.column = parseInt(targetColumn);
            newGroup.index = this.data.groups.length;
            if (!this.data.groups) this.data.groups = [];
            this.data.groups.push(newGroup);
            g = newGroup;
            
            if (!g) { 
              alert('No group available'); 
              return; 
            }
            
            // Add all no-group links to the selected group
            noGroupLinks.forEach(link => {
              const newLink = {
                uuid: this.generateUUID(),
                url: link.url || '',
                text: link.text || '',
                urlPlaceholders: [],
                keywords: link.keywords || '',
                shortcut: '',
                column: 0,
                index: g.links ? g.links.length : 0,
                editing: false,
                isMouseOver: false
              };
              if (!g.links) g.links = [];
              g.links.push(newLink);
            });
          }
          
          this.saveData();
          
          // Close modal
          const modalElement = document.getElementById('pasteClipboardModal');
          const modalInstance = modalElement ? bootstrap.Modal.getInstance(modalElement) : null;
          modalInstance && modalInstance.hide();

          // Note: resetImportDialog() will be called automatically by the modal hidden event listener
        },

        // ---------- Smart Sync for Shared Groups ----------
        
        initSmartSync() {
          // Initialize smart sync for shared groups
          if (!this.data.syncState) {
            this.$set(this.data, 'syncState', {});
          }
          
          debugLog('log', '[SMART-SYNC] Initializing sync for shared groups');
          
          // Check for updates on startup for all shared groups
          // This ensures offline members get updates when they come online
          this.data.groups.forEach(group => {
            if (group.shared && group.groupId) {
              // Schedule sync for all shared groups (both owners and members)
              // Members need updates from when they were offline
              // Owners might need to provide updates to members coming online
              const delay = Math.random() * 10000; // Random delay up to 10 seconds
              debugLog('log', `[SMART-SYNC] Scheduling initial sync for ${group.name} in ${Math.round(delay/1000)}s`);
              this.scheduleGroupSync(group, delay);
            }
          });
        },
        
        scheduleGroupSync(group, delayMs = Math.random() * 5000) {
          // Stagger sync requests to avoid thundering herd
          setTimeout(() => {
            this.requestSmartSync(group);
          }, delayMs);
        },
        
        async requestSmartSync(group) {
          if (!group.shared || !group.groupId) {
            debugLog('log', '[SMART-SYNC] Skipping non-shared group');
            return;
          }
          
          // Ensure syncState exists
          if (!this.data.syncState) {
            this.$set(this.data, 'syncState', {});
          }
          
          const syncStateKey = group.groupId || group.id;
          const syncState = this.data.syncState[syncStateKey] || {};
          const now = Date.now();
          
          // Don't sync too frequently (max once per minute)
          if (syncState.lastSyncAttempt && (now - syncState.lastSyncAttempt) < CONSTS.MINUTE_MS) {
            const remaining = Math.ceil((CONSTS.MINUTE_MS - (now - syncState.lastSyncAttempt)) / 1000);
            debugLog('log', `[SMART-SYNC] Too soon to sync ${group.name}, wait ${remaining}s`);
            return;
          }
          
          // Update sync attempt time
          this.$set(this.data.syncState, syncStateKey, {
            ...syncState,
            lastSyncAttempt: now
          });
          
          // Calculate our version
          const myVersion = group.version || (group.links?.length || 0);
          
          debugLog('log', '[SMART-SYNC] Requesting sync for group', {
            name: group.name,
            groupId: group.groupId,
            myVersion,
            members: group.sharedWith?.length
          });
          
          // Phase 1: Send version check request (lightweight)
          const versionCheckRequest = {
            type: 'sync-version-check',
            groupId: group.groupId,
            myVersion: myVersion,
            requestId: this.generateUUID(),
            from: { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' },
            timestamp: now
          };
          
          // Store request for response matching
          this.pendingSyncRequests = this.pendingSyncRequests || {};
          this.pendingSyncRequests[versionCheckRequest.requestId] = {
            group: group,
            responses: [],
            timeout: setTimeout(() => {
              this.processSyncResponses(versionCheckRequest.requestId);
            }, 3000) // Wait 3 seconds for responses
          };
          
          // Send to all group members via group channel
          if (window.sharing) {
            await window.sharing.sendToGroup(group, versionCheckRequest);
          }
        },
        
        async handleSyncVersionCheck(message, fromMember) {
          // Find group by groupId (shared groups use groupId, not id)
          const group = this.data.groups.find(g => g.groupId === message.groupId);
          if (!group || !group.shared) {
            debugLog('log', '[SMART-SYNC] Group not found or not shared', message.groupId);
            return;
          }
          
          // Calculate version from links count/modification
          const version = group.version || (group.links?.length || 0);
          
          debugLog('log', '[SMART-SYNC] Responding to version check', { 
            groupId: group.groupId, 
            myVersion: version,
            fromMember 
          });
          
          // Respond with our version info
          const response = {
            type: 'sync-version-response',
            requestId: message.requestId,
            groupId: message.groupId,
            myVersion: version,
            memberCount: group.sharedWith?.length || 0,
            uuid: this.data.identity?.uuid,
            from: { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' },
            timestamp: Date.now()
          };
          
          // Send response via group channel (more reliable than direct member channel)
          if (window.sharing) {
            await window.sharing.sendToGroup(group, response);
          }
        },
        
        handleSyncVersionResponse(message) {
          const pending = this.pendingSyncRequests?.[message.requestId];
          if (!pending) return;
          
          pending.responses.push(message);
        },
        
        processSyncResponses(requestId) {
          const pending = this.pendingSyncRequests?.[requestId];
          if (!pending) return;
          
          clearTimeout(pending.timeout);
          delete this.pendingSyncRequests[requestId];
          
          const group = pending.group;
          const responses = pending.responses;
          
          if (responses.length === 0) {
            // No responses - we might be the only one online
            debugLog('log', '[SYNC] No responses for group', group.name);
            return;
          }
          
          // Find the newest version
          const newestVersion = Math.max(
            group.version || 0,
            ...responses.map(r => r.myVersion || 0)
          );
          
          if (newestVersion <= (group.version || 0)) {
            // We already have the newest version
            debugLog('log', '[SYNC] Already have newest version for group', group.name);
            return;
          }
          
          // We need an update - determine who should send it
          const updatedMembers = responses.filter(r => r.myVersion === newestVersion);
          
          // Leader election: Member with newest version and lowest UUID sends
          updatedMembers.sort((a, b) => (a.uuid || '').localeCompare(b.uuid || ''));
          const designatedSender = updatedMembers[0];
          
          // Prepare fallback members (next 2 members with newest version)
          const fallbackMembers = updatedMembers.slice(1, 3).map(m => m.uuid);
          
          // Request full update from designated sender with fallbacks
          this.requestFullUpdate(group, designatedSender.uuid, fallbackMembers);
        },
        
        async requestFullUpdate(group, fromMemberUuid, fallbackMembers = []) {
          const request = {
            type: 'sync-request-full',
            groupId: group.id,
            requestId: this.generateUUID(),
            toMember: fromMemberUuid
          };
          
          // Store fallback info for timeout handling
          this.pendingUpdateRequests = this.pendingUpdateRequests || {};
          this.pendingUpdateRequests[request.requestId] = {
            group: group,
            primaryMember: fromMemberUuid,
            fallbackMembers: fallbackMembers,
            attemptNumber: 1,
            timeout: setTimeout(() => {
              this.handleUpdateTimeout(request.requestId);
            }, 5000) // 5 second timeout for full update
          };
          
          // Send request only to designated sender
          await this.sendToMember(fromMemberUuid, request);
        },
        
        handleUpdateTimeout(requestId) {
          const pending = this.pendingUpdateRequests?.[requestId];
          if (!pending) return;
          
          clearTimeout(pending.timeout);
          
          debugLog('log', '[SYNC] Update timeout for attempt', pending.attemptNumber, 'from', pending.primaryMember);
          
          // Try next fallback member
          if (pending.fallbackMembers.length > 0 && pending.attemptNumber < 3) {
            const nextMember = pending.fallbackMembers.shift();
            debugLog('log', '[SYNC] Trying fallback member', nextMember);
            
            // Update pending request
            pending.primaryMember = nextMember;
            pending.attemptNumber++;
            pending.timeout = setTimeout(() => {
              this.handleUpdateTimeout(requestId);
            }, 5000);
            
            // Send request to next member
            const request = {
              type: 'sync-request-full',
              groupId: pending.group.id,
              requestId: requestId,
              toMember: nextMember
            };
            
            this.sendToMember(nextMember, request);
          } else {
            // All attempts failed - try broadcast as last resort
            debugLog('log', '[SYNC] All targeted attempts failed, trying broadcast');
            delete this.pendingUpdateRequests[requestId];
            
            this.requestBroadcastUpdate(pending.group);
          }
        },
        
        async requestBroadcastUpdate(group) {
          // Last resort: Ask everyone for update
          const request = {
            type: 'sync-request-any',
            groupId: group.id,
            requestId: this.generateUUID(),
            myVersion: group.version || 0,
            timestamp: Date.now()
          };
          
          // Limit responses with a random selection mechanism
          this.pendingBroadcastRequests = this.pendingBroadcastRequests || {};
          this.pendingBroadcastRequests[request.requestId] = {
            group: group,
            responded: false,
            timeout: setTimeout(() => {
              delete this.pendingBroadcastRequests[request.requestId];
            }, 10000) // 10 second timeout
          };
          
          await this.broadcastToGroup(group, request);
        },
        
        async handleSyncRequestAny(message, fromMember) {
          const group = this.data.groups.find(g => g.id === message.groupId);
          if (!group || !group.shared) return;
          
          // Check if the requesting member is still in the group
          const memberStillInGroup = group.members?.some(m => m.uuid === fromMember.uuid);
          if (!memberStillInGroup) {
            // Member was removed - send removal notification
            await this.sendMemberRemovalNotification(group, fromMember);
            return;
          }
          
          // Check if we have a newer version
          if ((group.version || 0) <= message.myVersion) return;
          
          // Implement random backoff to avoid everyone responding
          const responseDelay = Math.random() * 3000; // 0-3 seconds random delay
          
          setTimeout(async () => {
            // Check if request is still pending (not already handled)
            if (!this.pendingBroadcastRequests?.[message.requestId]) return;
            
            // Send update with probability to reduce responses
            const shouldRespond = Math.random() < 0.3; // Only 30% chance to respond
            if (!shouldRespond) return;
            
            const update = {
              type: 'sync-broadcast-update',
              requestId: message.requestId,
              groupId: group.id,
              groupData: {
                version: group.version || Date.now(),
                links: group.links || [],
                name: group.name
              },
              timestamp: Date.now()
            };
            
            await this.sendToMember(fromMember, update);
          }, responseDelay);
        },
        
        handleSyncBroadcastUpdate(message) {
          const pending = this.pendingBroadcastRequests?.[message.requestId];
          if (!pending || pending.responded) return;
          
          // Mark as responded to ignore further updates
          pending.responded = true;
          clearTimeout(pending.timeout);
          delete this.pendingBroadcastRequests[message.requestId];
          
          // Apply the update
          this.handleSyncFullUpdate(message);
        },
        
        async handleSyncRequestFull(message, fromMember) {
          const group = this.data.groups.find(g => g.id === message.groupId);
          if (!group || !group.shared) return;
          
          // Check if the requesting member is still in the group
          const memberStillInGroup = group.members?.some(m => m.uuid === fromMember.uuid);
          if (!memberStillInGroup) {
            // Member was removed - send removal notification
            await this.sendMemberRemovalNotification(group, fromMember);
            return;
          }
          
          // Check if we're the designated sender
          if (message.toMember !== this.data.identity?.uuid) return;
          
          // Send full group update
          const update = {
            type: 'sync-full-update',
            requestId: message.requestId,
            groupId: group.id,
            groupData: {
              version: group.version || Date.now(),
              links: group.links || [],
              name: group.name,
              // Include other group properties as needed
            },
            timestamp: Date.now()
          };
          
          await this.sendToMember(fromMember, update);
        },
        
        handleSyncFullUpdate(message) {
          const group = this.data.groups.find(g => g.id === message.groupId);
          if (!group || !group.shared) return;
          
          // Clear any pending update requests for this group
          if (message.requestId && this.pendingUpdateRequests?.[message.requestId]) {
            clearTimeout(this.pendingUpdateRequests[message.requestId].timeout);
            delete this.pendingUpdateRequests[message.requestId];
          }
          
          // Apply the update if it's newer
          if ((message.groupData.version || 0) > (group.version || 0)) {
            // Merge the update
            group.version = message.groupData.version;
            group.links = (Array.isArray(message.groupData.links) ? message.groupData.links : []).map((link) => {
              const normalizedType = this.normalizeLinkItemType(link);
              return this.normalizeLinkDataForItemType(Object.assign({}, link), normalizedType);
            });
            // Update other properties as needed
            
            this.saveData();
            debugLog('log', '[SYNC] Updated group', group.name, 'to version', group.version);
            
            // Update sync state
            this.$set(this.data.syncState, group.id, {
              lastSyncAttempt: Date.now(),
              lastSuccessfulSync: Date.now(),
              version: group.version
            });
          }
        },
        
        async broadcastToGroup(group, message) {
          // Send message to all group members
          if (!group.sharedWith) return;
          
          for (const memberUuid of group.sharedWith) {
            if (memberUuid !== this.data.identity?.uuid) {
              await this.sendToMember(memberUuid, message);
            }
          }
        },
        
        async handleSyncFullRequest(message) {
          const group = this.data.groups.find(g => g.groupId === message.groupId);
          if (!group || !group.shared) {
            debugLog('log', '[SMART-SYNC] Cannot send full update - group not found', message.groupId);
            return;
          }
          
          debugLog('log', '[SMART-SYNC] Sending full update to requester', {
            groupId: group.groupId,
            links: group.links?.length
          });
          
          // Send full group snapshot including event-log and snapshots
          const fullUpdate = {
            type: 'sync-full-update',
            requestId: message.requestId,
            groupId: group.groupId,
            version: group.version || (group.links?.length || 0),
            name: group.name,
            emoji: group.emoji || '',
            color: group.color || '',
            links: (group.links || []).map(l => ({
              uuid: l.uuid || this.generateUUID(),
              itemType: this.normalizeLinkItemType(l),
              text: l.text || '',
              url: l.url || '',
              rawUrlInput: l.rawUrlInput || '',
              keywords: l.keywords || '',
              emoji: l.emoji || '',
              shortcut: l.shortcut || '',
              refTargetUuid: l.refTargetUuid || '',
              inheritSourceKeywords: l.inheritSourceKeywords !== false,
              urlPlaceholders: this.normalizePlaceholderList(l.urlPlaceholders || []),
              column: l.column || 0,
              index: typeof l.index === 'number' ? l.index : 0
            })),
            // Include event-log data if available
            useEventLog: group.useEventLog || false,
            eventLog: group.eventLog || [],
            snapshot: group.snapshot || null,
            headEventId: group.headEventId || null,
            vectorClock: group.vectorClock || {},
            from: { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' },
            timestamp: Date.now()
          };
          
          // Send via group channel for reliability (chunked if large)
          if (window.sharing) {
            const raw = JSON.stringify(fullUpdate);
            if (raw.length > 100000) {
              await window.sharing.sendChunkedGroup(group, 'full-update', fullUpdate);
            } else {
              await window.sharing.sendToGroup(group, fullUpdate);
            }
          }
        },
        
        async handleSyncFullUpdate(message) {
          const group = this.data.groups.find(g => g.groupId === message.groupId);
          if (!group || !group.shared) {
            debugLog('log', '[SMART-SYNC] Cannot apply full update - group not found', message.groupId);
            return;
          }
          
          // Clear pending update request if this matches
          const pending = this.pendingUpdateRequests?.[message.requestId];
          if (pending) {
            clearTimeout(pending.timeout);
            delete this.pendingUpdateRequests[message.requestId];
          }
          
          debugLog('log', '[SMART-SYNC] Applying full update', {
            groupId: group.groupId,
            newVersion: message.version,
            oldVersion: group.version || 0,
            linksCount: message.links?.length
          });
          
          // Update group metadata
          group.version = message.version;
          if (message.name) group.name = message.name;
          if (message.emoji !== undefined) group.emoji = message.emoji || '';
          if (message.color !== undefined) group.color = message.color;
          
          // Apply links update - prevent duplicates
          if (Array.isArray(message.links)) {
            const isOwner = (group.members || []).some(m => m.role === 'owner' && m.uuid === this.data.identity?.uuid);
            
            if (!isOwner) {
              // Members accept the full update
              const existingUuids = new Set();
              const newLinks = [];
              
              for (const link of message.links) {
                // Ensure each link has a UUID
                const linkUuid = link.uuid || this.generateUUID();
                
                // Skip duplicates
                if (existingUuids.has(linkUuid)) {
                  debugLog('log', '[SMART-SYNC] Skipping duplicate link', linkUuid);
                  continue;
                }
                
                existingUuids.add(linkUuid);
                const normalizedType = this.normalizeLinkItemType(link);
                newLinks.push(this.normalizeLinkDataForItemType({
                  uuid: linkUuid,
                  itemType: normalizedType,
                  text: link.text || '',
                  url: link.url || '',
                  rawUrlInput: link.rawUrlInput || '',
                  keywords: link.keywords || '',
                  emoji: link.emoji || '',
                  shortcut: link.shortcut || '',
                  refTargetUuid: link.refTargetUuid || '',
                  inheritSourceKeywords: link.inheritSourceKeywords !== false,
                  urlPlaceholders: this.normalizePlaceholderList(link.urlPlaceholders || []),
                  column: link.column || 0,
                  index: typeof link.index === 'number' ? link.index : 0,
                  editing: false,
                  isMouseOver: false
                }, normalizedType));
              }
              
              // Replace links array completely to avoid duplicates
              this.$set(group, 'links', newLinks);
              debugLog('log', '[SMART-SYNC] Replaced links array', { count: newLinks.length });
            }
          }
          
          // Apply event-log data if available - BUT DON'T OVERWRITE OWNER'S DATA
          if (message.useEventLog && message.eventLog) {
            const isOwner = (group.members || []).some(m => m.role === 'owner' && m.uuid === this.data.identity?.uuid);
            
            if (isOwner && group.useEventLog && group.eventLog) {
              // OWNER: Merge events, don't overwrite
              debugLog('log', '[SMART-SYNC] Owner merging event-log from full update', {
                currentEventCount: group.eventLog?.length || 0,
                incomingEventCount: message.eventLog?.length || 0
              });
              
              // Find new events that we don't have yet
              const existingEventIds = new Set((group.eventLog || []).map(e => e.eventId));
              const newEvents = (message.eventLog || []).filter(e => !existingEventIds.has(e.eventId));
              
              if (newEvents.length > 0) {
                debugLog('log', '[SMART-SYNC] Owner merging new events', { count: newEvents.length });
                // Merge new events
                if (this.eventLogManager) {
                  newEvents.forEach(event => {
                    this.eventLogManager.applyRemoteEvent(group, event, 'owner-leads');
                  });
                }
              }
              
              // Merge vector clocks
              if (message.vectorClock) {
                const mergedVC = { ...(group.vectorClock || {}) };
                Object.keys(message.vectorClock).forEach(key => {
                  mergedVC[key] = Math.max(mergedVC[key] || 0, message.vectorClock[key] || 0);
                });
                this.$set(group, 'vectorClock', mergedVC);
              }
            } else {
              // MEMBER or OWNER without event-log yet: Accept full event-log
              debugLog('log', '[SMART-SYNC] Applying complete event-log data', {
                isOwner,
                eventLogCount: message.eventLog?.length || 0,
                hasSnapshot: !!message.snapshot
              });
              
              this.$set(group, 'useEventLog', true);
              this.$set(group, 'eventLog', message.eventLog || []);
              this.$set(group, 'snapshot', message.snapshot || null);
              this.$set(group, 'headEventId', message.headEventId || null);
              this.$set(group, 'vectorClock', message.vectorClock || {});
            }
            
            debugLog('log', '[SMART-SYNC] Event-log data processed successfully');
          }
          
          this.saveData();
        },
        
        async handleSyncBroadcastRequest(message) {
          const group = this.data.groups.find(g => g.groupId === message.groupId);
          if (!group || !group.shared) return;
          
          const myVersion = group.version || (group.links?.length || 0);
          
          // Only respond if we have a newer version
          if (myVersion <= message.myVersion) {
            debugLog('log', '[SMART-SYNC] Ignoring broadcast request - no newer version');
            return;
          }
          
          // Use random delay and probability to avoid thundering herd
          const delay = Math.random() * 2000;
          const probability = 1 / Math.max(2, group.sharedWith?.length || 2);
          
          if (Math.random() < probability) {
            setTimeout(async () => {
              debugLog('log', '[SMART-SYNC] Responding to broadcast request with full update');
              await this.handleSyncFullRequest(message);
            }, delay);
          }
        },
        
        async sendMemberRemovalNotification(group, removedMember) {
          // Find the owner of the group
          const owner = group.members?.find(m => m.role === 'owner');
          const ownerName = owner?.name || owner?.uuid || 'Unknown';
          
          const notification = {
            type: 'member-removed-notification',
            groupId: group.id || group.uuid,
            groupName: group.name,
            ownerName: ownerName,
            removedAt: Date.now(),
            message: 'You have been removed from this group'
          };
          
          debugLog('log', '[SYNC] Sending removal notification to:', removedMember.uuid);
          await this.sendToMember(removedMember.uuid, notification);
        },
        
        handleMemberRemovedNotification(message) {
          debugLog('log', '[SYNC] Received removal notification:', message);
          
          // Show the notification dialog
          this.showRemovedFromGroupNotification(
            message.groupName,
            message.ownerName,
            message.groupId,
            message.removedAt
          );
        },
        
        async sendToMember(memberUuid, message) {
          // Send message to a specific group member via their contact channel
          try {
            // Find the contact by UUID
            const contact = (this.data.contacts || []).find(c => c.uuid === memberUuid);
            if (!contact) {
              debugLog('warn', '[SYNC] Cannot send to member - contact not found:', memberUuid);
              return false;
            }
            
            // Use the sharing service to send via the contact's channel
            if (window.sharing && typeof window.sharing.sendToContact === 'function') {
              await window.sharing.sendToContact(memberUuid, message);
              debugLog('log', '[SYNC] Message sent to member', memberUuid, message.type);
              return true;
            } else {
              debugLog('warn', '[SYNC] Sharing service not available');
              return false;
            }
          } catch (error) {
            debugLog('error', '[SYNC] Failed to send to member:', memberUuid, error);
            return false;
          }
        },
        
        // ---------- Sync All Groups ----------
        async syncAllGroups() {
          // Check cooldown
          const now = Date.now();
          if (this.lastSyncAllTime && (now - this.lastSyncAllTime) < CONSTS.MINUTE_MS) {
            const remainingSeconds = Math.ceil((CONSTS.MINUTE_MS - (now - this.lastSyncAllTime)) / 1000);
            alert(`Please wait ${remainingSeconds} seconds before syncing again.`);
            return;
          }
          
          // Start sync process
          this.isSyncingAll = true;
          this.lastSyncAllTime = now;
          
          // Start cooldown countdown
          this.syncAllCooldown = 60;
          const cooldownInterval = setInterval(() => {
            this.syncAllCooldown--;
            if (this.syncAllCooldown <= 0) {
              clearInterval(cooldownInterval);
            }
          }, 1000);
          
          try {
            // Find all shared groups - check for shared flag and groupId
            const sharedGroups = this.data.groups.filter(g => 
              g.shared && g.groupId && g.groupTopic
            );
            
            if (sharedGroups.length === 0) {
              debugLog('log', '[SYNC ALL] No shared groups found', {
                totalGroups: this.data.groups.length,
                groupsWithShared: this.data.groups.filter(g => g.shared).length,
                groupsWithGroupId: this.data.groups.filter(g => g.groupId).length
              });
              alert('No shared groups to sync.');
              this.isSyncingAll = false;
              return;
            }
            
            debugLog('log', `[SYNC ALL] Starting sync for ${sharedGroups.length} shared groups`);
            
            // Send sync requests for all shared groups with staggered timing
            for (let i = 0; i < sharedGroups.length; i++) {
              const group = sharedGroups[i];
              const delay = i * 200; // 200ms between each group to avoid overwhelming the network
              
              setTimeout(async () => {
                debugLog('log', `[SYNC ALL] Requesting sync for group: ${group.name}`);
                await this.requestSmartSync(group);
              }, delay);
            }
            
            // Show success message
            setTimeout(() => {
              this.isSyncingAll = false;
              debugLog('log', `[SYNC ALL] Sync requests sent for ${sharedGroups.length} groups`);
            }, sharedGroups.length * 200 + 1000);
            
          } catch (error) {
            debugLog('error', '[SYNC ALL] Error during sync:', error);
            this.isSyncingAll = false;
            alert('Error during sync. Please check the console for details.');
          }
        },
        
        // ---------- Duplicate Finder ----------

        // ---------- Snapshots ----------
        async saveSnapshot() {
          const name = prompt(this.getTranslation('snapshots.promptName'), new Date().toISOString().slice(0, 19).replace('T', ' '));
          if (!name) return;
          const base = this.getSavableData();
          // avoid nesting snapshots within snapshots
          if (base.snapshots) base.snapshots = [];
          const snap = {
            id: this.generateUUID(), // Use UUID for snapshots too
            name: name.trim(),
            createdAt: Date.now(),
            payload: base,
          };
          if (!Array.isArray(this.data.snapshots)) this.$set(this.data, 'snapshots', []);
          this.data.snapshots.unshift(snap);
          // keep last 20 snapshots
          if (this.data.snapshots.length > 20) this.data.snapshots.length = 20;
          if (typeof this.saveDataImmediate === 'function') await this.saveDataImmediate(); else this.saveData();
        },
        restoreSnapshot(id) {
          const snap = (this.data.snapshots || []).find(s => s.id === id);
          if (!snap) return;
          if (!confirm(this.getTranslation('snapshots.restore.confirm'))) return;
          // push current to history before restore
          this.historyPast.push(this.getSavableData());
          this._applySnapshot(snap.payload);
        },
        async deleteSnapshot(id) {
          if (!confirm(this.getTranslation('snapshots.delete.confirm'))) return;
          const arr = this.data.snapshots || [];
          const idx = arr.findIndex(s => s.id === id);
          if (idx >= 0) {
            arr.splice(idx, 1);
            if (typeof this.saveDataImmediate === 'function') await this.saveDataImmediate(); else this.saveData();
          }
        },
        formatSnapshotLabel(s) {
          const d = new Date(s.createdAt || Date.now());
          const ds = moment(d).format('LLL');
          return `${s.name} (${ds})`;
        },
        findDuplicateMap() {
          const map = {};
          (this.data.groups || []).forEach(g => (g.links || []).forEach(l => {
            if (!l.url) return;
            const key = this.normalizeUrl(l.url);
            if (!map[key]) map[key] = [];
            map[key].push({ group: g, link: l });
          }));
          return Object.fromEntries(Object.entries(map).filter(([, v]) => v.length > 1));
        },
        findAndResolveDuplicates() {
          const dups = this.findDuplicateMap();
          // Store duplicates with selection status
          this.duplicatesFound = {};
          Object.entries(dups).forEach(([url, items]) => {
            this.duplicatesFound[url] = items.map((item, index) => ({
              ...item,
              selected: index > 0 // By default, select all but the first occurrence
            }));
          });
          
          // Open the modal
          const modalElement = document.getElementById('duplicatesModal');
          if (modalElement) {
            const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
            modalInstance.show();
          }
        },
        toggleDuplicateSelection(url, index) {
          if (this.duplicatesFound[url] && this.duplicatesFound[url][index]) {
            this.duplicatesFound[url][index].selected = !this.duplicatesFound[url][index].selected;
          }
        },
        removeDuplicates() {
          let removedCount = 0;
          Object.values(this.duplicatesFound).forEach(list => {
            // Check if at least one item will remain
            const hasUnselected = list.some(item => !item.selected);
            if (!hasUnselected) {
              // If all items are selected, skip the first one to keep at least one
              list[0].selected = false;
            }
            
            list.forEach((item) => {
              if (item.selected) {
                const idx = item.group.links.findIndex(x => 
                  item.link.uuid && x.uuid === item.link.uuid
                );
                if (idx >= 0) {
                  item.group.links.splice(idx, 1);
                  removedCount++;
                }
                this.getLinkColumns(item.group.links).forEach(col => 
                  this.reindexArr(item.group.links.filter(l => l.column === col))
                );
              }
            });
          });
          
          this.saveData();
          
          // Close the modal
          const modalElement = document.getElementById('duplicatesModal');
          if (modalElement) {
            const modalInstance = bootstrap.Modal.getInstance(modalElement);
            if (modalInstance) {
              modalInstance.hide();
            }
          }
          
          // Show success message
          if (removedCount > 0) {
            alert(this.getTranslation('duplicates.deleted').replace('%s', removedCount));
          }
          
          // Clear duplicates data
          this.duplicatesFound = {};
        },
        // General keyboard activation helper
        onKeyActivate(evt, handler) {
          if (evt.key === 'Enter' || evt.key === ' ') {
            evt.preventDefault();
            handler();
          }
        },
        handleGlobalClick(event) {
          // Close context menus when clicking outside of them
          const groupMenu = document.getElementById('groupMenu');
          const linkMenu = document.getElementById('linkMenu');
          const t = event.target;
          if ((groupMenu && groupMenu.contains(t)) || (linkMenu && linkMenu.contains(t))) {
            return; // click inside an open menu -> ignore
          }
          this.hideMenus();
        },
        onClearClick() {
          this.filterText = '';
          this.activeKeywordFilters = [];
          if (this.data.options?.groups?.clearClosesAllGroups) {
            this.collapseAllGroups();
          }
        },
        onKeywordClick(kw) {
          const normalized = this.normalizeKeyword(kw);
          if (!normalized) return;
          const idx = (this.activeKeywordFilters || []).findIndex(item => this.normalizeKeyword(item) === normalized);
          if (idx >= 0) this.activeKeywordFilters.splice(idx, 1);
          else this.activeKeywordFilters.push(kw);
          if (this.data.options?.groups?.keywordClickExpandsAll) {
            this.expandAllGroups();
          }
        },
        normalizeKeyword(keyword) {
          return String(keyword || '').trim().toLowerCase();
        },
        sortKeywords(list) {
          return [...(list || [])].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        },
        normalizeKeywordList(list) {
          const seen = new Set();
          const result = [];
          (list || []).forEach(item => {
            const label = String(item || '').trim();
            if (!label) return;
            const slug = this.normalizeKeyword(label);
            if (seen.has(slug)) return;
            seen.add(slug);
            result.push(label);
          });
          return result;
        },
        joinKeywords(list) {
          return this.normalizeKeywordList(list).join(', ');
        },
        isKeywordFilterActive(keyword) {
          const normalized = this.normalizeKeyword(keyword);
          return (this.activeKeywordFilters || []).some(item => this.normalizeKeyword(item) === normalized);
        },
        keywordListContainsAll(value, requiredKeywords = this.activeKeywordFilters) {
          const required = this.normalizeKeywordList(requiredKeywords || []).map(kw => this.normalizeKeyword(kw));
          if (!required.length) return true;
          const current = new Set(this.parseKeywords(value || '').map(kw => this.normalizeKeyword(kw)));
          return required.every(req => current.has(req));
        },
        keywordValuesContainAll(values, requiredKeywords = this.activeKeywordFilters) {
          const required = this.normalizeKeywordList(requiredKeywords || []).map(kw => this.normalizeKeyword(kw));
          if (!required.length) return true;
          const current = new Set();
          const list = Array.isArray(values) ? values : [values];
          list.forEach(value => {
            this.parseKeywords(value || '').forEach(kw => current.add(this.normalizeKeyword(kw)));
          });
          return required.every(req => current.has(req));
        },
        groupOrLinkKeywordsContainAll(group, link, requiredKeywords = this.activeKeywordFilters) {
          return this.keywordValuesContainAll([group?.keywords || '', this.getEffectiveLinkKeywords(link) || ''], requiredKeywords);
        },
        groupMatchesKeywordFilters(group, requiredKeywords = this.activeKeywordFilters) {
          if (!group) return false;
          const required = this.normalizeKeywordList(requiredKeywords || []);
          if (!required.length) return true;
          if (this.keywordListContainsAll(group.keywords || '', required)) return true;
          return (group.links || []).some(link => this.groupOrLinkKeywordsContainAll(group, link, required));
        },
        isKeywordQuickAddBadgeEnabled() {
          const buttonSetting = this.data?.options?.buttons?.showKeywordQuickAddBadge;
          if (typeof buttonSetting === 'boolean') return buttonSetting;
          const legacySetting = this.data?.options?.common?.showKeywordQuickAddBadge;
          if (typeof legacySetting === 'boolean') return legacySetting;
          return true;
        },
        shouldShowGroupKeywordQuickAddBadge(group) {
          if (!this.isKeywordQuickAddBadgeEnabled()) return false;
          return !!group?.isMouseOver;
        },
        setLinkKeywordQuickAddBadgeHover(link, isHovered) {
          if (!link) return;
          this.$set(link, 'isKeywordQuickAddBadgeHover', !!isHovered);
        },
        shouldShowLinkKeywordQuickAddBadge(group, link) {
          if (!this.isKeywordQuickAddBadgeEnabled()) return false;
          if (!this.canEdit(group)) return false;
          if (this.isSeparatorLink(link)) return false;
          if (this.isReferenceLink(link)) return false;
          return !!(link?.isMouseOver || link?.isKeywordQuickAddBadgeHover);
        },
        getAssignedKeywordsForGroup(group) {
          if (!group) return [];
          return this.sortKeywords(this.parseKeywords(group.keywords || ''));
        },
        getAssignedKeywordsForLink(link) {
          if (!link) return [];
          return this.sortKeywords(this.parseKeywords(link.keywords || ''));
        },
        getAvailableKeywordsForGroup(group) {
          const assigned = new Set(this.getAssignedKeywordsForGroup(group).map(kw => this.normalizeKeyword(kw)));
          return this.sortKeywords((this.allKeywords || []).filter(kw => !assigned.has(this.normalizeKeyword(kw))));
        },
        getAvailableKeywordsForLink(link) {
          const assigned = new Set(this.getAssignedKeywordsForLink(link).map(kw => this.normalizeKeyword(kw)));
          return this.sortKeywords((this.allKeywords || []).filter(kw => !assigned.has(this.normalizeKeyword(kw))));
        },
        addKeywordToGroup(group, keyword) {
          if (!group || !keyword) return;
          const list = this.parseKeywords(group.keywords || '');
          const normalized = this.normalizeKeyword(keyword);
          if (list.some(kw => this.normalizeKeyword(kw) === normalized)) return;
          list.push(keyword);
          this.$set(group, 'keywords', this.joinKeywords(list));
          this.touchGroup(group);
          this.saveData();
        },
        removeKeywordFromGroup(group, keyword) {
          if (!group || !keyword) return;
          const normalized = this.normalizeKeyword(keyword);
          const before = this.parseKeywords(group.keywords || '');
          const after = before.filter(kw => this.normalizeKeyword(kw) !== normalized);
          if (after.length === before.length) return;
          this.$set(group, 'keywords', this.joinKeywords(after));
          this.touchGroup(group);
          this.saveData();
        },
        addKeywordToLink(group, link, keyword) {
          if (!group || !link || !keyword) return;
          const list = this.parseKeywords(link.keywords || '');
          const normalized = this.normalizeKeyword(keyword);
          if (list.some(kw => this.normalizeKeyword(kw) === normalized)) return;
          list.push(keyword);
          this.$set(link, 'keywords', this.joinKeywords(list));
          const nowTs = this.touchLink(link);
          this.touchGroup(group, nowTs);
          this.saveData();
        },
        removeKeywordFromLink(group, link, keyword) {
          if (!group || !link || !keyword) return;
          const normalized = this.normalizeKeyword(keyword);
          const before = this.parseKeywords(link.keywords || '');
          const after = before.filter(kw => this.normalizeKeyword(kw) !== normalized);
          if (after.length === before.length) return;
          this.$set(link, 'keywords', this.joinKeywords(after));
          const nowTs = this.touchLink(link);
          this.touchGroup(group, nowTs);
          this.saveData();
        },
        focusKeywordQuickInput(maxRetries = 5) {
          const tryFocus = (attempt = 0) => {
            let input = this.$refs.keywordQuickInput;
            if (Array.isArray(input)) input = input[0];
            if (input && typeof input.focus === 'function') {
              input.focus();
              const length = String(input.value || '').length;
              if (typeof input.setSelectionRange === 'function') {
                try { input.setSelectionRange(length, length); } catch {}
              }
              this.updateQuickKeywordContext({ target: input });
              return;
            }
            if (attempt < maxRetries) {
              setTimeout(() => tryFocus(attempt + 1), 50);
            }
          };
          this.$nextTick(() => tryFocus(0));
        },
        openKeywordQuickDialogForGroup(group) {
          if (!group) return;
          this.keywordQuickDialog = {
            mode: 'group',
            group,
            link: null,
            value: ''
          };
          this.keywordQuickSuggestionContext = null;
          this.quickKeywordSuggestionStyle = null;
          const modalElement = document.getElementById('keywordQuickAddModal');
          if (!modalElement) return;
          const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
          modalInstance.show();
          this.focusKeywordQuickInput();
        },
        openKeywordQuickDialogForLink(group, link) {
          if (!group || !link) return;
          this.keywordQuickDialog = {
            mode: 'link',
            group,
            link,
            value: ''
          };
          this.keywordQuickSuggestionContext = null;
          this.quickKeywordSuggestionStyle = null;
          const modalElement = document.getElementById('keywordQuickAddModal');
          if (!modalElement) return;
          const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
          modalInstance.show();
          this.focusKeywordQuickInput();
        },
        resetKeywordQuickDialog() {
          this.keywordQuickDialog = {
            mode: '',
            group: null,
            link: null,
            value: ''
          };
          this.keywordQuickSuggestionContext = null;
          this.quickKeywordSuggestionStyle = null;
        },
        submitKeywordQuickDialog() {
          const mode = this.keywordQuickDialog?.mode;
          const group = this.keywordQuickDialog?.group;
          const link = this.keywordQuickDialog?.link;
          const rawValue = String(this.keywordQuickDialog?.value || '').trim();
          if (!rawValue) {
            this.showToast(this.getTranslation('keywords.quick.empty') || 'Please enter at least one keyword.', 'warning');
            return;
          }

          const requested = this.normalizeKeywordList(this.parseKeywords(rawValue));
          if (!requested.length) {
            this.showToast(this.getTranslation('keywords.quick.empty') || 'Please enter at least one keyword.', 'warning');
            return;
          }

          if (mode === 'link' && (!group || !link || !this.canEdit(group))) {
            this.showToast(this.getTranslation('error.perm.edit') || 'You do not have permission to edit links in this group.', 'warning');
            return;
          }

          let changed = false;
          if (mode === 'group' && group) {
            const current = this.parseKeywords(group.keywords || '');
            const currentSet = new Set(current.map(kw => this.normalizeKeyword(kw)));
            requested.forEach(kw => {
              const norm = this.normalizeKeyword(kw);
              if (!norm || currentSet.has(norm)) return;
              current.push(kw);
              currentSet.add(norm);
              changed = true;
            });
            if (changed) {
              this.$set(group, 'keywords', this.joinKeywords(current));
              this.touchGroup(group);
              this.saveData();
            }
          } else if (mode === 'link' && group && link) {
            const current = this.parseKeywords(link.keywords || '');
            const currentSet = new Set(current.map(kw => this.normalizeKeyword(kw)));
            requested.forEach(kw => {
              const norm = this.normalizeKeyword(kw);
              if (!norm || currentSet.has(norm)) return;
              current.push(kw);
              currentSet.add(norm);
              changed = true;
            });
            if (changed) {
              this.$set(link, 'keywords', this.joinKeywords(current));
              const nowTs = this.touchLink(link);
              this.touchGroup(group, nowTs);
              this.saveData();
            }
          }

          if (changed) {
            this.showToast(this.getTranslation('keywords.quick.added') || 'Keyword added.', 'success');
          } else {
            this.showToast(this.getTranslation('keywords.quick.duplicate') || 'Keyword already assigned.', 'info');
          }

          const modalElement = document.getElementById('keywordQuickAddModal');
          const modalInstance = modalElement ? bootstrap.Modal.getInstance(modalElement) : null;
          if (modalInstance) modalInstance.hide();
          this.resetKeywordQuickDialog();
        },
        updateQuickKeywordContext(event) {
          const input = event?.target || this.$refs.keywordQuickInput;
          if (!input) return;
          const context = this.extractKeywordContext(
            input.value || '',
            input.selectionStart,
            input.selectionEnd
          );
          this.keywordQuickSuggestionContext = context;
          if (!context) {
            this.quickKeywordSuggestionStyle = null;
            return;
          }
          this.$nextTick(() => {
            this.updateQuickKeywordSuggestionPosition(input);
          });
        },
        clearQuickKeywordContext() {
          this.keywordQuickSuggestionContext = null;
          this.quickKeywordSuggestionStyle = null;
        },
        applyQuickKeywordSuggestion(suggestion) {
          if (!suggestion) return;
          const nextValue = (suggestion.value != null ? suggestion.value : suggestion.label || '').toString();
          if (!nextValue) return;
          this.keywordQuickDialog.value = nextValue;
          this.$nextTick(() => {
            const input = this.$refs.keywordQuickInput;
            if (input && input.value !== nextValue) input.value = nextValue;
            const cursor = typeof suggestion.cursor === 'number' ? suggestion.cursor : nextValue.length;
            if (input && typeof input.setSelectionRange === 'function') {
              try { input.setSelectionRange(cursor, cursor); } catch {}
              if (typeof input.focus === 'function') input.focus();
            }
            this.keywordQuickSuggestionContext = null;
            this.quickKeywordSuggestionStyle = null;
          });
        },
        handleQuickKeywordTab(event) {
          if (event.shiftKey) return;
          const input = event?.target || this.$refs.keywordQuickInput;
          if (!input) return;

          const context = this.extractKeywordContext(input.value || '', input.selectionStart, input.selectionEnd);
          if (!context) return;

          this.keywordQuickSuggestionContext = context;
          this.$nextTick(() => {
            this.updateQuickKeywordSuggestionPosition(input);
          });
          const candidates = this.quickKeywordSuggestionList || [];
          if (!candidates.length) return;

          const searchTerm = (context.searchTerm || '').toLowerCase();
          if (!searchTerm) return;

          const currentTokenLower = (context.currentToken || '').toLowerCase();
          let suggestion = candidates.find(item => {
            const label = (item.label || item.value || '').toString();
            const labelLower = label.toLowerCase();
            return labelLower.startsWith(searchTerm) && labelLower !== currentTokenLower;
          });
          if (!suggestion) {
            suggestion = candidates.find(item => {
              const label = (item.label || item.value || '').toString();
              return label.toLowerCase().startsWith(searchTerm);
            });
          }
          if (!suggestion) return;

          const suggestionLabel = (suggestion.label || suggestion.value || '').toString();
          if (suggestionLabel.toLowerCase() === currentTokenLower) return;

          event.preventDefault();
          this.applyQuickKeywordSuggestion(suggestion);
        },
        updateActiveKeywordFilterAfterRename(oldKeyword, newKeyword) {
          const oldNorm = this.normalizeKeyword(oldKeyword);
          const renamed = (this.activeKeywordFilters || []).map(kw => this.normalizeKeyword(kw) === oldNorm ? newKeyword : kw);
          this.activeKeywordFilters = this.normalizeKeywordList(renamed);
        },
        updateActiveKeywordFilterAfterDelete(keyword) {
          const normalized = this.normalizeKeyword(keyword);
          this.activeKeywordFilters = (this.activeKeywordFilters || []).filter(kw => this.normalizeKeyword(kw) !== normalized);
        },
        replaceKeywordEverywhere(oldKeyword, newKeyword) {
          const oldNorm = this.normalizeKeyword(oldKeyword);
          const nextKeyword = String(newKeyword || '').trim();
          if (!oldNorm || !nextKeyword) return false;
          let changed = false;
          (this.data.groups || []).forEach(group => {
            let groupChanged = false;
            const groupBefore = this.normalizeKeywordList(this.parseKeywords(group.keywords || ''));
            const groupAfter = this.normalizeKeywordList(groupBefore.map(kw => this.normalizeKeyword(kw) === oldNorm ? nextKeyword : kw));
            if (groupAfter.join('\u0001') !== groupBefore.join('\u0001')) {
              this.$set(group, 'keywords', this.joinKeywords(groupAfter));
              groupChanged = true;
              changed = true;
            }
            (group.links || []).forEach(link => {
              const linkBefore = this.normalizeKeywordList(this.parseKeywords(link.keywords || ''));
              const linkAfter = this.normalizeKeywordList(linkBefore.map(kw => this.normalizeKeyword(kw) === oldNorm ? nextKeyword : kw));
              if (linkAfter.join('\u0001') !== linkBefore.join('\u0001')) {
                this.$set(link, 'keywords', this.joinKeywords(linkAfter));
                const nowTs = this.touchLink(link);
                this.touchGroup(group, nowTs);
                groupChanged = true;
                changed = true;
              }
            });
            if (groupChanged) this.touchGroup(group);
          });
          return changed;
        },
        removeKeywordEverywhere(keyword) {
          const normalized = this.normalizeKeyword(keyword);
          if (!normalized) return false;
          let changed = false;
          (this.data.groups || []).forEach(group => {
            let groupChanged = false;
            const groupBefore = this.normalizeKeywordList(this.parseKeywords(group.keywords || ''));
            const groupAfter = groupBefore.filter(kw => this.normalizeKeyword(kw) !== normalized);
            if (groupAfter.length !== groupBefore.length) {
              this.$set(group, 'keywords', this.joinKeywords(groupAfter));
              groupChanged = true;
              changed = true;
            }
            (group.links || []).forEach(link => {
              const linkBefore = this.normalizeKeywordList(this.parseKeywords(link.keywords || ''));
              const linkAfter = linkBefore.filter(kw => this.normalizeKeyword(kw) !== normalized);
              if (linkAfter.length !== linkBefore.length) {
                this.$set(link, 'keywords', this.joinKeywords(linkAfter));
                const nowTs = this.touchLink(link);
                this.touchGroup(group, nowTs);
                groupChanged = true;
                changed = true;
              }
            });
            if (groupChanged) this.touchGroup(group);
          });
          return changed;
        },
        openKeywordManagerDialog() {
          const all = this.allKeywords || [];
          const first = all[0] || '';
          this.keywordManager.selected = first;
          this.keywordManager.newName = first;
          const modalElement = document.getElementById('keywordManagerModal');
          if (!modalElement) return;
          const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
          modalInstance.show();
        },
        selectManagedKeyword(keyword) {
          this.keywordManager.selected = keyword || '';
          this.keywordManager.newName = keyword || '';
        },
        renameManagedKeyword() {
          const current = this.keywordManager.selected;
          if (!current) {
            this.showToast(this.getTranslation('keywords.dialog.renameMissing') || 'Please select a keyword.', 'warning');
            return;
          }
          const next = (this.keywordManager.newName || '').trim();
          if (!next) {
            this.showToast(this.getTranslation('keywords.dialog.renameMissing') || 'Please select a keyword.', 'warning');
            return;
          }
          if (current === next) {
            this.showToast(this.getTranslation('keywords.dialog.renameSame') || 'Please enter a different keyword name.', 'warning');
            return;
          }
          const changed = this.replaceKeywordEverywhere(current, next);
          this.updateActiveKeywordFilterAfterRename(current, next);
          this.keywordManager.selected = next;
          this.keywordManager.newName = next;
          if (changed) {
            this.saveData();
            this.showToast(this.getTranslation('keywords.dialog.renameSuccess') || 'Keyword renamed.', 'success');
          }
        },
        deleteManagedKeyword() {
          const current = this.keywordManager.selected;
          if (!current) {
            this.showToast(this.getTranslation('keywords.dialog.renameMissing') || 'Please select a keyword.', 'warning');
            return;
          }
          const message = (this.getTranslation('keywords.dialog.confirmDelete') || 'Delete keyword "%s" everywhere?').replace('%s', current);
          if (!confirm(message)) return;
          const changed = this.removeKeywordEverywhere(current);
          this.updateActiveKeywordFilterAfterDelete(current);
          const remaining = this.allKeywords || [];
          const nextSelected = remaining[0] || '';
          this.keywordManager.selected = nextSelected;
          this.keywordManager.newName = nextSelected;
          if (changed) {
            this.saveData();
            this.showToast(this.getTranslation('keywords.dialog.deleteSuccess') || 'Keyword deleted.', 'success');
          }
        },
        openShortcutManagerDialog() {
          const list = this.normalizeGlobalShortcutList(this.data?.options?.links?.globalShortcuts || [], { ensureId: true });
          this.shortcutManager.linkFilter = '';
          this.shortcutManager.globalDrafts = list.map((entry) => ({
            id: entry.id || this.generateUUID(),
            combo: entry.combo || '',
            name: entry.name || '',
            groupIds: [...(entry.groupIds || [])],
            linkIds: [...(entry.linkIds || [])],
            legacyUrls: [...(entry.urls || [])]
          }));
          const modalElement = document.getElementById('shortcutManagerModal');
          if (!modalElement) return;
          const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
          modalInstance.show();
        },
        addGlobalShortcutDraft() {
          this.shortcutManager.globalDrafts.push({
            id: this.generateUUID(),
            combo: '',
            name: '',
            groupIds: [],
            linkIds: [],
            legacyUrls: []
          });
        },
        removeGlobalShortcutDraft(index) {
          if (!Array.isArray(this.shortcutManager.globalDrafts)) return;
          if (index < 0 || index >= this.shortcutManager.globalDrafts.length) return;
          this.shortcutManager.globalDrafts.splice(index, 1);
        },
        captureShortcutManagerDraft(index, event) {
          if (!event) return;
          if (event.key === 'Tab') return;
          if (!Array.isArray(this.shortcutManager.globalDrafts)) return;
          const draft = this.shortcutManager.globalDrafts[index];
          if (!draft) return;
          if (event.key === 'Escape' || event.key === 'Backspace' || event.key === 'Delete') {
            event.preventDefault();
            draft.combo = '';
            return;
          }
          const combo = this.normalizeShortcutFromEvent(event);
          if (!combo) {
            event.preventDefault();
            return;
          }
          if (this.isReservedShortcutCombo(combo)) {
            event.preventDefault();
            this.showToast(this.getTranslation('link.shortcut.reserved') || 'This shortcut is reserved by the browser/system.', 'warning');
            return;
          }
          event.preventDefault();
          draft.combo = combo;
        },
        clearShortcutManagerDraft(index) {
          if (!Array.isArray(this.shortcutManager.globalDrafts)) return;
          const draft = this.shortcutManager.globalDrafts[index];
          if (!draft) return;
          draft.combo = '';
        },
        normalizeShortcutIdList(value) {
          if (!Array.isArray(value)) return [];
          return [...new Set(value
            .map(item => String(item || '').trim())
            .filter(Boolean))];
        },
        getShortcutTargetIndex() {
          const groupIds = new Set();
          const linkIds = new Set();
          const linkToGroup = new Map();
          const groupToLinks = new Map();
          (this.shortcutManagerTargetGroups || []).forEach((group) => {
            const groupId = String(group?.groupId || '').trim();
            if (!groupId) return;
            groupIds.add(groupId);
            if (!groupToLinks.has(groupId)) groupToLinks.set(groupId, []);
            (group.links || []).forEach((link) => {
              const linkId = String(link?.linkId || '').trim();
              if (!linkId) return;
              linkIds.add(linkId);
              linkToGroup.set(linkId, groupId);
              groupToLinks.get(groupId).push(linkId);
            });
          });
          return { groupIds, linkIds, linkToGroup, groupToLinks };
        },
        ensureShortcutDraftSelectionState(draft) {
          if (!draft || typeof draft !== 'object') return;
          if (!Array.isArray(draft.groupIds)) this.$set(draft, 'groupIds', []);
          if (!Array.isArray(draft.linkIds)) this.$set(draft, 'linkIds', []);
          if (!Array.isArray(draft.legacyUrls)) this.$set(draft, 'legacyUrls', []);
          draft.groupIds = this.normalizeShortcutIdList(draft.groupIds);
          draft.linkIds = this.normalizeShortcutIdList(draft.linkIds);
          draft.legacyUrls = this.normalizeShortcutUrlListFromText(draft.legacyUrls);
        },
        isShortcutDraftGroupSelected(draft, groupId) {
          if (!draft || !groupId) return false;
          const selectedGroupIds = this.normalizeShortcutIdList(draft.groupIds || []);
          return selectedGroupIds.includes(String(groupId));
        },
        isShortcutDraftLinkSelected(draft, groupId, linkId) {
          if (!draft || !linkId) return false;
          if (this.isShortcutDraftGroupSelected(draft, groupId)) return true;
          const selectedLinkIds = this.normalizeShortcutIdList(draft.linkIds || []);
          return selectedLinkIds.includes(String(linkId));
        },
        getShortcutDraftGroupSelectedCount(draft, groupId) {
          const group = (this.shortcutManagerTargetGroups || []).find(item => item.groupId === String(groupId));
          if (!group) return 0;
          if (this.isShortcutDraftGroupSelected(draft, group.groupId)) return group.selectableLinkCount || 0;
          const linkIds = new Set(this.normalizeShortcutIdList(draft?.linkIds || []));
          return (group.links || []).reduce((sum, link) => {
            if (!link.validUrl) return sum;
            return sum + (linkIds.has(link.linkId) ? 1 : 0);
          }, 0);
        },
        toggleShortcutDraftGroup(index, groupId, enabled) {
          if (!Array.isArray(this.shortcutManager.globalDrafts)) return;
          const draft = this.shortcutManager.globalDrafts[index];
          if (!draft) return;
          this.ensureShortcutDraftSelectionState(draft);
          const normalizedGroupId = String(groupId || '').trim();
          if (!normalizedGroupId) return;
          const nextGroupIds = new Set(draft.groupIds);
          if (enabled) nextGroupIds.add(normalizedGroupId);
          else nextGroupIds.delete(normalizedGroupId);
          const indexData = this.getShortcutTargetIndex();
          const coveredLinkIds = new Set();
          nextGroupIds.forEach((gid) => {
            (indexData.groupToLinks.get(gid) || []).forEach((linkId) => coveredLinkIds.add(linkId));
          });
          draft.groupIds = [...nextGroupIds];
          draft.linkIds = draft.linkIds.filter((linkId) => !coveredLinkIds.has(linkId));
        },
        toggleShortcutDraftLink(index, groupId, linkId, enabled) {
          if (!Array.isArray(this.shortcutManager.globalDrafts)) return;
          const draft = this.shortcutManager.globalDrafts[index];
          if (!draft) return;
          if (this.isShortcutDraftGroupSelected(draft, groupId)) return;
          this.ensureShortcutDraftSelectionState(draft);
          const normalizedLinkId = String(linkId || '').trim();
          if (!normalizedLinkId) return;
          const nextLinkIds = new Set(draft.linkIds);
          if (enabled) nextLinkIds.add(normalizedLinkId);
          else nextLinkIds.delete(normalizedLinkId);
          draft.linkIds = [...nextLinkIds];
        },
        selectAllShortcutTargetsForDraft(index) {
          if (!Array.isArray(this.shortcutManager.globalDrafts)) return;
          const draft = this.shortcutManager.globalDrafts[index];
          if (!draft) return;
          const allGroupIds = (this.shortcutManagerTargetGroups || [])
            .filter(group => (group.selectableLinkCount || 0) > 0)
            .map(group => group.groupId);
          this.ensureShortcutDraftSelectionState(draft);
          draft.groupIds = this.normalizeShortcutIdList(allGroupIds);
          draft.linkIds = [];
        },
        clearShortcutTargetsForDraft(index) {
          if (!Array.isArray(this.shortcutManager.globalDrafts)) return;
          const draft = this.shortcutManager.globalDrafts[index];
          if (!draft) return;
          this.ensureShortcutDraftSelectionState(draft);
          draft.groupIds = [];
          draft.linkIds = [];
          draft.legacyUrls = [];
        },
        collectUrlsFromShortcutTargets(target) {
          const groupIds = new Set(this.normalizeShortcutIdList(target?.groupIds || []));
          const linkIds = new Set(this.normalizeShortcutIdList(target?.linkIds || []));
          const urls = [];
          (this.shortcutManagerTargetGroups || []).forEach((group) => {
            const groupSelected = groupIds.has(group.groupId);
            (group.links || []).forEach((link) => {
              if (!link.validUrl) return;
              if (!groupSelected && !linkIds.has(link.linkId)) return;
              const normalized = MB.Utils.ensureProtocol((link.rawUrl || '').trim());
              if (!MB.Utils.isValidHttpUrl(normalized)) return;
              urls.push(normalized);
            });
          });
          const legacyUrls = this.normalizeShortcutUrlListFromText(target?.legacyUrls || target?.urls || []);
          legacyUrls.forEach((url) => urls.push(url));
          return [...new Set(urls)];
        },
        getShortcutManagerDraftStatsText(draft) {
          const selectedGroupIds = this.normalizeShortcutIdList(draft?.groupIds || []);
          const selectedLinkIds = this.normalizeShortcutIdList(draft?.linkIds || []);
          const legacyUrls = this.normalizeShortcutUrlListFromText(draft?.legacyUrls || []);
          const groupsCount = selectedGroupIds.length;
          let linksCount = 0;
          (this.shortcutManagerTargetGroups || []).forEach((group) => {
            linksCount += this.getShortcutDraftGroupSelectedCount(draft, group.groupId);
          });
          const urlsCount = this.collectUrlsFromShortcutTargets({
            groupIds: selectedGroupIds,
            linkIds: selectedLinkIds,
            legacyUrls
          }).length;
          const template = this.getTranslation('shortcuts.manager.selectionStats') || '{groups} groups, {links} links selected, {urls} URLs will open';
          return template
            .replace('{groups}', String(groupsCount))
            .replace('{links}', String(linksCount))
            .replace('{urls}', String(urlsCount));
        },
        openUrlInNewTab(url) {
          const popup = window.open(url, '_blank');
          if (popup) {
            try { popup.opener = null; } catch {}
            return true;
          }
          return false;
        },
        openUrlsWithTabPriming(urls) {
          const uniqueUrls = [...new Set((Array.isArray(urls) ? urls : [])
            .map(url => String(url || '').trim())
            .filter(Boolean))];
          if (!uniqueUrls.length) return 0;

          const primedTabs = [];
          let openedCount = 0;

          uniqueUrls.forEach((url) => {
            let popup = null;
            try {
              popup = window.open('about:blank', '_blank');
            } catch {}

            if (popup) {
              primedTabs.push({ popup, url });
              return;
            }

            if (this.openUrlInNewTab(url)) openedCount += 1;
          });

          primedTabs.forEach(({ popup, url }) => {
            try { popup.opener = null; } catch {}
            try {
              popup.location.replace(url);
              openedCount += 1;
              return;
            } catch {}
            try {
              popup.location.href = url;
              openedCount += 1;
              return;
            } catch {}
            try { popup.close(); } catch {}
            if (this.openUrlInNewTab(url)) openedCount += 1;
          });

          return openedCount;
        },
        openShortcutUrls(urls, openInNewTab, queueKey = '') {
          const uniqueUrls = [...new Set((Array.isArray(urls) ? urls : [])
            .map(url => String(url || '').trim())
            .filter(Boolean))];
          if (!uniqueUrls.length) {
            this.shortcutOpenQueue = null;
            return { total: 0, opened: 0, openedTotal: 0, remaining: 0, queued: false };
          }

          const normalizedQueueKey = String(queueKey || '').trim();

          const forceNewTabs = uniqueUrls.length > 1 || openInNewTab;
          if (!forceNewTabs && uniqueUrls[0]) {
            this.shortcutOpenQueue = null;
            window.location.href = uniqueUrls[0];
            return { total: 1, opened: 1, openedTotal: 1, remaining: 0, queued: false };
          }

          const batchSize = 8;
          const existingQueue = this.shortcutOpenQueue && typeof this.shortcutOpenQueue === 'object'
            ? this.shortcutOpenQueue
            : null;
          const canResumeQueue = !!(
            normalizedQueueKey
            && existingQueue
            && existingQueue.key === normalizedQueueKey
            && Array.isArray(existingQueue.remainingUrls)
            && existingQueue.remainingUrls.length > 0
          );

          let total = uniqueUrls.length;
          let openedBefore = 0;
          let pendingUrls = uniqueUrls;

          if (canResumeQueue) {
            pendingUrls = [...existingQueue.remainingUrls];
            openedBefore = Number(existingQueue.opened) || 0;
            total = Number(existingQueue.total) || (openedBefore + pendingUrls.length);
          } else {
            this.shortcutOpenQueue = null;
          }

          const currentBatch = pendingUrls.slice(0, batchSize);
          const remainingUrls = pendingUrls.slice(batchSize);
          const opened = currentBatch.length > 1
            ? this.openUrlsWithTabPriming(currentBatch)
            : (this.openUrlInNewTab(currentBatch[0]) ? 1 : 0);
          const openedTotal = openedBefore + opened;

          if (remainingUrls.length > 0 && normalizedQueueKey) {
            this.shortcutOpenQueue = {
              key: normalizedQueueKey,
              total,
              opened: openedTotal,
              remainingUrls: remainingUrls
            };
          } else {
            this.shortcutOpenQueue = null;
          }

          return {
            total,
            opened,
            openedTotal,
            remaining: remainingUrls.length,
            queued: remainingUrls.length > 0
          };
        },
        showShortcutOpenResultToast(result) {
          const total = Number(result?.total) || 0;
          if (!total) return;
          const opened = Number(result?.openedTotal ?? result?.opened) || 0;
          const remaining = Number(result?.remaining) || 0;

          if (remaining > 0) {
            const template = this.getTranslation('link.shortcut.batchRemaining')
              || 'Opened {opened} of {total} link(s). {remaining} remaining. Trigger the same shortcut/action again to continue.';
            this.showToast(
              template
                .replace('{opened}', String(opened))
                .replace('{total}', String(total))
                .replace('{remaining}', String(remaining)),
              'warning'
            );
            return;
          }

          if (opened < total) {
            const template = this.getTranslation('link.shortcut.openedPartial')
              || 'Only opened {opened} of {total} link(s). Popup blocker may have blocked the rest.';
            this.showToast(
              template
                .replace('{opened}', String(opened))
                .replace('{total}', String(total)),
              'warning'
            );
            return;
          }

          this.showToast(
            (this.getTranslation('link.shortcut.opened') || 'Opened {count} link(s) via shortcut.')
              .replace('{count}', String(opened)),
            'info'
          );
        },
        openUrlsFromShortcutGroup(group) {
          if (!group || !Array.isArray(group.urls) || group.urls.length === 0) return;
          const uniqueUrls = [...new Set(group.urls)];
          const confirmThreshold = 8;
          if (uniqueUrls.length > confirmThreshold) {
            const confirmText = (this.getTranslation('link.shortcut.confirmMany') || 'Open {count} links at once?')
              .replace('{count}', uniqueUrls.length);
            if (!confirm(confirmText)) {
              this.shortcutOpenQueue = null;
              return;
            }
          }
          const openInNewTab = this.data?.options?.links?.openInNewTab !== false;
          const queueKey = `group:${String(group.combo || '').trim() || 'adhoc'}`;
          const result = this.openShortcutUrls(uniqueUrls, openInNewTab, queueKey);
          this.showShortcutOpenResultToast(result);
        },
        saveShortcutManagerDialog() {
          const drafts = Array.isArray(this.shortcutManager.globalDrafts) ? this.shortcutManager.globalDrafts : [];
          const normalizedEntries = [];
          for (let i = 0; i < drafts.length; i++) {
            const draft = drafts[i] || {};
            this.ensureShortcutDraftSelectionState(draft);
            const hasInput = !!(
              (draft.combo || '').trim()
              || (draft.name || '').trim()
              || (draft.groupIds || []).length
              || (draft.linkIds || []).length
              || (draft.legacyUrls || []).length
            );
            if (!hasInput) continue;
            const combo = this.normalizeShortcutText(draft.combo || '');
            if (!combo) {
              const msg = (this.getTranslation('shortcuts.manager.invalidCombo') || 'Please define a valid shortcut in row {row}.')
                .replace('{row}', String(i + 1));
              this.showToast(msg, 'warning');
              return;
            }
            if (this.isReservedShortcutCombo(combo)) {
              this.showToast(this.getTranslation('link.shortcut.reserved') || 'This shortcut is reserved by the browser/system.', 'warning');
              return;
            }
            const groupIds = this.normalizeShortcutIdList(draft.groupIds || []);
            const linkIds = this.normalizeShortcutIdList(draft.linkIds || []);
            const legacyUrls = this.normalizeShortcutUrlListFromText(draft.legacyUrls || []);
            const targetUrls = this.collectUrlsFromShortcutTargets({ groupIds, linkIds, legacyUrls });
            if (!targetUrls.length) {
              const msg = (this.getTranslation('shortcuts.manager.invalidTargets') || 'Please select at least one link or group in row {row}.')
                .replace('{row}', String(i + 1));
              this.showToast(msg, 'warning');
              return;
            }
            normalizedEntries.push({
              id: draft.id || this.generateUUID(),
              combo,
              name: (draft.name || '').trim(),
              groupIds,
              linkIds,
              urls: legacyUrls
            });
          }

          const mergedEntries = this.normalizeGlobalShortcutList(normalizedEntries, { ensureId: true });
          this.$set(this.data.options.links, 'globalShortcuts', mergedEntries);
          this.saveData();

          this.shortcutManager.globalDrafts = mergedEntries.map((entry) => ({
            id: entry.id || this.generateUUID(),
            combo: entry.combo || '',
            name: entry.name || '',
            groupIds: [...(entry.groupIds || [])],
            linkIds: [...(entry.linkIds || [])],
            legacyUrls: [...(entry.urls || [])]
          }));

          this.showToast(
            (this.getTranslation('shortcuts.manager.saved') || 'Saved {count} global shortcuts.')
              .replace('{count}', String(mergedEntries.length)),
            'success'
          );
          const modalElement = document.getElementById('shortcutManagerModal');
          if (modalElement) {
            const modalInstance = bootstrap.Modal.getInstance(modalElement) || bootstrap.Modal.getOrCreateInstance(modalElement);
            modalInstance.hide();
          }
        },
        isGroupMatched(g, q) {
          const query = (q || this.filterText || '').toLowerCase();
          if (!query) return true;
          return (
            g.name?.toLowerCase().includes(query)
            || (g.keywords && g.keywords.toLowerCase().includes(query))
            || (g.links && g.links.some(l =>
              l.text?.toLowerCase().includes(query)
              || (l.keywords && l.keywords.toLowerCase().includes(query))
              || (l.url && l.url.toLowerCase().includes(query))
            ))
          );
        },
        // Generic CSS parser function - parses JSON from complex colorpicker
        // ONLY applies properties that are actually SET (non-empty) in the JSON
        parseCssValue(value, defaultStyles = {}) {
          if (!value) return defaultStyles;
          
          // Try to parse as JSON from complex colorpicker
          try {
            const jsonData = JSON.parse(value);
            // Start with defaults
            const styles = { ...defaultStyles };
            
            // ONLY apply properties that have actual values (non-empty)
            // Background
            if (jsonData.backgroundColor && jsonData.backgroundColor.trim() !== '') {
              styles.backgroundColor = jsonData.backgroundColor;
            }
            
            // Text Color
            if (jsonData.color && jsonData.color.trim() !== '') {
              styles.color = jsonData.color;
            }
            
            // Opacity (only if not 100%)
            if (jsonData.opacity && jsonData.opacity < 100) {
              styles.opacity = (jsonData.opacity / 100).toFixed(2);
            }
            
            // Font properties
            if (jsonData.fontFamily && jsonData.fontFamily.trim() !== '') {
              styles.fontFamily = jsonData.fontFamily;
            }
            if (jsonData.fontSize && jsonData.fontSize !== '') {
              styles.fontSize = jsonData.fontSize + (jsonData.fontSizeUnit || 'px');
            }
            if (jsonData.fontWeight && jsonData.fontWeight.trim() !== '') {
              styles.fontWeight = jsonData.fontWeight;
            }
            if (jsonData.fontStyle && jsonData.fontStyle.trim() !== '' && jsonData.fontStyle !== 'normal') {
              styles.fontStyle = jsonData.fontStyle;
            }
            if (jsonData.textDecoration && jsonData.textDecoration.trim() !== '' && jsonData.textDecoration !== 'none') {
              styles.textDecoration = jsonData.textDecoration;
            }
            
            // Border properties - only apply if borderStyle is not 'none' or empty
            if (jsonData.borderStyle && jsonData.borderStyle !== '' && jsonData.borderStyle !== 'none') {
              styles.borderStyle = jsonData.borderStyle;
              
              // Only add width and color if border style exists and is not 'none'
              if (jsonData.borderWidth !== '' && jsonData.borderWidth !== undefined) {
                styles.borderWidth = (jsonData.borderWidth || 1) + 'px';
              }
              
              if (jsonData.borderColor && jsonData.borderColor.trim() !== '') {
                styles.borderColor = jsonData.borderColor;
              }
            }
            // If borderStyle is explicitly 'none', don't add any border properties at all
            
            // Border radius (only if > 0)
            if (jsonData.borderRadius && parseFloat(jsonData.borderRadius) > 0) {
              styles.borderRadius = jsonData.borderRadius + 'px';
            }
            
            // Box shadow (only if set)
            if (jsonData.boxShadow && jsonData.boxShadow.trim() !== '') {
              styles.boxShadow = jsonData.boxShadow;
            }
            
            // Spacing
            // Side-specific padding
            const pT = parseFloat(jsonData.paddingTop);
            const pR = parseFloat(jsonData.paddingRight);
            const pB = parseFloat(jsonData.paddingBottom);
            const pL = parseFloat(jsonData.paddingLeft);
            if (!isNaN(pT)) styles.paddingTop = pT + 'px';
            if (!isNaN(pR)) styles.paddingRight = pR + 'px';
            if (!isNaN(pB)) styles.paddingBottom = pB + 'px';
            if (!isNaN(pL)) styles.paddingLeft = pL + 'px';
            // Fallback uniform padding
            if (jsonData.padding !== undefined && jsonData.padding !== '') {
              const pv = parseFloat(jsonData.padding);
              if (!isNaN(pv)) styles.padding = pv + 'px';
            }
            // Side-specific margin
            const mT = parseFloat(jsonData.marginTop);
            const mR = parseFloat(jsonData.marginRight);
            const mB = parseFloat(jsonData.marginBottom);
            const mL = parseFloat(jsonData.marginLeft);
            if (!isNaN(mT)) styles.marginTop = mT + 'px';
            if (!isNaN(mR)) styles.marginRight = mR + 'px';
            if (!isNaN(mB)) styles.marginBottom = mB + 'px';
            if (!isNaN(mL)) styles.marginLeft = mL + 'px';
            // Fallback uniform margin
            if (jsonData.margin !== undefined && jsonData.margin !== '') {
              const mv = parseFloat(jsonData.margin);
              if (!isNaN(mv)) styles.margin = mv + 'px';
            }
            
            return styles;
          } catch (e) {
            // Not JSON - check if it's a CSS string
            if (typeof value === 'string' && value.includes(':') && value.includes(';')) {
              // Parse CSS string
              const styles = { ...defaultStyles };
              const rules = value.split(';').filter(r => r.trim());
              rules.forEach(rule => {
                const [prop, val] = rule.split(':').map(s => s.trim());
                if (prop && val) {
                  // Convert CSS property names to camelCase
                  const camelProp = prop.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
                  styles[camelProp] = val;
                }
              });
              return styles;
            }
            
            // Simple value (e.g., just a color)
            if (typeof value === 'string' && value.trim()) {
              // Assume it's a background color
              return { ...defaultStyles, backgroundColor: value };
            }
            
            return defaultStyles;
          }
        },
        
        // Get primary color from parsed CSS (for calculations like gradients)
        getPrimaryColorFromCss(value, defaultColor = '') {
          if (!value) return defaultColor;
          
          try {
            const jsonData = JSON.parse(value);
            return jsonData.backgroundColor || defaultColor;
          } catch (e) {
            // Check for simple hex color
            if (typeof value === 'string' && value.match(/^#[0-9A-Fa-f]{3,6}$/)) {
              return value;
            }
            // Check for CSS string with background-color
            if (typeof value === 'string' && value.includes('background-color:')) {
              const match = value.match(/background-color:\s*([^;]+)/);
              if (match) return match[1].trim();
            }
            return defaultColor;
          }
        },
        
        // All styling is now handled via CSS variables and classes
        // Style functions have been removed - use CSS classes and variables instead
        
        calculateStorageUsage(precomputedDataString = null) {
          try {
            let totalSize = 0;
            
            // Calculate size of the main data object (stored in IndexedDB)
            if (this.data) {
              const dataString = (typeof precomputedDataString === 'string')
                ? precomputedDataString
                : JSON.stringify(this.data);
              // Each character in JavaScript strings is typically 2 bytes (UTF-16)
              // But JSON.stringify creates UTF-8, so we use the actual byte length
              totalSize = new Blob([dataString]).size;
              
              debugLog('log', '[STORAGE] Data size calculation:', {
                groups: this.data.groups?.length || 0,
                totalLinks: this.data.groups?.reduce((sum, g) => sum + (g.links?.length || 0), 0) || 0,
                snapshots: this.data.snapshots?.length || 0,
                contacts: this.data.contacts?.length || 0,
                stringLength: dataString.length,
                byteSize: totalSize
              });
            }
            
            // Also add localStorage items (like preferences, etc.)
            for (let key in localStorage) {
              if (localStorage.hasOwnProperty(key)) {
                const item = localStorage.getItem(key);
                totalSize += new Blob([key + item]).size;
              }
            }
            
            this.storageUsed = totalSize;
          } catch (e) {
            debugLog('error', 'Error calculating storage:', e);
            this.storageUsed = 0;
          }
        },
        scheduleStorageUsageRecalc(precomputedDataString = null) {
          if (!this._debouncedStorageUsage) {
            this._debouncedStorageUsage = debounce(this.calculateStorageUsage, 500).bind(this);
          }
          this._debouncedStorageUsage(precomputedDataString);
        },

        // Schedule/clear CardDAV auto-sync timer based on options
        scheduleCardDavAutoSync() {
          try { if (this.carddavTimer) { clearInterval(this.carddavTimer); this.carddavTimer = null; } } catch {}
          const backend = this.data.options?.sync?.backend || '';
          if (!this.extensionAvailable || !backend) return;
          let sec = 0;
          if (backend === 'carddav') sec = Number(this.data.options?.carddav?.syncIntervalSec || 0);
          if (backend === 'nc-bookmarks') sec = Number(this.data.options?.bookmarks?.syncIntervalSec || 0);
          if (!sec || sec <= 0) {
            sec = Number(this.data.options?.sync?.autoSyncInterval || 0);
          }
          if (!Number.isFinite(sec)) sec = 0;
          if (!sec || sec <= 0) return;
          this.carddavTimer = setInterval(() => {
            try { this.syncNowGeneric(); } catch (e) { debugLog('warn', '[SYNC] auto-sync error', e); }
          }, sec * 1000);
          debugLog('log', `[SYNC] Auto-sync scheduled every ${sec}s for backend ${backend}`);
        },
        
        formatStorageSize(bytes) {
          if (bytes < 1024) return bytes + ' B';
          if (bytes < 1048576) return (bytes / 1024).toFixed(2) + ' KB';
          if (bytes < 1073741824) return (bytes / 1048576).toFixed(2) + ' MB';
          return (bytes / 1073741824).toFixed(2) + ' GB';
        },
        
        getStorageTooltip() {
          const used = this.formatStorageSize(this.storageUsed);
          return `${used}`;
        },
        getGroupInnerStyle(group) { return null; },
        getGroupKeywordBadgeStyle(group) {
          // Use titleFormatting which is what's actually set for group titles
          const color = group?.titleFormatting || group?.color || '#6c757d';
          return {
            backgroundColor: `${color} !important`,
            color: `${this.getContrastingTextColor(color)} !important`,
            opacity: '1 !important',
            border: 'none !important'
          };
        },
        getLinkKeywordBadgeStyle(link, group) {
          // Priority: link color > group titleColor > group color > default
          let bgColor = '#6c757d'; // default gray
          
          // Check if link has a color set
          if (link && link.color) {
            try {
              const parsed = JSON.parse(link.color);
              // If it's JSON from CSS dialog, extract the background color
              bgColor = parsed.backgroundColor || parsed.color || bgColor;
            } catch (e) {
              // Not JSON, use as-is
              bgColor = link.color;
            }
          } else {
            // Fall back to group's titleFormatting for consistency with keyword overview
            bgColor = group?.titleFormatting || group?.color || bgColor;
          }
          
          return {
            backgroundColor: `${bgColor} !important`,
            color: `${this.getContrastingTextColor(bgColor)} !important`,
            fontSize: '0.65rem',
            padding: '0.15rem 0.4rem',
            marginLeft: '0.2rem',
            opacity: '1 !important',
            border: 'none !important'
          };
        },
        groupKeywordsArray(group) {
          if (!group || !group.keywords) return [];
          return this.parseKeywords(group.keywords);
        },
        // --- Auto-expand collapsed groups on link hover ---
        scheduleExpandGroup(group) {
          if (!group || !group.collapsed) return;
          if (this.dragState !== 'link') return;
          if (!this.data.options?.groups?.hoverExpandEnabled) return;
          if (this.expandHoverTimers[group.uuid]) return;
          const delay = Math.max(0, Number(this.data.options?.groups?.hoverExpandDelayMs) || 0);
          this.expandHoverTimers[group.uuid] = setTimeout(() => {
            try {
              if (this.dragState === 'link' && group.collapsed) {
                // Expand only if still collapsed
                this.toggleGroupCollapse(group);
              }
            } finally {
              this.$delete(this.expandHoverTimers, group.uuid);
            }
          }, delay);
        },
        handleGroupDragEnter(group) {
          if (this.dragState !== 'link') return;
          this.scheduleExpandGroup(group);
        },
        handleGroupDragOver(group) {
          if (this.dragState !== 'link') return;
          this.scheduleExpandGroup(group);
        },
        handleGroupDragLeave(group) {
          const t = this.expandHoverTimers[group?.uuid];
          if (t) {
            clearTimeout(t);
            this.$delete(this.expandHoverTimers, group.uuid);
          }
        },
        clearExpandHoverTimers() {
          Object.values(this.expandHoverTimers).forEach(t => clearTimeout(t));
          this.expandHoverTimers = {};
        },

        resetAllMouseOverStates() {
          // Reset mouseover state for all groups
          if (this.data.groups) {
            this.data.groups.forEach(group => {
              group.isMouseOver = false;
              // Reset mouseover state for all links in the group
              if (group.links) {
                group.links.forEach(link => {
                  link.isMouseOver = false;
                });
              }
            });
          }
          debugLog('log', 'Reset all mouseover states for groups and links');
        },

        expandAllGroups() {
          (this.data.groups || []).forEach(g => { this.$set(g, 'collapsed', false); });
          this.saveData();
        },
        collapseAllGroups() {
          (this.data.groups || []).forEach(g => { this.$set(g, 'collapsed', true); });
          this.saveData();
        },

        handleDragEnd(evt) {
          debugLog('log', "handleDragEnd called");

          // Reset cursor for dragged element
          if (evt.target) {
            evt.target.style.cursor = 'grab';
          }

          // Always reset mouseover states when drag ends
          this.resetAllMouseOverStates();

          // Check if we even have a drag operation in progress
          if (!this.dropManager.draggedState) {
            debugLog('log', "No drag state found, ignoring dragend (already reset)");
            return;
          }

          // Check if enough time has passed since drag started
          const dragDuration = this.dropManager.dragStartTime ? Date.now() - this.dropManager.dragStartTime : 0;
          debugLog('log', "Drag duration:", dragDuration, "ms");

          // Browser detection
          const userAgent = navigator.userAgent;
          const isEdge = /Edg/.test(userAgent);
          
          // Edge specific: Handle immediate dragend (< 100ms) differently
          if (isEdge && dragDuration < 100) {
            debugLog('log', "Edge: Immediate dragend detected (< 100ms), keeping state for real drag");
            // This is Edge's immediate cancel - keep everything active
            // Clear the start time to allow the next attempt
            this.dropManager.dragStartTime = null;
            // Mark that we're expecting a second attempt
            this.dropManager.edgeDragPending = true;
            // Keep drag state and dropzones visible
            return;
          }
          
          // For Edge with pending drag, check if this is a real drag
          if (isEdge && this.dropManager.edgeDragPending) {
            debugLog('log', "Edge: Real drag completed after pending state");
            this.dropManager.edgeDragPending = false;
          }
          
          // For other short durations, might be a cancel
          if (dragDuration < 200) {
            debugLog('log', `Short drag duration (${dragDuration}ms), likely cancelled`);
          }

          debugLog('log', "Processing legitimate dragend event");
          this.dropManager.reset();
          this.dropManager.edgeDragAttempt = false;
        },
        
        // Universal browser workaround for drag and drop
        prepareForDrag(event, element) {
          if (!element) return;
          
          // Detect browser engine
          const userAgent = navigator.userAgent;
          const isEdge = /Edg/.test(userAgent);
          const isChrome = /Chrome/.test(userAgent) && !isEdge;
          const isFirefox = /Firefox/.test(userAgent);
          const isSafari = /Safari/.test(userAgent) && !isChrome && !isEdge;
          
          if (event.type === 'mouseover') {
            // Always ensure element is draggable on mouseover
            if (element.getAttribute('draggable') !== 'true') {
              element.setAttribute('draggable', 'true');
              debugLog('log', `DnD: Setting draggable=true on mouseover`);
            }
            
            // Browser-specific optimizations
            if (isEdge || isChrome) {
              // Chromium-based browsers need these styles
              element.style.webkitUserDrag = 'element';
              element.style.webkitUserSelect = 'none';
            }
            
            // Universal styles for better drag experience
            element.style.userSelect = 'none';
            element.style.cursor = 'grab';
          } else if (event.type === 'mousedown') {
            // For Edge, we need to ensure draggable is still true
            if (isEdge) {
              // Double-check draggable is set for Edge
              if (element.getAttribute('draggable') !== 'true') {
                element.setAttribute('draggable', 'true');
                debugLog('log', "Edge: Re-ensuring draggable=true on mousedown");
              }
              // Don't change cursor to grabbing for Edge as it might interfere
              debugLog('log', "Edge: Mousedown handled, maintaining grab cursor");
            } else {
              // For non-Edge browsers
              element.style.cursor = 'grabbing';
              debugLog('log', `DnD: Mousedown handled for non-Edge browser`);
            }
          }
        },

        handleDropToNewColumn(evt, targetColumnIndex) {
          debugLog('log', `handleDropToNewColumn called for target column index ${targetColumnIndex}`);

          // Prevent default and stop propagation
          evt.preventDefault();
          evt.stopPropagation();

          // Get the dragged group from dropManager
          const draggedGroup = this.dropManager.oldItem;
          const draggedState = this.dropManager.draggedState;

          debugLog('log', 'Dragged group:', draggedGroup);
          debugLog('log', 'Dragged state:', draggedState);

          if (!draggedGroup || draggedState !== 'group') {
            debugLog('warn', 'No valid group being dragged');
            this.dropManager.reset();
            return;
          }

          const oldColumn = draggedGroup.column;
          const oldIndex = draggedGroup.index;
          const sourceColumnGroupCount = this.data.groups.filter(g => g.column === oldColumn).length;
          const isOnlyGroupInSourceColumn = sourceColumnGroupCount === 1;

          // Get all existing columns sorted
          const existingColumns = this.getGroupColumns();
          debugLog('log', 'Existing columns before move:', existingColumns);
          debugLog('log', `Moving group from column ${oldColumn} to dropzone at position ${targetColumnIndex}`);

          // Check if this is the same position (no move needed)
          if (targetColumnIndex !== -1) {
            // The dropzone after column X has targetColumnIndex = X + 1
            // So if we're dropping on the dropzone right after our current column, it's a no-op
            if (oldColumn === targetColumnIndex || oldColumn === targetColumnIndex - 1) {
              if (isOnlyGroupInSourceColumn) {
                debugLog('log', 'Group is alone in its column and dropping in adjacent position - no move needed');
                this.dropManager.reset();
                return;
              }
            }
          }

          let insertedColumnWidth = CONSTS.GROUP_COLUMN_WIDTH_MIN;
          if (this.isManualGroupColumnWidthEnabled()) {
            this.ensureGroupColumnWidthsInitialized(existingColumns);
            if (isOnlyGroupInSourceColumn) {
              const sourceWidth = this.normalizeGroupColumnWidth(this.getCurrentGroupColumnWidth(oldColumn));
              insertedColumnWidth = Number.isFinite(sourceWidth) ? sourceWidth : CONSTS.GROUP_COLUMN_WIDTH_MIN;
            }
          }
          let newColumnIndex;

          if (targetColumnIndex === -1) {
            // Drop before first column - all columns shift right
            newColumnIndex = 0;
            this.shiftGroupColumnWidthsRight(0);
            if (this.isManualGroupColumnWidthEnabled()) {
              this.setGroupColumnWidth(newColumnIndex, insertedColumnWidth);
            }

            // Shift all groups to the right (except the dragged one)
            this.data.groups.forEach(g => {
              if (g.uuid !== draggedGroup.uuid) {
                g.column = (g.column || 0) + 1;
              }
            });
          } else {
            // targetColumnIndex is the position where we want to insert the new column
            // This is the column index AFTER which the dropzone is located

            // The new column should be created at this exact position
            newColumnIndex = targetColumnIndex;
            this.shiftGroupColumnWidthsRight(newColumnIndex);
            if (this.isManualGroupColumnWidthEnabled()) {
              this.setGroupColumnWidth(newColumnIndex, insertedColumnWidth);
            }

            debugLog('log', `Creating new column at position ${newColumnIndex}`);

            // Shift all groups at or after the target position to the right
            // But not the dragged group itself
            this.data.groups.forEach(g => {
              if (g.uuid !== draggedGroup.uuid && g.column >= newColumnIndex) {
                g.column++;
                debugLog('log', `Shifted group "${g.name}" from column ${g.column - 1} to ${g.column}`);
              }
            });
          }

          // Update indices in the old column (remove the gap)
          const groupsInOldColumn = this.data.groups.filter(g =>
            g.column === oldColumn && g.uuid !== draggedGroup.uuid && g.index > oldIndex
          );
          groupsInOldColumn.forEach(g => {
            g.index--;
          });

          // Move the dragged group to the new column
          draggedGroup.column = newColumnIndex;
          draggedGroup.index = 0; // Place at top of new column

          debugLog('log', `Moved group "${draggedGroup.name}" from column ${oldColumn} to new column ${newColumnIndex}`);

          // Now normalize column indices to remove any gaps
          this.normalizeColumnIndices();

          // Save and reset
          this.saveData();
          this.dropManager.reset();
        },

        normalizeColumnIndices() {
          // Get all unique columns and sort them
          const columns = [...new Set(this.data.groups.map(g => g.column))].sort((a, b) => a - b);

          // Create a mapping from old column index to new normalized index
          const columnMapping = {};
          columns.forEach((col, index) => {
            columnMapping[col] = index;
          });

          // Apply the mapping to all groups
          this.data.groups.forEach(g => {
            const oldCol = g.column;
            const newCol = columnMapping[oldCol];
            if (oldCol !== newCol) {
              debugLog('log', `Normalized column for group "${g.name}": ${oldCol} -> ${newCol}`);
              g.column = newCol;
            }
          });

          this.remapGroupColumnWidths(columnMapping);
          this.ensureGroupColumnWidthsWithinViewport(this.getGroupColumns());

          debugLog('log', 'Column normalization complete. Final columns:', this.getGroupColumns());
        },

        // Combined handlers removed - using inline handlers instead
        // Edge has issues finding these methods, so we use inline expressions
        reindexArr(arr) { // Now a method of the Vue instance
          if (!arr || arr.length === 0) return;
          // Sort based on the temporary index, then re-assign sequential index
          let tmpArr = arr.sort((a, b) => a.index - b.index);
          tmpArr.forEach((item, index) => {
            item.index = index;
          });
        },

        // Make sure dropManager is initialized with the app instance
        initializeDropManager() {
          this.dropManager = new DropManager(this);
        },

        // --- Database & Data Management ---
        normalizeLocalSecurityOptions(rawSecurity = null) {
          const fallback = { enabled: false, sessionTimeoutMinutes: 30 };
          const source = (rawSecurity && typeof rawSecurity === 'object' && !Array.isArray(rawSecurity)) ? rawSecurity : {};
          const merged = Object.assign({}, fallback, source);
          merged.enabled = !!merged.enabled;
          const timeoutMinutes = Number(merged.sessionTimeoutMinutes);
          merged.sessionTimeoutMinutes = Number.isFinite(timeoutMinutes)
            ? Math.max(0, Math.min(1440, Math.round(timeoutMinutes)))
            : 30;
          return merged;
        },
        isLocalSecurityEnabled() {
          return !!this.normalizeLocalSecurityOptions(this.data?.options?.security).enabled;
        },
        isEncryptedLocalEnvelope(value) {
          return !!(
            value
            && typeof value === 'object'
            && value.__mbLocalEncrypted === true
            && Number(value.version) === 1
            && value.kdf
            && value.cipher
            && typeof value.cipher.iv === 'string'
            && typeof value.cipher.payload === 'string'
          );
        },
        normalizeLocalSecurityKdfMeta(rawKdf = null) {
          const fallback = {
            salt: B64.enc(crypto.getRandomValues(new Uint8Array(16))),
            iterations: 210000,
            hash: 'SHA-256'
          };
          const source = (rawKdf && typeof rawKdf === 'object' && !Array.isArray(rawKdf)) ? rawKdf : {};
          const salt = (typeof source.salt === 'string' && source.salt.trim()) ? source.salt.trim() : fallback.salt;
          const iterations = Number(source.iterations);
          const hash = (typeof source.hash === 'string' && source.hash.trim()) ? source.hash.trim() : fallback.hash;
          return {
            salt,
            iterations: Number.isFinite(iterations) ? Math.max(100000, Math.round(iterations)) : fallback.iterations,
            hash
          };
        },
        createLocalSecurityKdfMeta() {
          return {
            salt: B64.enc(crypto.getRandomValues(new Uint8Array(16))),
            iterations: 210000,
            hash: 'SHA-256'
          };
        },
        async deriveLocalSecurityKey(password, kdfMeta) {
          const pass = String(password || '');
          if (!pass) throw new Error('Missing password');
          const normalizedKdf = this.normalizeLocalSecurityKdfMeta(kdfMeta);
          const baseKey = await crypto.subtle.importKey(
            'raw',
            new TextEncoder().encode(pass),
            'PBKDF2',
            false,
            ['deriveKey']
          );
          return await crypto.subtle.deriveKey(
            {
              name: 'PBKDF2',
              salt: B64.dec(normalizedKdf.salt),
              iterations: normalizedKdf.iterations,
              hash: normalizedKdf.hash
            },
            baseKey,
            { name: 'AES-GCM', length: 256 },
            false,
            ['encrypt', 'decrypt']
          );
        },
        async encryptLocalSecurityEnvelope(payloadObj, key, kdfMeta) {
          const iv = crypto.getRandomValues(new Uint8Array(12));
          const plainBytes = new TextEncoder().encode(JSON.stringify(payloadObj));
          const cipherBytes = new Uint8Array(
            await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, plainBytes)
          );
          return {
            __mbLocalEncrypted: true,
            version: 1,
            kdf: this.normalizeLocalSecurityKdfMeta(kdfMeta),
            cipher: {
              iv: B64.enc(iv),
              payload: B64.enc(cipherBytes)
            },
            updatedAt: Date.now()
          };
        },
        async decryptLocalSecurityEnvelopeWithKey(envelope, key) {
          if (!this.isEncryptedLocalEnvelope(envelope)) throw new Error('Invalid encrypted envelope');
          const iv = B64.dec(envelope.cipher.iv);
          const cipherBytes = B64.dec(envelope.cipher.payload);
          const plainBuffer = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv },
            key,
            cipherBytes
          );
          const plainText = new TextDecoder().decode(plainBuffer);
          return JSON.parse(plainText);
        },
        async decryptLocalSecurityEnvelopeWithPassword(envelope, password) {
          const normalizedKdf = this.normalizeLocalSecurityKdfMeta(envelope?.kdf);
          const key = await this.deriveLocalSecurityKey(password, normalizedKdf);
          const payload = await this.decryptLocalSecurityEnvelopeWithKey(envelope, key);
          return { payload, key, kdf: normalizedKdf };
        },
        clearLocalSecurityRuntime() {
          this._localEncryptionKey = null;
          this._localEncryptionKdf = null;
        },
        clearLocalSecuritySessionTimer() {
          if (this._localSecuritySessionTimer) {
            clearTimeout(this._localSecuritySessionTimer);
            this._localSecuritySessionTimer = null;
          }
          this.localSecurity.sessionExpiresAt = 0;
        },
        startLocalSecuritySessionTimer() {
          this.clearLocalSecuritySessionTimer();
          if (!this.localSecurity.isEncryptedStore || this.localSecurity.locked) return;
          if (!this.isLocalSecurityEnabled()) return;
          const timeoutMinutes = this.normalizeLocalSecurityOptions(this.data?.options?.security).sessionTimeoutMinutes;
          if (!Number.isFinite(timeoutMinutes) || timeoutMinutes <= 0) {
            this.localSecurity.sessionExpiresAt = 0;
            return;
          }
          const timeoutMs = Math.max(60000, timeoutMinutes * 60 * 1000);
          this.localSecurity.sessionExpiresAt = Date.now() + timeoutMs;
          this._localSecuritySessionTimer = setTimeout(() => {
            this.triggerLocalSecurityLock('timeout');
          }, timeoutMs);
        },
        focusLocalUnlockInput() {
          this.$nextTick(() => {
            const input = this.$refs.localUnlockPasswordInput;
            if (input && typeof input.focus === 'function') input.focus();
          });
        },
        focusLocalSecurityPasswordInput() {
          this.$nextTick(() => {
            const input = this.$refs.localSecurityPasswordInput;
            if (input && typeof input.focus === 'function') input.focus();
          });
        },
        enterLocalSecurityLockedState(envelope, recordId, reason = 'initial') {
          this.clearLocalSecuritySessionTimer();
          this.localSecurity.isEncryptedStore = true;
          this.localSecurity.locked = true;
          this.localSecurity.lockReason = reason || 'initial';
          this.localSecurity.unlockPassword = '';
          this.localSecurity.unlockBusy = false;
          this.localSecurity.unlockError = '';
          this.localSecurity.encryptedEnvelope = envelope;
          this.localSecurity.encryptedDataId = Number.isFinite(recordId) ? recordId : -1;
          this.clearLocalSecurityRuntime();
          this.dataLoaded = false;
          this._allowSaveDuringLoad = false;
          this.loadFailed = false;
          this.lastLoadError = '';
          this.dataId = Number.isFinite(recordId) ? recordId : -1;
          this.data = JSON.parse(JSON.stringify(initialData));
          this.fixOptions();
          this.focusLocalUnlockInput();
        },
        async captureLatestLocalSecurityEnvelope() {
          try {
            if (!linksDb?.links) return;
            const latestRecord = await linksDb.links.orderBy('id').last();
            if (!latestRecord) return;
            const parsed = JSON.parse(latestRecord.data);
            if (!this.isEncryptedLocalEnvelope(parsed)) return;
            this.localSecurity.encryptedEnvelope = parsed;
            this.localSecurity.encryptedDataId = latestRecord.id;
            this.dataId = latestRecord.id;
          } catch (error) {
            debugLog('warn', '[SECURITY] Could not capture encrypted envelope', error);
          }
        },
        async triggerLocalSecurityLock(reason = 'timeout') {
          if (!this.localSecurity.isEncryptedStore || this.localSecurity.locked) return;
          this.clearLocalSecuritySessionTimer();
          try {
            if (this._debouncedSave && this._debouncedSave.cancel) this._debouncedSave.cancel();
            await this.saveDataImmediate();
          } catch (error) {
            debugLog('warn', '[SECURITY] Failed to persist data before lock', error);
          }
          this.clearLocalSecurityRuntime();
          this.localSecurity.locked = true;
          this.localSecurity.lockReason = reason || 'timeout';
          this.localSecurity.unlockPassword = '';
          this.localSecurity.unlockBusy = false;
          this.localSecurity.unlockError = '';
          this.dataLoaded = false;
          this._allowSaveDuringLoad = false;
          this.loadFailed = false;
          this.lastLoadError = '';
          this.data = JSON.parse(JSON.stringify(initialData));
          this.fixOptions();
          if (!this.localSecurity.encryptedEnvelope) {
            await this.captureLatestLocalSecurityEnvelope();
          }
          this.focusLocalUnlockInput();
        },
        async submitLocalSecurityUnlock() {
          if (this.localSecurity.unlockBusy) return;
          const password = String(this.localSecurity.unlockPassword || '');
          if (!password) return;
          if (!this.localSecurity.encryptedEnvelope) {
            this.localSecurity.unlockError = this.getTranslation('options.security.unlockError') || 'Could not unlock data. Please check the password.';
            return;
          }
          this.localSecurity.unlockBusy = true;
          this.localSecurity.unlockError = '';
          try {
            const decrypted = await this.decryptLocalSecurityEnvelopeWithPassword(this.localSecurity.encryptedEnvelope, password);
            this._localEncryptionKey = decrypted.key;
            this._localEncryptionKdf = decrypted.kdf;
            this.localSecurity.unlockPassword = '';
            this.localSecurity.locked = false;
            this.localSecurity.lockReason = '';
            this._pendingDecryptedStoredData = decrypted.payload;
            this._pendingDecryptedRecordId = Number.isFinite(this.localSecurity.encryptedDataId)
              ? this.localSecurity.encryptedDataId
              : -1;
            await this.loadData();
          } catch (error) {
            debugLog('warn', '[SECURITY] Unlock failed', error);
            this.localSecurity.unlockError = this.getTranslation('options.security.unlockError') || 'Could not unlock data. Please check the password.';
          } finally {
            this.localSecurity.unlockBusy = false;
          }
        },
        promptForLocalSecurityPassword() {
          return new Promise((resolve) => {
            this.localSecurityPasswordDialog.password = '';
            this.localSecurityPasswordDialog.confirmPassword = '';
            this.localSecurityPasswordDialog.error = '';
            this._localSecurityPasswordPromptResult = null;
            this._localSecurityPasswordPromptResolver = resolve;
            const modalElement = document.getElementById('localSecurityPasswordModal');
            if (!modalElement) {
              this._localSecurityPasswordPromptResolver = null;
              resolve(null);
              return;
            }
            const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
            modalInstance.show();
            this.focusLocalSecurityPasswordInput();
          });
        },
        submitLocalSecurityPasswordDialog() {
          const password = String(this.localSecurityPasswordDialog.password || '');
          const confirmPassword = String(this.localSecurityPasswordDialog.confirmPassword || '');
          if (!password.trim()) {
            this.localSecurityPasswordDialog.error = this.getTranslation('options.security.passwordDialog.error.empty') || 'Please enter a password.';
            return;
          }
          if (password.length < 8) {
            this.localSecurityPasswordDialog.error = this.getTranslation('options.security.passwordDialog.error.short') || 'Password must be at least 8 characters.';
            return;
          }
          if (password !== confirmPassword) {
            this.localSecurityPasswordDialog.error = this.getTranslation('options.security.passwordDialog.error.mismatch') || 'Passwords do not match.';
            return;
          }
          this.localSecurityPasswordDialog.error = '';
          this._localSecurityPasswordPromptResult = password;
          this.hideModalById('localSecurityPasswordModal');
        },
        cancelLocalSecurityPasswordDialog() {
          this._localSecurityPasswordPromptResult = null;
          this.hideModalById('localSecurityPasswordModal');
        },
        onLocalSecurityPasswordModalHidden() {
          const resolver = this._localSecurityPasswordPromptResolver;
          if (!resolver) return;
          const result = this._localSecurityPasswordPromptResult || null;
          this._localSecurityPasswordPromptResolver = null;
          this._localSecurityPasswordPromptResult = null;
          this.localSecurityPasswordDialog.password = '';
          this.localSecurityPasswordDialog.confirmPassword = '';
          this.localSecurityPasswordDialog.error = '';
          resolver(result);
        },
        initDatabase() {
          linksDb = new Dexie('data');
          linksDb.version(1).stores({
            links: '++id',
          });
          this.loadData();
        },
        async loadData() {
          try {
            this.dataLoaded = false;
            this.loadFailed = false;
            this.lastLoadError = '';
            this._allowSaveDuringLoad = true;

            const pendingStoredData = this._pendingDecryptedStoredData || null;
            const pendingRecordId = Number.isFinite(this._pendingDecryptedRecordId) ? this._pendingDecryptedRecordId : -1;
            this._pendingDecryptedStoredData = null;
            this._pendingDecryptedRecordId = null;

            let latestRecord = null;
            let isFresh = false;
            if (pendingStoredData) {
              isFresh = false;
              this.dataId = pendingRecordId;
              this.localSecurity.isEncryptedStore = true;
              this.localSecurity.locked = false;
              this.localSecurity.lockReason = '';
              this.localSecurity.unlockError = '';
              this.localSecurity.unlockPassword = '';
              this.localSecurity.encryptedDataId = pendingRecordId;
              // Merge gespeicherte Daten auf die Standardstruktur
              this.data = Object.assign({}, JSON.parse(JSON.stringify(initialData)), pendingStoredData);
              debugLog('log', 'Loaded data from decrypted session:', pendingStoredData);
            } else {
              latestRecord = await linksDb.links.orderBy('id').last();
              isFresh = !latestRecord;
              if (latestRecord) {
                this.dataId = latestRecord.id;
                const storedRecord = JSON.parse(latestRecord.data);
                if (this.isEncryptedLocalEnvelope(storedRecord)) {
                  this._allowSaveDuringLoad = false;
                  this.enterLocalSecurityLockedState(storedRecord, latestRecord.id, 'initial');
                  return;
                }
                this.localSecurity.isEncryptedStore = false;
                this.localSecurity.locked = false;
                this.localSecurity.lockReason = '';
                this.localSecurity.unlockError = '';
                this.localSecurity.unlockPassword = '';
                this.localSecurity.encryptedEnvelope = null;
                this.localSecurity.encryptedDataId = -1;
                this.clearLocalSecurityRuntime();
                this.clearLocalSecuritySessionTimer();
                // Merge gespeicherte Daten auf die Standardstruktur
                this.data = Object.assign({}, JSON.parse(JSON.stringify(initialData)), storedRecord);
                debugLog('log', "Loaded data:", storedRecord);
                try {
                  const total = await linksDb.links.count();
                  if (total > 1) {
                    debugLog('warn', `[STORAGE] Multiple records detected (${total}). Using newest id=${this.dataId}.`);
                  }
                } catch {}
              } else {
                // DB leer -> Initialisiere mit Defaults
                this.localSecurity.isEncryptedStore = false;
                this.localSecurity.locked = false;
                this.localSecurity.lockReason = '';
                this.localSecurity.unlockError = '';
                this.localSecurity.unlockPassword = '';
                this.localSecurity.encryptedEnvelope = null;
                this.localSecurity.encryptedDataId = -1;
                this.clearLocalSecurityRuntime();
                this.clearLocalSecuritySessionTimer();
                this.data = JSON.parse(JSON.stringify(initialData));
                this.dataId = -1;
                // Optional: Default-Gruppe erstellen, wenn gewünscht
                // const tmpGroup = this.getNewGroupTemplate(this.getTranslation('options.common'));
                // this.data.groups = [tmpGroup];
              }
            }
            // Track if we need to save due to migrations
            let needsSaveForMigration = false;
            // Apply schema migrations and normalization before further processing
            try { if (this.applyMigrations && this.applyMigrations(this.data)) needsSaveForMigration = true; } catch (e) { debugLog('warn','[MIGRATION] applyMigrations failed', e); }

            // 1. Optionsstruktur sicherstellen
            this.fixOptions();
            if (!this.localSecurity.isEncryptedStore && this.data?.options?.security?.enabled) {
              this.$set(this.data.options.security, 'enabled', false);
              needsSaveForMigration = true;
              debugLog('warn', '[SECURITY] Security option was enabled but storage is not encrypted. Auto-disabling option.');
            }
            // Ensure identity exists with a UUID (needed for event-log)
            if (!this.data.identity) {
              this.$set(this.data, 'identity', { 
                uuid: this.generateUUID(), // Always generate a UUID for event-log
                name: '', 
                pubKey: '', 
                privKey: '' 
              });
            } else if (!this.data.identity.uuid) {
              // If identity exists but has no UUID, generate one
              this.$set(this.data.identity, 'uuid', this.generateUUID());
            }

            // Ensure display name: on fresh settings or if not set
            try {
              const currentName = (this.data.options?.common?.identityName || this.data.identity?.name || '').trim();
              if (isFresh || !currentName) {
                const rand = Math.random().toString(36).slice(2, 8); // 6-stellig, [a-z0-9]
                const generated = `mybookmarks_${rand}`;
                if (!this.data.options) this.$set(this.data, 'options', {});
                if (!this.data.options.common) this.$set(this.data.options, 'common', {});
                this.$set(this.data.options.common, 'identityName', generated);
                if (!this.data.identity) this.$set(this, 'identity', {});
                this.$set(this.data.identity, 'name', generated);
                debugLog('log', '[INIT] Generated default identity name:', generated);
                // Persist immediately so subsequent logic sees the identity
                this.saveData();
              }
            } catch {}
            if (!Array.isArray(this.data.contacts)) this.$set(this.data, 'contacts', []);
            if (!Array.isArray(this.data.inbox)) this.$set(this.data, 'inbox', []);
            // Ensure auxiliary arrays exist
            if (!Array.isArray(this.data.snapshots)) this.$set(this.data, 'snapshots', []);

            // Ensure all groups have required IDs and clean up shared status
            (this.data.groups || []).forEach(g => {
              // Ensure every group has a groupId (needed for event-log)
              if (!g.groupId) {
                g.groupId = g.uuid || this.generateUUID();
                if (!g.uuid) {
                  g.uuid = g.groupId;
                }
                debugLog('log', '[INIT] Added groupId to group:', g.name, g.groupId);
              }

              if (g.favicon === undefined) this.$set(g, 'favicon', '');
              if (g.faviconError === undefined) this.$set(g, 'faviconError', false);
              if (g.faviconLoading === undefined) this.$set(g, 'faviconLoading', false);
              if (g.faviconSource === undefined) this.$set(g, 'faviconSource', null);
              if (g.faviconRuleId === undefined) this.$set(g, 'faviconRuleId', null);
              if (g.snapshot && typeof g.snapshot === 'object') {
                if (g.snapshot.favicon === undefined) this.$set(g.snapshot, 'favicon', g.favicon || '');
                if (g.snapshot.faviconSource === undefined) this.$set(g.snapshot, 'faviconSource', g.faviconSource || null);
                if (g.snapshot.faviconRuleId === undefined) this.$set(g.snapshot, 'faviconRuleId', g.faviconRuleId || null);
              }

              // Add progressive loading defaults for existing groups
              if (g.linksExpanded === undefined) {
                g.linksExpanded = false; // Start collapsed for performance
              }
              if (g.initialLinkCount === undefined) {
                // Use global setting or default to 100
                const threshold = this.data.options?.links?.progressiveLoadingThreshold || CONSTS.PROGRESSIVE_LOADING_THRESHOLD;
                g.initialLinkCount = threshold;
              }
              if (g.expandedLinkCount === undefined) {
                g.expandedLinkCount = CONSTS.EXPANDED_LINK_LIMIT; // Show 500 when expanded
              }
              if (g.bodyHeight === undefined || g.bodyHeight === null) {
                g.bodyHeight = CONSTS.GROUP_BODY_HEIGHT_DEFAULT;
              } else {
                g.bodyHeight = this.normalizeGroupBodyHeight(g.bodyHeight);
              }
              
              // Clean up shared flag for groups without active members
              if (g.shared) {
                const noMembers = !g.members || g.members.length === 0;
                const onlyOwnerRemains = g.members && g.members.length === 1 && g.members[0].role === 'owner';
                const noRegularMembers = g.members && g.members.length > 0 && !g.members.some(x => x.role === 'member');
                if (noMembers || onlyOwnerRemains || noRegularMembers) {
                  debugLog('log', '[CLEANUP] Auto-unshare group without active members:', g.name);
                  g.shared = false;
                  try { if (g.groupTopic && window.sharing) window.sharing.ntfy.unsubscribe(g.groupTopic); } catch (e) { debugLog('warn','[CLEANUP] Unsubscribe failed', e); }
                }
              }
            });

            // 2. Option lesen *nach* dem Fixen
            const forceCollapseAll = this.data.options.groups.collapseGroupsOnStart;
            debugLog('log', "Option collapseGroupsOnStart:", forceCollapseAll);
            
            
            // 3. Gruppen verarbeiten und 'collapsed' Status korrekt setzen
            if (this.data.groups && Array.isArray(this.data.groups)) {
              this.data.groups.forEach(g => {

                // --- NEUE, KORRIGIERTE Logik ---
                if (forceCollapseAll) {
                  // Option ist TRUE -> Alle Gruppen einklappen, gespeicherten Zustand ignorieren
                  this.$set(g, 'collapsed', true);
                  debugLog('log', `Group "${g.name}" (ID: ${g.id}) forced collapsed=true due to option.`);
                } else {
                  // Option ist FALSE -> Gespeicherten Zustand verwenden oder auf ausgeklappt (false) setzen
                  if (g.collapsed === undefined || g.collapsed === null) {
                    // Wenn kein Zustand gespeichert, default ist AUSGEKLAPPT
                    this.$set(g, 'collapsed', false);
                    debugLog('log', `Group "${g.name}" (ID: ${g.id}) 'collapsed' state MISSING, defaulting to expanded (false).`);
                  } else {
                    // Gespeicherten Zustand (true oder false) verwenden
                    debugLog('log', `Group "${g.name}" (ID: ${g.id}) 'collapsed' state loaded from save: ${g.collapsed}`);
                    // Hier ist keine Aktion nötig, der Wert aus storedData wurde bereits übernommen
                    // Nur zur Sicherheit via $set setzen, falls Objekt nicht reaktiv war:
                    this.$set(g, 'collapsed', g.collapsed);
                  }
                }
                // --- Ende NEUE, KORRIGIERTE Logik ---

                // UUID-Migration für Gruppen: Add UUID to existing groups that don't have one
                if (!g.uuid) {
                  this.$set(g, 'uuid', this.generateUUID());
                  needsSaveForMigration = true;
                  debugLog('log', `[MIGRATION] Added UUID to group "${g.name}": ${g.uuid}`);
                }

                // Andere Eigenschaften setzen/prüfen (wie zuvor)
                if (g.column === undefined || g.column === null) this.$set(g, 'column', 0);
                this.$set(g, 'editing', false);
                this.$set(g, 'isMouseOver', false);
                this.$set(g, 'searchCollapsed', true); // Immer für Suche initial einklappen
                this.$set(g, 'newLinkText', '');
                this.$set(g, 'newLinkUrl', '');
                if (g.shortcut === undefined) this.$set(g, 'shortcut', '');

                // Links verarbeiten und UUID-Migration
                if (!g.links || !Array.isArray(g.links)) {
                  this.$set(g, 'links', []);
                } else {
                  g.links.forEach(l => {
                    // UUID-Migration: Add UUID to existing links that don't have one
                    if (!l.uuid) {
                      this.$set(l, 'uuid', this.generateUUID());
                      needsSaveForMigration = true;
                      debugLog('log', `[MIGRATION] Added UUID to link "${l.text}" in group "${g.name}"`);
                    }
                    
                    if (l.column === undefined || l.column === null) this.$set(l, 'column', 0);
                    if (l.keywords === undefined) this.$set(l, 'keywords', '');
                    if (l.shortcut === undefined) this.$set(l, 'shortcut', '');
                    this.$set(l, 'editing', false);
                    this.$set(l, 'isMouseOver', false);
                  });
                  
                  // Links-Spalten innerhalb der Gruppe neu indizieren
                  this.getLinkColumns(g.links).forEach(col => this.reindexArr(g.links.filter(l => l.column === col)));
                }
              });

              // Gruppen-Spalten neu indizieren
              this.getGroupColumns().forEach(col => {
                this.reindexArr(this.data.groups.filter(g => g.column === col));
              });
            } else {
              this.$set(this.data, 'groups', []);
            }

            if (this.ensureAllTimestamps()) {
              needsSaveForMigration = true;
            }

            // Initialdaten speichern, wenn DB leer war oder Migration durchgeführt wurde
            if (this.dataId === -1 || needsSaveForMigration) {
              if (needsSaveForMigration) {
                debugLog('log', "[MIGRATION] Saving data after UUID migration - this is critical for sync!");
                // Force immediate save to ensure UUIDs are persisted before any sharing operations
                await this.saveDataImmediate();
              } else {
                debugLog('log', "Saving initial data structure.");
                this.saveData();
              }
            }

            // 4. UI-Einstellungen anwenden
            this.updateSettings();
            this.loadVisualCssRules();
            this.loadCustomRuleSets();
            this.loadCollapsedRules();
            this.loadDesignTokensCollapsed();
            this.applyVisualCssSidebarPreferences();

            // Ensure identity now that data is loaded, then subscribe pairwise
            try {
              if (sharing) {
                sharing.applyConfig();
                await sharing.ensureIdentity();
                for (const c of (this.data.contacts || [])) {
                  try { await sharing.derivePairwiseFor(c.uuid); } catch {}
                }
                // subscribe shared groups
                for (const g of (this.data.groups || [])) {
                  try { 
                    if (g.shared && g.groupTopic && g.groupKey) {
                      debugLog('log', '[INIT] Subscribing to shared group from loadData:', g.name, g.groupId);
                      sharing.subscribeGroup(g, false); // false = send update request
                    }
                  } catch(e) {
                    debugLog('warn', '[INIT] Failed to subscribe group:', g.name, e);
                  }
                }
                // Ensure owner membership on non-shared groups
                try {
                  const myUuid = this.data.identity?.uuid || '';
                  const myName = this.data.identity?.name || '';
                  (this.data.groups||[]).forEach(g => {
                    if (!g.shared) {
                      if (!Array.isArray(g.members) || !g.members.length) {
                        this.$set(g, 'members', [ { uuid: myUuid, name: myName, role: 'owner' } ]);
                      } else if (!g.members.some(m => m.uuid === myUuid && m.role === 'owner')) {
                        g.members = g.members.filter(m => m.uuid !== myUuid);
                        g.members.unshift({ uuid: myUuid, name: myName, role: 'owner' });
                      }
                    }
                  });
                  this.saveData();
                } catch (error) {
                debugLog('error', '[Sharing] Error processing message headers:', error);
              }
                // Owner-initiated sync on open
                for (const g of (this.data.groups || [])) {
                  try { await sharing.sendOwnerSync(g); } catch {}
                }
              }
            } catch {}

            // 5. Vue rendern lassen (Template Binding kümmert sich um 'show' Klasse)
            this.$nextTick(() => {
              debugLog('log', "Vue data processed. Template binding should set initial collapse state based on final group.collapsed values.");
              // Stelle sicher, dass setInitialCollapseStates HIER NICHT aufgerufen wird, wenn du Template Binding nutzt.
              try { this.lastSavedJson = JSON.stringify(this.getSavableData()); } catch { }
            });
            this.dataLoaded = true;
            this._allowSaveDuringLoad = false;
            if (this.localSecurity.isEncryptedStore && !this.localSecurity.locked && this.isLocalSecurityEnabled()) {
              this.startLocalSecuritySessionTimer();
            } else {
              this.clearLocalSecuritySessionTimer();
            }

          } catch (e) {
            debugLog('error', "Error loading data:", e);
            this.loadFailed = true;
            this.lastLoadError = (e && e.message) ? e.message : String(e);
            this.dataLoaded = false;
            this._allowSaveDuringLoad = false;
            this.localSecurity.isEncryptedStore = false;
            this.localSecurity.locked = false;
            this.localSecurity.lockReason = '';
            this.localSecurity.encryptedEnvelope = null;
            this.localSecurity.encryptedDataId = -1;
            this.localSecurity.unlockPassword = '';
            this.localSecurity.unlockError = '';
            this.clearLocalSecurityRuntime();
            this.clearLocalSecuritySessionTimer();
            // Fallback
            this.data = JSON.parse(JSON.stringify(initialData));
            this.fixOptions();
            this.dataId = -1;
            if (!Array.isArray(this.data.snapshots)) this.$set(this.data, 'snapshots', []);
            this.updateSettings();
            this.loadVisualCssRules();
            this.loadCustomRuleSets();
            this.loadCollapsedRules();
            this.loadDesignTokensCollapsed();
            this.applyVisualCssSidebarPreferences();
            this.$nextTick(() => {
              debugLog('log', "Vue data processed after error/fallback.");
              // Stelle sicher, dass setInitialCollapseStates HIER NICHT aufgerufen wird.

              try { this.lastSavedJson = JSON.stringify(this.getSavableData()); } catch { }
            });
          }
        }, // Ende loadData
        getSavableData() {
          // Create a deep copy to avoid modifying the original data structure
          const dataToSave = JSON.parse(JSON.stringify({
            groups: this.data.groups,
            options: this.data.options,
            identity: this.data.identity,
            contacts: this.data.contacts,
            inbox: this.data.inbox,
            snapshots: this.data.snapshots || [],
            pendingNcDeletes: this.data.pendingNcDeletes || []
          }));

          // Remove transient UI properties
          dataToSave.groups.forEach(group => {
            delete group.editing;
            delete group.isMouseOver;
            delete group.newLinkText;
            delete group.newLinkUrl;
            delete group.searchCollapsed; // Don't save search-specific collapse state
            group.links.forEach(link => {
              delete link.editing;
              delete link.isMouseOver;
              delete link.isKeywordQuickAddBadgeHover;
              delete link._originalValue;
              delete link._refAliasWasEmpty;
              delete link._refEditSeedValue;
            });
          });

          return dataToSave;
        },
        // saveData defined later (debounced); keep single source of truth
        resetData() {
          if (!confirm(this.getTranslation('eraseDatabase') + ' ' + this.getTranslation('Are you sure?'))) return;
          Dexie.delete('data').then(() => {
            location.reload();
          }).catch(err => {
            debugLog('error', "Error deleting database:", err);
            alert("Could not delete the database. Please clear site data manually.");
          });
        },
        resetDataFromOptions() {
          // Show warning message first
          const warning = this.getTranslation('eraseDatabase.warning') || 'Warning! This will permanently delete ALL your bookmarks, groups, and settings. This action cannot be undone!';
          const confirmMsg = this.getTranslation('eraseDatabase.confirm') || 'Are you absolutely sure you want to delete everything?';
          
          if (!confirm(warning)) return;
          if (!confirm(confirmMsg)) return;
          
          // Close the modal first
          const modalElement = document.getElementById('optionsModal');
          if (modalElement) {
            const modalInstance = bootstrap.Modal.getInstance(modalElement);
            if (modalInstance) {
              modalInstance.hide();
            }
          }
          
          // Delete the database
          Dexie.delete('data').then(() => {
            location.reload();
          }).catch(err => {
            debugLog('error', "Error deleting database:", err);
            alert("Could not delete the database. Please clear site data manually.");
          });
        },
        // Reset all Nextcloud/Sync bindings on groups and links
        resetSyncBindingsFromOptions() {
          try {
            const msg = (this.getTranslation('sync.resetBindings.confirm') || 'This will remove all Nextcloud sync bindings (folder and bookmark IDs) from all groups and links. Your bookmarks stay, but re-sync will recreate mappings. Continue?');
            if (!confirm(msg)) return;
            let groupsCleared = 0, linksCleared = 0;
            for (const g of (this.data.groups||[])) {
              if (g.ncBookmarks) { try { this.$delete(g, 'ncBookmarks'); } catch { delete g.ncBookmarks; } groupsCleared++; }
              for (const l of (g.links||[])) {
                if (l && l.ncBookmarks) { try { this.$delete(l, 'ncBookmarks'); } catch { delete l.ncBookmarks; } linksCleared++; }
              }
            }
            // Clear cached folder hashes
            try {
              if (this.data.options && this.data.options.bookmarks) {
                this.$set(this.data.options.bookmarks, 'folderHashes', {});
              }
            } catch {}
            this.saveData();
            this.showToast((this.getTranslation('sync.resetBindings.done') || 'Sync bindings cleared') + ` (groups: ${groupsCleared}, links: ${linksCleared})`, 'success');
          } catch (e) {
            debugLog('error', '[SYNC] reset bindings failed', e);
            this.showToast((this.getTranslation('sync.resetBindings.failed') || 'Failed to clear sync bindings') + ': ' + (e?.message||String(e)), 'error');
          }
        },
        exportAndDownload() {
          // Prepare export selection data
          this.exportSelection = this.data.groups.map(group => ({
            name: group.name,
            selected: true,
            original: group,
            links: (group.links || []).filter(l => !l.deleted).map(link => ({
              text: link.text,
              url: link.url,
              keywords: Array.isArray(link.keywords) ? link.keywords.join(';') : (link.keywords || ''),
              selected: true,
              original: link
            }))
          }));
          
          // Open export dialog
          const modalElement = document.getElementById('exportModal');
          if (!modalElement) return;
          const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
          modalInstance && modalInstance.show();
        },
        
        onExportGroupChange(groupIndex) {
          const group = this.exportSelection[groupIndex];
          if (group.selected) {
            // Select all links in the group
            group.links.forEach(link => { link.selected = true; });
          }
        },
        
        onExportLinkChange(groupIndex) {
          const group = this.exportSelection[groupIndex];
          // Update group selection based on links
          const anySelected = group.links.some(l => l.selected);
          const allSelected = group.links.length > 0 && group.links.every(l => l.selected);
          group.selected = allSelected;
        },
        
        selectAllExportGroups() {
          this.exportSelection.forEach(group => {
            group.selected = true;
            group.links.forEach(link => { link.selected = true; });
          });
        },
        
        deselectAllExportGroups() {
          this.exportSelection.forEach(group => {
            group.selected = false;
            group.links.forEach(link => { link.selected = false; });
          });
        },
        
        hasExportSelection() {
          return this.exportSelection.some(g => g.links.some(l => l.selected));
        },
        
        getExportSelectionCount() {
          let count = 0;
          this.exportSelection.forEach(g => {
            count += g.links.filter(l => l.selected).length;
          });
          return count;
        },
        getFullJsonPreview() {
          try {
            return JSON.stringify(this.getSavableData(), null, 2);
          } catch { return '{}'; }
        },
        getSettingsJsonPreview() {
          try {
            return JSON.stringify({ options: this.data.options || {} }, null, 2);
          } catch { return '{}'; }
        },
        
        confirmExport() {
          const selectedGroups = [];
          if (this.exportFormat !== 'json') {
            this.exportSelection.forEach(group => {
              const selectedLinks = group.links.filter(l => l.selected);
              if (selectedLinks.length > 0) {
                selectedGroups.push({
                  ...group.original,
                  links: selectedLinks.map(l => l.original)
                });
              }
            });
            if (selectedGroups.length === 0) {
              alert('No links selected for export');
              return;
            }
          }
          
          let content = '';
          let filename = '';
          let mimeType = '';
          const dateStr = new Date().toISOString().slice(0, 10);
          
          switch (this.exportFormat) {
            case 'json':
              // JSON (Full) exports the complete application data
              content = JSON.stringify(this.getSavableData(), null, 2);
              filename = `bookmarks-export-${dateStr}.json`;
              mimeType = 'application/json;charset=utf-8';
              break;
              
            case 'json-array':
              // JSON Array of links only
              const allLinks = [];
              selectedGroups.forEach(g => {
                g.links.forEach(l => {
                  allLinks.push({
                    url: l.url,
                    text: l.text,
                    keywords: Array.isArray(l.keywords) ? l.keywords.join(';') : (l.keywords || '')
                  });
                });
              });
              content = JSON.stringify(allLinks, null, 2);
              filename = `bookmarks-links-${dateStr}.json`;
              mimeType = 'application/json;charset=utf-8';
              break;
              
            case 'csv':
              // CSV export
              let csv = 'Title,URL,Keywords\n';
              selectedGroups.forEach(g => {
                g.links.forEach(l => {
                  const title = (l.text || '').replace(/"/g, '""');
                  const url = (l.url || '').replace(/"/g, '""');
                  const keywords = (l.keywords || '').replace(/"/g, '""');
                  csv += `"${title}","${url}","${keywords}"\n`;
                });
              });
              content = csv;
              filename = `bookmarks-${dateStr}.csv`;
              mimeType = 'text/csv;charset=utf-8';
              break;
              
            case 'html':
              // HTML Bookmarks format
              let html = '<!DOCTYPE NETSCAPE-Bookmark-file-1>\n';
              html += '<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">\n';
              html += '<TITLE>Bookmarks</TITLE>\n';
              html += '<H1>Bookmarks</H1>\n';
              html += '<DL><p>\n';
              selectedGroups.forEach(g => {
                html += `    <DT><H3>${this.escapeHtml(g.name || 'Untitled')}</H3>\n`;
                html += '    <DL><p>\n';
                g.links.forEach(l => {
                  const tags = (l.keywords || '');
                  html += `        <DT><A HREF="${this.escapeHtml(l.url || '')}"`;
                  if (tags) html += ` TAGS="${this.escapeHtml(tags)}"`;
                  html += `>${this.escapeHtml(l.text || l.url || '')}</A>\n`;
                });
                html += '    </DL><p>\n';
              });
              html += '</DL><p>\n';
              content = html;
              filename = `bookmarks-${dateStr}.html`;
              mimeType = 'text/html;charset=utf-8';
              break;
          }
          
          // Download file
          try {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Close modal
            const modalElement = document.getElementById('exportModal');
            const modalInstance = modalElement ? bootstrap.Modal.getInstance(modalElement) : null;
            modalInstance && modalInstance.hide();
          } catch (error) {
            debugLog('error', "Export failed:", error);
            alert("Export failed. See console for details.");
          }
        },
        
        escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        },
        // Generate UUID for links to ensure unique identification across all members
        generateUUID() {
          try {
            // Prefer native crypto.randomUUID
            if (crypto && crypto.randomUUID) {
              return crypto.randomUUID();
            }
            // Fallback to crypto.getRandomValues with proper UUID v4 format
            if (crypto && crypto.getRandomValues) {
              const bytes = new Uint8Array(16);
              crypto.getRandomValues(bytes);
              // Set version (4) and variant bits according to UUID v4 spec
              bytes[6] = (bytes[6] & 0x0f) | 0x40; // Version 4
              bytes[8] = (bytes[8] & 0x3f) | 0x80; // Variant 10
              // Format as UUID string
              const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
              return `${hex.substr(0,8)}-${hex.substr(8,4)}-${hex.substr(12,4)}-${hex.substr(16,4)}-${hex.substr(20,12)}`;
            }
            // Fallback to URL.createObjectURL (still better than timestamp)
            return URL.createObjectURL(new Blob()).split('/').pop();
          } catch (error) {
            debugLog('error', '[UUID] Failed to generate secure UUID:', error);
            // Last resort with better entropy
            const timestamp = Date.now().toString(36);
            const random1 = Math.random().toString(36).substr(2, 9);
            const random2 = Math.random().toString(36).substr(2, 9);
            const random3 = performance.now().toString(36).substr(2, 5);
            return `${timestamp}-${random1}-${random2}-${random3}`;
          }
        },
        // --- Options & Settings ---
        fixOptions() { // Ensures options structure exists with defaults
          const defaultOptions = initialData.options;
          this.data.options = this.data.options || {};
          this.data.options.common = Object.assign({}, defaultOptions.common, this.data.options.common);
          this.data.options.common.manualGroupColumnWidth = !!this.data.options.common.manualGroupColumnWidth;
          this.data.options.common.debugEnabled = !!this.data.options.common.debugEnabled;
          setDebugEnabled(this.data.options.common.debugEnabled);
          this.data.options.groups = Object.assign({}, defaultOptions.groups, this.data.options.groups);
          this.data.options.groups.autoAdjustHeightOnLinkChanges = !!this.data.options.groups.autoAdjustHeightOnLinkChanges;
          if (!this.data.options.groups.columnWidths || typeof this.data.options.groups.columnWidths !== 'object' || Array.isArray(this.data.options.groups.columnWidths)) {
            this.$set(this.data.options.groups, 'columnWidths', {});
          }
          this.data.options.links = Object.assign({}, defaultOptions.links || {}, this.data.options.links || {});
          this.data.options.links.showReferenceMarker = this.data.options.links.showReferenceMarker !== false;
          const hasButtonsKeywordQuickAddBadge = !!(this.data.options.buttons && Object.prototype.hasOwnProperty.call(this.data.options.buttons, 'showKeywordQuickAddBadge'));
          const legacyKeywordQuickAddBadge = (this.data.options.common && Object.prototype.hasOwnProperty.call(this.data.options.common, 'showKeywordQuickAddBadge'))
            ? this.data.options.common.showKeywordQuickAddBadge
            : undefined;
          this.data.options.buttons = Object.assign({}, defaultOptions.buttons || {}, this.data.options.buttons || {});
          if (!hasButtonsKeywordQuickAddBadge && typeof legacyKeywordQuickAddBadge === 'boolean') {
            this.$set(this.data.options.buttons, 'showKeywordQuickAddBadge', legacyKeywordQuickAddBadge);
          }
          if (typeof this.data.options.links.defaultUrlPrefix !== 'string') {
            this.$set(this.data.options.links, 'defaultUrlPrefix', CONSTS.DEFAULT_URL_PREFIX);
          } else {
            this.data.options.links.defaultUrlPrefix = this.data.options.links.defaultUrlPrefix.trim();
          }
          if (!Array.isArray(this.data.options.links.faviconRules)) {
            this.$set(this.data.options.links, 'faviconRules', getDefaultFaviconRules());
          }
          if (!Array.isArray(this.data.options.links.globalShortcuts)) {
            this.$set(this.data.options.links, 'globalShortcuts', []);
          }
          if (!Array.isArray(this.data.options.links.globalPlaceholders)) {
            this.$set(this.data.options.links, 'globalPlaceholders', []);
          } else {
            this.$set(this.data.options.links, 'globalPlaceholders', this.normalizePlaceholderList(this.data.options.links.globalPlaceholders));
          }
          // Ensure Nextcloud Bookmarks block exists and preserves saved values (including rootFolderId)
          this.data.options.bookmarks = Object.assign({}, defaultOptions.bookmarks || { serverUrl:'', username:'', password:'', rootFolderId:0, syncIntervalSec:0, folderHashes:{} }, this.data.options.bookmarks || {});
          this.data.options.sharing = Object.assign({}, defaultOptions.sharing || {}, this.data.options.sharing || {});
          this.data.options.colors = Object.assign({}, defaultOptions.colors || {}, this.data.options.colors || {});
          
          // Event-Log defaults - use initialData defaults
          this.data.options.eventlog = Object.assign({}, defaultOptions.eventlog || {
            snapshotInterval: CONSTS.EVENT_LOG_SNAPSHOT_INTERVAL,
            maxEvents: CONSTS.EVENT_LOG_MAX_EVENTS * 2, // Double for main setting
            syncStrategy: 'owner-leads'
          }, this.data.options.eventlog || {});
          
          // Sync defaults - sensible defaults for good user experience
          this.data.options.sync = Object.assign({}, {
            backend: '',
            // Good defaults for all users
            conflictNotificationLevel: 'minimal', // Show important conflicts only
            autoSyncInterval: '600', // 10 minutes - good balance
            offlineMode: 'optimistic', // Better UX for most users
            // Owner defaults
            conflictResolution: 'last-write-wins', // Fair default
            memberRateLimit: 30, // 30 changes per minute is reasonable
            validationLevel: 'moderate', // Balance between security and flexibility
            // Member defaults
            localCacheStrategy: 'full', // Keep everything for offline access
            errorHandling: 'retry' // Auto-retry is user-friendly
          }, this.data.options.sync || {});
          const syncOptions = this.data.options.sync;
          const normalizeEnum = (value, allowed, fallback) => allowed.includes(value) ? value : fallback;
          syncOptions.backend = normalizeEnum(syncOptions.backend, ['', 'carddav', 'nc-bookmarks'], '');
          syncOptions.conflictNotificationLevel = normalizeEnum(syncOptions.conflictNotificationLevel, ['silent', 'minimal', 'verbose'], 'minimal');
          syncOptions.offlineMode = normalizeEnum(syncOptions.offlineMode, ['optimistic', 'conservative'], 'optimistic');
          syncOptions.conflictResolution = normalizeEnum(syncOptions.conflictResolution, ['owner-wins', 'last-write-wins', 'manual'], 'last-write-wins');
          syncOptions.validationLevel = normalizeEnum(syncOptions.validationLevel, ['strict', 'moderate', 'permissive'], 'moderate');
          syncOptions.localCacheStrategy = normalizeEnum(syncOptions.localCacheStrategy, ['full', 'minimal'], 'full');
          syncOptions.errorHandling = normalizeEnum(syncOptions.errorHandling, ['retry', 'queue', 'discard'], 'retry');
          const normalizedAutoSyncInterval = String(syncOptions.autoSyncInterval ?? '600').trim();
          syncOptions.autoSyncInterval = ['0', '300', '600', '1800', '3600'].includes(normalizedAutoSyncInterval)
            ? normalizedAutoSyncInterval
            : '600';
          const normalizedRateLimit = Number(syncOptions.memberRateLimit);
          syncOptions.memberRateLimit = Number.isFinite(normalizedRateLimit)
            ? Math.max(0, Math.min(100, Math.floor(normalizedRateLimit)))
            : 30;

          // Performance defaults
          this.data.options.performance = Object.assign({}, defaultOptions.performance || {
            virtualizeLinks: false,
            initialLimit: 200,
            pageSize: 200
          }, this.data.options.performance || {});
          this.data.options.security = Object.assign({}, defaultOptions.security || {
            enabled: false,
            sessionTimeoutMinutes: 30
          }, this.data.options.security || {});
          this.data.options.security.enabled = !!this.data.options.security.enabled;
          const normalizedSessionTimeoutMinutes = Number(this.data.options.security.sessionTimeoutMinutes);
          this.data.options.security.sessionTimeoutMinutes = Number.isFinite(normalizedSessionTimeoutMinutes)
            ? Math.max(0, Math.min(1440, Math.round(normalizedSessionTimeoutMinutes)))
            : 30;
          // Visual CSS defaults and migration from legacy fields
          const defaultVisualCssOptions = defaultOptions.visualCss || {
            stateVersion: 0,
            rules: [],
            designTokens: [],
            selectedTemplate: null,
            customRuleSets: {},
            collapsedRules: [],
            designTokensCollapsed: false,
            sidebarWidth: 400,
            sidebarTopHeight: 300
          };
          const existingVisualCssOptions = (this.data.options.visualCss && typeof this.data.options.visualCss === 'object' && !Array.isArray(this.data.options.visualCss))
            ? this.data.options.visualCss
            : {};
          const legacyVisualCssRules = Array.isArray(this.data.options.visualCssRules) ? this.data.options.visualCssRules : null;
          const mergedVisualCssOptions = Object.assign({}, defaultVisualCssOptions, existingVisualCssOptions);
          if ((!Array.isArray(mergedVisualCssOptions.rules) || mergedVisualCssOptions.rules.length === 0)
              && Array.isArray(legacyVisualCssRules) && legacyVisualCssRules.length > 0) {
            mergedVisualCssOptions.rules = legacyVisualCssRules;
          }
          if (!Array.isArray(mergedVisualCssOptions.rules)) mergedVisualCssOptions.rules = [];
          if (!Array.isArray(mergedVisualCssOptions.designTokens)) mergedVisualCssOptions.designTokens = [];
          if (!mergedVisualCssOptions.customRuleSets || typeof mergedVisualCssOptions.customRuleSets !== 'object' || Array.isArray(mergedVisualCssOptions.customRuleSets)) {
            mergedVisualCssOptions.customRuleSets = {};
          }
          if (!Array.isArray(mergedVisualCssOptions.collapsedRules)) mergedVisualCssOptions.collapsedRules = [];
          mergedVisualCssOptions.designTokensCollapsed = !!mergedVisualCssOptions.designTokensCollapsed;
          const visualCssStateVersion = parseInt(mergedVisualCssOptions.stateVersion, 10);
          mergedVisualCssOptions.stateVersion = Number.isFinite(visualCssStateVersion) ? visualCssStateVersion : 0;
          mergedVisualCssOptions.selectedTemplate = (typeof mergedVisualCssOptions.selectedTemplate === 'string' && mergedVisualCssOptions.selectedTemplate.trim())
            ? mergedVisualCssOptions.selectedTemplate.trim()
            : null;
          const visualSidebarWidth = parseInt(mergedVisualCssOptions.sidebarWidth, 10);
          mergedVisualCssOptions.sidebarWidth = Number.isFinite(visualSidebarWidth) ? visualSidebarWidth : 400;
          const visualSidebarTopHeight = parseInt(mergedVisualCssOptions.sidebarTopHeight, 10);
          mergedVisualCssOptions.sidebarTopHeight = Number.isFinite(visualSidebarTopHeight) ? visualSidebarTopHeight : 300;
          this.$set(this.data.options, 'visualCss', mergedVisualCssOptions);
          // Keep legacy field for backwards compatibility with older code paths/imports
          this.$set(this.data.options, 'visualCssRules', mergedVisualCssOptions.rules);
          // Custom CSS default
          if (typeof this.data.options.customCss !== 'string') this.$set(this.data.options, 'customCss', '');
        },
        // Migrations/Normalization to keep schema compatible
        applyMigrations(data) {
          let migrated = false;
          try {
            if (!data.schemaVersion) { data.schemaVersion = 1; migrated = true; }
            // Example migration scaffolding for future versions
            // if (data.schemaVersion < 2) { /* transform ... */ data.schemaVersion = 2; migrated = true; }
            // Ensure structural fields exist
            if (!Array.isArray(data.groups)) { data.groups = []; migrated = true; }
            if (!data.options) { data.options = JSON.parse(JSON.stringify(initialData.options)); migrated = true; }
            // Ensure performance block exists
            if (!data.options.performance) { data.options.performance = JSON.parse(JSON.stringify(initialData.options.performance)); migrated = true; }
          } catch (e) {
            debugLog('warn', '[MIGRATION] failed to normalize data', e);
          }
          return migrated;
        },
        updateSettings() { // Applies settings to the UI
          this.fixOptions(); // Ensure options are valid before using them
          setDebugEnabled(!!this.data.options?.common?.debugEnabled);
          this.title = this.data.options.common.pageTitle || initialData.options.common.pageTitle;
          document.title = this.title; // Update browser tab title
          const normalizedGlobalShortcuts = this.normalizeGlobalShortcutList(this.data?.options?.links?.globalShortcuts || [], { ensureId: true });
          if (JSON.stringify(normalizedGlobalShortcuts) !== JSON.stringify(this.data?.options?.links?.globalShortcuts || [])) {
            this.$set(this.data.options.links, 'globalShortcuts', normalizedGlobalShortcuts);
          }
          
          // Custom colors are now handled via CSS variables

          // Initialize collapse state based on options ONLY if not already set
          this.data.groups.forEach(g => {
            if (g.collapsed === undefined) { // Check if the property exists
              this.$set(g, 'collapsed', this.data.options.groups.collapseGroupsOnStart);
            }
            // Always reset searchCollapsed state
            this.$set(g, 'searchCollapsed', true);
            // Ensure keywords property exists
            if (g.keywords === undefined) this.$set(g, 'keywords', '');
            if (g.shortcut === undefined) this.$set(g, 'shortcut', '');
            if (g.manualHeightResizeOverride === undefined) this.$set(g, 'manualHeightResizeOverride', false);
            this.$set(g, 'urlPlaceholders', this.normalizePlaceholderList(g.urlPlaceholders || []));
            (g.links || []).forEach(l => {
              if (l.keywords === undefined) this.$set(l, 'keywords', '');
              if (l.shortcut === undefined) this.$set(l, 'shortcut', '');
              const normalizedType = this.normalizeLinkItemType(l);
              this.$set(l, 'itemType', normalizedType);
              this.normalizeLinkDataForItemType(l, normalizedType);
              this.$set(l, 'urlPlaceholders', this.normalizePlaceholderList(l.urlPlaceholders || []));
              if (this.isReferenceLink(l) && l.inheritSourceKeywords === undefined) {
                this.$set(l, 'inheritSourceKeywords', true);
              }
            });
            // Ensure opacity property exists (use global default if available)
          });
          const existingGroupColumns = [...new Set((this.data.groups || []).map(g => g.column))];
          this.pruneGroupColumnWidths(existingGroupColumns);
          // Populate missing faviconUrl for existing links when option is enabled
          // Removed - no fallback favicon URL needed anymore
        },
        // Generic Edit Dialog Methods
        openGenericEditDialog(type, data, design, title, saveCallback, context = {}) {
          debugLog('log', 'openGenericEditDialog called with type:', type);
          debugLog('log', 'openGenericEditDialog called with type:', type);
          this.genericEditConfig = {
            title: title,
            type: type,
            design: design,
            saveCallback: saveCallback,
            context: context || {}
          };
          
          // Deep clone the data for editing
          this.genericEditData = JSON.parse(JSON.stringify(data));
          if (type === 'link') {
            const normalizedType = this.normalizeLinkItemType(this.genericEditData);
            this.$set(this.genericEditData, 'itemType', normalizedType);
            this.normalizeLinkDataForItemType(this.genericEditData, normalizedType);
          }
          this.keywordSuggestionContext = null;
          this.keywordSuggestionField = null;
          this.keywordSuggestionStyle = null;
          this.genericFilterText = '';
          this.genericExpandedSections = {};
          
          debugLog('log', 'Looking for modal element: genericEditModal');
          debugLog('log', 'Looking for modal element: genericEditModal');
          // Open the modal
          const modalElement = document.getElementById('genericEditModal');
          debugLog('log', 'Modal element:', modalElement);
          if (modalElement) {
            debugLog('log', 'Modal element found, creating instance');
            debugLog('log', 'Modal element found, creating Bootstrap instance');
            try {
              const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
              debugLog('log', 'Modal instance:', modalInstance);
              modalInstance.show();

              if (!modalElement.dataset.keywordSuggestionCleanupAttached) {
                modalElement.addEventListener('hidden.bs.modal', () => {
                  this.keywordSuggestionContext = null;
                  this.keywordSuggestionField = null;
                  this.keywordSuggestionStyle = null;
                });
                modalElement.dataset.keywordSuggestionCleanupAttached = '1';
              }
              
              // Ensure focus is set when modal is shown
              modalElement.addEventListener('shown.bs.modal', () => {
                // Prefer explicit autofocus fields, then URL inputs, else first focusable
                const auto = modalElement.querySelector('[data-autofocus="true"]');
                if (auto) { auto.focus(); return; }
                const urlInput = modalElement.querySelector('input[type="url"]');
                if (urlInput) { urlInput.focus(); return; }
                const firstFocusable = modalElement.querySelector('input:not([readonly]), button:not([disabled]), select, textarea');
                if (firstFocusable) { firstFocusable.focus(); }
              }, { once: true });
              
              debugLog('log', 'Modal show called');
              debugLog('log', 'Modal show() called successfully');
            } catch (error) {
              debugLog('error', 'Error creating/showing modal:', error);
              debugLog('error', 'Error creating/showing modal:', error);
            }
          } else {
            debugLog('error', 'Modal element genericEditModal not found!');
            debugLog('error', 'Modal element genericEditModal not found in DOM!');
          }
        },
        
        getDisplayValueForCssField(sectionKey, fieldKey, field) {
          const value = this.getGenericFieldValue(sectionKey, fieldKey);
          if (!value) return '';
          
          try {
            const jsonData = JSON.parse(value);
            // Show a summary of all set properties
            const parts = [];
            if (jsonData.backgroundColor) parts.push(`bg: ${jsonData.backgroundColor}`);
            if (jsonData.color) parts.push(`text: ${jsonData.color}`);
            if (jsonData.border) parts.push(`border: ${jsonData.border}`);
            if (jsonData.fontSize) parts.push(`size: ${jsonData.fontSize}`);
            if (jsonData.fontWeight && jsonData.fontWeight !== 'normal') parts.push(`weight: ${jsonData.fontWeight}`);
            if (jsonData.fontStyle && jsonData.fontStyle !== 'normal') parts.push(jsonData.fontStyle);
            if (jsonData.textDecoration && jsonData.textDecoration !== 'none') parts.push(jsonData.textDecoration);
            if (jsonData.boxShadow) {
              // Shorten shadow description for display
              const shadow = jsonData.boxShadow;
              if (shadow.length > 20) {
                // For long shadows, show abbreviated version
                const shortShadow = shadow.substring(0, 20) + '...';
                parts.push(`shadow: ${shortShadow}`);
              } else {
                parts.push(`shadow: ${shadow}`);
              }
            }
            if (jsonData.opacity && jsonData.opacity < 100) parts.push(`opacity: ${jsonData.opacity}%`);
            if (jsonData.fontFamily) parts.push(`font: ${jsonData.fontFamily}`);
            if (jsonData.borderStyle && jsonData.borderStyle !== 'none') {
              parts.push(`border-style: ${jsonData.borderStyle}`);
            }
            if (jsonData.borderRadius && jsonData.borderRadius > 0) parts.push(`radius: ${jsonData.borderRadius}px`);
            if (jsonData.padding && jsonData.padding > 0) parts.push(`padding: ${jsonData.padding}px`);
            if (jsonData.margin && jsonData.margin > 0) parts.push(`margin: ${jsonData.margin}px`);
            
            // If nothing is set, show placeholder
            if (parts.length === 0) {
              return 'No custom styles';
            }
            
            // Return summary (truncate if too long)
            const summary = parts.join(', ');
            if (summary.length > 60) {
              return summary.substring(0, 57) + '...';
            }
            return summary;
          } catch (e) {
            // Not JSON - could be hex color or CSS string
            if (!value) return '';
            
            // Check if it's a simple hex color
            if (value.match(/^#[0-9A-Fa-f]{3,6}$/)) {
              return `color: ${value}`;
            }
            
            // Check if it's a CSS string with multiple properties
            if (value.includes(':') && value.includes(';')) {
              // Parse CSS string and show summary
              const props = value.split(';').filter(p => p.trim());
              const parts = [];
              props.forEach(prop => {
                const [key, val] = prop.split(':').map(s => s.trim());
                if (key && val) {
                  if (key.includes('background')) parts.push(`bg: ${val}`);
                  else if (key.includes('color')) parts.push(`text: ${val}`);
                  else if (key.includes('border')) parts.push(`border: ${val}`);
                  else if (key.includes('font-size')) parts.push(`size: ${val}`);
                  else if (key.includes('font-weight')) parts.push(`weight: ${val}`);
                  else if (key.includes('shadow')) parts.push('shadow');
                  else parts.push(`${key}: ${val}`);
                }
              });
              const summary = parts.join(', ');
              return summary.length > 60 ? summary.substring(0, 57) + '...' : summary;
            }
            
            // Return as is if we can't parse it
            return value.length > 60 ? value.substring(0, 57) + '...' : value;
          }
        },
        
        isGenericSeparatorEditMode() {
          if (this.genericEditConfig?.type !== 'link') return false;
          return this.isNonUrlLink(this.genericEditData);
        },
        shouldShowGenericField(sectionKey, fieldKey, field) {
          if (this.genericEditConfig?.type !== 'link') return true;
          const itemType = this.normalizeLinkItemType(this.genericEditData);
          if (itemType !== 'separator' && itemType !== 'note') return true;
          const allowedForSeparator = new Set(['itemType', 'text']);
          const allowedForNote = new Set(['itemType', 'text', 'emoji', 'keywords', 'infoHtml']);
          if (field?.type === 'action' || field?.type === 'actions') return true;
          if (itemType === 'separator') return allowedForSeparator.has(fieldKey);
          return allowedForNote.has(fieldKey);
        },
        hasVisibleGenericSectionFields(sectionKey, section) {
          if (!section || !section.fields) return false;
          return Object.entries(section.fields).some(([fieldKey, field]) => this.shouldShowGenericField(sectionKey, fieldKey, field));
        },
        getGenericFieldValue(sectionKey, fieldKey) {
          if (this.genericEditConfig.type === 'options') {
            // For options, navigate the nested structure
            const pathParts = this.genericEditConfig.design[sectionKey].fields[fieldKey].optionPath?.split('.');
            if (pathParts) {
              let value = this.genericEditData;
              for (const part of pathParts) {
                value = value?.[part];
              }
              // Ensure select binding types match option keys
              const optPath = this.genericEditConfig.design[sectionKey].fields[fieldKey].optionPath || '';
              if (optPath === 'bookmarks.rootFolderId') return String(value ?? '0');
              return value;
            }
          }
          // For groups and links, direct access
          return this.genericEditData?.[fieldKey];
        },
        
        onGenericTextInput(sectionKey, fieldKey, event) {
          const value = event?.target?.value ?? '';
          this.setGenericFieldValue(sectionKey, fieldKey, value);
          if (this.isKeywordField(sectionKey, fieldKey)) {
            this.keywordSuggestionField = { section: sectionKey, field: fieldKey };
            this.updateKeywordSuggestionContext(value, event?.target);
          }
        },
        setGenericFieldValue(sectionKey, fieldKey, value) {
          if (this.genericEditConfig.type === 'options') {
            // For options, navigate the nested structure
            const pathParts = this.genericEditConfig.design[sectionKey].fields[fieldKey].optionPath?.split('.');
            if (pathParts) {
              let obj = this.genericEditData;
              for (let i = 0; i < pathParts.length - 1; i++) {
                if (!obj[pathParts[i]]) {
                  this.$set(obj, pathParts[i], {});
                }
                obj = obj[pathParts[i]];
              }
              // Cast value for specific options to preserve type
              const optPath = this.genericEditConfig.design[sectionKey].fields[fieldKey].optionPath || '';
              let finalValue = value;
              if (optPath === 'bookmarks.rootFolderId') finalValue = Number(value || 0);
              this.$set(obj, pathParts[pathParts.length - 1], finalValue);
            }

            // If NC-Bookmarks credentials/URL change during Options editing, refresh folder list
            if (sectionKey === 'bookmarks' && (fieldKey === 'serverUrl' || fieldKey === 'username' || fieldKey === 'password')) {
              clearTimeout(this._ncFolderRefreshTimer);
              this._ncFolderRefreshTimer = setTimeout(async () => {
                try {
                  const bk = (this.genericEditData && this.genericEditData.bookmarks) ? this.genericEditData.bookmarks : (this.data.options?.bookmarks || {});
                  const values = await this.fetchNcFolderValues((bk.serverUrl||'').trim(), bk.username||'', bk.password||'');
                  const current = String(bk.rootFolderId || '0');
                  if (!values[current]) values[current] = current === '0' ? 'All folders' : `Folder #${current}`;
                  this.$set(this.optionsDesign.bookmarks.fields.rootFolderId, 'values', values);
                } catch (e) {
                  debugLog('warn', '[NC] Refresh folder select failed', e);
                }
              }, 500);
            }
          } else {
            // For groups and links, direct access
            if (this.genericEditConfig.type === 'link' && fieldKey === 'itemType') {
              const normalizedType = this.normalizeLinkItemType({ itemType: value, refTargetUuid: this.genericEditData?.refTargetUuid });
              this.$set(this.genericEditData, 'itemType', normalizedType);
              this.normalizeLinkDataForItemType(this.genericEditData, normalizedType);
              return;
            }
            const isShortcutField = fieldKey === 'shortcut';
            const normalizedValue = isShortcutField ? this.normalizeShortcutText(value) : value;
            this.$set(this.genericEditData, fieldKey, normalizedValue);
            if (isShortcutField && value && !normalizedValue) {
              this.showToast(this.getTranslation('link.shortcut.invalid') || 'Please use Ctrl/Alt/Cmd plus a key (e.g. Ctrl+Alt+M).', 'warning');
            }

            // Auto-fetch metadata when URL changes
            if (this.genericEditConfig.type === 'link' && fieldKey === 'url') {
              if (value && !this.isGenericSeparatorEditMode()) {
                // Clear any existing timeout
                if (this.autoFetchTimeout) {
                  clearTimeout(this.autoFetchTimeout);
                }

                // Set a new timeout to fetch after user stops typing
                this.autoFetchTimeout = setTimeout(() => {
                  this.autoFetchLinkMetadata(value);
                }, 800); // Wait 800ms after user stops typing
              }
            }
          }
        },
        getGenericPlaceholderRows(fieldKey = 'urlPlaceholders') {
          if (!this.genericEditData) return [];
          const current = this.genericEditData[fieldKey];
          if (Array.isArray(current)) return current;
          this.$set(this.genericEditData, fieldKey, []);
          return this.genericEditData[fieldKey];
        },
        getGenericInheritedPlaceholderRows(fieldKey = 'urlPlaceholders') {
          if (!this.genericEditData) return [];
          const type = this.genericEditConfig?.type;
          if (type !== 'group' && type !== 'link') return [];
          const inheritedLayers = [this.getGlobalPlaceholderList()];
          if (type === 'link') {
            const parentGroup = (this.data.groups || []).find(g => g.uuid === this.genericEditConfig?.context?.parentGroupUuid) || null;
            inheritedLayers.push(this.getGroupPlaceholderList(parentGroup));
          }
          return this.mergePlaceholderRowsForEditor(inheritedLayers);
        },
        getGenericInheritedPlaceholderMap(fieldKey = 'urlPlaceholders') {
          const map = new Map();
          this.getGenericInheritedPlaceholderRows(fieldKey).forEach((row) => {
            const key = this.placeholderNameKey(row?.name);
            if (!key) return;
            map.set(key, row);
          });
          return map;
        },
        getGenericInheritedPlaceholderEntry(row, fieldKey = 'urlPlaceholders') {
          const key = this.placeholderNameKey(row?.name);
          if (!key) return null;
          return this.getGenericInheritedPlaceholderMap(fieldKey).get(key) || null;
        },
        isGenericInheritedPlaceholderRow(row, fieldKey = 'urlPlaceholders', index = -1) {
          const key = this.placeholderNameKey(row?.name);
          if (!key) return false;
          const inheritedMap = this.getGenericInheritedPlaceholderMap(fieldKey);
          if (!inheritedMap.has(key)) return false;
          const rows = this.getGenericPlaceholderRows(fieldKey);
          const rowIndex = (Number.isInteger(index) && index >= 0) ? index : rows.indexOf(row);
          if (rowIndex < 0) return true;
          const firstMatchingIndex = rows.findIndex(candidate => this.placeholderNameKey(candidate?.name) === key);
          return firstMatchingIndex === rowIndex;
        },
        getGenericInheritedPlaceholderValue(row, fieldKey = 'urlPlaceholders', index = -1) {
          if (!this.isGenericInheritedPlaceholderRow(row, fieldKey, index)) return '';
          const entry = this.getGenericInheritedPlaceholderEntry(row, fieldKey);
          return entry ? String(entry.value || '') : '';
        },
        canRestoreGenericInheritedPlaceholderRow(row, fieldKey = 'urlPlaceholders', index = -1) {
          if (!this.isGenericInheritedPlaceholderRow(row, fieldKey, index)) return false;
          const entry = this.getGenericInheritedPlaceholderEntry(row, fieldKey);
          if (!entry) return false;
          return !!String(row?.value || '').trim() || !!row?.encode;
        },
        restoreGenericInheritedPlaceholderRow(fieldKey = 'urlPlaceholders', index = 0) {
          const rows = this.getGenericPlaceholderRows(fieldKey);
          if (!Array.isArray(rows) || index < 0 || index >= rows.length) return;
          const current = rows[index];
          if (!this.isGenericInheritedPlaceholderRow(current, fieldKey, index)) return;
          const inherited = this.getGenericInheritedPlaceholderEntry(current, fieldKey);
          if (!inherited) return;
          this.$set(current, 'name', inherited.name || current.name || '');
          this.$set(current, 'value', '');
          this.$set(current, 'encode', false);
        },
        addGenericPlaceholderRow(fieldKey = 'urlPlaceholders') {
          const rows = this.getGenericPlaceholderRows(fieldKey);
          rows.push({ name: '', value: '', encode: false });
        },
        removeGenericPlaceholderRow(fieldKey = 'urlPlaceholders', index = 0) {
          const rows = this.getGenericPlaceholderRows(fieldKey);
          if (!Array.isArray(rows) || index < 0 || index >= rows.length) return;
          if (this.isGenericInheritedPlaceholderRow(rows[index], fieldKey, index)) return;
          rows.splice(index, 1);
        },
        getGenericLinkPlaceholderTemplate() {
          if (!this.genericEditData || this.genericEditConfig?.type !== 'link') return '';
          if (this.isGenericSeparatorEditMode()) return '';
          return (typeof this.genericEditData.url === 'string') ? this.genericEditData.url : '';
        },
        previewGenericLinkPlaceholderUrl(fieldKey = 'urlPlaceholders') {
          if (!this.genericEditData || this.genericEditConfig?.type !== 'link') return '';
          if (this.isGenericSeparatorEditMode()) return '';
          const template = this.getGenericLinkPlaceholderTemplate();
          if (!template) return '';
          const globalRows = this.getGlobalPlaceholderList();
          const parentGroup = (this.data.groups || []).find(g => g.uuid === this.genericEditConfig?.context?.parentGroupUuid) || null;
          const groupRows = this.getGroupPlaceholderList(parentGroup);
          const linkRows = this.getLinkPlaceholderList({ urlPlaceholders: this.getGenericPlaceholderRows(fieldKey) });
          const merged = this.mergePlaceholderLayers([globalRows, groupRows, linkRows]);
          const details = this.resolveUrlTemplatePlaceholders(template, merged);
          return details.url || '';
        },
        getGenericLinkPlaceholderUnresolved(fieldKey = 'urlPlaceholders') {
          if (!this.genericEditData || this.genericEditConfig?.type !== 'link') return [];
          if (this.isGenericSeparatorEditMode()) return [];
          const template = this.getGenericLinkPlaceholderTemplate();
          if (!template) return [];
          const globalRows = this.getGlobalPlaceholderList();
          const parentGroup = (this.data.groups || []).find(g => g.uuid === this.genericEditConfig?.context?.parentGroupUuid) || null;
          const groupRows = this.getGroupPlaceholderList(parentGroup);
          const linkRows = this.getLinkPlaceholderList({ urlPlaceholders: this.getGenericPlaceholderRows(fieldKey) });
          const merged = this.mergePlaceholderLayers([globalRows, groupRows, linkRows]);
          const details = this.resolveUrlTemplatePlaceholders(template, merged);
          return details.unresolved || [];
        },
        getGenericShortcutNoticeItems(sectionKey, fieldKey) {
          if (fieldKey !== 'shortcut') return [];
          const notices = [];
          const rawValue = this.getGenericFieldValue(sectionKey, fieldKey) || '';
          const combo = this.normalizeShortcutText(rawValue);
          const globalShortcuts = this.normalizeGlobalShortcutList(this.data?.options?.links?.globalShortcuts || []);

          if (combo) {
            const globalEntry = globalShortcuts.find((entry) => entry.combo === combo);
            if (globalEntry) {
              const urlCount = this.collectUrlsFromShortcutTargets({
                groupIds: globalEntry.groupIds || [],
                linkIds: globalEntry.linkIds || [],
                legacyUrls: globalEntry.urls || []
              }).length;
              const template = this.getTranslation('shortcut.notice.globalDefined') || 'Global shortcut "{combo}" is already defined and opens {count} URL(s).';
              notices.push({
                key: `global-${combo}`,
                className: 'text-warning',
                text: template
                  .replace('{combo}', combo)
                  .replace('{count}', String(urlCount))
              });
            }
          }

          if (this.genericEditConfig?.type === 'group') {
            const groupUuid = String(
              this.genericEditConfig?.context?.groupUuid
              || this.genericEditData?.uuid
              || ''
            ).trim();
            const groupName = String(
              this.genericEditConfig?.context?.groupName
              || this.genericEditData?.name
              || '-'
            );
            if (groupUuid) {
              globalShortcuts.forEach((entry) => {
                const groupIds = this.normalizeShortcutIdList(entry.groupIds || []);
                if (!groupIds.includes(groupUuid)) return;
                const template = this.getTranslation('shortcut.notice.groupInGlobal') || 'Group "{group}" is already part of global shortcut "{combo}".';
                notices.push({
                  key: `group-global-${groupUuid}-${entry.combo}`,
                  className: 'text-info',
                  text: template
                    .replace('{group}', groupName)
                    .replace('{combo}', entry.combo || '')
                });
              });
            }
          }

          if (this.genericEditConfig?.type === 'link') {
            const parentGroupUuid = String(this.genericEditConfig?.context?.parentGroupUuid || '').trim();
            const parentGroupNameFromContext = String(this.genericEditConfig?.context?.parentGroupName || '').trim();
            const linkUuid = String(this.genericEditData?.uuid || '').trim();
            const pushedKeys = new Set();
            if (parentGroupUuid) {
              const parentGroup = (this.data.groups || []).find((group) => String(group?.uuid || '') === parentGroupUuid);
              const parentGroupName = parentGroupNameFromContext || String(parentGroup?.name || '-');
              const groupCombo = this.normalizeShortcutText(parentGroup?.shortcut || '');
              if (groupCombo) {
                const template = this.getTranslation('shortcut.notice.linkInGroupShortcut') || 'Link is already covered by group shortcut "{combo}" (group "{group}").';
                notices.push({
                  key: `group-${parentGroupUuid}-${groupCombo}`,
                  className: 'text-info',
                  text: template
                    .replace('{group}', parentGroupName)
                    .replace('{combo}', groupCombo)
                });
              }

              globalShortcuts.forEach((entry) => {
                const groupIds = this.normalizeShortcutIdList(entry.groupIds || []);
                if (!groupIds.includes(parentGroupUuid)) return;
                const key = `link-global-group-${parentGroupUuid}-${entry.combo}`;
                if (pushedKeys.has(key)) return;
                pushedKeys.add(key);
                const template = this.getTranslation('shortcut.notice.linkInGlobalViaGroup') || 'Link is already included in global shortcut "{combo}" via group "{group}".';
                notices.push({
                  key,
                  className: 'text-info',
                  text: template
                    .replace('{group}', parentGroupName)
                    .replace('{combo}', entry.combo || '')
                });
              });
            }

            if (linkUuid) {
              globalShortcuts.forEach((entry) => {
                const linkIds = this.normalizeShortcutIdList(entry.linkIds || []);
                if (!linkIds.includes(linkUuid)) return;
                const key = `link-global-direct-${linkUuid}-${entry.combo}`;
                if (pushedKeys.has(key)) return;
                pushedKeys.add(key);
                const template = this.getTranslation('shortcut.notice.linkInGlobalDirect') || 'Link is already selected in global shortcut "{combo}".';
                notices.push({
                  key,
                  className: 'text-info',
                  text: template
                    .replace('{combo}', entry.combo || '')
                });
              });
            }
          }

          return notices;
        },
        isKeywordField(sectionKey, fieldKey) {
          return ['link', 'group'].includes(this.genericEditConfig?.type) && fieldKey === 'keywords';
        },
        isKeywordSuggestionField(sectionKey, fieldKey) {
          return this.keywordSuggestionField &&
                 this.keywordSuggestionField.section === sectionKey &&
                 this.keywordSuggestionField.field === fieldKey;
        },
        handleKeywordTab(sectionKey, fieldKey, event) {
          if (!this.isKeywordField(sectionKey, fieldKey)) return;
          if (event.shiftKey) return;
          const input = event.target;
          if (!input) return;
          const value = input.value || '';
          const selectionStart = input.selectionStart;
          const selectionEnd = input.selectionEnd;
          const context = this.extractKeywordContext(value, selectionStart, selectionEnd);
          if (!context) return;

          this.keywordSuggestionContext = context;
          this.keywordSuggestionField = { section: sectionKey, field: fieldKey };
          const candidates = this.keywordSuggestionList || [];
          if (!candidates.length) return;

          const searchTerm = (context.searchTerm || '').toLowerCase();
          if (!searchTerm) return;

          const currentTokenLower = (context.currentToken || '').toLowerCase();
          let suggestion = candidates.find(item => {
            const label = (item.label || item.value || '').toString();
            const labelLower = label.toLowerCase();
            return labelLower.startsWith(searchTerm) && labelLower !== currentTokenLower;
          });
          if (!suggestion) {
            suggestion = candidates.find(item => {
              const label = (item.label || item.value || '').toString();
              return label.toLowerCase().startsWith(searchTerm);
            });
          }
          if (!suggestion) return;
          const suggestionLabel = (suggestion.label || suggestion.value || '').toString();
          if (suggestionLabel.toLowerCase() === currentTokenLower) return;

          event.preventDefault();
          this.applyKeywordSuggestion(sectionKey, fieldKey, suggestion);
        },
        maybeUpdateKeywordContext(sectionKey, fieldKey, event) {
          if (!this.isKeywordField(sectionKey, fieldKey)) {
            if (this.isKeywordSuggestionField(sectionKey, fieldKey)) {
              this.keywordSuggestionField = null;
              this.keywordSuggestionContext = null;
              this.keywordSuggestionStyle = null;
            }
            return;
          }
          const input = event?.target;
          if (!input) return;
          this.keywordSuggestionField = { section: sectionKey, field: fieldKey };
          this.updateKeywordSuggestionContext(input.value, input);
        },
        clearKeywordContext(sectionKey, fieldKey) {
          if (!this.isKeywordField(sectionKey, fieldKey)) return;
          if (this.isKeywordSuggestionField(sectionKey, fieldKey)) {
            this.keywordSuggestionContext = null;
            this.keywordSuggestionField = null;
            this.keywordSuggestionStyle = null;
          }
        },
        handleKeywordSuggestionViewportChange() {
          if (!this.shouldShowKeywordSuggestions && !this.shouldShowQuickKeywordSuggestions) return;
          this.$nextTick(() => {
            if (this.shouldShowKeywordSuggestions) {
              this.updateKeywordSuggestionPosition();
            }
            if (this.shouldShowQuickKeywordSuggestions) {
              this.updateQuickKeywordSuggestionPosition();
            }
          });
        },
        updateKeywordSuggestionPosition(inputEl = null) {
          if (!this.shouldShowKeywordSuggestions) {
            this.keywordSuggestionStyle = null;
            return;
          }

          let input = inputEl;
          if (!input) {
            const section = this.keywordSuggestionField?.section;
            const field = this.keywordSuggestionField?.field;
            if (section && field) {
              const selector = `input.mb-edit-text-input[data-section="${section}"][data-field="${field}"]`;
              const modalElement = document.getElementById('genericEditModal');
              if (modalElement) input = modalElement.querySelector(selector);
            }
          }
          if (!input || typeof input.getBoundingClientRect !== 'function') {
            this.keywordSuggestionStyle = null;
            return;
          }

          const rect = input.getBoundingClientRect();
          if (!rect || rect.width <= 0) {
            this.keywordSuggestionStyle = null;
            return;
          }

          const viewportPadding = 8;
          const minHeight = 80;
          const maxHeight = 220;
          const minWidth = 180;

          let width = Math.max(minWidth, rect.width);
          if (width > window.innerWidth - (viewportPadding * 2)) {
            width = Math.max(minWidth, window.innerWidth - (viewportPadding * 2));
          }

          let left = rect.left;
          if (left + width > window.innerWidth - viewportPadding) {
            left = window.innerWidth - viewportPadding - width;
          }
          left = Math.max(viewportPadding, left);

          const preferredTop = rect.bottom + 4;
          const spaceBelow = window.innerHeight - preferredTop - viewportPadding;
          const spaceAbove = rect.top - viewportPadding - 4;
          const placeAbove = spaceBelow < 120 && spaceAbove > spaceBelow;
          const availableHeight = placeAbove ? spaceAbove : spaceBelow;
          const dropdownHeight = Math.max(minHeight, Math.min(maxHeight, availableHeight));
          const top = placeAbove
            ? Math.max(viewportPadding, rect.top - dropdownHeight - 4)
            : preferredTop;

          this.keywordSuggestionStyle = {
            left: `${Math.round(left)}px`,
            top: `${Math.round(top)}px`,
            width: `${Math.round(width)}px`,
            maxHeight: `${Math.round(dropdownHeight)}px`
          };
        },
        updateQuickKeywordSuggestionPosition(inputEl = null) {
          if (!this.shouldShowQuickKeywordSuggestions) {
            this.quickKeywordSuggestionStyle = null;
            return;
          }

          const input = inputEl || this.$refs.keywordQuickInput;
          if (!input || typeof input.getBoundingClientRect !== 'function') {
            this.quickKeywordSuggestionStyle = null;
            return;
          }

          const rect = input.getBoundingClientRect();
          if (!rect || rect.width <= 0) {
            this.quickKeywordSuggestionStyle = null;
            return;
          }

          const viewportPadding = 8;
          const minHeight = 80;
          const maxHeight = 220;
          const minWidth = 180;

          let width = Math.max(minWidth, rect.width);
          if (width > window.innerWidth - (viewportPadding * 2)) {
            width = Math.max(minWidth, window.innerWidth - (viewportPadding * 2));
          }

          let left = rect.left;
          if (left + width > window.innerWidth - viewportPadding) {
            left = window.innerWidth - viewportPadding - width;
          }
          left = Math.max(viewportPadding, left);

          const preferredTop = rect.bottom + 4;
          const spaceBelow = window.innerHeight - preferredTop - viewportPadding;
          const spaceAbove = rect.top - viewportPadding - 4;
          const placeAbove = spaceBelow < 120 && spaceAbove > spaceBelow;
          const availableHeight = placeAbove ? spaceAbove : spaceBelow;
          const dropdownHeight = Math.max(minHeight, Math.min(maxHeight, availableHeight));
          const top = placeAbove
            ? Math.max(viewportPadding, rect.top - dropdownHeight - 4)
            : preferredTop;

          this.quickKeywordSuggestionStyle = {
            left: `${Math.round(left)}px`,
            top: `${Math.round(top)}px`,
            width: `${Math.round(width)}px`,
            maxHeight: `${Math.round(dropdownHeight)}px`
          };
        },
        applyKeywordSuggestion(sectionKey, fieldKey, suggestion) {
          if (!this.isKeywordField(sectionKey, fieldKey) || !suggestion) return;
          const suggestionLabel = (suggestion.label || suggestion.value || '').toString();
          const suggestionValue = (suggestion.value != null ? suggestion.value : suggestionLabel).toString();
          if (!suggestionValue) return;
          this.setGenericFieldValue(sectionKey, fieldKey, suggestionValue);
          this.$nextTick(() => {
            const selector = `input.mb-edit-text-input[data-section="${sectionKey}"][data-field="${fieldKey}"]`;
            let input = document.activeElement && typeof document.activeElement.matches === 'function' && document.activeElement.matches(selector)
              ? document.activeElement
              : null;
            if (!input) {
              const modalElement = document.getElementById('genericEditModal');
              if (modalElement) {
                input = modalElement.querySelector(selector);
              }
            }
            if (input && input.value !== suggestionValue) {
              input.value = suggestionValue;
            }
            const cursor = typeof suggestion.cursor === 'number' ? suggestion.cursor : suggestionValue.length;
            if (input && typeof input.setSelectionRange === 'function') {
              try { input.setSelectionRange(cursor, cursor); } catch {}
            }
            this.keywordSuggestionContext = null;
            this.keywordSuggestionField = null;
            this.keywordSuggestionStyle = null;
          });
        },
        updateKeywordSuggestionContext(value, inputEl = null) {
          if (!['link', 'group'].includes(this.genericEditConfig?.type)) {
            this.keywordSuggestionContext = null;
            this.keywordSuggestionField = null;
            this.keywordSuggestionStyle = null;
            return;
          }
          const stringValue = value != null ? String(value) : '';
          const selectionStart = inputEl?.selectionStart ?? stringValue.length;
          const selectionEnd = inputEl?.selectionEnd ?? selectionStart;
          const context = this.extractKeywordContext(stringValue, selectionStart, selectionEnd);
          this.keywordSuggestionContext = context;
          if (!context) {
            this.keywordSuggestionField = null;
            this.keywordSuggestionStyle = null;
            return;
          }
          this.$nextTick(() => {
            this.updateKeywordSuggestionPosition(inputEl);
          });
        },
        extractKeywordContext(rawValue, selectionStart, selectionEnd = selectionStart) {
          const value = typeof rawValue === 'string' ? rawValue : (rawValue ?? '').toString();
          if (selectionStart == null) selectionStart = value.length;
          if (selectionEnd == null) selectionEnd = selectionStart;
          if (selectionStart !== selectionEnd) return null;
          const cursor = Math.max(0, Math.min(selectionStart, value.length));

          const lastComma = value.lastIndexOf(',', cursor - 1);
          const lastSemicolon = value.lastIndexOf(';', cursor - 1);
          let tokenStartRaw = Math.max(lastComma, lastSemicolon);
          tokenStartRaw = tokenStartRaw === -1 ? 0 : tokenStartRaw + 1;

          const nextCommaIndex = value.indexOf(',', cursor);
          const nextSemicolonIndex = value.indexOf(';', cursor);
          let tokenEndRaw = value.length;
          if (nextCommaIndex !== -1) tokenEndRaw = Math.min(tokenEndRaw, nextCommaIndex);
          if (nextSemicolonIndex !== -1) tokenEndRaw = Math.min(tokenEndRaw, nextSemicolonIndex);

          const rawSegment = value.slice(tokenStartRaw, tokenEndRaw);
          const leadingSpaces = rawSegment.match(/^\s*/)?.[0].length || 0;
          const trailingSpaces = rawSegment.match(/\s*$/)?.[0].length || 0;
          const tokenStart = tokenStartRaw + leadingSpaces;
          let tokenEnd = tokenEndRaw - trailingSpaces;
          if (tokenEnd < tokenStart) tokenEnd = tokenStart;

          if (cursor < tokenStart || cursor > tokenEnd) return null;

          const prefix = value.slice(0, tokenStart);
          const suffix = value.slice(tokenEnd);
          const currentToken = value.slice(tokenStart, tokenEnd);
          const partialBeforeCursor = value.slice(tokenStart, cursor);
          const searchTerm = partialBeforeCursor.trim().toLowerCase();

          return {
            prefix,
            suffix,
            currentToken,
            searchTerm,
            cursor
          };
        },

        async autoFetchLinkMetadata(url) {
          if (this.isGenericSeparatorEditMode()) return;
          // Normalize URL
          url = MB.Utils.ensureProtocol(url);
          if (!MB.Utils.isValidHttpUrl(url)) {
            debugLog('log', 'Not a valid HTTP URL yet:', url);
            return;
          }

          // Additional validation: Check if domain looks complete
          try {
            const urlObj = new URL(url);
            const hostname = urlObj.hostname;

            // Check if hostname has at least a TLD (e.g., "example.com", not just "example")
            if (!hostname.includes('.') || hostname.endsWith('.')) {
              debugLog('log', 'Domain not complete yet:', hostname);
              return;
            }

            // Check for very short domains that are likely incomplete
            const parts = hostname.split('.');
            const tld = parts[parts.length - 1];
            if (tld.length < 2) {
              debugLog('log', 'TLD too short, likely incomplete:', tld);
              return;
            }

            // Don't fetch for localhost or IP addresses during typing
            if (hostname === 'localhost' || /^\d{1,3}(\.\d{1,3}){0,3}$/.test(hostname)) {
              debugLog('log', 'Skipping auto-fetch for localhost/IP:', hostname);
              return;
            }
          } catch (e) {
            debugLog('log', 'URL parsing failed, not ready:', e.message);
            return;
          }

          // Always resolve and preview matching favicon rules in the editor.
          // Extension/network fetch remains optional and is handled below.
          try {
            const rawInput = (this.genericEditData?.url || '').trim();
            this.applyFaviconRulesToLink(this.genericEditData, null, rawInput || url);
          } catch (e) {
            debugLog('warn', '[FaviconRules] generic preview apply failed', e);
          }

          // Check if extension is available before trying to fetch
          if (!this.extensionAvailable || !window.MyBookmarksExtension) {
            debugLog('warn', 'Auto-fetch requested but extension not available');
            return;
          }

          debugLog('log', 'Auto-fetching metadata for URL:', url);

          // Set loading state for favicon
          this.$set(this.genericEditData, 'faviconLoading', true);

          // Auto-fetch title if enabled and text is empty or same as URL
          if (this.data.options?.links?.autoFetchTitle) {
            const currentText = this.genericEditData.text || '';
            // Also check if text is just "h" or similar single character (from premature fetch)
            if (!currentText || currentText === url || currentText === url.replace(/^https?:\/\//, '') || currentText.length === 1) {
              debugLog('log', 'Fetching title for URL:', url);
              try {
                const title = await this.tryFetchTitle(url);
                if (title && title !== url) {
                  debugLog('log', 'Auto-fetched title:', title);
                  this.$set(this.genericEditData, 'text', title);
                }
              } catch (e) {
                debugLog('warn', 'Title fetch failed:', e);
              }
            }
          }

          // Auto-fetch favicon if enabled
          if (this.data.options?.links?.autoFetchFavicon) {
            debugLog('log', 'Fetching favicon for URL:', url);
            try {
              await this.tryFetchAndSetFavicon(this.genericEditData, url);
            } catch (e) {
              debugLog('warn', 'Favicon fetch failed:', e);
            }
          }

          // Clear loading state
          this.$set(this.genericEditData, 'faviconLoading', false);
        },
        
        getFilteredGenericSettings() {
          if (!this.genericFilterText) {
            return this.genericEditConfig.design;
          }
          
          const filter = this.genericFilterText.toLowerCase();
          const filtered = {};
          
          for (const [sectionKey, section] of Object.entries(this.genericEditConfig.design)) {
            const sectionLabel = this.getTranslation(section.translateKey) || sectionKey;
            
            // Check if section matches
            if (sectionLabel.toLowerCase().includes(filter)) {
              filtered[sectionKey] = section;
              continue;
            }
            
            // Check if any field matches
            const matchingFields = {};
            for (const [fieldKey, field] of Object.entries(section.fields)) {
              const fieldLabel = this.getTranslation(field.translateKey) || fieldKey;
              const helpText = this.getTranslation(field.helpText) || '';
              
              if (fieldLabel.toLowerCase().includes(filter) || 
                  helpText.toLowerCase().includes(filter)) {
                matchingFields[fieldKey] = field;
              }
            }
            
            if (Object.keys(matchingFields).length > 0) {
              filtered[sectionKey] = {
                ...section,
                fields: matchingFields
              };
            }
          }
          
          return filtered;
        },
        
        isGenericSectionExpanded(sectionKey) {
          // Auto-expand if filtering
          if (this.genericFilterText) return true;
          return this.genericExpandedSections[sectionKey] !== false;
        },
        
        toggleGenericSection(sectionKey) {
          this.$set(this.genericExpandedSections, sectionKey, !this.isGenericSectionExpanded(sectionKey));
        },
        focusGenericEditSection(sectionKey, design = null) {
          const sourceDesign = design || this.genericEditConfig?.design || {};
          const keys = Object.keys(sourceDesign || {});
          if (!sectionKey || !keys.length || !keys.includes(sectionKey)) return;
          const expanded = {};
          keys.forEach((key) => {
            expanded[key] = key === sectionKey;
          });
          this.genericExpandedSections = expanded;
        },
        
        saveGenericEditDialog() {
          const type = this.genericEditConfig?.type;
          if (type === 'group') {
            const name = (this.genericEditData?.name || '').trim();
            if (!name) {
              this.showToast(this.getTranslation('group.name.required') || 'Group name is required', 'warning');
              return;
            }
            this.$set(this.genericEditData, 'name', name);
            this.$set(this.genericEditData, 'urlPlaceholders', this.normalizePlaceholderList(this.genericEditData?.urlPlaceholders || []));
          } else if (type === 'link') {
            const itemType = this.normalizeLinkItemType(this.genericEditData);
            this.$set(this.genericEditData, 'itemType', itemType);
            const text = (this.genericEditData?.text || '').trim();
            if (itemType !== 'separator' && !text) {
              this.showToast(this.getTranslation('link.text.required') || 'Link text is required', 'warning');
              return;
            }
            this.$set(this.genericEditData, 'text', text);
            this.normalizeLinkDataForItemType(this.genericEditData, itemType);
          }

          if (this.genericEditConfig.saveCallback) {
            this.genericEditConfig.saveCallback(this.genericEditData);
          }
          
          // Close the modal
          const modalElement = document.getElementById('genericEditModal');
          if (modalElement) {
            const modalInstance = bootstrap.Modal.getInstance(modalElement);
            if (modalInstance) {
              modalInstance.hide();
            }
          }
        },
        
        handleGenericAction(sectionKey, fieldKey) {
          try {
            if (sectionKey === 'bookmarks' && fieldKey === 'resetBindings') {
              this.resetSyncBindingsFromOptions();
              return;
            } else if (sectionKey === 'bookmarks' && fieldKey === 'testConnection') {
              // Run generic connection test (uses selected backend adapter)
              this.testConnectionGeneric();
              return;
            } else if (sectionKey === 'links' && fieldKey === 'faviconRulesManage') {
              this.openFaviconRulesModal();
              return;
            }
            debugLog('warn', '[OPTIONS] Unknown action', { sectionKey, fieldKey });
          } catch (e) {
            debugLog('error', '[OPTIONS] handleGenericAction failed', { sectionKey, fieldKey, error: e });
          }
        },
        openFaviconRulesModal() {
          // Ensure structure exists
          if (!this.data.options) this.$set(this, 'data', { options: {} });
          if (!this.data.options.links) this.$set(this.data.options, 'links', {});
          if (!Array.isArray(this.data.options.links.faviconRules)) this.$set(this.data.options.links, 'faviconRules', []);
          this.faviconRulesWorking = JSON.parse(JSON.stringify(this.data.options.links.faviconRules));
          this.faviconRulesWorking.forEach((rule, idx) => {
            if (rule.comment === undefined) {
              this.$set(this.faviconRulesWorking[idx], 'comment', '');
            }
          });
          this.faviconRulesTestUrl = '';
          const modalEl = document.getElementById('faviconRulesModal');
          if (modalEl && !modalEl.dataset.refreshListenerAttached) {
            modalEl.addEventListener('hidden.bs.modal', () => {
              try {
                this.onFaviconRulesClosed();
              } catch (err) {
                debugLog('warn', '[FaviconRules] hidden handler failed', err);
              }
            });
            modalEl.dataset.refreshListenerAttached = '1';
          }
          const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
          modal && modal.show();
        },
        addFaviconRule() {
          const rule = {
            id: this.generateUUID ? this.generateUUID() : `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
            enabled: true,
            patternType: 'domain',
            pattern: '',
            iconDataUrl: '',
            comment: '',
            createdAt: Date.now()
          };
          this.faviconRulesWorking.push(rule);
        },
        restoreDefaultFaviconRules() {
          if (!Array.isArray(this.faviconRulesWorking)) {
            this.$set(this, 'faviconRulesWorking', []);
          }
          const defaults = getDefaultFaviconRules();
          const existingKeys = new Set(
            (this.faviconRulesWorking || []).map(rule => `${(rule.patternType || 'domain')}__${(rule.pattern || '').trim().toLowerCase()}`)
          );
          let added = 0;
          defaults.forEach((rule, idx) => {
            const key = `${rule.patternType || 'domain'}__${(rule.pattern || '').trim().toLowerCase()}`;
            if (!existingKeys.has(key)) {
              const newRule = Object.assign({}, rule, { createdAt: Date.now() + idx });
              this.faviconRulesWorking.push(newRule);
              existingKeys.add(key);
              added++;
            }
          });
          if (added) {
            this.showToast(this.getTranslation('favicon.rules.defaultsRestored') || 'Default favicon rules restored', 'success');
          } else {
            this.showToast(this.getTranslation('favicon.rules.defaultsAlreadyPresent') || 'All default favicon rules are already present', 'info');
          }
        },
        exportFaviconRules() {
          try {
            const data = JSON.stringify(this.faviconRulesWorking || [], null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = url;
            a.download = `favicon-rules-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          } catch (error) {
            debugLog('error', '[FaviconRules] export failed', error);
            this.showToast(this.getTranslation('favicon.rules.exportError') || 'Failed to export favicon rules', 'error');
          }
        },
        estimateFaviconPayloadSize(iconDataUrl) {
          const src = (typeof iconDataUrl === 'string') ? iconDataUrl.trim() : '';
          if (!src) return 0;
          const commaIdx = src.indexOf(',');
          if (commaIdx === -1) return src.length;

          const meta = src.slice(0, commaIdx).toLowerCase();
          const payload = src.slice(commaIdx + 1).trim();
          if (!payload) return 0;

          if (meta.includes(';base64')) {
            const normalized = payload.replace(/\s+/g, '');
            const padding = normalized.endsWith('==') ? 2 : (normalized.endsWith('=') ? 1 : 0);
            return Math.max(0, Math.floor((normalized.length * 3) / 4) - padding);
          }

          try {
            return decodeURIComponent(payload).length;
          } catch {
            return payload.length;
          }
        },
        isFaviconPayloadWithinLimit(iconDataUrl, maxBytes = 256 * 1024) {
          return this.estimateFaviconPayloadSize(iconDataUrl) <= maxBytes;
        },
        onImportFaviconRules(event) {
          const input = event?.target;
          const file = input?.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const text = typeof reader.result === 'string' ? reader.result : '';
              const parsed = JSON.parse(text);
              if (!Array.isArray(parsed)) {
                throw new Error('Invalid format');
              }

              if (!Array.isArray(this.faviconRulesWorking)) {
                this.$set(this, 'faviconRulesWorking', []);
              }

              const validTypes = ['domain', 'prefix', 'regex'];
              const existingKeys = new Set(
                (this.faviconRulesWorking || []).map(rule => `${(rule.patternType || 'domain')}__${(rule.pattern || '').trim().toLowerCase()}`)
              );
              let added = 0;
              let skippedTooLarge = 0;
              parsed.forEach((rule, idx) => {
                if (!rule || typeof rule !== 'object') return;
                const pattern = (rule.pattern || '').toString().trim();
                if (!pattern) return;
                const typeRaw = (rule.patternType || 'domain').toString().toLowerCase();
                const patternType = validTypes.includes(typeRaw) ? typeRaw : 'domain';
                const key = `${patternType}__${pattern.toLowerCase()}`;
                if (existingKeys.has(key)) return;

                const iconDataUrlRaw = typeof rule.iconDataUrl === 'string' ? rule.iconDataUrl.trim() : '';
                if (iconDataUrlRaw && !this.isFaviconPayloadWithinLimit(iconDataUrlRaw)) {
                  skippedTooLarge++;
                  return;
                }

                const normalized = {
                  id: rule.id || (this.generateUUID ? this.generateUUID() : `${Date.now()}-${idx}-${Math.random().toString(36).slice(2, 8)}`),
                  enabled: rule.enabled !== false,
                  patternType,
                  pattern,
                  iconDataUrl: iconDataUrlRaw,
                  comment: typeof rule.comment === 'string' ? rule.comment : '',
                  createdAt: Number(rule.createdAt) || Date.now() + idx
                };

                this.faviconRulesWorking.push(normalized);
                existingKeys.add(key);
                added++;
              });

              if (added) {
                const messageTemplate = this.getTranslation('favicon.rules.importSuccess') || 'Imported {count} favicon rules';
                this.showToast(messageTemplate.replace('{count}', added), 'success');
              } else {
                this.showToast(this.getTranslation('favicon.rules.importNothing') || 'No new favicon rules to import', 'info');
              }
              if (skippedTooLarge > 0) {
                const tooLargeMsg = this.getTranslation('link.favicon.tooLarge') || 'Image is too large (max 256KB)';
                this.showToast(`${skippedTooLarge} imported favicon rule(s) skipped: ${tooLargeMsg}`, 'warning');
              }
            } catch (error) {
              debugLog('error', '[FaviconRules] import failed', error);
              this.showToast(this.getTranslation('favicon.rules.importError') || 'Failed to import favicon rules', 'error');
            } finally {
              try { input.value = ''; } catch {}
            }
          };
          reader.onerror = () => {
            debugLog('error', '[FaviconRules] import read error');
            this.showToast(this.getTranslation('favicon.rules.importError') || 'Failed to import favicon rules', 'error');
            try { input.value = ''; } catch {}
          };
          reader.readAsText(file);
        },
        openFaviconRuleFile(idx) {
          // When using ref inside v-for, Vue returns an array of elements
          const r = this.$refs && this.$refs.frFile;
          if (Array.isArray(r)) {
            const el = r[idx];
            if (el && typeof el.click === 'function') el.click();
          } else if (r && typeof r.click === 'function') {
            r.click();
          }
        },
        deleteFaviconRule(idx) {
          this.faviconRulesWorking.splice(idx, 1);
        },
        async autoFetchRuleIcon(rule) {
          try {
            if (!rule || !rule.pattern) return;
            let sampleUrl = '';
            const raw = (rule.pattern || '').trim();
            if (rule.patternType === 'domain') {
              // Strip any protocol, slashes and wildcard prefixes, keep only hostname
              let host = raw.replace(/^https?:\/\//i, '').replace(/^\/{2}/, '');
              host = host.replace(/^\*\.?/, '');
              host = host.replace(/\/.*$/, '');
              if (!host) return;
              sampleUrl = `https://${host}`;
            } else if (rule.patternType === 'prefix') {
              sampleUrl = MB.Utils.ensureProtocol(raw);
            } else {
              // regex: use test URL if provided, else fallback
              sampleUrl = this.faviconRulesTestUrl ? MB.Utils.ensureProtocol(this.faviconRulesTestUrl) : 'https://example.com';
            }
            if (!this.extensionAvailable || !window.MyBookmarksExtension) {
              this.showToast(this.getTranslation('favicon.rules.needsExtension') || 'Extension required to auto-fetch icons', 'warning');
              return;
            }
            const md = await window.MyBookmarksExtension.fetchMetadata(sampleUrl, {});
            if (md && md.favicon) {
              rule.iconDataUrl = md.favicon;
              this.showToast(this.getTranslation('link.favicon.uploaded') || 'Favicon uploaded', 'success');
            } else {
              this.showToast('No favicon found', 'warning');
            }
          } catch (e) {
            this.showToast(e?.message || 'Auto-fetch failed', 'error');
          }
        },
        onFaviconRuleFileSelected(idx, event) {
          const file = event?.target?.files?.[0];
          if (!file) return;
          if (!file.type || !file.type.startsWith('image/')) { this.showToast(this.getTranslation('link.favicon.invalidFile') || 'Please select an image file', 'warning'); event.target.value=''; return; }
          if (file.size > 256 * 1024) { this.showToast(this.getTranslation('link.favicon.tooLarge') || 'Image is too large (max 256KB)', 'warning'); event.target.value=''; return; }
          const reader = new FileReader();
          reader.onload = () => {
            const dataUrl = reader.result;
            if (typeof dataUrl === 'string') {
              this.$set(this.faviconRulesWorking[idx], 'iconDataUrl', dataUrl);
              this.showToast(this.getTranslation('link.favicon.uploaded') || 'Favicon uploaded', 'success');
            }
            try { event.target.value=''; } catch{}
          };
          reader.onerror = () => { this.showToast(this.getTranslation('link.favicon.readError') || 'Could not read image file', 'error'); };
          reader.readAsDataURL(file);
        },
        faviconSourceClass(link) {
          const s = (link && link.faviconSource) || '';
          if (s === 'rule') return 'src-rule';
          if (s === 'upload') return 'src-upload';
          if (s === 'extension') return 'src-extension';
          return '';
        },
        faviconSourceTooltip(link) {
          try {
            if (!link || !link.favicon) return '';
            const s = link.faviconSource || '';
            if (s === 'upload') return 'Favicon (upload)';
            if (s === 'extension') return 'Favicon (extension)';
            if (s === 'rule') {
              const rules = this.data.options?.links?.faviconRules || [];
              const r = rules.find(x => x.id === link.faviconRuleId);
              if (r) return `Favicon (rule: ${r.patternType} ${r.pattern})`;
              return 'Favicon (rule)';
            }
            return '';
          } catch { return ''; }
        },
        saveFaviconRules() {
          if (!this.data.options) this.$set(this, 'data', { options: {} });
          if (!this.data.options.links) this.$set(this.data.options, 'links', {});
          this.$set(this.data.options.links, 'faviconRules', JSON.parse(JSON.stringify(this.faviconRulesWorking)));
          this.saveData();
          this.showToast(this.getTranslation('favicon.rules.saved') || 'Favicon rules saved', 'success');
          this.refreshVisibleFavicons();
          // Close the modal after saving
          try {
            const modalEl = document.getElementById('faviconRulesModal');
            const modal = modalEl ? bootstrap.Modal.getInstance(modalEl) : null;
            if (modal) modal.hide();
          } catch {}
        },
        findRuleForUrl(url, rulesOverride = null, rawInput = null) {
          try {
            if (!url && !rawInput) return null;
            const sourceRules = Array.isArray(rulesOverride) ? rulesOverride : (this.data.options?.links?.faviconRules || []);
            const rules = sourceRules.filter(r => r && r.enabled && r.iconDataUrl);
            if (!rules.length) return null;

            const normalizedSource = (url || '').trim();
            const normalizedCandidate = MB.Utils.ensureProtocol(normalizedSource);
            const normalizedLower = normalizedCandidate ? normalizedCandidate.toLowerCase() : '';

            const rawFallbackValue = rawInput != null ? rawInput : null;
            const rawFallback = rawFallbackValue != null ? String(rawFallbackValue) : normalizedSource;
            const rawTrimmed = (rawFallback || '').trim();
            const rawLower = rawTrimmed.toLowerCase();

            const candidateStrings = [];
            const addCandidate = (val) => {
              if (!val || typeof val !== 'string') return;
              const v = val.trim();
              if (!v) return;
              if (!candidateStrings.includes(v)) candidateStrings.push(v);
            };

            addCandidate(normalizedCandidate);
            addCandidate(normalizedLower);
            addCandidate(normalizedSource);
            addCandidate(normalizedSource.toLowerCase());
            addCandidate(rawTrimmed);
            addCandidate(rawLower);
            if (rawLower.includes('\\')) addCandidate(rawLower.replace(/\\+/g, '/'));
            if (normalizedLower.includes('\\')) addCandidate(normalizedLower.replace(/\\+/g, '/'));

            const configuredPrefix = (this.data?.options?.links?.defaultUrlPrefix ?? CONSTS.DEFAULT_URL_PREFIX) || '';
            const prefixStripList = Array.from(new Set([
              typeof configuredPrefix === 'string' ? configuredPrefix.trim().toLowerCase() : '',
              'http://',
              'https://'
            ].filter(Boolean)));
            const existingCandidates = candidateStrings.slice();
            prefixStripList.forEach(pref => {
              existingCandidates.forEach(candidate => {
                if (candidate.toLowerCase().startsWith(pref)) {
                  addCandidate(candidate.slice(pref.length));
                }
              });
            });
            candidateStrings.slice().forEach(candidate => {
              if (candidate.startsWith('//')) addCandidate(candidate.slice(2));
            });

            let host = '';
            let parsedUrl = null;
            if (normalizedCandidate) {
              try {
                parsedUrl = new URL(normalizedCandidate);
                host = parsedUrl.hostname.toLowerCase();
              } catch {
                parsedUrl = null;
                host = '';
              }
            }
            let best = null; let bestLen = -1;
            for (const r of rules) {
              const patternRaw = (r.pattern || '').toString().trim();
              if (!patternRaw) continue;
              if (r.patternType === 'domain') {
                const patRaw = patternRaw.toLowerCase();
                // Normalize: strip scheme, //, wildcard, and path
                let pat = patRaw
                  .replace(/^https?:\/\//, '')
                  .replace(/^\/\//, '')
                  .replace(/^\*\.?/, '')
                  .replace(/\/.*$/, '')
                  .replace(/\.+$/, '');
                if (!pat) continue;
                if (host && (host === pat || host.endsWith('.' + pat))) {
                  const len = pat.length; if (len > bestLen) { best = r; bestLen = len; }
                }
              } else if (r.patternType === 'prefix') {
                const patRaw = patternRaw.toLowerCase();
                const trimSlash = (s) => s.replace(/\/+$/, '');
                const patternVariants = [];
                const addPatternVariant = (val) => {
                  if (!val) return;
                  const v = trimSlash(val.toLowerCase());
                  if (!v) return;
                  if (!patternVariants.includes(v)) patternVariants.push(v);
                };
                addPatternVariant(patRaw);
                addPatternVariant(patRaw.replace(/^[a-z]+:\/\//, ''));
                addPatternVariant(MB.Utils.ensureProtocol(patternRaw).toLowerCase());
                const matchedVariant = patternVariants.reduce((bestLocalLen, patt) => {
                  const len = patt.length;
                  if (!len) return bestLocalLen;
                  const found = candidateStrings.some(candidate => {
                    const target = trimSlash(candidate.toLowerCase());
                    return target.startsWith(patt);
                  });
                  return found ? Math.max(bestLocalLen, len) : bestLocalLen;
                }, -1);
                if (matchedVariant > bestLen) { best = r; bestLen = matchedVariant; }
              } else if (r.patternType === 'regex') {
                try {
                  // Be forgiving: unescape \/ to /
                  let rxSrc = patternRaw.replace(/\\\//g, '/');
                  const re = new RegExp(rxSrc, 'i');
                  const matched = candidateStrings.some(candidate => {
                    try { return re.test(candidate); } finally { re.lastIndex = 0; }
                  });
                  if (matched) {
                    const len = rxSrc.length;
                    if (len > bestLen) { best = r; bestLen = len; }
                  }
                } catch {}
              }
            }
            return best;
          } catch { return null; }
        },
        findRuleIconForUrl(url, rulesOverride = null, rawInput = null) {
          const r = this.findRuleForUrl(url, rulesOverride, rawInput);
          return r ? r.iconDataUrl : null;
        },

        getEnabledFaviconRules() {
          const rules = this.data?.options?.links?.faviconRules;
          if (!Array.isArray(rules)) return [];
          return rules.filter(r => r && r.enabled && r.iconDataUrl);
        },

        applyFaviconRulesToLink(link, rulesOverride = null, rawInput = null) {
          try {
            if (!link || !link.url) return false;
            const enabledRules = Array.isArray(rulesOverride) ? rulesOverride : this.getEnabledFaviconRules();
            if (!enabledRules.length) {
              if (link.faviconSource === 'rule' && (link.favicon || link.faviconRuleId)) {
                this.$set(link, 'favicon', null);
                this.$set(link, 'faviconError', false);
                this.$set(link, 'faviconSource', null);
                this.$set(link, 'faviconRuleId', null);
                return true;
              }
              return false;
            }

            const incomingRaw = rawInput != null ? rawInput : (link.rawUrlInput ?? null);
            const normalizedRaw = incomingRaw != null ? String(incomingRaw).trim() : null;
            const rule = this.findRuleForUrl(link.url, enabledRules, normalizedRaw);
            if (rule && rule.iconDataUrl) {
              const ruleIcon = rule.iconDataUrl;
              const ruleId = rule.id ?? null;
              if (link.favicon !== ruleIcon || link.faviconSource !== 'rule' || link.faviconRuleId !== ruleId) {
                this.$set(link, 'favicon', ruleIcon);
                this.$set(link, 'faviconError', false);
                this.$set(link, 'faviconSource', 'rule');
                this.$set(link, 'faviconRuleId', ruleId);
                if (normalizedRaw !== null && link.rawUrlInput !== normalizedRaw) {
                  this.$set(link, 'rawUrlInput', normalizedRaw || '');
                }
                return true;
              }
              return false;
            }

            if (link.faviconSource === 'rule' && (link.favicon || link.faviconRuleId)) {
              this.$set(link, 'favicon', null);
              this.$set(link, 'faviconError', false);
              this.$set(link, 'faviconSource', null);
              this.$set(link, 'faviconRuleId', null);
              if (normalizedRaw !== null && link.rawUrlInput !== normalizedRaw) {
                this.$set(link, 'rawUrlInput', normalizedRaw || '');
              }
              return true;
            }
            return false;
          } catch (err) {
            debugLog('warn', '[FaviconRules] applyFaviconRulesToLink failed', err);
            return false;
          }
        },

        onFaviconRulesClosed() {
          this.refreshVisibleFavicons();
        },

        refreshVisibleFavicons() {
          try {
            const groups = Array.isArray(this.data?.groups) ? this.data.groups : [];
            if (!groups.length) return;

            const enabledRules = this.getEnabledFaviconRules();

            let changed = false;

            groups.forEach(group => {
              if (!group || group.deleted) return;
              const links = Array.isArray(group.links) ? group.links : [];
              links.forEach(link => {
                if (!link || link.deleted || !link.url) return;
                if (this.applyFaviconRulesToLink(link, enabledRules)) changed = true;
              });
            });

            if (changed) {
              this.saveData();
            }
          } catch (err) {
            debugLog('warn', '[FaviconRules] refreshVisibleFavicons failed', err);
          }
        },

      showOptionsDialog() {
        debugLog('log', 'showOptionsDialog called');
        // Ensure options structure is complete before editing
        this.fixOptions();
        // Remember current identity name to detect changes on save
        this.prevIdentityName = this.data.identity?.name || '';
          
          debugLog('log', 'this.optionsDesign:', this.optionsDesign);
          debugLog('log', 'this.data.options:', this.data.options);
          debugLog('log', 'Opening generic dialog with:', {
            type: 'options',
            design: this.optionsDesign,
            title: this.getTranslation('options')
          });
          
        // Prepare dynamic NC folder select values before opening
        try { this.prepareNcFolderSelectInOptions(); } catch {}

        // Use the generic dialog
        this.openGenericEditDialog(
          'options',
          this.data.options,
          this.optionsDesign,
          this.getTranslation('options'),
            async (editedData) => {
              try {
              const previousSecurity = this.normalizeLocalSecurityOptions(this.data.options?.security);
              // Apply the edited options
              const wasAutoHeightOnLinkChanges = !!this.data.options?.groups?.autoAdjustHeightOnLinkChanges;
              const wasManualGroupColumnWidth = !!this.data.options?.common?.manualGroupColumnWidth;
              Object.assign(this.data.options, editedData);
              this.fixOptions();
              let currentSecurity = this.normalizeLocalSecurityOptions(this.data.options?.security);
              if (!previousSecurity.enabled && currentSecurity.enabled) {
                const password = await this.promptForLocalSecurityPassword();
                if (!password) {
                  this.$set(this.data.options.security, 'enabled', false);
                  this.localSecurity.isEncryptedStore = false;
                  this.clearLocalSecurityRuntime();
                  this.showToast(this.getTranslation('options.security.enableCanceled') || 'Encryption was not enabled (password entry canceled).', 'warning');
                } else {
                  try {
                    const kdf = this.createLocalSecurityKdfMeta();
                    const key = await this.deriveLocalSecurityKey(password, kdf);
                    this._localEncryptionKey = key;
                    this._localEncryptionKdf = kdf;
                    this.localSecurity.isEncryptedStore = true;
                    this.localSecurity.locked = false;
                    this.localSecurity.lockReason = '';
                    this.localSecurity.unlockError = '';
                    this.localSecurity.unlockPassword = '';
                    this.localSecurity.encryptedEnvelope = null;
                    this.localSecurity.encryptedDataId = this.dataId;
                    this.showToast(this.getTranslation('options.security.enabledSuccess') || 'Local data encryption enabled.', 'success');
                  } catch (error) {
                    debugLog('error', '[SECURITY] Could not enable encryption', error);
                    this.$set(this.data.options.security, 'enabled', false);
                    this.localSecurity.isEncryptedStore = false;
                    this.clearLocalSecurityRuntime();
                    this.showToast(this.getTranslation('options.security.enableFailed') || 'Could not enable encryption.', 'error');
                  }
                }
              } else if (previousSecurity.enabled && !currentSecurity.enabled) {
                const confirmText = this.getTranslation('options.security.disable.confirm')
                  || 'Disable local encryption and store data unencrypted?';
                if (!confirm(confirmText)) {
                  this.$set(this.data.options.security, 'enabled', true);
                } else {
                  this.localSecurity.isEncryptedStore = false;
                  this.localSecurity.locked = false;
                  this.localSecurity.lockReason = '';
                  this.localSecurity.encryptedEnvelope = null;
                  this.localSecurity.encryptedDataId = -1;
                  this.localSecurity.unlockError = '';
                  this.localSecurity.unlockPassword = '';
                  this.clearLocalSecurityRuntime();
                  this.clearLocalSecuritySessionTimer();
                  this.showToast(this.getTranslation('options.security.disabledSuccess') || 'Local data encryption disabled.', 'success');
                }
              }
              this.fixOptions();
              currentSecurity = this.normalizeLocalSecurityOptions(this.data.options?.security);
              const securityModeChanged = previousSecurity.enabled !== currentSecurity.enabled;
              const isAutoHeightOnLinkChanges = !!this.data.options?.groups?.autoAdjustHeightOnLinkChanges;
              const isManualGroupColumnWidth = !!this.data.options?.common?.manualGroupColumnWidth;
              setDebugEnabled(!!this.data.options?.common?.debugEnabled);
              // Normalize and ensure identity name
              try {
                let newIdentityName = this.data.options?.common?.identityName || '';
                // Trim and auto-generate if empty on save
                newIdentityName = (typeof newIdentityName === 'string') ? newIdentityName.trim() : '';
                if (!newIdentityName) {
                  const rand = Math.random().toString(36).slice(2, 8); // 6 chars
                  newIdentityName = `mybookmarks_${rand}`;
                  if (!this.data.options) this.$set(this, 'options', {});
                  if (!this.data.options.common) this.$set(this.data.options, 'common', {});
                  this.$set(this.data.options.common, 'identityName', newIdentityName);
                  debugLog('log', '[OPTIONS] Auto-generated identityName on empty save:', newIdentityName);
                }
                if (!this.data.identity) this.$set(this, 'identity', {});
                this.$set(this.data.identity, 'name', newIdentityName);
              } catch {}
              if (securityModeChanged) {
                await this.saveDataImmediate();
              } else {
                this.saveData();
              }
              if (currentSecurity.enabled && this.localSecurity.isEncryptedStore && !this.localSecurity.locked) {
                this.startLocalSecuritySessionTimer();
              } else {
                this.clearLocalSecuritySessionTimer();
              }
              this.applyCustomColors();
              try { this.scheduleCardDavAutoSync(); } catch {}
              
              // Update page title if changed
              if (this.data.options.common.pageTitle !== this.title) {
                this.title = this.data.options.common.pageTitle;
                document.title = this.title;
              }
              
              // Refresh groups if identity name changed
              if (this.prevIdentityName !== this.data.identity?.name) {
                this.data.groups.forEach(group => {
                  if (group.members) {
                    group.members.forEach(member => {
                      if (member.uuid === this.data.identity?.uuid) {
                        member.name = this.data.identity?.name || '';
                      }
                    });
                  }
                });
              }

              if (isAutoHeightOnLinkChanges && !wasAutoHeightOnLinkChanges) {
                this.autoAdjustAllGroupHeightsForAutoMode();
              }
              if (!isManualGroupColumnWidth && wasManualGroupColumnWidth) {
                this.endGroupColumnResize();
              }
              if (isManualGroupColumnWidth && !wasManualGroupColumnWidth) {
                this.$nextTick(() => {
                  const columns = this.getGroupColumns();
                  this.ensureGroupColumnWidthsInitialized(columns);
                  this.ensureGroupColumnWidthsWithinViewport(columns);
                  this.saveData();
                });
              }
              } catch (error) {
                debugLog('error', '[OPTIONS] Failed to apply options', error);
                const reason = error?.message ? ` ${error.message}` : '';
                this.showToast((this.getTranslation('options.applyError') || 'Could not apply options.') + reason, 'error');
              }
            }
          );
        },
        
        // Populate NC-Bookmarks folder select in Options dialog
        async prepareNcFolderSelectInOptions() {
          try {
            const bk = this.data.options?.bookmarks || {};
            const serverUrl = (bk.serverUrl || '').trim();
            const username = bk.username || '';
            const password = bk.password || '';
            const values = await this.fetchNcFolderValues(serverUrl, username, password);
            // Ensure current selection exists
            const current = String(bk.rootFolderId || '0');
            if (!values[current]) values[current] = current === '0' ? 'All folders' : `Folder #${current}`;
            this.$set(this.optionsDesign.bookmarks.fields.rootFolderId, 'values', values);
          } catch (e) {
            debugLog('warn', '[NC] Could not populate folder select:', e);
            // Fallback to only "All folders"
            this.$set(this.optionsDesign.bookmarks.fields.rootFolderId, 'values', { '0': 'All folders' });
          }
        },
        async fetchNcFolderValues(serverUrl, username, password) {
          const map = { '0': 'All folders' };
          if (!serverUrl) return map;
          try {
            await MB.Extension.setDavAuth(serverUrl, username||'', password||'');
            const url = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
            const auth = MB.CardDAV.buildBasicAuthHeader(username||'', password||'');
            const res = await MB.Extension.davRequest({ method:'GET', url, headers:{ 'Accept':'application/json', 'OCS-APIREQUEST':'true', 'X-Requested-With':'XMLHttpRequest', 'Authorization':auth }, username, password });
            if (!res.ok) return map;
            let parsed=null; try { parsed = JSON.parse(res.bodyText||'[]'); } catch {}
            const list = Array.isArray(parsed) ? parsed : (parsed && Array.isArray(parsed.data) ? parsed.data : []);
            for (const f of list) {
              if (!f || f.id === undefined) continue;
              const id = String(f.id);
              map[id] = f.title ? `${f.title} (#${f.id})` : `Folder #${f.id}`;
            }
          } catch (e) {
            debugLog('warn', '[NC] fetchNcFolderValues failed', e);
          }
          return map;
        },
        
        // --- Generic Options Dialog Methods ---
        getFilteredSettings() {
          // Backend-aware section filtering
          const backend = this.data.options?.sync?.backend || (this.data.options?.carddav?.enabled ? 'carddav' : null);
          const design = {};
          Object.entries(this.optionsDesign).forEach(([key, section]) => {
            // Hide provider-specific sections that don't match backend
            if (key === 'carddav' && backend && backend !== 'carddav') return;
            if (key === 'bookmarks' && backend && backend !== 'nc-bookmarks') return;
            design[key] = section;
          });
          if (!this.settingsFilterText) return design;
          
          const filter = this.settingsFilterText.toLowerCase();
          const filtered = {};
          
          for (const [sectionKey, section] of Object.entries(design)) {
            // Skip if not an object with fields
            if (!section.fields) continue;
            
            const filteredFields = {};
            let sectionMatches = false;
            
            // Check section title
            const sectionTitle = this.getTranslation(section.translateKey) || sectionKey;
            if (sectionTitle.toLowerCase().includes(filter)) {
              sectionMatches = true;
            }
            
            // Check fields
            for (const [fieldKey, field] of Object.entries(section.fields)) {
              const fieldLabel = this.getTranslation(field.translateKey) || fieldKey;
              const fieldHelp = this.getTranslation(field.helpText) || '';
              
              if (fieldLabel.toLowerCase().includes(filter) || fieldHelp.toLowerCase().includes(filter)) {
                filteredFields[fieldKey] = field;
                sectionMatches = true;
              }
            }
            
            if (sectionMatches) {
              filtered[sectionKey] = {
                ...section,
                fields: Object.keys(filteredFields).length > 0 ? filteredFields : section.fields
              };
            }
          }
          
          return filtered;
        },
        
        isSectionExpanded(sectionKey) {
          // Auto-expand if filter is active and section has matches
          if (this.settingsFilterText && this.getFilteredSettings()[sectionKey]) {
            return true;
          }
          // Otherwise use stored state (default to false)
          return this.expandedSections[sectionKey] || false;
        },
        
        toggleSection(sectionKey) {
          this.$set(this.expandedSections, sectionKey, !this.expandedSections[sectionKey]);
        },
        
        getFieldComponent(type) {
          // Map field types to component names
          const componentMap = {
            'text': 'text-field',
            'number': 'number-field',
            'checkbox': 'checkbox-field',
            'select': 'select-field',
            'color': 'color-field'
          };
          return componentMap[type] || 'text-field';
        },
        
        
        // --- Group Edit Dialog Methods ---
        isGroupSectionExpanded(sectionKey) {
          // Auto-expand all sections by default
          if (this.expandedGroupSections[sectionKey] === undefined) {
            this.$set(this.expandedGroupSections, sectionKey, true);
          }
          return this.expandedGroupSections[sectionKey];
        },
        toggleGroupSection(sectionKey) {
          this.$set(this.expandedGroupSections, sectionKey, !this.expandedGroupSections[sectionKey]);
        },
        
        // --- Link Edit Dialog Methods ---
        isLinkSectionExpanded(sectionKey) {
          // Auto-expand all sections by default
          if (this.expandedLinkSections[sectionKey] === undefined) {
            this.$set(this.expandedLinkSections, sectionKey, true);
          }
          return this.expandedLinkSections[sectionKey];
        },
        toggleLinkSection(sectionKey) {
          this.$set(this.expandedLinkSections, sectionKey, !this.expandedLinkSections[sectionKey]);
        },

        // --- Ref-Link Edit Dialog Methods ---
        isRefAliasSectionExpanded(sectionKey) {
          if (this.refAliasExpandedSections[sectionKey] === undefined) {
            this.$set(this.refAliasExpandedSections, sectionKey, true);
          }
          return this.refAliasExpandedSections[sectionKey];
        },
        toggleRefAliasSection(sectionKey) {
          this.$set(this.refAliasExpandedSections, sectionKey, !this.isRefAliasSectionExpanded(sectionKey));
        },
        
        // --- Translation ---
        getTranslation(key, values) {
          const lang = this.data.options?.common?.language || 'en';
          // Use i18n translations
          let text = (this.i18n?.[lang]?.[key]) || (this.i18n?.['en']?.[key]) || '';
          
          // Fallback: show key if no translation found
          if (!text) text = key;
          
          // Replace placeholders with values
          if (values && Array.isArray(values)) {
            values.forEach(val => { 
              text = text.replace('%s', (val !== undefined && val !== null) ? val : ''); 
            });
          }
          return text;
        },
        // --- Groups ---
        getNewGroupTemplate(name) {
          const groupUuid = this.generateUUID();
          const nowTs = Date.now();
          const newGroup = {
            uuid: groupUuid, // Every group gets a permanent UUID from creation
            groupId: groupUuid, // Use the same UUID as groupId for all groups (needed for event-log)
            name: name,
            emoji: '',
            keywords: '',
            shortcut: '',
            urlPlaceholders: [],
            favicon: '',
            faviconError: false,
            faviconLoading: false,
            faviconSource: null,
            faviconRuleId: null,
            links: [],
            index: this.data.groups.length > 0 ? Math.max(...this.data.groups.map(g => g.index)) + 1 : 0,
            column: 0,
            createdAt: nowTs,
            lastModified: nowTs,
            // Transient UI state defaults
            collapsed: this.data.options.groups.collapseGroupsOnStart, // Use option default
            searchCollapsed: true,
            editing: false,
            isMouseOver: false,
            newLinkText: '', // Moved from main data
            newLinkUrl: '',    // Moved from main data
            // Progressive loading state
            linksExpanded: false, // Start with limited links for performance
            bodyHeight: CONSTS.GROUP_BODY_HEIGHT_DEFAULT,
            manualHeightResizeOverride: false,
            // If true, disable colored background and use neutral styling
            shared: false,
            members: [ { uuid: this.data.identity?.uuid || '', name: this.data.identity?.name || '', role: 'owner' } ],
            // Enable event-log by default for all new groups
            useEventLog: true,
            eventLog: [],
            snapshot: null,
            headEventId: null,
            vectorClock: {}
          };
          
          // Create initial snapshot event for the new group
          // Ensure we have an identity UUID for event-log
          if (!this.data.identity?.uuid) {
            if (!this.data.identity) {
              this.$set(this.data, 'identity', { 
                uuid: this.generateUUID(),
                name: '', 
                pubKey: '', 
                privKey: '' 
              });
            } else {
              this.$set(this.data.identity, 'uuid', this.generateUUID());
            }
          }
          
          const author = this.data.identity.uuid;
          const migrationEvent = {
            eventId: 'creation-' + groupUuid,
            parentId: null,
            timestamp: nowTs,
            author: author,
            type: 'snapshot',
            data: {
              groupId: groupUuid,
              name: name,
              emoji: '',
              favicon: '',
              links: [],
              keywords: '',
              shortcut: '',
              urlPlaceholders: [],
              members: newGroup.members
            }
          };
          
          newGroup.eventLog = [migrationEvent];
          newGroup.snapshot = migrationEvent.data;
          newGroup.headEventId = migrationEvent.eventId;
          newGroup.vectorClock = { [author]: 1 };
          
          return newGroup;
        },
        addGroup() {
          const newGroup = this.getNewGroupTemplate('New Group'); // Default name
          // apply default colors from settings
          newGroup.color = this.data.options?.groups?.defaultGroupFormatting || '';
          newGroup.titleFormatting = this.data.options?.groups?.defaultGroupTitleFormatting || '';
          newGroup.linkFormatting = this.data.options?.groups?.defaultGroupLinkFormatting || '';
          newGroup.badgeFormatting = this.data.options?.groups?.defaultGroupBadgeFormatting || '';
          newGroup.pillFormatting = this.data.options?.groups?.defaultGroupPillFormatting || '';
          newGroup.pillColor = '';
          // Find the column with the fewest groups or default to 0
          const columns = this.getGroupColumns();
          let targetColumn = 0;
          if (columns.length > 0) {
            const counts = columns.map(col => this.data.groups.filter(g => g.column === col).length);
            const minCount = Math.min(...counts);
            targetColumn = columns[counts.indexOf(minCount)];
          }
          newGroup.column = targetColumn;
          newGroup.index = this.getMaxIndexForColumn(this.data.groups, targetColumn) + 1; // Add to end of target column
          this.data.groups.push(newGroup);
          // No need to reindex all if adding to end
          // reindexArr(this.data.groups.filter(g => g.column === newGroup.column));
          this.saveData();
        },
        // --- Sharing: context actions ---
        // Preserve original confirmShare to allow extension
        // _originalConfirmShare removed; extend confirmShare in-place
        async shareGroup(group) {
          try {
            this.openShareDialog('group', group);
          } catch (e) { debugLog('error', e); alert('Send failed'); }
        },
        async shareLink(link) {
          try {
            this.openShareDialog('link', link);
          } catch (e) { debugLog('error', e); alert('Send failed'); }
        },
        openShareDialog(mode, payload) {
          this.shareDialog.visible = true;
          this.shareDialog.mode = mode;
          this.shareDialog.payload = payload;
          this.shareDialog.selectedContacts = {};
          
          // Check online status for all contacts when dialog opens
          this.checkAllContactsStatus();
          
          const modalElement = document.getElementById('shareModal');
          if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).show();
          this.hideMenus();
        },
        async confirmShare() {
          if (this.shareDialog?.mode === 'owner-transfer') {
            const selected = Object.entries(this.shareDialog.selectedContacts||{}).filter(([,v])=>!!v).map(([k])=>k);
            if (selected.length !== 1) { alert(this.getTranslation('dialog.transfer.select')||'Select new owner:'); return; }
            const g = this.shareDialog.group;
            if (!g) return;
            await this.transferOwnership(g, selected[0]);
            this.shareDialog.visible=false; const modalElement = document.getElementById('shareModal'); if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).hide();
            return;
          }
          const selectedContacts = Object.entries(this.shareDialog.selectedContacts).filter(([,v])=>!!v).map(([k])=>k);
          if (selectedContacts.length===0) { alert('Select at least one contact'); return; }
          const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
          const base = { v:1, ts: Date.now(), from, schemaVersion:1, msgId: (Math.random().toString(36).slice(2)+Date.now()) };
          if (this.shareDialog.mode==='link') {
            const l = this.shareDialog.payload;
            const selection = { groups: [], links: [this.serializeLinkForSync(l)] };
            // to contacts
            for (const uuid of selectedContacts) {
              await sharing.sendToContact(uuid, Object.assign({}, base, { type:'share', mode:'merge', selection }));
            }
          } else if (this.shareDialog.mode==='group') {
            const g0 = this.shareDialog.payload;
            const gPayload = { 
              uuid:g0.uuid, 
              name:g0.name, 
              color:g0.color, 
              opacity:g0.opacity, 
              keywords:g0.keywords, 
              urlPlaceholders: this.normalizePlaceholderList(g0.urlPlaceholders || []),
              favicon:g0.favicon || '',
              faviconSource:g0.faviconSource || null,
              links:(g0.links||[]).map(l=>this.serializeLinkForSync(l)),
              // Include event-log data if available
              useEventLog: g0.useEventLog || false,
              eventLog: g0.eventLog || [],
              snapshot: g0.snapshot || null,
              headEventId: g0.headEventId || null,
              vectorClock: g0.vectorClock || {}
            };
            const selection = { groups:[gPayload], links:[] };
            for (const uuid of selectedContacts) {
              await sharing.sendToContact(uuid, Object.assign({}, base, { type:'share', mode:'merge', selection }));
            }
          } else if (this.shareDialog.mode==='invite-group') {
            const g = this.shareDialog.payload;
            // ensure group is shared and has topic/key
            await sharing.inviteContactToGroup(g, selectedContacts[0] || '');
            for (let i=1;i<selectedContacts.length;i++) {
              await sharing.inviteContactToGroup(g, selectedContacts[i]);
            }
          }
          this.shareDialog.visible=false; const modalElement = document.getElementById('shareModal'); if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).hide();
          // Removed alert - modal will close to indicate success
        },
        inviteMembers(group) {
          // For non-shared groups, allow current user to initiate sharing (becomes owner)
          if (group?.shared && !this.isOwnerOfGroup(group)) { alert(this.getTranslation('error.onlyOwner')); return; }
          // reuse share dialog to pick contacts; on confirm, send invites
          this.shareDialog.visible = true;
          this.shareDialog.mode = 'invite-group';
          this.shareDialog.payload = group;
          this.shareDialog.selectedContacts = {};

          // Check online status for all contacts when dialog opens
          this.checkAllContactsStatus();

          const modalElement = document.getElementById('shareModal');
          if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).show();
          this.hideMenus();
        },
        duplicateGroup(group) {
          if (!group) return;
          const copy = {
            uuid: this.generateUUID(), // Generate new UUID for the duplicated group
            name: `${group.name} (Kopie)`,
            keywords: group.keywords || '',
            urlPlaceholders: this.normalizePlaceholderList(group.urlPlaceholders || []),
            links: [],
            index: (this.data.groups && this.data.groups.length ? Math.max(...this.data.groups.map(g=>g.index)) + 1 : 0),
            column: group.column || 0,
            collapsed: !!group.collapsed,
            searchCollapsed: true,
            editing: false,
            isMouseOver: false,
            newLinkText: '',
            newLinkUrl: '',
            color: group.color || '',
            titleFormatting: group.titleFormatting || '',
            linkFormatting: group.linkFormatting || '',
            badgeFormatting: group.badgeFormatting || '',
            pillFormatting: group.pillFormatting || '',
            favicon: group.favicon || '',
            faviconError: false,
            faviconLoading: false,
            faviconSource: group.faviconSource || null,
            faviconRuleId: group.faviconRuleId || null,
            shared: false,
            members: [ { uuid: this.data.identity?.uuid || '', name: this.data.identity?.name || '', role: 'owner' } ]
          };
          const nowTs = Date.now();
          copy.createdAt = nowTs;
          copy.lastModified = nowTs;
          (group.links||[]).forEach((l, idx)=>{
            const linkCreated = this.normalizeTimestampValue(l.createdAt) ?? nowTs;
            const linkModified = this.normalizeTimestampValue(l.lastModified) ?? linkCreated;
            copy.links.push({ 
              uuid: this.generateUUID(), // New UUID for duplicated link
              text: l.text||l.url, 
              url: l.url, 
              urlPlaceholders: this.normalizePlaceholderList(l.urlPlaceholders || []),
              keywords: l.keywords||'', 
              shortcut: l.shortcut || '',
              color: l.color || '',
              refTargetUuid: l.refTargetUuid || '',
              inheritSourceKeywords: l.inheritSourceKeywords !== false,
              column: 0, 
              index: idx, 
              editing:false, 
              isMouseOver:false,
              createdAt: linkCreated,
              lastModified: linkModified
            });
          });
          if (!Array.isArray(this.data.groups)) this.$set(this.data, 'groups', []);
          this.data.groups.push(copy);
          this.touchGroup(copy, nowTs);
          this.saveData();
          this.hideMenus();
        },
        async delGroup(group) {
          const needConfirm = !!this.data?.options?.common?.confirmDeleteGroup;
          if (needConfirm) {
            const msg = this.getTranslation('confirm.deleteGroup', [group?.name || '']);
            if (!confirm(msg)) return;
          }
          const oldColumn = group.column; // Spalte merken
          const index = this.data.groups.findIndex(g => g.uuid === group.uuid);
          const isOwner = (group.members||[]).some(m=>m.role==='owner' && m.uuid===this.data.identity?.uuid);
          // If this is a shared group and we are NOT the owner, notify owner that we left; owner's group stays intact
          if (group.shared && !isOwner) {
            try {
              const owner = (group.members||[]).find(m=>m.role==='owner') || (group.members||[]).find(m=>m.uuid!==this.data.identity?.uuid);
              if (owner) {
                const env = { v:1, type:'group-member-left', ts:Date.now(), from:{ uuid:this.data.identity?.uuid, name:this.data.identity?.name||'' }, groupId: group.groupId, memberUuid: this.data.identity?.uuid };
                await sharing.sendToContact(owner.uuid, env);
              }
            } catch {}
            try { sharing.ntfy.unsubscribe(group.groupTopic); } catch {}
          }
          if (index > -1) {
            this.data.groups.splice(index, 1);
            this.reindexArr(this.data.groups.filter(g => g.column === oldColumn)); // Alte Spalte neu indizieren
            this.normalizeColumnNumbers(); // <-- HIER AUFRUFEN
            this.saveData(); // Speichern nach Normalisierung und Reindexierung
          }
          this.hideMenus();
        },
        normalizeGroupColumnWidth(value) {
          const parsed = Number(value);
          if (!Number.isFinite(parsed)) return null;
          const rounded = Math.round(parsed);
          return Math.max(CONSTS.GROUP_COLUMN_WIDTH_MIN, rounded);
        },
        isManualGroupColumnWidthEnabled() {
          return !!this.data?.options?.common?.manualGroupColumnWidth;
        },
        ensureGroupColumnWidthStore() {
          if (!this.data?.options) this.$set(this.data, 'options', {});
          if (!this.data.options.groups) this.$set(this.data.options, 'groups', {});
          if (!this.data.options.groups.columnWidths || typeof this.data.options.groups.columnWidths !== 'object' || Array.isArray(this.data.options.groups.columnWidths)) {
            this.$set(this.data.options.groups, 'columnWidths', {});
          }
          return this.data.options.groups.columnWidths;
        },
        getStoredGroupColumnWidth(columnIndex) {
          if (columnIndex === undefined || columnIndex === null) return null;
          if (!this.isManualGroupColumnWidthEnabled()) return null;
          const widths = this.ensureGroupColumnWidthStore();
          const normalized = this.normalizeGroupColumnWidth(widths[String(columnIndex)]);
          return Number.isFinite(normalized) ? normalized : null;
        },
        setGroupColumnWidth(columnIndex, width) {
          if (columnIndex === undefined || columnIndex === null) return;
          const normalized = this.normalizeGroupColumnWidth(width);
          if (!Number.isFinite(normalized)) return;
          const widths = this.ensureGroupColumnWidthStore();
          const key = String(columnIndex);
          if (widths[key] !== normalized) {
            this.$set(widths, key, normalized);
          }
        },
        getMeasuredGroupColumnWidth(columnIndex) {
          if (columnIndex === undefined || columnIndex === null) return null;
          if (typeof document === 'undefined') return null;
          const cell = document.querySelector(`.groupCell[data-column-index="${columnIndex}"]`);
          if (!cell) return null;
          const measured = this.normalizeGroupColumnWidth(cell.getBoundingClientRect().width);
          return Number.isFinite(measured) ? measured : null;
        },
        getCurrentGroupColumnWidth(columnIndex) {
          return this.getStoredGroupColumnWidth(columnIndex) ?? this.getMeasuredGroupColumnWidth(columnIndex);
        },
        getGroupColumnCellStyle(columnIndex) {
          if (!this.isManualGroupColumnWidthEnabled()) return null;
          const width = this.getStoredGroupColumnWidth(columnIndex);
          if (!Number.isFinite(width)) {
            return {
              minWidth: `${CONSTS.GROUP_COLUMN_WIDTH_MIN}px`
            };
          }
          return {
            width: `${width}px`,
            minWidth: `${width}px`,
            maxWidth: `${width}px`
          };
        },
        getGroupColumnWidthLabel(columnIndex) {
          const width = this.getCurrentGroupColumnWidth(columnIndex);
          if (!Number.isFinite(width)) return '0px';
          return `${Math.round(width)}px`;
        },
        equalizeGroupColumnWidths() {
          if (!this.isManualGroupColumnWidthEnabled()) return;
          const columns = this.getGroupColumns();
          if (!columns.length) return;
          const minWidth = CONSTS.GROUP_COLUMN_WIDTH_MIN;
          const availableWidth = this.getAvailableGroupColumnWidthSpace(columns);
          let baseWidth = minWidth;
          let remainder = 0;

          if (Number.isFinite(availableWidth) && availableWidth > 0) {
            baseWidth = Math.max(minWidth, Math.floor(availableWidth / columns.length));
            const used = baseWidth * columns.length;
            remainder = Math.max(0, availableWidth - used);
          }

          columns.forEach((col, idx) => {
            const extra = idx < remainder ? 1 : 0;
            this.setGroupColumnWidth(col, baseWidth + extra);
          });

          const changedByFit = this.ensureGroupColumnWidthsWithinViewport(columns);
          this.saveData();
          if (changedByFit) this.$forceUpdate();
        },
        ensureGroupColumnWidthsInitialized(columns = null) {
          if (!this.isManualGroupColumnWidthEnabled()) return;
          const cols = Array.isArray(columns) ? columns : this.getGroupColumns();
          const widths = this.ensureGroupColumnWidthStore();
          cols.forEach(col => {
            const key = String(col);
            const existing = this.normalizeGroupColumnWidth(widths[key]);
            if (Number.isFinite(existing)) {
              if (widths[key] !== existing) this.$set(widths, key, existing);
              return;
            }
            const measured = this.getMeasuredGroupColumnWidth(col);
            if (Number.isFinite(measured)) {
              this.$set(widths, key, measured);
            }
          });
        },
        shiftGroupColumnWidthsRight(fromColumnIndex) {
          const widths = this.ensureGroupColumnWidthStore();
          const entries = Object.entries(widths)
            .map(([k, v]) => ({ col: Number(k), width: this.normalizeGroupColumnWidth(v) }))
            .filter(entry => Number.isFinite(entry.col) && Number.isFinite(entry.width))
            .sort((a, b) => b.col - a.col);

          entries.forEach(({ col, width }) => {
            if (col >= fromColumnIndex) {
              this.$set(widths, String(col + 1), width);
              this.$delete(widths, String(col));
            }
          });
        },
        remapGroupColumnWidths(columnMapping) {
          const widths = this.ensureGroupColumnWidthStore();
          const remapped = {};
          Object.entries(columnMapping || {}).forEach(([oldCol, newCol]) => {
            const width = this.normalizeGroupColumnWidth(widths[String(oldCol)]);
            if (!Number.isFinite(width) || newCol === undefined || newCol === null) return;
            remapped[String(newCol)] = width;
          });
          this.$set(this.data.options.groups, 'columnWidths', remapped);
        },
        pruneGroupColumnWidths(validColumns = null) {
          const widths = this.ensureGroupColumnWidthStore();
          const valid = new Set((validColumns || this.getGroupColumns()).map(col => String(col)));
          Object.keys(widths).forEach(key => {
            if (!valid.has(key)) this.$delete(widths, key);
          });
        },
        getGroupColumnDropzoneWidthPx() {
          if (typeof document === 'undefined') return 10;
          const zone = document.querySelector('.groupsTable .verticalDropZone');
          const measured = Number(zone?.getBoundingClientRect().width || 0);
          if (Number.isFinite(measured) && measured > 0) return measured;
          return 10;
        },
        getAvailableGroupColumnWidthSpace(columns = null) {
          if (typeof document === 'undefined') return null;
          const cols = Array.isArray(columns) ? columns : this.getGroupColumns();
          if (!cols.length) return null;
          const containerEl = document.querySelector('.mb-groups-links-container') || document.querySelector('.mainContainer');
          if (!containerEl) return null;
          const containerWidth = Number(containerEl.clientWidth || containerEl.getBoundingClientRect().width || 0);
          if (!Number.isFinite(containerWidth) || containerWidth <= 0) return null;
          let tablePaddingX = 0;
          const tableEl = document.querySelector('.groupsTable');
          if (tableEl && typeof window !== 'undefined' && typeof window.getComputedStyle === 'function') {
            const styles = window.getComputedStyle(tableEl);
            const leftPad = Number.parseFloat(styles.paddingLeft || '0');
            const rightPad = Number.parseFloat(styles.paddingRight || '0');
            tablePaddingX = (Number.isFinite(leftPad) ? leftPad : 0) + (Number.isFinite(rightPad) ? rightPad : 0);
          }
          const dropZoneWidth = this.getGroupColumnDropzoneWidthPx();
          const dropZoneTotal = dropZoneWidth * (cols.length + 1);
          const available = Math.floor(containerWidth - tablePaddingX - dropZoneTotal);
          return Number.isFinite(available) && available > 0 ? available : null;
        },
        ensureGroupColumnWidthsWithinViewport(columns = null) {
          if (!this.isManualGroupColumnWidthEnabled()) return false;
          const cols = Array.isArray(columns) ? columns : this.getGroupColumns();
          if (!cols.length) return false;
          const widths = this.ensureGroupColumnWidthStore();
          const minWidth = CONSTS.GROUP_COLUMN_WIDTH_MIN;
          let changed = false;
          const resolved = cols.map(col => {
            const key = String(col);
            let width = this.normalizeGroupColumnWidth(widths[key]);
            if (!Number.isFinite(width)) {
              const measured = this.getMeasuredGroupColumnWidth(col);
              width = this.normalizeGroupColumnWidth(measured);
            }
            if (!Number.isFinite(width)) width = minWidth;
            if (widths[key] !== width) {
              this.$set(widths, key, width);
              changed = true;
            }
            return { key, col, width };
          });

          const availableWidth = this.getAvailableGroupColumnWidthSpace(cols);
          if (!Number.isFinite(availableWidth)) return changed;

          let totalWidth = resolved.reduce((sum, entry) => sum + entry.width, 0);
          if (!Number.isFinite(totalWidth) || totalWidth <= availableWidth) return changed;

          let overflow = totalWidth - availableWidth;
          while (overflow > 0) {
            let largest = null;
            resolved.forEach(entry => {
              if (entry.width <= minWidth) return;
              if (!largest || entry.width > largest.width) {
                largest = entry;
              }
            });
            if (!largest) break;
            const reducible = Math.max(0, largest.width - minWidth);
            if (reducible <= 0) break;
            const reduceBy = Math.min(reducible, overflow);
            largest.width = this.normalizeGroupColumnWidth(largest.width - reduceBy);
            overflow -= reduceBy;
          }

          resolved.forEach(entry => {
            if (widths[entry.key] !== entry.width) {
              this.$set(widths, entry.key, entry.width);
              changed = true;
            }
          });

          if (overflow > 0) {
            debugLog('warn', '[GROUP-COLUMNS] Remaining overflow after fitting to viewport', {
              overflow,
              availableWidth,
              minWidth,
              columns: cols.length
            });
          }
          return changed;
        },
        startGroupColumnResize(event, leftColumn, rightColumn) {
          if (!this.isManualGroupColumnWidthEnabled()) return;
          if (event && event.button !== undefined && event.button !== 0) return;
          if (leftColumn === undefined || leftColumn === null || rightColumn === undefined || rightColumn === null) return;
          if (leftColumn === rightColumn) return;
          if (this.isGroupHeightResizing) return;
          const columns = this.getGroupColumns();
          if (!columns.includes(leftColumn) || !columns.includes(rightColumn)) return;

          this.ensureGroupColumnWidthsInitialized(columns);
          const leftWidth = this.getCurrentGroupColumnWidth(leftColumn);
          const rightWidth = this.getCurrentGroupColumnWidth(rightColumn);
          if (!Number.isFinite(leftWidth) || !Number.isFinite(rightWidth)) return;

          this.isGroupColumnResizing = true;
          this.groupColumnResizeState = {
            leftColumn,
            rightColumn,
            startX: event.clientX,
            startLeftWidth: leftWidth,
            startRightWidth: rightWidth
          };
          document.body.classList.add('mb-group-column-resizing');
          document.addEventListener('mousemove', this.handleGroupColumnResize);
          document.addEventListener('mouseup', this.endGroupColumnResize);
        },
        handleGroupColumnResize(event) {
          if (!this.isGroupColumnResizing) return;
          const state = this.groupColumnResizeState || {};
          const leftColumn = state.leftColumn;
          const rightColumn = state.rightColumn;
          if (leftColumn === null || rightColumn === null) return;

          const minWidth = CONSTS.GROUP_COLUMN_WIDTH_MIN;
          const total = Number(state.startLeftWidth || 0) + Number(state.startRightWidth || 0);
          if (!Number.isFinite(total) || total <= 0) return;

          const deltaX = event.clientX - state.startX;
          let nextLeft = Number(state.startLeftWidth || 0) + deltaX;
          let nextRight = Number(state.startRightWidth || 0) - deltaX;

          if (nextLeft < minWidth) {
            nextLeft = minWidth;
            nextRight = total - minWidth;
          }
          if (nextRight < minWidth) {
            nextRight = minWidth;
            nextLeft = total - minWidth;
          }

          nextLeft = this.normalizeGroupColumnWidth(nextLeft);
          nextRight = this.normalizeGroupColumnWidth(nextRight);
          if (!Number.isFinite(nextLeft) || !Number.isFinite(nextRight)) return;

          this.setGroupColumnWidth(leftColumn, nextLeft);
          this.setGroupColumnWidth(rightColumn, nextRight);
        },
        endGroupColumnResize() {
          if (!this.isGroupColumnResizing) return;
          this.isGroupColumnResizing = false;
          this.groupColumnResizeState = {
            leftColumn: null,
            rightColumn: null,
            startX: 0,
            startLeftWidth: 0,
            startRightWidth: 0
          };
          document.removeEventListener('mousemove', this.handleGroupColumnResize);
          document.removeEventListener('mouseup', this.endGroupColumnResize);
          document.body.classList.remove('mb-group-column-resizing');
          this.saveData();
        },
        getGroupColumns() {
          if (!this.data.groups || this.data.groups.length === 0) return [0]; // Default to one column if empty
          const columns = [...new Set(this.data.groups.map(g => g.column))];
          return columns.sort((a, b) => a - b);
        },
        getMaxIndexForColumn(arr, column) {
          const itemsInColumn = arr.filter(item => item.column === column);
          return itemsInColumn.length > 0 ? Math.max(...itemsInColumn.map(item => item.index)) : -1;
        },
        getGroupsByColumn(colIndex) {
          const query = (this.filterText || '').trim().toLowerCase();
          const activeKeywords = this.activeKeywordFilters || [];
          return this.data.groups
            .filter(g => {
              if (g.column !== colIndex) return false;
              const matchesText = (
                !query ||
                g.name?.toLowerCase().includes(query) ||
                (g.keywords && g.keywords.toLowerCase().includes(query)) ||
                (g.links && g.links.some(l =>
                  l.text?.toLowerCase().includes(query) ||
                  (l.keywords && l.keywords.toLowerCase().includes(query)) ||
                  (l.url && l.url.toLowerCase().includes(query))
                ))
              );
              if (!matchesText) return false;
              if (!activeKeywords.length) return true;
              return this.groupMatchesKeywordFilters(g, activeKeywords);
            })
            .sort((a, b) => a.index - b.index);
        },
        // Innerhalb von methods: { ... } der Vue-Instanz 'app'
        normalizeColumnNumbers() {
          const groups = this.data.groups;
          if (!groups || groups.length === 0) {
            this.pruneGroupColumnWidths([]);
            return;
          } // Nichts zu tun, wenn keine Gruppen da sind

          const currentColumns = this.getGroupColumns(); // Holt sortierte, eindeutige Spalten, z.B. [0, 2, 3]
          if (currentColumns.length === 0) return; // Sollte nicht passieren, aber sicher ist sicher

          let expectedCol = 0;
          let changed = false;
          const columnMapping = {}; // Objekt zum Speichern der Zuordnung: alteSpalte -> neueSpalte

          // 1. Mapping erstellen
          for (const currentCol of currentColumns) {
            if (currentCol !== expectedCol) {
              // Lücke oder erster Eintrag ist nicht 0 (sollte nicht sein, aber zur Sicherheit)
              columnMapping[currentCol] = expectedCol; // Weise die erwartete Nummer zu
            } else {
              columnMapping[currentCol] = currentCol; // Keine Änderung für diese Spalte
            }
            expectedCol++; // Erhöhe die erwartete Nummer für die nächste Iteration
          }

          // 2. Mapping auf alle Gruppen anwenden
          groups.forEach(group => {
            const oldCol = group.column;
            if (columnMapping[oldCol] !== undefined && columnMapping[oldCol] !== oldCol) {
              // Nur ändern, wenn eine neue Zuordnung existiert und sie anders ist
              this.$set(group, 'column', columnMapping[oldCol]);
              changed = true;
            }
          });

          if (changed) {
            debugLog('log', "Columns normalized. New mapping:", columnMapping);
            this.remapGroupColumnWidths(columnMapping);
            this.$forceUpdate(); // Erzwinge UI-Update nach Spaltenänderung
            // Wichtig: saveData() wird in der aufrufenden Funktion (moveGroup/delGroup/onDrop) gemacht!
          } else {
            this.pruneGroupColumnWidths(currentColumns);
          }
          this.ensureGroupColumnWidthsWithinViewport(this.getGroupColumns());
        },
        toggleGroupCollapse(group) {
          // 1. Toggle den Vue-Datenzustand (für Icon etc.)
          this.$set(group, 'collapsed', !group.collapsed);

          // Apply favicon rules (and optionally extension fetch if enabled) on expand
          if (!group.collapsed) {
            this.loadFaviconsForGroup(group);
          }

          // 2. Hole das Bootstrap Collapse Element
          const elementId = 'collapseGroup-' + group.uuid;
          const collapseElement = document.getElementById(elementId);

          if (collapseElement) {
            // 3. Hole oder erstelle die Bootstrap Instanz
            let bsCollapseInstance = bootstrap.Collapse.getInstance(collapseElement);
            if (!bsCollapseInstance) {
              bsCollapseInstance = new bootstrap.Collapse(collapseElement, { toggle: false });
            }
            // 4. Trigger Bootstrap's Toggle-Funktion
            bsCollapseInstance.toggle();

            // 5. Speichere den neuen Zustand (optional, je nachdem ob du den manuellen Toggle speichern willst)
            // Das Speichern hier kann dazu führen, dass beim nächsten Laden der Zustand korrekt ist,
            // überschreibt aber ggf. die "collapseGroupsOnStart"-Option für diese eine Gruppe.
            this.saveData();

          } else {
            debugLog('warn', "Could not find collapse element to toggle:", elementId);
          }
        },

        async loadFaviconsForGroup(group, linksOverride = null) {
          const targetLinks = Array.isArray(linksOverride) ? linksOverride : (group.links || []);
          if (!targetLinks.length) return;

          debugLog('log', `Loading favicons for group: ${group.name}`, { overrideCount: linksOverride ? targetLinks.length : undefined });

          // Track which links already have favicons
          const linksToFetch = targetLinks.filter(link => {
            const fav = link && link.favicon ? String(link.favicon) : '';
            const isBase64 = fav.startsWith('data:');
            return !this.isNonUrlLink(link) && link.url && !isBase64 && !link.faviconLoading;
          });

          if (linksToFetch.length === 0) {
            debugLog('log', 'All links already have favicons');
            return;
          }

          // Mark links as loading to prevent duplicate fetches
          linksToFetch.forEach(link => {
            this.$set(link, 'faviconLoading', true);
          });

          // Fetch favicons in batches
          const batchSize = 5;
          for (let i = 0; i < linksToFetch.length; i += batchSize) {
            const batch = linksToFetch.slice(i, i + batchSize);

            // Fetch metadata for each link in the batch
            const fetchPromises = batch.map(async (link) => {
              try {
                await this.tryFetchAndSetFavicon(link, link.url, link.rawUrlInput ?? null);
              } catch (error) {
                debugLog('warn', `Failed to fetch favicon for ${link.url}:`, error);
              } finally {
                this.$set(link, 'faviconLoading', false);
              }
            });

            // Wait for batch to complete before continuing
            await Promise.all(fetchPromises);

            // Small delay between batches to avoid overwhelming the extension
            if (i + batchSize < linksToFetch.length) {
              await new Promise(resolve => setTimeout(resolve, 100));
            }
          }

          // Save data after all favicons are loaded
          this.saveData();
          debugLog('log', `Finished loading favicons for group: ${group.name}`);
        },
        // --- Links ---
        getNewLinkTemplate(group) {
          const rawInput = (group.newLinkUrl || '').trim();
          // Basic URL normalization using configured default prefix
          let url = MB.Utils.ensureProtocol(rawInput);
          const nowTs = Date.now();

          return {
            uuid: this.generateUUID(), // UUID is the only identifier
            itemType: 'link',
            text: group.newLinkText.trim() || url || '', // Links can have empty text
            url: url || '', // Empty string instead of null for consistency
            rawUrlInput: rawInput || '',
            urlPlaceholders: [],
            keywords: '', // Add keywords field
            emoji: '', // Add emoji field for custom icons
            shortcut: '',
            index: group.links.length > 0 ? Math.max(...group.links.map(link => link.index)) + 1 : 0,
            column: 0, // Default to first column within the group
            // Timestamps for conflict resolution
            createdAt: nowTs,
            lastModified: nowTs,
            // Transient UI state defaults
            editing: false,
            isMouseOver: false,
          };
        },
        async addLink(group) {
          debugLog('log', '[addLink] Function called for group:', {
            groupName: group.name,
            groupId: group.groupId,
            useEventLog: group.useEventLog,
            hasEventLog: !!group.eventLog,
            isShared: group.shared
          });
          
          if (!this.canAdd(group)) { alert(this.getTranslation('error.perm.add')); return; }
          if (!group.newLinkText.trim() && !group.newLinkUrl.trim()) return; // Require at least text or URL
          const rawNewLinkInput = group.newLinkUrl;
          const newLink = this.getNewLinkTemplate(group);
          debugLog('log', '[DEBUG] Created new link:', { 
            uuid: newLink.uuid, 
            text: newLink.text, 
            url: newLink.url, 
            hasUrl: !!newLink.url && newLink.url !== '',
            urlLength: newLink.url ? newLink.url.length : 0
          });
          
          group.links.push(newLink);
          const newLinkTimestamp = this.touchLink(newLink, newLink.createdAt);
          this.touchGroup(group, newLinkTimestamp);
          group.newLinkText = '';
          group.newLinkUrl = '';

          const rawInputTrimmed = typeof rawNewLinkInput === 'string' ? rawNewLinkInput.trim() : rawNewLinkInput;
          if (rawInputTrimmed !== undefined && rawInputTrimmed !== null) {
            this.$set(newLink, 'rawUrlInput', rawInputTrimmed || '');
          }

          if (newLink.url) {
            try {
              if (!this.applyFaviconRulesToLink(newLink, null, rawInputTrimmed)) {
                await this.tryFetchAndSetFavicon(newLink, newLink.url, rawInputTrimmed);
              }
            } catch (err) {
              debugLog('warn', '[addLink] Failed to apply favicon for new link', { error: err, url: newLink.url });
            }
          }

          if (!group.collapsed && this.data.options?.links?.autoFetchFavicon) {
            this.loadFaviconsForGroup(group, [newLink]);
          }

          // Update version for sync tracking
          if (group.shared) {
            group.version = (group.version || 0) + 1;
            debugLog('log', '[SYNC] Updated group version after adding link', { groupId: group.groupId, version: group.version });
          }
          
          // EVENT-LOG: Create and send event for link addition (for ALL groups with event-log)
          debugLog('log', '[LINK-ADD] Checking event-log for group:', {
            groupName: group.name,
            groupId: group.groupId,
            useEventLog: group.useEventLog,
            hasEventLog: !!group.eventLog,
            isShared: group.shared
          });
          
          if (group.useEventLog) {
            debugLog('log', '[LINK-ADD] Creating event-log entry for link addition');
            this.createAndApplyEvent(group, {
              type: 'link-add',
              linkId: newLink.uuid,
              data: {
                uuid: newLink.uuid,  // Include UUID in data for consistency
                text: newLink.text || '',
                url: newLink.url || '',
                rawUrlInput: newLink.rawUrlInput || '',
                keywords: newLink.keywords || '',
                emoji: newLink.emoji || '',
                shortcut: newLink.shortcut || '',
                itemType: newLink.itemType || 'link',
                refTargetUuid: newLink.refTargetUuid || '',
                inheritSourceKeywords: newLink.inheritSourceKeywords !== false,
                urlPlaceholders: this.normalizePlaceholderList(newLink.urlPlaceholders || []),
                column: newLink.column || 0,
                index: newLink.index || 0,
                createdAt: newLink.createdAt || newLinkTimestamp,
                lastModified: newLink.lastModified || newLinkTimestamp
              }
            });
          } else {
            debugLog('warn', '[LINK-ADD] Event-log is disabled for this group');
          }
          
          this.saveData();
          this.maybeAutoAdjustGroupHeightAfterLinkChange(group);
          // Broadcast to shared group (legacy for backward compatibility)
          try {
            if (group.shared && group.groupTopic && group.groupKey && !group.useEventLog) {
              const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
              const linkToShare = this.serializeLinkForSync(newLink);
              debugLog('log', '[SYNC] Broadcasting new link', { 
                uuid: linkToShare.uuid, 
                text: linkToShare.text, 
                url: linkToShare.url,
                hasUrl: !!linkToShare.url && linkToShare.url !== '',
                urlLength: linkToShare.url ? linkToShare.url.length : 0,
                rawEnvelope: JSON.stringify(linkToShare)
              });
              const env = { v:1, type:'share-links', ts:Date.now(), from, groupId: group.groupId, selection:{ groups:[], links:[linkToShare] }, mode:'merge', msgId:(Math.random().toString(36).slice(2)+Date.now()) };
              await sharing.sendToGroup(group, env);
            }
          } catch {}
        },
        // Accept external link drops (from browser address bar or page links) or fall back to internal reordering
        async handleLinkDrop(evt, group, targetIndex, targetColumn) {
          // Try external data first
          const ext = this.extractUrlAndTitle(evt.dataTransfer);
          if (ext && ext.url && /^https?:\/\//i.test(ext.url)) {
            if (!this.canAdd(group)) { alert(this.getTranslation('error.perm.add')); return; }
            const url = ext.url.trim();
            const title = (ext.title || '').trim();
            const nowTs = Date.now();
            const newLink = {
              uuid: this.generateUUID(), // UUID is the only identifier
              itemType: 'link',
              text: title || url,
              url,
              rawUrlInput: url,
              urlPlaceholders: [],
              keywords: '',
              shortcut: '',
              column: targetColumn,
              index: 0,
              editing: false,
              isMouseOver: false,
              createdAt: nowTs,
              lastModified: nowTs,
            };
            if (!Array.isArray(group.links)) this.$set(group, 'links', []);
            group.links.push(newLink);
            // Reindex target column with new link inserted at requested position
            const colLinks = group.links.filter(l => l.column === targetColumn).sort((a, b) => a.index - b.index);
            const before = colLinks.slice(0, Math.max(0, Math.min(targetIndex, colLinks.length)));
            const after = colLinks.slice(Math.max(0, Math.min(targetIndex, colLinks.length)));
            const ordered = [...before, newLink, ...after.filter(l => l !== newLink)];
            ordered.forEach((l, i) => l.index = i);
            const newLinkTs = this.touchLink(newLink, nowTs);
            this.touchGroup(group, newLinkTs);
            // Always apply favicon rules; extension fetch stays gated inside tryFetchAndSetFavicon
            await this.tryFetchAndSetFavicon(newLink, url, url);
            if (this.data.options?.links?.autoFetchTitle && (!title || title === url)) {
              // best effort, non-blocking
              this.tryFetchTitle(url).then(tt => { if (tt) newLink.text = tt; this.saveData(); }).catch(() => { });
            }
            // EVENT-LOG: Create event for external link drop (for ALL groups with event-log)
            if (group.useEventLog) {
              this.createAndApplyEvent(group, {
                type: 'link-add',
                linkId: newLink.uuid,
                data: {
                  uuid: newLink.uuid,
                  text: newLink.text || '',
                  url: newLink.url || '',
                  rawUrlInput: newLink.rawUrlInput || '',
                  keywords: newLink.keywords || '',
                  shortcut: newLink.shortcut || '',
                  itemType: newLink.itemType || 'link',
                  refTargetUuid: newLink.refTargetUuid || '',
                  inheritSourceKeywords: newLink.inheritSourceKeywords !== false,
                  urlPlaceholders: this.normalizePlaceholderList(newLink.urlPlaceholders || []),
                  column: newLink.column || 0,
                  index: newLink.index || 0,
                  createdAt: newLink.createdAt || newLinkTs,
                  lastModified: newLink.lastModified || newLinkTs
                }
              });
            }
            
            this.saveData();
            this.maybeAutoAdjustGroupHeightAfterLinkChange(group);
            // Broadcast to shared group (legacy only)
            try {
              if (group.shared && group.groupTopic && group.groupKey && !group.useEventLog) {
                const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                const linkToShare = this.serializeLinkForSync(newLink);
                debugLog('log', '[SYNC] Broadcasting dropped link', { uuid: linkToShare.uuid, hasUrl: !!linkToShare.url, text: linkToShare.text });
                const env = { v:1, type:'share-links', ts:Date.now(), from, groupId: group.groupId, selection:{ groups:[], links:[linkToShare] }, mode:'merge', msgId:(Math.random().toString(36).slice(2)+Date.now()) };
                await sharing.sendToGroup(group, env);
              }
            } catch {}
            return;
          }
          // No external URL -> if we're dragging an internal link, delegate to DropManager
          if (this.dragState === 'link' && this.dropManager && this.dropManager.oldItem) {
            this.dropManager.onDrop(evt, group.links, null, targetIndex, targetColumn, 'link');
            const nowTs = Date.now();
            const draggedLink = this.dropManager.oldItem;
            const linkTs = draggedLink ? this.touchLink(draggedLink, nowTs) : nowTs;
            const sourceGroup = this.dropManager.oldArr ? this.data.groups.find(g => g.links === this.dropManager.oldArr) : null;
            this.touchGroup(group, linkTs);
            if (sourceGroup && sourceGroup !== group) this.touchGroup(sourceGroup, nowTs);
            this.saveData();
            if (sourceGroup && sourceGroup !== group) {
              this.maybeAutoAdjustGroupHeightAfterLinkChange(group);
              this.maybeAutoAdjustGroupHeightAfterLinkChange(sourceGroup);
            }
          }
        },

        handleLinkDropToNewColumn(evt, group, targetColumnIndex) {
          debugLog('log', `handleLinkDropToNewColumn called for group ${group.name}, target column index ${targetColumnIndex}`);

          // Prevent default and stop propagation
          evt.preventDefault();
          evt.stopPropagation();

          // Get the dragged link from dropManager
          const draggedLink = this.dropManager.oldItem;
          const draggedState = this.dropManager.draggedState;
          const sourceGroup = this.dropManager.oldArr ? this.data.groups.find(g => g.links === this.dropManager.oldArr) : null;

          debugLog('log', 'Dragged link:', draggedLink);
          debugLog('log', 'Dragged state:', draggedState);
          debugLog('log', 'Source group:', sourceGroup);
          debugLog('log', 'Target group:', group);

          if (!draggedLink || draggedState !== 'link') {
            debugLog('warn', 'No valid link being dragged');
            this.dropManager.reset();
            return;
          }

          const moveTimestamp = Date.now();
          let linkMoveTimestamp = moveTimestamp;

          const oldColumn = draggedLink.column || 0;
          const oldIndex = draggedLink.index || 0;

          // Check if this is a cross-group move
          const isCrossGroup = sourceGroup && sourceGroup !== group;

          if (isCrossGroup) {
            debugLog('log', 'Cross-group move detected');

            // Check permissions BEFORE making any changes
            if (!this.canDelete(sourceGroup)) {
              alert(this.getTranslation('error.perm.delete') || 'You do not have permission to remove links from this group');
              this.dropManager.reset();
              return;
            }

            if (!this.canAdd(group)) {
              alert(this.getTranslation('error.perm.add') || 'You do not have permission to add links to this group');
              this.dropManager.reset();
              return;
            }

            // Remove link from source group (only after permission check)
            const linkIndex = sourceGroup.links.findIndex(l => l.uuid === draggedLink.uuid);
            if (linkIndex !== -1) {
              sourceGroup.links.splice(linkIndex, 1);

              // Update indices in the old column of source group
              const remainingLinksInOldColumn = sourceGroup.links.filter(l =>
                (l.column || 0) === oldColumn && (l.index || 0) > oldIndex
              );
              remainingLinksInOldColumn.forEach(l => {
                l.index = (l.index || 0) - 1;
              });

              this.touchGroup(sourceGroup, moveTimestamp);
            }

            // Add link to target group
            if (!Array.isArray(group.links)) {
              this.$set(group, 'links', []);
            }
            group.links.push(draggedLink);
            this.touchGroup(group, moveTimestamp);
          }

          // Get all existing link columns in target group
          const existingColumns = this.getLinkColumns(group.links);
          debugLog('log', 'Existing link columns before move:', existingColumns);
          debugLog('log', `Moving link from column ${oldColumn} to dropzone at position ${targetColumnIndex}`);

          // For same-group moves, check if this link is alone in its column
          if (!isCrossGroup) {
            const linksInOldColumn = group.links.filter(l => (l.column || 0) === oldColumn);
            const isAloneInColumn = linksInOldColumn.length === 1;

            // Check if this is effectively no move
            if (isAloneInColumn) {
              if ((targetColumnIndex === -1 && oldColumn === 0) ||
                  (targetColumnIndex !== -1 && targetColumnIndex === oldColumn) ||
                  (targetColumnIndex !== -1 && targetColumnIndex - 1 === oldColumn)) {
                debugLog('log', 'Link is alone in column and target position is same - no move needed');
                this.dropManager.reset();
                return;
              }
            }
          }

          let newColumnIndex;

          if (targetColumnIndex === -1) {
            // Drop before first column - all columns shift right
            newColumnIndex = 0;

            // Shift all links to the right (except the dragged one)
            group.links.forEach(l => {
              if (l.uuid !== draggedLink.uuid) {
                l.column = (l.column || 0) + 1;
              }
            });
          } else {
            // targetColumnIndex is the position where we want to insert the new column
            // This is the column index AFTER which the dropzone is located

            // The new column should be created at this exact position
            newColumnIndex = targetColumnIndex;

            debugLog('log', `Creating new link column at position ${newColumnIndex}`);

            // Shift all links at or after the target position to the right
            // But not the dragged link itself
            group.links.forEach(l => {
              if (l.uuid !== draggedLink.uuid && (l.column || 0) >= newColumnIndex) {
                l.column = (l.column || 0) + 1;
                debugLog('log', `Shifted link "${l.text}" from column ${l.column - 1} to ${l.column}`);
              }
            });
          }

          // Update indices in the old column (remove the gap) - only for same-group moves
          if (!isCrossGroup) {
            const remainingLinksInOldColumn = group.links.filter(l =>
              (l.column || 0) === oldColumn && l.uuid !== draggedLink.uuid && (l.index || 0) > oldIndex
            );
            remainingLinksInOldColumn.forEach(l => {
              l.index = (l.index || 0) - 1;
            });
          }

          // Move the dragged link to the new column
          draggedLink.column = newColumnIndex;
          draggedLink.index = 0; // Place at top of new column
          linkMoveTimestamp = this.touchLink(draggedLink, moveTimestamp);
          if (!isCrossGroup) {
            this.touchGroup(group, moveTimestamp);
          }

          debugLog('log', `Moved link "${draggedLink.text}" from column ${oldColumn} to new column ${newColumnIndex}`);

          // Now normalize link column indices to remove any gaps
          this.normalizeLinkColumnIndices(group);

          // Also normalize source group if it was a cross-group move
          if (isCrossGroup && sourceGroup) {
            this.normalizeLinkColumnIndices(sourceGroup);

            // Handle sync for cross-group moves
            // Send DELETE event/message to source group if it's shared
            if (sourceGroup.shared) {
              if (sourceGroup.useEventLog && this.eventLogManager) {
                // Create link-delete event for source group
                this.createAndApplyEvent(sourceGroup, {
                  type: 'link-delete',
                  linkId: draggedLink.uuid,
                  data: {
                    deletedLink: {
                      uuid: draggedLink.uuid,
                      text: draggedLink.text,
                      url: draggedLink.url,
                      column: oldColumn,
                      index: oldIndex
                    }
                  }
                });
                debugLog('log', '[DND EVENT-LOG] Created link-delete event for source group:', sourceGroup.name);
              } else if (sourceGroup.groupTopic && sourceGroup.groupKey) {
                // Legacy sync for source group
                try {
                  const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
                  const deleteEnv = {
                    v: 1,
                    type: 'link-delete',
                    ts: Date.now(),
                    from,
                    groupId: sourceGroup.groupId,
                    link: { uuid: draggedLink.uuid, url: draggedLink.url || null },
                    version: sourceGroup.version || CONSTS.VERSION_FALLBACK,
                    msgId: (Math.random().toString(36).slice(2) + Date.now())
                  };
                  debugLog('log', '[DRAG] Sending link-delete to source shared group:', sourceGroup.name, draggedLink.uuid);
                  if (typeof sharing !== 'undefined' && sharing) {
                    sharing.sendToGroup(sourceGroup, deleteEnv);
                  }
                } catch (error) {
                  debugLog('error', '[DRAG] Error sending link-delete:', error);
                }
              }
            }

            // Send ADD event/message to target group if it's shared
            if (group.shared) {
              if (group.useEventLog && this.eventLogManager) {
                // Create link-add event for target group
                this.createAndApplyEvent(group, {
                  type: 'link-add',
                  linkId: draggedLink.uuid,
                    data: {
                      uuid: draggedLink.uuid,
                      text: draggedLink.text || '',
                      url: draggedLink.url || '',
                      rawUrlInput: draggedLink.rawUrlInput || '',
                      keywords: draggedLink.keywords || '',
                      shortcut: draggedLink.shortcut || '',
                      itemType: this.normalizeLinkItemType(draggedLink),
                      refTargetUuid: draggedLink.refTargetUuid || '',
                      inheritSourceKeywords: draggedLink.inheritSourceKeywords !== false,
                      urlPlaceholders: this.normalizePlaceholderList(draggedLink.urlPlaceholders || []),
                      column: draggedLink.column || 0,
                      index: draggedLink.index || 0,
                      createdAt: draggedLink.createdAt || linkMoveTimestamp,
                      lastModified: draggedLink.lastModified || linkMoveTimestamp
                    }
                });
                debugLog('log', '[DND EVENT-LOG] Created link-add event for target group:', group.name);
              } else if (group.groupTopic && group.groupKey) {
                // Legacy sync for target group
                try {
                  const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
                  const linkData = this.serializeLinkForSync(draggedLink);
                  const addEnv = {
                    v: 1,
                    type: 'share-links',
                    ts: Date.now(),
                    from,
                    groupId: group.groupId,
                    selection: { groups: [], links: [linkData] },
                    mode: 'merge',
                    msgId: (Math.random().toString(36).slice(2) + Date.now())
                  };
                  debugLog('log', '[DRAG] Sending share-links to target shared group:', group.name, linkData);
                  if (typeof sharing !== 'undefined' && sharing) {
                    sharing.sendToGroup(group, addEnv);
                  }
                } catch (error) {
                  debugLog('error', '[DRAG] Error sending share-links:', error);
                }
              }
            }
          } else if (group.shared && !isCrossGroup) {
            // Within same group movement - send position update for shared groups
            if (group.useEventLog && this.eventLogManager) {
              // For event-log groups, create a link-update event
              this.createAndApplyEvent(group, {
                type: 'link-update',
                linkId: draggedLink.uuid,
                data: {
                  uuid: draggedLink.uuid,
                  text: draggedLink.text || '',
                  url: draggedLink.url || '',
                  keywords: draggedLink.keywords || '',
                  shortcut: draggedLink.shortcut || '',
                  itemType: this.normalizeLinkItemType(draggedLink),
                  refTargetUuid: draggedLink.refTargetUuid || '',
                  inheritSourceKeywords: draggedLink.inheritSourceKeywords !== false,
                  urlPlaceholders: this.normalizePlaceholderList(draggedLink.urlPlaceholders || []),
                  column: draggedLink.column || 0,
                  index: draggedLink.index || 0,
                  lastModified: draggedLink.lastModified || linkMoveTimestamp
                }
              });
              debugLog('log', '[DND EVENT-LOG] Created link-update event for position change:', group.name);
            } else if (group.groupTopic && group.groupKey) {
              // Legacy sync - send position update
              try {
                const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
                const linkData = this.serializeLinkForSync(draggedLink);
                const env = {
                  v: 1,
                  type: 'share-links',
                  ts: Date.now(),
                  from,
                  groupId: group.groupId,
                  selection: { groups: [], links: [linkData] },
                  mode: 'merge',
                  msgId: (Math.random().toString(36).slice(2) + Date.now())
                };
                debugLog('log', '[DRAG] Sending share-links update within same group:', linkData);
                if (typeof sharing !== 'undefined' && sharing) {
                  sharing.sendToGroup(group, env);
                }
              } catch (error) {
                debugLog('error', '[DRAG] Error sending share-links update:', error);
              }
            }
          }

          // Save and reset
          this.touchGroup(group, moveTimestamp);
          if (isCrossGroup && sourceGroup) {
            this.touchGroup(sourceGroup, moveTimestamp);
          }
          this.saveData();
          if (isCrossGroup && sourceGroup) {
            this.maybeAutoAdjustGroupHeightAfterLinkChange(group);
            this.maybeAutoAdjustGroupHeightAfterLinkChange(sourceGroup);
          }
          this.dropManager.reset();
        },

        normalizeLinkColumnIndices(group) {
          // Get all unique columns and sort them
          const columns = [...new Set(group.links.map(l => l.column || 0))].sort((a, b) => a - b);

          // Create mapping from old to new column indices
          const columnMapping = {};
          columns.forEach((col, index) => {
            columnMapping[col] = index;
          });

          // Update all links with new column indices
          group.links.forEach(l => {
            const oldCol = l.column || 0;
            const newCol = columnMapping[oldCol];
            if (oldCol !== newCol) {
              l.column = newCol;
              debugLog('log', `Normalized link "${l.text}" from column ${oldCol} to ${newCol}`);
            }
          });
        },

        extractUrlAndTitle(dt) {
          if (!dt) return { url: '', title: '' };
          const safeGet = (t) => { try { return dt.getData(t) || ''; } catch { return ''; } };
          // 1) text/uri-list
          const uriListRaw = safeGet('text/uri-list');
          if (uriListRaw) {
            const lines = uriListRaw.split('\n').map(s => s.trim()).filter(s => s && !s.startsWith('#'));
            if (lines.length && /^https?:\/\//i.test(lines[0])) return { url: lines[0], title: '' };
          }
          // 2) Firefox: text/x-moz-url => "URL\nTitel"
          const moz = safeGet('text/x-moz-url');
          if (moz) {
            const [url, title] = moz.split('\n');
            if (url && /^https?:\/\//i.test(url)) return { url, title: title || '' };
          }
          // 3) text/html: <a href="..">Titel</a>
          const html = safeGet('text/html');
          if (html) {
            try {
              const doc = new DOMParser().parseFromString(html, 'text/html');
              const a = doc.querySelector('a[href]');
              const href = a?.getAttribute('href') || '';
              const title = (a?.textContent || '').trim();
              if (/^https?:\/\//i.test(href)) return { url: href, title };
            } catch { }
          }
          // 4) text/plain
          const plain = safeGet('text/plain').trim();
          if (/^https?:\/\//i.test(plain)) return { url: plain, title: '' };
          return { url: '', title: '' };
        },
        async deleteLink(link) {
          const needConfirm = !!this.data?.options?.common?.confirmDeleteLink;
          if (needConfirm) {
            const msg = this.isReferenceLink(link)
              ? (this.getTranslation('confirm.deleteRefLink') || this.getTranslation('confirm.deleteLink'))
              : this.getTranslation('confirm.deleteLink');
            if (!confirm(msg)) return;
          }
          try {
            const refCount = this.countReferenceLinksTo(link?.uuid);
            if (refCount > 0) {
              const msg = (this.getTranslation('link.ref.deleteSourceConfirm') || 'This link is used by {count} reference link(s). Delete anyway?')
                .replace('{count}', String(refCount));
              if (!confirm(msg)) return;
            }
          } catch {}
          const group = this.data.groups.find(g => g.links.some(l => 
            link.uuid && l.uuid === link.uuid
          ));
          if (group) {
            if (!this.canDelete(group)) { alert(this.getTranslation('error.perm.delete')); return; }
            const linkIndex = group.links.findIndex(l => 
              link.uuid && l.uuid === link.uuid
            );
            if (linkIndex > -1) {
              const nowTs = Date.now();
              const removed = group.links.splice(linkIndex, 1)[0];
              const noteState = this.data?.options?.links?.noteCollapsedState;
              if (removed?.uuid && noteState && Object.prototype.hasOwnProperty.call(noteState, removed.uuid)) {
                this.$delete(noteState, removed.uuid);
              }
              // Queue deletion to Nextcloud if this link was synced
              try {
                const nid = removed?.ncBookmarks?.id;
                const fid = removed?.ncBookmarks?.folderId;
                if (nid) {
                  if (!Array.isArray(this.data.pendingNcDeletes)) this.$set(this.data, 'pendingNcDeletes', []);
                  this.data.pendingNcDeletes.push({ id: nid, folderId: fid||null, url: removed.url||'', ts: Date.now() });
                  debugLog('log', '[NC SYNC] Queued NC deletion', { id: nid, folderId: fid });
                }
              } catch {}

              // Update version for sync tracking (only for shared groups)
              if (group.shared) {
                group.version = (group.version || 0) + 1;
                debugLog('log', '[SYNC] Updated group version after deleting link', { groupId: group.groupId, version: group.version });
              }

              // Event-log integration for delete (for ALL groups with event-log)
              if (group.useEventLog) {
                this.createAndApplyEvent(group, {
                  type: 'link-delete',
                  linkId: removed.uuid,
                  data: {
                    deletedLink: {
                      uuid: removed.uuid,
                      text: removed.text,
                      url: removed.url,
                      column: removed.column,
                      index: removed.index
                    }
                  }
                });
              }
              this.reindexArr(group.links.filter(l => l.column === link.column)); // Reindex affected column
              this.touchGroup(group, nowTs);
              this.saveData();
              this.maybeAutoAdjustGroupHeightAfterLinkChange(group);
              // Propagate delete to group members (legacy sync)
              try {
                if (group.shared && group.groupTopic && group.groupKey) {
                  const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                  const env = { 
                    v:1, 
                    type:'link-delete', 
                    ts:Date.now(), 
                    from, 
                    groupId: group.groupId, 
                    link:{ uuid: removed.uuid, url: removed.url||null }, 
                    version: group.version || 0,  // Include version for delete operations
                    msgId:(Math.random().toString(36).slice(2)+Date.now()) 
                  };
                  await sharing.sendToGroup(group, env);
                }
              } catch (error) {
                debugLog('error', '[Sharing] Error processing message headers:', error);
              }
            }
          }
          this.hideMenus();
        },
        getLinkColumns(links) {
          if (!links || links.length === 0) return [0];
          const columns = [...new Set(links.map(l => l.column))];
          return columns.sort((a, b) => a - b);
        },
        getLinksByColumn(links, colIndex) {
          // First, find the group that contains these links
          const group = this.data.groups.find(g => g.links === links);
          const rawFilter = (this.filterText || '').trim();
          const activeKeywords = this.activeKeywordFilters || [];
          // Tokenize search text
          const tokens = rawFilter ? rawFilter.toLowerCase().split(/\s+/).filter(Boolean) : [];
          // If any token matches group keywords, show all links
          const groupHasKeyword = group && tokens.length && this.parseKeywords(group.keywords || '')
            .map(k => k.toLowerCase()).some(kw => tokens.some(t => kw.includes(t)));
          
          let result = links
            .filter(l => {
              if (l.column !== colIndex) return false;
              const matchesText = (tokens.length === 0 || groupHasKeyword || (function() {
                const text = (this.getEffectiveLinkText(l) || '').toLowerCase();
                const url = (this.getEffectiveLinkUrl(l) || '').toLowerCase();
                const kws = (Array.isArray(this.getEffectiveLinkKeywords(l)) ? this.getEffectiveLinkKeywords(l) : (typeof this.getEffectiveLinkKeywords(l) === 'string' ? this.getEffectiveLinkKeywords(l).split(/[,;]+/) : []))
                  .map(s => String(s).trim().toLowerCase()).join(' ');
                return tokens.every(t => text.includes(t) || url.includes(t) || kws.includes(t));
              }).call(this));
              if (!matchesText) return false;
              if (!activeKeywords.length) return true;
              return this.groupOrLinkKeywordsContainAll(group, l, activeKeywords);
            })
            .sort((a, b) => a.index - b.index); // Sort by index

          // Progressive loading: limit display if not expanded
          if (group && !this.filterText && (!activeKeywords || activeKeywords.length === 0)) {
            const threshold = this.data.options?.links?.progressiveLoadingThreshold || 100;
            const expandedLimit = CONSTS.EXPANDED_LINK_LIMIT;

            if (!group.linksExpanded && result.length > threshold) {
              // Show limited links when not expanded
              const columnCount = this.getLinkColumns(links).length || 1;
              const perColumnLimit = Math.ceil(threshold / columnCount);
              result = result.slice(0, perColumnLimit);
            } else if (group.linksExpanded && result.length > expandedLimit) {
              // Even when expanded, limit to expandedLimit for performance
              const columnCount = this.getLinkColumns(links).length || 1;
              const perColumnLimit = Math.ceil(expandedLimit / columnCount);
              result = result.slice(0, perColumnLimit);
            }
          }

          // Optional simple virtualization by limit to reduce DOM on huge lists
          try {
            const perf = this.data?.options?.performance || {};
            if (perf.virtualizeLinks) {
              const init = Number(perf.initialLimit || 200);
              const groupKey = group?.uuid || 'default';
              if (!this._visibleLimits) this._visibleLimits = {};
              if (!this._visibleLimits[groupKey]) this._visibleLimits[groupKey] = init;
              result = result.slice(0, this._visibleLimits[groupKey]);
            }
          } catch {}

          return result;
        },
        getMaxGroupBodyHeight() {
          const viewportHeight = (typeof window !== 'undefined' && window.innerHeight) ? window.innerHeight : 1000;
          return Math.max(CONSTS.GROUP_BODY_HEIGHT_MIN + 40, Math.floor(viewportHeight * 0.85));
        },
        normalizeGroupBodyHeight(value) {
          const numeric = Number(value);
          const fallback = CONSTS.GROUP_BODY_HEIGHT_DEFAULT;
          const safeValue = Number.isFinite(numeric) ? numeric : fallback;
          const min = CONSTS.GROUP_BODY_HEIGHT_MIN;
          const max = this.getMaxGroupBodyHeight();
          return Math.round(Math.min(Math.max(safeValue, min), max));
        },
        getGroupBodyHeight(group) {
          return this.normalizeGroupBodyHeight(group?.bodyHeight);
        },
        isAutoAdjustGroupHeightOnLinkChangesEnabled() {
          return !!this.data?.options?.groups?.autoAdjustHeightOnLinkChanges;
        },
        isGroupManualHeightResizeOverride(group) {
          return !!group?.manualHeightResizeOverride;
        },
        canManuallyResizeGroupHeight(group) {
          if (!group || group.collapsed) return false;
          if (!this.isAutoAdjustGroupHeightOnLinkChangesEnabled()) return true;
          return this.isGroupManualHeightResizeOverride(group);
        },
        shouldAutoAdjustGroupHeightAfterLinkChange(group) {
          if (!group || group.collapsed) return false;
          if (!this.isAutoAdjustGroupHeightOnLinkChangesEnabled()) return false;
          if (this.isGroupManualHeightResizeOverride(group)) return false;
          return true;
        },
        measureGroupContentHeight(group) {
          if (!group) return null;
          const bodyEl = document.getElementById(`collapseGroup-${group.uuid}`);
          if (!bodyEl) return null;
          const prevHeight = bodyEl.style.height;
          const prevOverflowY = bodyEl.style.overflowY;
          bodyEl.style.height = 'auto';
          bodyEl.style.overflowY = 'visible';
          const contentHeight = Number(bodyEl.scrollHeight || bodyEl.getBoundingClientRect().height || 0);
          bodyEl.style.height = prevHeight;
          bodyEl.style.overflowY = prevOverflowY;
          if (!Number.isFinite(contentHeight) || contentHeight <= 0) return null;
          return contentHeight;
        },
        applyAutoAdjustedGroupHeight(group, { save = false } = {}) {
          if (!group || group.collapsed) return false;
          const contentHeight = this.measureGroupContentHeight(group);
          if (!Number.isFinite(contentHeight)) return false;
          const targetHeight = this.normalizeGroupBodyHeight(contentHeight + 2);
          const currentHeight = this.getGroupBodyHeight(group);
          const hasOverflow = contentHeight > currentHeight + 1;
          const hasExtraSpace = contentHeight < currentHeight - 1;
          const missingStoredHeight = group.bodyHeight === undefined || group.bodyHeight === null;
          if (!hasOverflow && !hasExtraSpace && !missingStoredHeight) return false;
          if (!missingStoredHeight && currentHeight === targetHeight) return false;
          this.$set(group, 'bodyHeight', targetHeight);
          if (save) this.saveData();
          return true;
        },
        maybeAutoAdjustGroupHeightAfterLinkChange(group) {
          if (!this.shouldAutoAdjustGroupHeightAfterLinkChange(group)) return;
          this.$nextTick(() => {
            const apply = () => {
              if (this.applyAutoAdjustedGroupHeight(group)) {
                this.saveData();
              }
            };
            if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
              window.requestAnimationFrame(apply);
            } else {
              setTimeout(apply, 0);
            }
          });
        },
        autoAdjustAllGroupHeightsForAutoMode() {
          this.$nextTick(() => {
            const apply = () => {
              let changed = false;
              (this.data.groups || []).forEach(group => {
                if (!this.shouldAutoAdjustGroupHeightAfterLinkChange(group)) return;
                if (this.applyAutoAdjustedGroupHeight(group)) changed = true;
              });
              if (changed) this.saveData();
            };
            if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
              window.requestAnimationFrame(apply);
            } else {
              setTimeout(apply, 0);
            }
          });
        },
        startGroupHeightResize(event, group) {
          if (!group || group.collapsed) return;
          if (!this.canManuallyResizeGroupHeight(group)) return;
          if (event && event.button !== undefined && event.button !== 0) return;
          const currentHeight = this.getGroupBodyHeight(group);
          if (group.bodyHeight === undefined || group.bodyHeight === null) {
            this.$set(group, 'bodyHeight', currentHeight);
          }
          this.isGroupHeightResizing = true;
          this.groupHeightResizeState = {
            groupUuid: group.uuid,
            startY: event.clientY,
            startHeight: currentHeight
          };
          document.body.classList.add('mb-group-resizing');
          document.addEventListener('mousemove', this.handleGroupHeightResize);
          document.addEventListener('mouseup', this.endGroupHeightResize);
        },
        handleGroupHeightResize(event) {
          if (!this.isGroupHeightResizing || !this.groupHeightResizeState?.groupUuid) return;
          const group = (this.data.groups || []).find(g => g.uuid === this.groupHeightResizeState.groupUuid);
          if (!group) return;
          const deltaY = event.clientY - this.groupHeightResizeState.startY;
          const nextHeight = this.normalizeGroupBodyHeight(this.groupHeightResizeState.startHeight + deltaY);
          this.$set(group, 'bodyHeight', nextHeight);
        },
        endGroupHeightResize() {
          if (!this.isGroupHeightResizing) return;
          this.isGroupHeightResizing = false;
          this.groupHeightResizeState = { groupUuid: null, startY: 0, startHeight: 0 };
          document.removeEventListener('mousemove', this.handleGroupHeightResize);
          document.removeEventListener('mouseup', this.endGroupHeightResize);
          document.body.classList.remove('mb-group-resizing');
          this.saveData();
        },
        autoFitGroupHeight(group) {
          if (!this.canManuallyResizeGroupHeight(group)) return;
          if (!group || group.collapsed) return;
          const bodyEl = document.getElementById(`collapseGroup-${group.uuid}`);
          let targetHeight = this.getGroupBodyHeight(group);
          if (bodyEl) {
            const prevHeight = bodyEl.style.height;
            const prevOverflowY = bodyEl.style.overflowY;
            bodyEl.style.height = 'auto';
            bodyEl.style.overflowY = 'visible';
            const contentHeight = Number(bodyEl.scrollHeight || bodyEl.getBoundingClientRect().height || 0);
            bodyEl.style.height = prevHeight;
            bodyEl.style.overflowY = prevOverflowY;
            if (Number.isFinite(contentHeight) && contentHeight > 0) {
              targetHeight = this.normalizeGroupBodyHeight(contentHeight + 2);
            }
          }
          const currentHeight = this.getGroupBodyHeight(group);
          if (currentHeight !== targetHeight || group.bodyHeight === undefined || group.bodyHeight === null) {
            this.$set(group, 'bodyHeight', targetHeight);
            this.saveData();
          }
        },
        // --- Sorting helpers for links ---
        _getLocaleCollator() {
          try {
            const lang = (this.data?.options?.common?.language || navigator.language || 'en').toString();
            return new Intl.Collator(lang, { numeric: true, sensitivity: 'base' });
          } catch { return new Intl.Collator('en', { numeric: true, sensitivity: 'base' }); }
        },
        _normalizeLinkSortKey(link, { ignoreArticles = true } = {}) {
          const raw = (link?.text || link?.url || '').toString().trim().toLowerCase();
          if (!ignoreArticles) return raw;
          const lang = (this.data?.options?.common?.language || 'en').toString().toLowerCase();
          // Minimal article lists (customize as needed)
          const articles = {
            en: ['the ', 'a ', 'an '],
            de: ['der ', 'die ', 'das ', 'ein ', 'eine ']
          };
          const list = articles[lang] || [];
          const match = list.find(p => raw.startsWith(p));
          return match ? raw.slice(match.length) : raw;
        },
        _compareLinks(a, b, collator, { direction = 'asc', ignoreArticles = true } = {}) {
          const ka = this._normalizeLinkSortKey(a, { ignoreArticles });
          const kb = this._normalizeLinkSortKey(b, { ignoreArticles });
          const c = collator.compare(ka, kb) || collator.compare(a.url||'', b.url||'');
          return direction === 'desc' ? -c : c;
        },
        // Sort links in a group by text (or URL as fallback)
        // strategy:
        //  - 'within-columns' (default): sort each column independently
        //  - 'preserve-counts': global sort, then slice back into current column counts (keeps visual balance)
        //  - 'rebalance-columns': global sort, then distribute as evenly as possible across columns
        sortGroupLinksByText(group, { strategy = 'within-columns', direction = 'asc', ignoreArticles = true } = {}) {
          if (!group || !Array.isArray(group.links) || group.links.length === 0) return;
          const hasSeparators = group.links.some(link => this.isSeparatorLink(link));
          if (hasSeparators && strategy !== 'within-columns') {
            this.showToast(
              this.getTranslation('menu.group.sort.separatorFallback') || 'Groups with separators can only be sorted within columns.',
              'info'
            );
            strategy = 'within-columns';
          }
          const collator = this._getLocaleCollator();
          const columns = this.getLinkColumns(group.links);
          const byCol = (col) => group.links.filter(l => l.column === col);
          if (strategy === 'within-columns') {
            columns.forEach(col => {
              const list = byCol(col).sort((a, b) => (a.index || 0) - (b.index || 0));
              const sortable = list
                .filter(link => !this.isSeparatorLink(link))
                .sort((a, b) => this._compareLinks(a, b, collator, { direction, ignoreArticles }));
              let sortablePos = 0;
              const reordered = list.map((entry) => {
                if (this.isSeparatorLink(entry)) return entry;
                const next = sortable[sortablePos];
                sortablePos += 1;
                return next;
              });
              reordered.forEach((l, idx) => {
                l.column = col;
                l.index = idx;
              });
            });
            this.saveData();
            return;
          }
          // Global sort for the remaining strategies
          const all = [...group.links].sort((a, b) => this._compareLinks(a, b, collator, { direction, ignoreArticles }));
          let counts = [];
          if (strategy === 'preserve-counts') {
            counts = columns.map(col => byCol(col).length);
          } else if (strategy === 'rebalance-columns') {
            const total = all.length;
            const base = Math.floor(total / columns.length);
            const extra = total % columns.length;
            counts = columns.map((_, i) => base + (i < extra ? 1 : 0));
          }
          // Assign back according to counts
          let pos = 0;
          columns.forEach((col, ci) => {
            const take = counts[ci] || 0;
            const slice = all.slice(pos, pos + take);
            pos += take;
            slice.forEach((l, idx) => { l.column = col; l.index = idx; });
          });
          this.saveData();
        },
        // Helper methods for progressive loading
        shouldShowExpandButton(group) {
          if (!group || !group.links || this.filterText || (this.activeKeywordFilters && this.activeKeywordFilters.length > 0)) return false;

          const totalLinks = group.links.length;
          const initialLimit = this.data.options?.links?.progressiveLoadingThreshold || CONSTS.PROGRESSIVE_LOADING_THRESHOLD;

          return totalLinks > initialLimit;
        },
        toggleGroupExpansion(group) {
          if (!group) return;
          group.linksExpanded = !group.linksExpanded;
          this.saveData();
        },
        getRemainingLinksCount(group) {
          if (!group || !group.links) return 0;
          const totalLinks = group.links.length;
          const initialLimit = group.initialLinkCount || 100;
          return Math.max(0, totalLinks - initialLimit);
        },
        increaseVisibleLinks(group) {
          try {
            const perf = this.data?.options?.performance || {};
            const page = Number(perf.pageSize || 200);
            const key = group?.uuid || 'default';
            if (!this._visibleLimits) this._visibleLimits = {};
            this._visibleLimits[key] = (this._visibleLimits[key] || Number(perf.initialLimit || 200)) + page;
            this.$forceUpdate();
          } catch {}
        },
        getNoteCollapsedStateMap() {
          const map = this.data?.options?.links?.noteCollapsedState;
          if (!map || typeof map !== 'object' || Array.isArray(map)) return {};
          return map;
        },
        ensureNoteCollapsedStateMap() {
          if (!this.data.options) this.$set(this.data, 'options', {});
          if (!this.data.options.links) this.$set(this.data.options, 'links', {});
          const current = this.data.options.links.noteCollapsedState;
          if (!current || typeof current !== 'object' || Array.isArray(current)) {
            this.$set(this.data.options.links, 'noteCollapsedState', {});
          }
          return this.data.options.links.noteCollapsedState;
        },
        isNoteCollapsed(link) {
          if (!this.isNoteLink(link) || !link?.uuid) return false;
          const map = this.getNoteCollapsedStateMap();
          return !!map[link.uuid];
        },
        toggleNoteCollapsed(link) {
          if (!this.isNoteLink(link) || !link?.uuid) return;
          const stateMap = this.ensureNoteCollapsedStateMap();
          if (stateMap[link.uuid]) {
            this.$delete(stateMap, link.uuid);
          } else {
            this.$set(stateMap, link.uuid, true);
          }
          this.saveData();
        },

        onLinkRowDblClick(link) {
          if (!link) return;
          if (this.isReferenceLink(link)) {
            this.openReferenceAliasDialog(link);
            return;
          }
          if (this.isSeparatorLink(link) || this.isNoteLink(link)) {
            this.showLinkEditModal(link);
            return;
          }
          this.startEditing(link);
        },
        showModalById(modalId) {
          const modalElement = document.getElementById(modalId);
          if (!modalElement) return null;
          const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
          modalInstance.show();
          return modalInstance;
        },
        hideModalById(modalId) {
          const modalElement = document.getElementById(modalId);
          if (!modalElement) return;
          const modalInstance = bootstrap.Modal.getInstance(modalElement);
          if (modalInstance) modalInstance.hide();
        },
        openReferenceAliasDialog(link) {
          const targetLink = (link && link.uuid) ? (this.findLinkByUuid(link.uuid) || link) : link;
          if (!targetLink) return;
          if (!this.isReferenceLink(targetLink)) {
            this.startEditing(targetLink);
            return;
          }

          const parentGroup = this.findGroupContainingLinkUuid(targetLink.uuid);
          if (parentGroup && !this.canEdit(parentGroup)) {
            alert(this.getTranslation('error.perm.edit'));
            this.hideMenus();
            return;
          }

          const source = this.getReferenceSourceLink(targetLink);
          const sourceKeywords = source?.keywords || '';
          const sourceUrlTemplate = (typeof source?.url === 'string') ? source.url : '';
          const inheritedRefRows = this.mergePlaceholderRowsForEditor([
            this.getGlobalPlaceholderList(),
            this.getGroupPlaceholderList(parentGroup),
            this.getLinkPlaceholderList(source)
          ]);
          this.refAliasExpandedSections = {
            basic: true,
            keywords: true,
            placeholders: true
          };
          this.refAliasEditData = {
            linkUuid: targetLink.uuid,
            aliasText: typeof targetLink.text === 'string' ? targetLink.text : '',
            sourceTitle: source ? this.getLinkDisplayTitle(source) : '',
            sourceUrlTemplate,
            sourceMissing: !source,
            sourceKeywords: sourceKeywords,
            sourceKeywordsLabel: this.joinKeywords(this.parseKeywords(sourceKeywords || '')),
            inheritSourceKeywords: targetLink.inheritSourceKeywords !== false,
            localKeywords: typeof targetLink.keywords === 'string' ? targetLink.keywords : '',
            placeholderRows: this.buildPlaceholderRowsForTemplate(
              sourceUrlTemplate,
              this.getLinkPlaceholderList(targetLink),
              inheritedRefRows
            )
          };

          this.hideMenus();
          this.$nextTick(() => {
            this.showModalById('referenceAliasModal');
            this.$nextTick(() => {
              const inputRef = this.$refs.refAliasInput;
              const inputElement = Array.isArray(inputRef) ? inputRef[0] : inputRef;
              if (inputElement && typeof inputElement.focus === 'function') {
                inputElement.focus();
                if (typeof inputElement.select === 'function') inputElement.select();
              }
            });
          });
        },
        previewReferenceAliasResolvedUrl() {
          const editData = this.refAliasEditData;
          if (!editData?.linkUuid) return '';
          const link = this.findLinkByUuid(editData.linkUuid);
          if (!link) return '';
          const details = this.getEffectiveLinkUrlDetails(link, {
            refLinkRows: editData.placeholderRows || []
          });
          return details.url || '';
        },
        getReferenceAliasUnresolvedPlaceholders() {
          const editData = this.refAliasEditData;
          if (!editData?.linkUuid) return [];
          const link = this.findLinkByUuid(editData.linkUuid);
          if (!link) return [];
          const details = this.getEffectiveLinkUrlDetails(link, {
            refLinkRows: editData.placeholderRows || []
          });
          return details.unresolved || [];
        },
        getReferenceAliasInheritedPlaceholderRows() {
          const editData = this.refAliasEditData;
          if (!editData?.linkUuid) return [];
          const link = this.findLinkByUuid(editData.linkUuid);
          if (!link) return [];
          const source = this.getReferenceSourceLink(link);
          const refGroup = this.findGroupContainingLinkUuid(link.uuid);
          return this.mergePlaceholderRowsForEditor([
            this.getGlobalPlaceholderList(),
            this.getGroupPlaceholderList(refGroup),
            this.getLinkPlaceholderList(source)
          ]);
        },
        getReferenceAliasInheritedPlaceholderMap() {
          const map = new Map();
          this.getReferenceAliasInheritedPlaceholderRows().forEach((row) => {
            const key = this.placeholderNameKey(row?.name);
            if (!key) return;
            map.set(key, row);
          });
          return map;
        },
        getReferenceAliasInheritedPlaceholderEntry(row) {
          const key = this.placeholderNameKey(row?.name);
          if (!key) return null;
          return this.getReferenceAliasInheritedPlaceholderMap().get(key) || null;
        },
        isReferenceAliasInheritedPlaceholder(row) {
          return !!this.getReferenceAliasInheritedPlaceholderEntry(row);
        },
        getReferenceAliasInheritedPlaceholderValue(row) {
          const entry = this.getReferenceAliasInheritedPlaceholderEntry(row);
          return entry ? String(entry.value || '') : '';
        },
        canRestoreReferenceAliasPlaceholder(row) {
          if (!this.isReferenceAliasInheritedPlaceholder(row)) return false;
          return !!String(row?.value || '').trim() || !!row?.encode;
        },
        restoreReferenceAliasPlaceholder(index = 0) {
          const rows = this.refAliasEditData?.placeholderRows;
          if (!Array.isArray(rows) || index < 0 || index >= rows.length) return;
          const current = rows[index];
          const inherited = this.getReferenceAliasInheritedPlaceholderEntry(current);
          if (!inherited) return;
          this.$set(current, 'name', inherited.name || current.name || '');
          this.$set(current, 'value', '');
          this.$set(current, 'encode', false);
        },
        saveReferenceAliasDialog() {
          const editData = this.refAliasEditData;
          if (!editData || !editData.linkUuid) {
            this.cancelReferenceAliasDialog();
            return;
          }

          const link = this.findLinkByUuid(editData.linkUuid);
          if (!link || !this.isReferenceLink(link)) {
            this.cancelReferenceAliasDialog();
            return;
          }

          const parentGroup = this.findGroupContainingLinkUuid(link.uuid);
          if (parentGroup && !this.canEdit(parentGroup)) {
            alert(this.getTranslation('error.perm.edit'));
            return;
          }

          const currentAlias = typeof link.text === 'string' ? link.text : '';
          const currentLocalKeywords = typeof link.keywords === 'string' ? link.keywords : '';
          const currentInherit = link.inheritSourceKeywords !== false;
          const currentRefRows = this.getLinkPlaceholderList(link);
          const nextAlias = String(editData.aliasText || '').trim();
          const nextLocalKeywords = this.joinKeywords(this.parseKeywords(editData.localKeywords || ''));
          const nextInherit = editData.inheritSourceKeywords !== false;
          const nextRefRows = this.normalizePlaceholderList(editData.placeholderRows || []);

          let changed = false;
          if (nextAlias !== currentAlias) {
            this.$set(link, 'text', nextAlias);
            changed = true;
          }
          if (nextLocalKeywords !== currentLocalKeywords) {
            this.$set(link, 'keywords', nextLocalKeywords);
            changed = true;
          }
          if (nextInherit !== currentInherit) {
            this.$set(link, 'inheritSourceKeywords', nextInherit);
            changed = true;
          }
          if (JSON.stringify(nextRefRows) !== JSON.stringify(currentRefRows)) {
            this.$set(link, 'urlPlaceholders', nextRefRows);
            changed = true;
          }

          if (changed) {
            const nowTs = this.touchLink(link);
            if (parentGroup) {
              this.touchGroup(parentGroup, nowTs);
              if (parentGroup.shared) parentGroup.version = (parentGroup.version || 0) + 1;

              if (parentGroup.useEventLog && this.eventLogManager) {
                const changes = {};
                if (nextAlias !== currentAlias) changes.text = nextAlias;
                if (nextLocalKeywords !== currentLocalKeywords) changes.keywords = nextLocalKeywords;
                if (nextInherit !== currentInherit) changes.inheritSourceKeywords = nextInherit;
                if (JSON.stringify(nextRefRows) !== JSON.stringify(currentRefRows)) changes.urlPlaceholders = nextRefRows;
                changes.lastModified = nowTs;
                this.createAndApplyEvent(parentGroup, {
                  type: 'link-edit',
                  linkId: link.uuid,
                  data: changes
                });
              } else if (parentGroup.shared && parentGroup.groupTopic && parentGroup.groupKey) {
                try {
                  const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
                  const linkToShare = this.serializeLinkForSync(link);
                  const env = {
                    v: 1,
                    type: 'share-links',
                    ts: Date.now(),
                    from,
                    groupId: parentGroup.groupId || parentGroup.uuid,
                    selection: { groups: [], links: [linkToShare] },
                    mode: 'merge',
                    msgId: (Math.random().toString(36).slice(2) + Date.now())
                  };
                  sharing.sendToGroup(parentGroup, env);
                } catch {}
              }
            }
            this.saveData();
          }
          this.cancelReferenceAliasDialog();
        },
        cancelReferenceAliasDialog() {
          this.hideModalById('referenceAliasModal');
          this.refAliasEditData = null;
          this.refAliasExpandedSections = {};
        },
        openGlobalPlaceholderDialog() {
          this.globalPlaceholderRows = this.getGlobalPlaceholderList().map(row => ({ ...row }));
          this.hideMenus();
          this.$nextTick(() => this.showModalById('globalPlaceholdersModal'));
        },
        addGlobalPlaceholderRow() {
          if (!Array.isArray(this.globalPlaceholderRows)) this.$set(this, 'globalPlaceholderRows', []);
          this.globalPlaceholderRows.push({ name: '', value: '', encode: false });
        },
        removeGlobalPlaceholderRow(index) {
          if (!Array.isArray(this.globalPlaceholderRows)) return;
          this.globalPlaceholderRows.splice(index, 1);
        },
        saveGlobalPlaceholderDialog() {
          if (!this.data.options) this.$set(this.data, 'options', {});
          if (!this.data.options.links) this.$set(this.data.options, 'links', {});
          const current = this.getGlobalPlaceholderList();
          const nextRows = this.normalizePlaceholderList(this.globalPlaceholderRows || []);
          if (JSON.stringify(current) !== JSON.stringify(nextRows)) {
            this.$set(this.data.options.links, 'globalPlaceholders', nextRows);
            this.saveData();
          }
          this.hideModalById('globalPlaceholdersModal');
        },
        // --- Inline Editing (Vue way) ---
        startEditing(item) {
          // Cancel any other active editing
          this.data.groups.forEach(g => {
            if (g.editing && g.uuid !== item.uuid) g.editing = false;
            g.links.forEach(l => {
              if (l.editing && l.uuid !== item.uuid) l.editing = false;
            });
          });
          // Permission enforcement: block inline edit for links in shared groups
          try {
            if (item && item.url !== undefined) { // treat as link
              const group = (this.data.groups||[]).find(g => Array.isArray(g.links) && g.links.some(l => l.uuid === item.uuid));
              if (group && group.shared && !this.canEdit(group)) {
                alert(this.getTranslation('error.perm.edit'));
                return;
              }
            }
          } catch {}
          const isLinkItem = !!(item && item.url !== undefined);
          const isRefLink = isLinkItem && this.isReferenceLink(item);
          // Store original value in case of escape
          if (item && item.name !== undefined) {
            item._originalValue = item.name || '';
          } else {
            const originalText = item?.text || '';
            item._originalValue = originalText;
            // For reference links without local alias, prefill inline editor with effective text.
            if (isRefLink && !String(originalText).trim()) {
              const seedValue = this.getEffectiveLinkText(item) || '';
              this.$set(item, 'text', seedValue);
              item._refAliasWasEmpty = true;
              item._refEditSeedValue = seedValue;
            } else {
              delete item._refAliasWasEmpty;
              delete item._refEditSeedValue;
            }
          }
          this.$set(item, 'editing', true); // Ensure reactivity
          if (isLinkItem) {
            this.hideLinkPopover();
          }
          // Focus handled by v-focus directive
        },
        saveEditing(item) {
          if (!item) return;
          const isLinkItem = !!(item && item.url !== undefined);
          const isRefLink = isLinkItem && this.isReferenceLink(item);
          // Trim and check if changed
          let newValue = (item.name !== undefined ? item.name : item.text || '').trim();
          const oldValue = item._originalValue || '';
          const valueKey = item.name !== undefined ? 'name' : 'text';

          // Permission enforcement for links
          try {
            if (isLinkItem) { // link
              const group = (this.data.groups||[]).find(g => Array.isArray(g.links) && g.links.some(l => l.uuid === item.uuid));
              if (group && group.shared && !this.canEdit(group)) {
                alert(this.getTranslation('error.perm.edit'));
                // revert if was editing
                if (item._originalValue !== undefined) item[valueKey] = item._originalValue;
                item.editing = false;
                delete item._originalValue;
                delete item._refAliasWasEmpty;
                delete item._refEditSeedValue;
                return;
              }
            }
          } catch {}

          if (isRefLink && item._refAliasWasEmpty && newValue === String(item._refEditSeedValue || '').trim()) {
            // Seed value was untouched -> keep no local alias
            newValue = '';
          }

          if (!isRefLink && newValue === '') { // Revert if empty
            item[valueKey] = oldValue;
          } else {
            item[valueKey] = newValue; // Update with trimmed value
            if (newValue !== oldValue) {
              const nowTs = isLinkItem
                ? this.touchLink(item)
                : this.touchGroup(item);
              this.saveData();
              // Mark local edit timestamp + hash for conflict resolution (links only)
              try {
                if (isLinkItem) {
                  const nb = Object.assign({}, item.ncBookmarks||{}, { localUpdatedAt: nowTs });
                  // Do NOT update lastHash here; keep last synced signature as baseline
                  this.$set(item, 'ncBookmarks', nb);
                  debugLog('log', '[NC SYNC] Inline edit marked localUpdatedAt', { id: nb.id, localUpdatedAt: nb.localUpdatedAt });
                }
              } catch {}
              // If this is a link editing its text inline, broadcast to shared group
              try {
                // Check if item is a link (has url property, even if empty)
                if (isLinkItem) {
                  const group = (this.data.groups||[]).find(g=>Array.isArray(g.links) && g.links.some(l=>
                    item.uuid && l.uuid === item.uuid
                  ));
                  if (group) {
                    this.touchGroup(group, nowTs);
                    // Update version for sync tracking (only for shared groups)
                    if (group.shared) {
                      group.version = (group.version || 0) + 1;
                      debugLog('log', '[SYNC] Updated group version after inline edit', { groupId: group.groupId, version: group.version });
                    }

                    // Event-log integration for inline edit (for ALL groups with event-log)
                    if (group.useEventLog && group.eventLog && this.eventLogManager) {
                      // Only track what actually changed
                      const changes = {};
                      const oldValues = {};

                      // For inline edit, we mainly change the text
                      if (oldValue !== newValue) {
                        changes.text = newValue;
                        oldValues.text = oldValue;
                      }

                      changes.lastModified = nowTs;

                      debugLog('log', '[INLINE-EDIT] Creating event-log entry for link edit:', {
                        groupName: group.name,
                        groupId: group.groupId,
                        linkId: item.uuid,
                        oldText: oldValue,
                        newText: newValue,
                        isShared: group.shared
                      });

                      // Create and apply event using helper
                      this.createAndApplyEvent(group, {
                        type: 'link-edit',
                        linkId: item.uuid,
                        data: changes  // Just the changes, not wrapped
                      });
                    } else if (group.shared && group.groupTopic && group.groupKey && !group.useEventLog) {
                      // Legacy sync ONLY if event-log is NOT active and group is shared
                      const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                      const linkToShare = this.serializeLinkForSync(item);
                      debugLog('log', '[SYNC] Broadcasting inline-edited link (legacy)', {
                        uuid: linkToShare.uuid,
                        text: linkToShare.text,
                        url: linkToShare.url,
                        hasUrl: !!linkToShare.url && linkToShare.url !== ''
                      });
                      const env = { v:1, type:'share-links', ts:Date.now(), from, groupId: group.groupId, selection:{ groups:[], links:[linkToShare] }, mode:'merge', msgId:(Math.random().toString(36).slice(2)+Date.now()) };
                      sharing.sendToGroup(group, env);
                    }
                  }
                }
              } catch (error) {
                debugLog('error', '[SYNC] Failed to broadcast inline edit:', error);
              }
            }
          }
          item.editing = false;
          delete item._originalValue;
          delete item._refAliasWasEmpty;
          delete item._refEditSeedValue;
        },
        cancelEditing(item) {
          if (item && item.editing) {
            const valueKey = item.name !== undefined ? 'name' : 'text';
            if (item._originalValue !== undefined) {
              item[valueKey] = item._originalValue; // Revert to original
            }
            item.editing = false;
            delete item._originalValue;
            delete item._refAliasWasEmpty;
            delete item._refEditSeedValue;
          }
        },

        // --- Context Menus (Vue way) ---
        showMenu(event, type, item, groupContext = null) {
          event.preventDefault();
          event.stopPropagation(); // Verhindert, dass der globale Klick-Listener sofort schließt

          this.hideMenus(); // Andere Menüs ausblenden

          this.contextMenuTarget = { type: type, item: item, groupContext: groupContext };

          // Verwende nextTick, um sicherzustellen, dass das Menü-Element (falls neu gerendert) im DOM ist
        this.$nextTick(() => {
          const menuId = type === 'link' ? 'linkMenu' : 'groupMenu';
          const menu = document.getElementById(menuId);
          if (!menu) {
            debugLog('error', "Context menu element not found:", menuId);
            return;
          }

            // Stelle sicher, dass das Menü sichtbar ist, um Dimensionen zu messen (kann kurz unsichtbar bleiben)
            const initialDisplay = menu.style.display;
            const initialVisibility = menu.style.visibility;
            menu.style.display = 'block'; // Muss block sein für offsetWidth/Height
            menu.style.visibility = 'hidden'; // Aber noch nicht sichtbar machen

            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;

            // Reset styles before calculating final position
            menu.style.display = initialDisplay; // Zurücksetzen, falls es vorher none war
            menu.style.visibility = initialVisibility; // Zurücksetzen

            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const padding = 5; // Kleiner Abstand zum Rand
            const clamp = (value, min, max) => {
              const low = Math.min(min, max);
              const high = Math.max(min, max);
              return Math.min(Math.max(value, low), high);
            };

            let x = event.clientX;
            let y = event.clientY;

            const menuMaxWidth = Math.max(1, windowWidth - (padding * 2));
            const menuMaxHeight = Math.max(1, windowHeight - (padding * 2));
            const boundedMenuWidth = Math.min(menuWidth, menuMaxWidth);
            const boundedMenuHeight = Math.min(menuHeight, menuMaxHeight);

            // Berechne maximale erlaubte X/Y-Koordinaten
            const maxX = windowWidth - boundedMenuWidth - padding;
            const maxY = windowHeight - boundedMenuHeight - padding;

            // Stelle sicher, dass x und y innerhalb der Grenzen liegen
            x = clamp(x, padding, maxX);
            y = clamp(y, padding, maxY);

            // Setze den Stil und mache das Menü sichtbar
          this.contextMenuStyle = {
            top: `${y}px`,
            left: `${x}px`,
            maxWidth: `${Math.floor(menuMaxWidth)}px`,
            maxHeight: `${Math.floor(menuMaxHeight)}px`,
            overflowX: menuWidth > menuMaxWidth ? 'auto' : '',
            overflowY: menuHeight > menuMaxHeight ? 'auto' : ''
          };
          if (type === 'link') this.isLinkMenuVisible = true;
          if (type === 'group') this.isGroupMenuVisible = true;

          // After showing, clamp submenus so they never leave the viewport
          this.$nextTick(() => {
            try {
              const padding2 = 8;
              const winW = window.innerWidth;
              const winH = window.innerHeight;
              const subs = menu.querySelectorAll('.submenu');
              subs.forEach((li) => {
                const fly = li.querySelector(':scope > .context-submenu');
                if (!fly) return;

                // Temporarily show to measure
                const prevDisp = fly.style.display;
                const prevVis = fly.style.visibility;
                fly.style.display = 'block';
                fly.style.visibility = 'hidden';
                fly.style.position = 'fixed';
                fly.style.left = '0px';
                fly.style.right = 'auto';
                fly.style.top = '0px';
                fly.style.bottom = 'auto';
                fly.style.maxWidth = '';
                fly.style.maxHeight = '';
                fly.style.overflowX = '';
                fly.style.overflowY = '';

                const flyW = fly.offsetWidth || 220;
                const flyH = fly.offsetHeight || 240;

                // Position check relative to viewport
                const liRect = li.getBoundingClientRect();
                const viewportMaxW = Math.max(1, winW - (padding2 * 2));
                let boundedFlyW = Math.min(flyW, viewportMaxW);
                if (flyW > viewportMaxW) {
                  fly.style.maxWidth = `${Math.floor(viewportMaxW)}px`;
                  fly.style.overflowX = 'auto';
                }

                // Keep submenu inside viewport vertically
                const viewportMaxH = Math.max(1, winH - (padding2 * 2));
                const cssMaxHRaw = parseFloat(window.getComputedStyle(fly).maxHeight || '');
                const cssMaxH = Number.isFinite(cssMaxHRaw) ? cssMaxHRaw : Infinity;
                const effectiveMaxH = Math.min(viewportMaxH, cssMaxH);
                const boundedFlyH = Math.min(flyH, effectiveMaxH);

                if (flyH > effectiveMaxH) {
                  fly.style.maxHeight = `${Math.floor(effectiveMaxH)}px`;
                  fly.style.overflowY = 'auto';
                }

                const rightX = liRect.right;
                const leftX = liRect.left - boundedFlyW;
                const rightFits = (rightX + boundedFlyW + padding2) <= winW;
                const leftFits = leftX >= padding2;
                let openLeft = false;
                let submenuX = rightX;

                if (rightFits) {
                  submenuX = rightX;
                } else if (leftFits) {
                  submenuX = leftX;
                  openLeft = true;
                } else {
                  submenuX = clamp(rightX, padding2, winW - boundedFlyW - padding2);
                  openLeft = submenuX < rightX;
                }

                submenuX = clamp(submenuX, padding2, winW - boundedFlyW - padding2);
                if (openLeft) li.classList.add('open-left');
                else li.classList.remove('open-left');

                let submenuY = liRect.top;
                if (submenuY + boundedFlyH + padding2 > winH) submenuY = winH - boundedFlyH - padding2;
                if (submenuY < padding2) submenuY = padding2;

                fly.style.left = `${Math.round(submenuX)}px`;
                fly.style.top = `${Math.round(submenuY)}px`;

                // restore
                fly.style.display = prevDisp;
                fly.style.visibility = prevVis;
              });
            } catch (e) { debugLog('warn', 'submenu adjust failed', e); }
          });

            // Optional: Kleiner Timeout, falls es immer noch Probleme gibt (normalerweise nicht nötig)
            /*
            setTimeout(() => {
                if (type === 'link') this.isLinkMenuVisible = true;
                if (type === 'group') this.isGroupMenuVisible = true;
            }, 0);
            */
          });
        },
        showLinkMenu(event, group, link) {
          this.showMenu(event, 'link', link, group);
        },
        showGroupMenu(event, group) {
          this.showMenu(event, 'group', group);
        },
        hideMenus() {
          this.isLinkMenuVisible = false;
          this.isGroupMenuVisible = false;
          this.contextMenuTarget = null; // Clear the target
        },
        createReferenceLinkFromContext(sourceGroup, sourceLink) {
          if (!sourceLink) {
            this.hideMenus();
            return;
          }

          if (this.isReferenceLink(sourceLink) || this.isSeparatorLink(sourceLink) || this.isNoteLink(sourceLink)) {
              this.showToast(
              this.getTranslation('link.ref.createFromRefDisabled') || 'Create ref link is only available for original URL links.',
              'info'
            );
            this.hideMenus();
            return;
          }

          const source = sourceLink;
          if (!source?.uuid) {
            alert(this.getTranslation('link.ref.sourceMissing') || 'Original link could not be resolved.');
            this.hideMenus();
            return;
          }

          const targetGroup = sourceGroup || this.findGroupContainingLinkUuid(sourceLink.uuid);
          if (!targetGroup) {
            alert(this.getTranslation('link.ref.invalidTarget') || 'Invalid group selection.');
            this.hideMenus();
            return;
          }

          if (!this.canAdd(targetGroup)) {
            alert(this.getTranslation('error.perm.add'));
            this.hideMenus();
            return;
          }

          // No alias prompt on creation: new ref should mirror original text by default.
          this.createReferenceLink(source, targetGroup, '', {
            insertAfterLinkUuid: sourceLink.uuid
          });
          this.hideMenus();
        },
        createReferenceLink(sourceLink, targetGroup, aliasText = '', options = {}) {
          if (!sourceLink?.uuid || !targetGroup || this.isSeparatorLink(sourceLink) || this.isNoteLink(sourceLink)) return;

          const nowTs = Date.now();
          if (!Array.isArray(targetGroup.links)) this.$set(targetGroup, 'links', []);
          const links = targetGroup.links;

          const insertAfterLink = options?.insertAfterLinkUuid
            ? links.find(l => l.uuid === options.insertAfterLinkUuid)
            : null;
          const targetColumn = Number.isFinite(options?.targetColumn)
            ? Number(options.targetColumn)
            : Number(insertAfterLink?.column ?? 0);

          let nextIndex = 0;
          if (insertAfterLink) {
            nextIndex = Number(insertAfterLink.index || 0) + 1;
            links.forEach(link => {
              if ((link.column || 0) === targetColumn && (link.index || 0) >= nextIndex) {
                link.index = (link.index || 0) + 1;
              }
            });
          } else {
            const columnLinks = links.filter(l => (l.column || 0) === targetColumn);
            nextIndex = columnLinks.length ? Math.max(...columnLinks.map(l => Number(l.index) || 0)) + 1 : 0;
          }

          const refLink = {
            uuid: this.generateUUID(),
            itemType: 'ref',
            text: String(aliasText || '').trim(),
            url: '',
            urlPlaceholders: [],
            keywords: '',
            inheritSourceKeywords: true,
            shortcut: '',
            color: '',
            infoHtml: '',
            emoji: '',
            column: targetColumn,
            index: nextIndex,
            refTargetUuid: sourceLink.uuid,
            isReference: true,
            editing: false,
            isMouseOver: false,
            createdAt: nowTs,
            lastModified: nowTs
          };

          links.push(refLink);

          const refTs = this.touchLink(refLink, nowTs);
          this.touchGroup(targetGroup, refTs);
          this.saveData();
          this.maybeAutoAdjustGroupHeightAfterLinkChange(targetGroup);
          this.showToast(this.getTranslation('link.ref.created') || 'Reference link created.', 'success');
        },
        editOriginalLinkFromReference(link) {
          const source = this.getReferenceSourceLink(link);
          if (!source) {
            this.showToast(this.getTranslation('link.ref.sourceMissing') || 'Original link could not be resolved.', 'warning');
            this.hideMenus();
            return;
          }
          this.showLinkEditModal(source);
        },
        shareResolvedLink(link) {
          const effectiveUrl = this.getEffectiveLinkUrl(link);
          if (!effectiveUrl) return;
          const payload = Object.assign({}, link, {
            itemType: 'link',
            text: this.getEffectiveLinkText(link) || effectiveUrl,
            url: effectiveUrl,
            keywords: this.getEffectiveLinkKeywords(link),
            infoHtml: this.getEffectiveLinkInfoHtml(link),
            emoji: this.getEffectiveLinkEmoji(link),
            favicon: this.getEffectiveLinkFavicon(link),
            faviconError: this.getEffectiveLinkFaviconError(link),
            refTargetUuid: '',
            inheritSourceKeywords: true,
            urlPlaceholders: []
          });
          this.shareLink(payload);
        },
        // Search removed by request
        showLinkEditModal(link, options = {}) {
          if (this.isReferenceLink(link)) {
            this.openReferenceAliasDialog(link);
            return;
          }
          // Find the original link object in the data to ensure reactivity
          let originalLink = null;
          let parentGroup = null;
          for (const group of this.data.groups) {
            originalLink = group.links.find(l => 
              link.uuid && l.uuid === link.uuid
            );
            if (originalLink) {
              parentGroup = group;
              break;
            }
          }
          if (originalLink) {
            if (!this.canEdit(parentGroup)) { alert(this.getTranslation('error.perm.edit')); return; }
            
            // Prepare link data with defaults
            const linkData = JSON.parse(JSON.stringify(originalLink));
            if (linkData.infoHtml === undefined) linkData.infoHtml = '';
            if (linkData.keywords === undefined) linkData.keywords = '';
            if (linkData.color === undefined) linkData.color = '';
            if (linkData.shortcut === undefined) linkData.shortcut = '';
            if (linkData.itemType === undefined) linkData.itemType = this.normalizeLinkItemType(originalLink);
            this.normalizeLinkDataForItemType(linkData, linkData.itemType || 'link');
            // Include favicon fields in edit dialog data
            if (linkData.favicon === undefined) linkData.favicon = null;
            if (linkData.faviconError === undefined) linkData.faviconError = false;
            const inheritedLinkRows = this.mergePlaceholderRowsForEditor([
              this.getGlobalPlaceholderList(),
              this.getGroupPlaceholderList(parentGroup)
            ]);
            linkData.urlPlaceholders = this.isNonUrlLink(linkData)
              ? []
              : this.buildPlaceholderRowsForTemplate(
                '',
                this.getLinkPlaceholderList(originalLink),
                inheritedLinkRows
              );

            // Store original values for event-log comparison
            const originalValues = {
              text: originalLink.text || '',
              url: originalLink.url || '',
              keywords: originalLink.keywords || '',
              color: originalLink.color || '',
              infoHtml: originalLink.infoHtml || '',
              emoji: originalLink.emoji || '',
              shortcut: originalLink.shortcut || '',
              urlPlaceholders: JSON.stringify(this.getLinkPlaceholderList(originalLink)),
              itemType: this.normalizeLinkItemType(originalLink)
            };
            const editTitle = this.isSeparatorLink(originalLink)
              ? (this.getTranslation('menu.link.editSeparator') || this.getTranslation('menu.link.editLink'))
              : (this.isNoteLink(originalLink)
                ? (this.getTranslation('menu.link.editNote') || this.getTranslation('menu.link.editLink'))
                : this.getTranslation('menu.link.editLink'));
            
            // Use the generic dialog
            this.openGenericEditDialog(
              'link',
              linkData,
              this.linkEditDesign,
              editTitle,
              async (editedData) => {
                const previousUrl = (originalLink?.url || '').trim();
                const previousRawUrlInput = (originalLink?.rawUrlInput || '').trim();
                const itemType = this.normalizeLinkItemType(editedData);
                this.$set(editedData, 'itemType', itemType);
                // Normalize URL
                let url = '';
                if (!this.isNonUrlItemType(itemType)) {
                  url = MB.Utils.ensureProtocol((editedData.url || '').trim());
                }
                editedData.url = url;
                editedData.shortcut = this.normalizeShortcutText(editedData.shortcut || '');
                this.normalizeLinkDataForItemType(editedData, itemType);
                
                // Apply changes to the original link
                Object.assign(originalLink, editedData);
                this.$set(originalLink, 'keywords', (editedData.keywords || '').trim());
                const nowTs = this.touchLink(originalLink);
                originalLink.lastEdited = nowTs;
                this.touchGroup(parentGroup, nowTs);

                // Ensure favicon fields are properly copied
                if ('favicon' in editedData) {
                  this.$set(originalLink, 'favicon', editedData.favicon);
                }
                if ('faviconError' in editedData) {
                  this.$set(originalLink, 'faviconError', editedData.faviconError);
                }
                if ('faviconSource' in editedData) {
                  this.$set(originalLink, 'faviconSource', editedData.faviconSource);
                }
                if ('faviconRuleId' in editedData) {
                  this.$set(originalLink, 'faviconRuleId', editedData.faviconRuleId);
                }
                await this.refreshLinkFaviconAfterUrlChange(originalLink, previousUrl, previousRawUrlInput);
                
                // Event log for changes
                const changes = [];
                if (originalValues.text !== (editedData.text || '')) changes.push('text');
                if (originalValues.url !== url) changes.push('url');
                if (originalValues.keywords !== (editedData.keywords || '')) changes.push('keywords');
                if (originalValues.color !== (editedData.color || '')) changes.push('color');
                if (originalValues.infoHtml !== (editedData.infoHtml || '')) changes.push('info');
                if (originalValues.emoji !== (editedData.emoji || '')) changes.push('emoji');
                if (originalValues.shortcut !== (editedData.shortcut || '')) changes.push('shortcut');
                if (originalValues.urlPlaceholders !== JSON.stringify(editedData.urlPlaceholders || [])) changes.push('urlPlaceholders');
                if (originalValues.itemType !== itemType) changes.push('itemType');
                
                // Event-Log sync for shared groups with event-log enabled
                if (changes.length > 0 && parentGroup && parentGroup.useEventLog && this.eventLogManager) {
                  const changedData = {};
                  if (changes.includes('text')) changedData.text = editedData.text || '';
                  if (changes.includes('url')) changedData.url = url || '';
                  if (changes.includes('keywords')) changedData.keywords = editedData.keywords || '';
                  if (changes.includes('color')) changedData.color = editedData.color || '';
                  if (changes.includes('info')) changedData.infoHtml = this.sanitizeHtml(editedData.infoHtml || '');
                  if (changes.includes('emoji')) changedData.emoji = editedData.emoji || '';
                  if (changes.includes('shortcut')) changedData.shortcut = editedData.shortcut || '';
                  if (changes.includes('urlPlaceholders')) changedData.urlPlaceholders = editedData.urlPlaceholders || [];
                  if (changes.includes('itemType')) changedData.itemType = itemType;
                  changedData.lastModified = nowTs;

                  this.createAndApplyEvent(parentGroup, {
                    type: 'link-edit',
                    linkId: originalLink.uuid,
                    data: changedData
                  });
                }
                
                if (changes.length > 0 && parentGroup && (!parentGroup.useEventLog || !this.eventLogManager)) {
                  const event = {
                    type: 'link-edited',
                    ts: nowTs,
                    by: this.data.identity?.uuid || 'unknown',
                    linkId: originalLink.uuid,
                    text: `Edited link "${editedData.text || url}" (${changes.join(', ')})`
                  };
                  this.eventLogManager.addEvent(event, parentGroup);
                }
                
                // Save and sync
                this.saveData();
                
                // Sync to group members if this is a shared/synced group with proper topic/key
                try {
                  const sharing = window.sharing;
                  const canSyncGroup = sharing && parentGroup && parentGroup.shared && parentGroup.groupId && parentGroup.groupTopic && parentGroup.groupKey && !parentGroup.groupKey.startsWith('contact:');
                  if (canSyncGroup) {
                    const snapshot = {
                      action: 'update',
                      element: 'link',
                      group: this.serializeGroupMetaForSync(parentGroup),
                      link: this.serializeLinkForSync(originalLink),
                      ts: Date.now()
                    };
                    sharing.sendToGroup(parentGroup, snapshot);
                  }
                } catch {}
              },
              {
                parentGroupUuid: parentGroup?.uuid || '',
                parentGroupName: parentGroup?.name || ''
              }
            );
            if (options?.focusSection) {
              this.$nextTick(() => {
                this.focusGenericEditSection(options.focusSection, this.linkEditDesign);
              });
            }
          }
          this.hideMenus();
        },
        async saveLinkEditModal() {
          if (!this.editLink) return;
          let originalLink = null;
          let parentGroup = null;
          // Find the original link to update
          for (const group of this.data.groups) {
            originalLink = group.links.find(l => 
              this.editLink.uuid && l.uuid === this.editLink.uuid
            );
            if (originalLink) {
              parentGroup = group;
              break;
            }
          }
          // Normalize URL
          let url = MB.Utils.ensureProtocol(this.editLink.url || '');
          const editItemType = this.normalizeLinkItemType(this.editLink);
          if (this.isNonUrlItemType(editItemType)) url = '';

          if (originalLink) {
            if (!this.canEdit(parentGroup)) { alert(this.getTranslation('error.perm.edit')); return; }
            const previousUrl = (originalLink.url || '').trim();
            const previousRawUrlInput = (originalLink.rawUrlInput || '').trim();
            // Update existing link
            this.$set(originalLink, 'text', this.editLink.text.trim() || '');
            this.$set(originalLink, 'itemType', editItemType);
            this.$set(originalLink, 'url', url || ''); // Use empty string instead of null
            this.$set(originalLink, 'keywords', this.editLink.keywords?.trim() || '');
            this.$set(originalLink, 'shortcut', this.normalizeShortcutText(this.editLink.shortcut || ''));
            this.$set(originalLink, 'color', this.editLink.color || '');
            this.$set(originalLink, 'infoHtml', this.sanitizeHtml(this.editLink.infoHtml?.trim() || ''));
            this.normalizeLinkDataForItemType(originalLink, editItemType);
            // Update local timestamps for conflict resolution
            const nowTs = this.touchLink(originalLink);
            try {
              const nb = Object.assign({}, originalLink.ncBookmarks||{}, { localUpdatedAt: nowTs });
              // Do NOT update lastHash here; keep last synced signature as baseline
              this.$set(originalLink, 'ncBookmarks', nb);
              debugLog('log', '[NC SYNC] Marked local link edit', { id: nb.id, localUpdatedAt: nb.localUpdatedAt });
            } catch {}

            // Copy favicon from dialog state if present
            if (this.editLink.favicon) {
              this.$set(originalLink, 'favicon', this.editLink.favicon);
              this.$set(originalLink, 'faviconError', false);
            } else if (this.editLink.faviconError) {
              this.$set(originalLink, 'faviconError', true);
            }
            await this.refreshLinkFaviconAfterUrlChange(originalLink, previousUrl, previousRawUrlInput);
            // Update version for sync tracking
            this.touchGroup(parentGroup, nowTs);
            if (parentGroup.shared) {
              parentGroup.version = (parentGroup.version || 0) + 1;
              debugLog('log', '[SYNC] Updated group version after editing link', { groupId: parentGroup.groupId, version: parentGroup.version });
              
              // Event-log integration for edit
              debugLog('log', '[EVENT-LOG] Checking for event-log edit', {
                hasEventLog: !!parentGroup.eventLog,
                hasManager: !!this.eventLogManager,
                eventLogLength: parentGroup.eventLog?.length || 0
              });
              
              if (parentGroup.useEventLog && parentGroup.eventLog && this.eventLogManager) {
                // Capture what actually changed using stored original values
                const changes = {};
                const oldValues = {};
                
                // Use the stored original values, not the current link values
                const origValues = this.editLinkOriginalValues || {};
                
                const newText = this.editLink.text.trim() || '';
                const oldText = origValues.text || '';
                if (newText !== oldText) {
                  changes.text = newText;
                  oldValues.text = oldText;
                }
                
                const newUrl = url || '';
                const oldUrl = origValues.url || '';
                if (newUrl !== oldUrl) {
                  changes.url = newUrl;
                  oldValues.url = oldUrl;
                }
                
                const newKeywords = this.editLink.keywords?.trim() || '';
                const oldKeywords = origValues.keywords || '';
                if (newKeywords !== oldKeywords) {
                  changes.keywords = newKeywords;
                  oldValues.keywords = oldKeywords;
                }
                
                const newColor = this.editLink.color || '';
                const oldColor = origValues.color || '';
                // Only track color changes if it actually changed (not both empty/default)
                if (newColor !== oldColor && !((!newColor || newColor === 'default') && (!oldColor || oldColor === 'default'))) {
                  changes.color = newColor;
                  oldValues.color = oldColor;
                }
                
                const newInfo = this.sanitizeHtml(this.editLink.infoHtml?.trim() || '');
                const oldInfo = origValues.infoHtml || '';
                // Only track info changes if content actually changed
                if (newInfo !== oldInfo && !(newInfo === '' && oldInfo === '')) {
                  changes.infoHtml = newInfo;
                  oldValues.infoHtml = oldInfo;
                }
                
                // Only create event if something actually changed
                // Emoji change
                const newEmoji = (this.editLink.emoji || '').trim();
                const oldEmoji = (origValues.emoji || '').trim();
                if (newEmoji !== oldEmoji) {
                  changes.emoji = newEmoji;
                  oldValues.emoji = oldEmoji;
                }

                const newShortcut = this.normalizeShortcutText(this.editLink.shortcut || '');
                const oldShortcut = this.normalizeShortcutText(origValues.shortcut || '');
                if (newShortcut !== oldShortcut) {
                  changes.shortcut = newShortcut;
                  oldValues.shortcut = oldShortcut;
                }

                const newItemType = editItemType;
                const oldItemType = this.normalizeLinkItemType({ itemType: origValues.itemType || '', refTargetUuid: origValues.refTargetUuid || '' });
                if (newItemType !== oldItemType) {
                  changes.itemType = newItemType;
                  oldValues.itemType = oldItemType;
                }

                if (Object.keys(changes).length > 0) {
                  changes.lastModified = nowTs;
                  // Create and apply event using helper
                  this.createAndApplyEvent(parentGroup, {
                    type: 'link-edit',
                    linkId: originalLink.uuid,
                    data: changes  // Just the changes, not wrapped
                  });
                } // Close if (Object.keys(changes).length > 0)
              }
            }
            
            this.saveData();
            // Broadcast change to shared group (legacy sync only)
            try {
              if (parentGroup.shared && parentGroup.groupTopic && parentGroup.groupKey && !parentGroup.useEventLog) {
                const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                const linkToShare = this.serializeLinkForSync(originalLink);
                debugLog('log', '[SYNC] Broadcasting edited link', { uuid: linkToShare.uuid, hasUrl: !!linkToShare.url, text: linkToShare.text });
                const env = { v:1, type:'share-links', ts:Date.now(), from, groupId: parentGroup.groupId||parentGroup.uuid, selection:{ groups:[], links:[linkToShare] }, mode:'merge', msgId:(Math.random().toString(36).slice(2)+Date.now()) };
                await sharing.sendToGroup(parentGroup, env);
              }
            } catch {}
          } else {
            // Create new link via dialog
            const targetGroup = (this.data.groups || []).find(g => g.uuid === this.pendingNewLinkGroupId);
            if (!targetGroup) { debugLog('warn', 'No target group for new link'); return; }
            if (!this.canAdd(targetGroup)) { alert(this.getTranslation('error.perm.add')); return; }
            const nowTs = Date.now();
            const itemType = this.normalizeLinkItemType(this.editLink);
            const newLink = {
              uuid: this.generateUUID(), // UUID is the only identifier
              itemType,
              text: this.editLink.text.trim(),
              url: this.isNonUrlItemType(itemType) ? '' : (url || ''),
              rawUrlInput: this.isNonUrlItemType(itemType) ? '' : (this.editLink.url || '').trim(),
              urlPlaceholders: this.isNonUrlItemType(itemType) ? [] : this.normalizePlaceholderList(this.editLink.urlPlaceholders || []),
              keywords: itemType === 'separator' ? '' : (this.editLink.keywords?.trim() || ''),
              shortcut: itemType === 'separator' ? '' : this.normalizeShortcutText(this.editLink.shortcut || ''),
              color: this.editLink.color || '',
              emoji: itemType === 'separator' ? '' : (this.editLink.emoji || ''),
              infoHtml: itemType === 'separator' ? '' : this.sanitizeHtml(this.editLink.infoHtml?.trim() || ''),
              index: (targetGroup.links && targetGroup.links.length ? Math.max(...targetGroup.links.map(l => l.index)) + 1 : 0),
              column: 0,
              favicon: this.editLink.favicon || null,
              faviconError: this.editLink.faviconError || false,
              editing: false,
              isMouseOver: false,
              createdAt: nowTs,
              lastModified: nowTs,
            };
            this.normalizeLinkDataForItemType(newLink, itemType);
            targetGroup.links.push(newLink);
            const linkTimestamp = this.touchLink(newLink, nowTs);
            this.touchGroup(targetGroup, linkTimestamp);

            // Always apply favicon rules; extension fetch stays gated inside tryFetchAndSetFavicon
            if (url && MB.Utils.isValidHttpUrl(url)) {
              await this.tryFetchAndSetFavicon(newLink, url, this.editLink?.url || url);
            }

            this.saveData();
            this.maybeAutoAdjustGroupHeightAfterLinkChange(targetGroup);

            // Update version for sync tracking (only for shared groups)
            if (targetGroup.shared) {
              targetGroup.version = (targetGroup.version || 0) + 1;
            }

            // Event-log integration for new link from dialog (for ALL groups with event-log)
            if (targetGroup.useEventLog && targetGroup.eventLog && this.eventLogManager) {
              const event = {
                type: 'link-add',
                data: {
                  linkId: newLink.uuid,
                  data: {
                    uuid: newLink.uuid,
                    text: newLink.text || '',
                    url: newLink.url || '',
                    rawUrlInput: newLink.rawUrlInput || '',
                    keywords: newLink.keywords || '',
                    shortcut: newLink.shortcut || '',
                    color: newLink.color || '',
                    emoji: newLink.emoji || '',
                    infoHtml: this.sanitizeHtml(newLink.infoHtml || ''),
                    itemType: newLink.itemType || 'link',
                    refTargetUuid: newLink.refTargetUuid || '',
                    inheritSourceKeywords: newLink.inheritSourceKeywords !== false,
                    urlPlaceholders: this.normalizePlaceholderList(newLink.urlPlaceholders || []),
                    column: newLink.column || 0,
                    index: newLink.index || 0,
                    createdAt: newLink.createdAt || linkTimestamp,
                    lastModified: newLink.lastModified || linkTimestamp
                  }
                },
                authorId: this.data.identity?.uuid,
                timestamp: Date.now()
              };

              debugLog('log', '[EVENT-LOG] Creating link-add event from dialog', event);

              // Apply event locally
              const added = this.eventLogManager.addEvent(event, targetGroup);
              debugLog('log', '[EVENT-LOG] Event added:', added, 'New event count:', targetGroup.eventLog?.length || 0);

              // Send event to all members (only for shared groups)
              if (targetGroup.shared) {
                const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                const syncEvent = {
                  v: 1,
                  type: 'sync-event',
                  ts: Date.now(),
                  from,
                  groupId: targetGroup.groupId,
                  event: event,
                  msgId: (Math.random().toString(36).slice(2) + Date.now())
                };

                try {
                  await sharing.sendToGroup(targetGroup, syncEvent);
                  debugLog('log', '[EVENT-LOG] Sent link-add event to group members', {
                    groupId: targetGroup.groupId,
                    linkId: newLink.uuid
                  });
                } catch (error) {
                  debugLog('error', '[EVENT-LOG] Failed to send add event:', error);
                }
              }
            }
            
            // Broadcast to shared group (legacy only)
            try {
              if (targetGroup.shared && targetGroup.groupTopic && targetGroup.groupKey && !targetGroup.useEventLog) {
                const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                const linkToShare = this.serializeLinkForSync(newLink);
                debugLog('log', '[SYNC] Broadcasting new link from dialog', { uuid: linkToShare.uuid, hasUrl: !!linkToShare.url, text: linkToShare.text });
                const env = { v:1, type:'share-links', ts:Date.now(), from, groupId: targetGroup.groupId||targetGroup.uuid, selection:{ groups:[], links:[linkToShare] }, mode:'merge', msgId:(Math.random().toString(36).slice(2)+Date.now()) };
                await sharing.sendToGroup(targetGroup, env);
              }
            } catch {}
          }
          // Close generic edit dialog if open
          const genModal = document.getElementById('genericEditModal');
          if (genModal) {
            const inst = bootstrap.Modal.getInstance(genModal);
            if (inst) inst.hide();
          }
          // Reset states
          this.linkModalVisible = false;
          this.editLink = null;
          this.editLinkOriginalValues = null;
          this.pendingNewLinkGroupId = null;
        },
        openAddLinkDialog(group, options = {}) {
          if (!group) return;
          if (!this.canAdd(group)) { alert(this.getTranslation('error.perm.add')); return; }
          const targetGroup = group;
          const initialItemType = this.normalizeLinkItemType({ itemType: options?.initialItemType || 'link' });
          const inheritedLinkRows = this.mergePlaceholderRowsForEditor([
            this.getGlobalPlaceholderList(),
            this.getGroupPlaceholderList(targetGroup)
          ]);
          const linkData = {
            itemType: initialItemType,
            text: '',
            url: '',
            urlPlaceholders: this.isNonUrlItemType(initialItemType) ? [] : this.buildPlaceholderRowsForTemplate('', [], inheritedLinkRows),
            keywords: '',
            shortcut: '',
            color: '',
            emoji: '',
            infoHtml: '',
            favicon: null,
            faviconError: false,
            faviconUrl: ''
          };
          const title = initialItemType === 'separator'
            ? (this.getTranslation('group.separator.add') || 'Add separator')
            : (initialItemType === 'note'
              ? (this.getTranslation('group.note.add') || this.getTranslation('group.link.add') || 'Add')
              : (this.getTranslation('group.link.add') || 'Add'));
          this.openGenericEditDialog(
            'link',
            linkData,
            this.linkEditDesign,
            title,
            async (edited) => {
              try {
                if (!this.canAdd(targetGroup)) { alert(this.getTranslation('error.perm.add')); return; }
                const itemType = this.normalizeLinkItemType(edited);
                const rawInput = this.isNonUrlItemType(itemType) ? '' : (edited.url || '').trim();
                const url = this.isNonUrlItemType(itemType) ? '' : MB.Utils.ensureProtocol(edited.url || '');
                const neighbors = (targetGroup.links || []).filter(l => l.column === 0).sort((a,b)=>a.index-b.index);
                const last = neighbors[neighbors.length - 1];
                const nowTs = Date.now();
                const newLink = {
                  uuid: this.generateUUID(),
                  itemType,
                  text: (edited.text || '').trim(),
                  url: url || '',
                  rawUrlInput: rawInput,
                  urlPlaceholders: this.isNonUrlItemType(itemType) ? [] : this.normalizePlaceholderList(edited.urlPlaceholders || []),
                  keywords: itemType === 'separator' ? '' : (edited.keywords || '').trim(),
                  shortcut: itemType === 'separator' ? '' : this.normalizeShortcutText(edited.shortcut || ''),
                  color: edited.color || '',
                  emoji: itemType === 'separator' ? '' : (edited.emoji || ''),
                  infoHtml: itemType === 'separator' ? '' : this.sanitizeHtml((edited.infoHtml || '').trim()),
                  index: last ? (last.index + 1) : 0,
                  column: 0,
                  favicon: null,
                  faviconError: false,
                  editing: false,
                  isMouseOver: false,
                  createdAt: nowTs,
                  lastModified: nowTs
                };
                this.normalizeLinkDataForItemType(newLink, itemType);
                if (!Array.isArray(targetGroup.links)) this.$set(targetGroup, 'links', []);
                targetGroup.links.push(newLink);
                const newLinkTs = this.touchLink(newLink, nowTs);
                this.touchGroup(targetGroup, newLinkTs);

                // Always apply favicon rules; extension fetch stays gated inside tryFetchAndSetFavicon
                if (!this.isNonUrlLink(newLink) && url) {
                  await this.tryFetchAndSetFavicon(newLink, url, rawInput);
                }

                this.saveData();
                this.maybeAutoAdjustGroupHeightAfterLinkChange(targetGroup);

                // Update version for sync tracking (only for shared groups)
                if (targetGroup.shared) {
                  targetGroup.version = (targetGroup.version || 0) + 1;
                }

                // Event-log integration (for ALL groups with event-log)
                if (targetGroup.useEventLog && targetGroup.eventLog && this.eventLogManager) {
                  const event = {
                    type: 'link-add',
                    data: { linkId: newLink.uuid, data: {
                      uuid: newLink.uuid,
                      text: newLink.text || '',
                      url: newLink.url || '',
                      rawUrlInput: newLink.rawUrlInput || '',
                      keywords: newLink.keywords || '',
                      shortcut: newLink.shortcut || '',
                      color: newLink.color || '',
                      emoji: newLink.emoji || '',
                      infoHtml: newLink.infoHtml || '',
                      itemType: newLink.itemType || 'link',
                      refTargetUuid: newLink.refTargetUuid || '',
                      inheritSourceKeywords: newLink.inheritSourceKeywords !== false,
                      urlPlaceholders: this.normalizePlaceholderList(newLink.urlPlaceholders || []),
                      column: newLink.column || 0,
                      index: newLink.index || 0,
                      createdAt: newLink.createdAt || newLinkTs,
                      lastModified: newLink.lastModified || newLinkTs
                    }},
                    authorId: this.data.identity?.uuid,
                    timestamp: Date.now()
                  };
                  this.eventLogManager.addEvent(event, targetGroup);
                  // Only send sync events for shared groups
                  if (targetGroup.shared) {
                    try {
                      const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                      const syncEvent = MB.Sync.buildEnvelope(this, 'sync-event', { groupId: targetGroup.groupId, event });
                      await sharing.sendToGroup(targetGroup, syncEvent);
                    } catch (e) { debugLog('warn','[EVENT-LOG] send add failed', e); }
                  }
                }
                // Legacy share-links broadcast
                try {
                  if (targetGroup.shared && targetGroup.groupTopic && targetGroup.groupKey) {
                    const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                    const linkToShare = this.serializeLinkForSync(newLink);
                    const env = MB.Sync.buildEnvelope(this, 'share-links', { from, groupId: targetGroup.groupId||targetGroup.uuid, selection:{ groups:[], links:[linkToShare] }, mode:'merge' });
                    await sharing.sendToGroup(targetGroup, env);
                  }
                } catch {}
              } catch (e) {
                debugLog('error', '[ADD] failed', e);
              }
            },
            {
              parentGroupUuid: targetGroup?.uuid || '',
              parentGroupName: targetGroup?.name || ''
            }
          );
        },
        openAddSeparatorDialog(group) {
          this.openAddLinkDialog(group, { initialItemType: 'separator' });
        },
        openAddNoteDialog(group) {
          this.openAddLinkDialog(group, { initialItemType: 'note' });
        },
        async fetchMetadataForEditLink(force) {
          try {
            const url = (this.editLink?.url || '').trim();
            if (!url) return;
            this.metadataMessage = '';
            // Title
            if (force || (this.data.options?.links?.autoFetchTitle && (!this.editLink.text || this.editLink.text === this.editLink.url))) {
              this.titleFetchState = 'loading';
              const title = await this.tryFetchTitle(url);
              if (title) {
                this.editLink.text = title;
                this.titleFetchState = 'ok';
              } else {
                this.titleFetchState = 'fail';
              }
            }
            // Favicon
            if (this.data.options?.links?.autoFetchFavicon) {
              this.faviconFetchState = 'loading';
              try {
                await this.tryFetchAndSetFavicon(this.editLink, url);
                this.faviconFetchState = 'ok';
              } catch {
                this.faviconFetchState = 'fail';
              }
            }
          } catch (e) {
            this.metadataMessage = 'Metadata fetch failed';
            this.titleFetchState = this.titleFetchState === 'loading' ? 'fail' : this.titleFetchState;
            this.faviconFetchState = this.faviconFetchState === 'loading' ? 'fail' : this.faviconFetchState;
          }
        },
        isLikelyValidUrl(url) {
          if (!url) return false;
          const s = url.trim();
          // Allow schemes like http, https, ftp, smb, nfs, file, mailto, ws, wss
          const re = /^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)(?:\/\/)?\S+$/;
          // Also allow mailto: with address
          const mail = /^mailto:\S+@\S+$/i;
          return re.test(s) || mail.test(s);
        },
        async tryFetchTitle(url) {
          if (!url) return null;

          // Only use extension for all web requests
          if (this.extensionAvailable) {
            try {
              const metadata = await MB.Extension.fetchMetadata(url);
              if (metadata.title) {
                debugLog('log', 'Extension fetched title:', metadata.title);
                return metadata.title;
              }
            } catch (e) {
              debugLog('warn', 'Extension title fetch failed:', e.message);
            }
          }

          // Fallback: derive a readable title from the hostname/path if extension not available
          try {
            const u = new URL(url);
            const host = (u.hostname || '').replace(/^www\./i, '');
            // Use last non-empty path segment if present
            const segs = (u.pathname || '').split('/').filter(Boolean);
            const last = segs.length ? segs[segs.length - 1] : '';
            const pretty = (s) => s.replace(/[-_]+/g, ' ').replace(/\s+/g, ' ').trim();
            return pretty(last || host) || host || url;
          } catch {
            return url;
          }
        },
        async tryFetchAndSetFavicon(link, url, rawInput = null) {
          if (!url) return;
          if (this.isNonUrlLink(link)) return;

          // 0) Apply favicon rules first (no network if match exists)
          const rawCandidate = rawInput != null ? rawInput : (link?.rawUrlInput ?? null);
          const normalizedRaw = rawCandidate != null ? String(rawCandidate).trim() : null;
          if (this.applyFaviconRulesToLink(link, null, normalizedRaw)) return;

          // Extension fetch is optional and controlled by autoFetchFavicon only
          if (!this.data.options?.links?.autoFetchFavicon) return;

          // 1) Use extension for all web requests
          if (this.extensionAvailable) {
            try {
              const metadata = await MB.Extension.fetchMetadata(url);

              if (metadata.favicon) {
                debugLog('log', 'Extension fetched favicon successfully');
                // Store base64 favicon directly
                this.$set(link, 'favicon', metadata.favicon);
                this.$set(link, 'faviconError', false);
                this.$set(link, 'faviconSource', 'extension');
                this.$set(link, 'faviconRuleId', null);
              } else {
                debugLog('warn', 'Extension could not fetch favicon');
                this.$set(link, 'faviconError', true);
              }
            } catch (e) {
              debugLog('warn', 'Extension favicon fetch failed:', e.message);
              this.$set(link, 'faviconError', true);
            }
          } else if (this.data.options?.links?.autoFetchFavicon) {
            // 2) Extension not available but option is enabled - mark as error
            debugLog('warn', 'Favicon fetch requested but extension not available');
            this.$set(link, 'faviconError', true);
          }
        },
        async refreshLinkFaviconAfterUrlChange(link, previousUrl = '', previousRawUrlInput = '') {
          try {
            if (!link || this.isNonUrlLink(link)) return;

            const nextUrl = (link.url || '').trim();
            const nextRaw = (link.rawUrlInput || '').trim();
            const prevUrl = (previousUrl || '').trim();
            const prevRaw = (previousRawUrlInput || '').trim();

            if (nextUrl === prevUrl && nextRaw === prevRaw) return;

            // Keep manual uploads untouched when URL changes.
            if (link.faviconSource === 'upload') return;

            this.$set(link, 'favicon', null);
            this.$set(link, 'faviconError', false);
            this.$set(link, 'faviconSource', null);
            this.$set(link, 'faviconRuleId', null);

            if (!nextUrl) return;
            await this.tryFetchAndSetFavicon(link, nextUrl, nextRaw || null);
          } catch (err) {
            debugLog('warn', '[FaviconRules] refreshLinkFaviconAfterUrlChange failed', err);
          }
        },
        
        // Link detail popover helpers
        shouldShowLinkPopover() {
          const linksOptions = this.data?.options?.links;
          return linksOptions?.showLinkPopover !== false;
        },
        normalizeTimestampValue(value) {
          if (value === null || value === undefined) return null;
          if (value instanceof Date) return value.getTime();
          if (typeof value === 'number' && Number.isFinite(value)) return value;
          if (typeof value === 'string') {
            const trimmed = value.trim();
            if (!trimmed) return null;
            const numeric = Number(trimmed);
            if (!Number.isNaN(numeric) && Number.isFinite(numeric)) return numeric;
            const parsed = Date.parse(trimmed);
            if (!Number.isNaN(parsed)) return parsed;
          }
          return null;
        },
        isReferenceLink(link) {
          return !!(link && typeof link === 'object' && link.refTargetUuid);
        },
        normalizeLinkItemType(linkLike) {
          const source = (linkLike && typeof linkLike === 'object') ? linkLike : {};
          const rawType = String(source.itemType || '').trim().toLowerCase();
          if (rawType === 'separator') return 'separator';
          if (rawType === 'note') return 'note';
          if (rawType === 'ref') return 'ref';
          if (source.refTargetUuid) return 'ref';
          return 'link';
        },
        isSeparatorLink(link) {
          return this.normalizeLinkItemType(link) === 'separator';
        },
        isNoteLink(link) {
          return this.normalizeLinkItemType(link) === 'note';
        },
        isNonUrlItemType(itemType, refTargetUuid = '') {
          const normalized = this.normalizeLinkItemType({ itemType, refTargetUuid });
          return normalized === 'separator' || normalized === 'note';
        },
        isNonUrlLink(link) {
          const source = (link && typeof link === 'object') ? link : { itemType: link };
          return this.isNonUrlItemType(source.itemType || '', source.refTargetUuid || '');
        },
        getGroupLinkCount(group) {
          const links = Array.isArray(group?.links) ? group.links : [];
          return links.filter(link => !this.isSeparatorLink(link)).length;
        },
        normalizeLinkDataForItemType(linkObj, fallbackType = 'link') {
          const target = (linkObj && typeof linkObj === 'object') ? linkObj : {};
          const normalizedType = this.normalizeLinkItemType({ itemType: target.itemType || fallbackType, refTargetUuid: target.refTargetUuid || '' });
          target.itemType = normalizedType;
          if (normalizedType === 'separator') {
            target.refTargetUuid = '';
            target.inheritSourceKeywords = true;
            target.url = '';
            target.rawUrlInput = '';
            target.urlPlaceholders = [];
            target.keywords = '';
            target.shortcut = '';
            target.emoji = '';
            target.infoHtml = '';
            target.favicon = null;
            target.faviconError = false;
            target.faviconSource = null;
            target.faviconRuleId = null;
          } else if (normalizedType === 'note') {
            target.refTargetUuid = '';
            target.inheritSourceKeywords = true;
            target.url = '';
            target.rawUrlInput = '';
            target.urlPlaceholders = [];
            target.shortcut = '';
            target.favicon = null;
            target.faviconError = false;
            target.faviconSource = null;
            target.faviconRuleId = null;
            target.itemType = 'note';
          } else {
            target.urlPlaceholders = this.normalizePlaceholderList(target.urlPlaceholders || []);
            if (normalizedType === 'ref' || target.refTargetUuid) {
              target.itemType = 'ref';
            } else {
              target.refTargetUuid = '';
              target.itemType = 'link';
            }
          }
          return target;
        },
        findGroupContainingLinkUuid(linkUuid) {
          if (!linkUuid) return null;
          return (this.data.groups || []).find(g => Array.isArray(g.links) && g.links.some(l => l.uuid === linkUuid)) || null;
        },
        findLinkByUuid(linkUuid) {
          if (!linkUuid) return null;
          const group = this.findGroupContainingLinkUuid(linkUuid);
          if (!group) return null;
          return group.links.find(l => l.uuid === linkUuid) || null;
        },
        countReferenceLinksTo(linkUuid) {
          if (!linkUuid) return 0;
          let count = 0;
          (this.data.groups || []).forEach(group => {
            (group.links || []).forEach(link => {
              if (link && link.refTargetUuid === linkUuid) count += 1;
            });
          });
          return count;
        },
        getReferenceSourceLink(link, maxDepth = 12) {
          if (!this.isReferenceLink(link)) return null;
          const visited = new Set();
          if (link.uuid) visited.add(link.uuid);
          let currentUuid = link.refTargetUuid;
          let source = null;
          let depth = 0;
          while (currentUuid && depth < maxDepth) {
            if (visited.has(currentUuid)) break;
            visited.add(currentUuid);
            const target = this.findLinkByUuid(currentUuid);
            if (!target) break;
            source = target;
            if (!this.isReferenceLink(target)) return target;
            currentUuid = target.refTargetUuid;
            depth += 1;
          }
          return source;
        },
        getEffectiveLink(link) {
          if (!link) return null;
          if (this.isSeparatorLink(link)) return link;
          const source = this.getReferenceSourceLink(link);
          return source || link;
        },
        normalizePlaceholderName(name) {
          return String(name === undefined || name === null ? '' : name).trim();
        },
        placeholderNameKey(name) {
          return this.normalizePlaceholderName(name).toLowerCase();
        },
        normalizePlaceholderList(rows) {
          const list = Array.isArray(rows) ? rows : [];
          const normalized = [];
          const indexByKey = new Map();
          list.forEach((row) => {
            const normalizedName = this.normalizePlaceholderName(row?.name);
            if (!normalizedName) return;
            const key = this.placeholderNameKey(normalizedName);
            if (!key) return;
            const nextRow = {
              name: normalizedName,
              value: row?.value === undefined || row?.value === null ? '' : String(row.value),
              encode: !!row?.encode
            };
            if (indexByKey.has(key)) {
              normalized[indexByKey.get(key)] = nextRow;
            } else {
              indexByKey.set(key, normalized.length);
              normalized.push(nextRow);
            }
          });
          return normalized;
        },
        extractUrlPlaceholderNames(urlTemplate) {
          const template = (typeof urlTemplate === 'string') ? urlTemplate : '';
          if (!template) return [];
          const regex = /\{\{([^{}]+)\}\}/g;
          const names = [];
          const seen = new Set();
          let match = null;
          while ((match = regex.exec(template)) !== null) {
            const normalizedName = this.normalizePlaceholderName(match[1]);
            const key = this.placeholderNameKey(normalizedName);
            if (!normalizedName || seen.has(key)) continue;
            seen.add(key);
            names.push(normalizedName);
          }
          return names;
        },
        mergePlaceholderRowsForEditor(layers) {
          const merged = new Map();
          (Array.isArray(layers) ? layers : []).forEach((layer) => {
            this.normalizePlaceholderList(layer).forEach((entry) => {
              const key = this.placeholderNameKey(entry.name);
              if (!key) return;
              const value = (entry.value === undefined || entry.value === null) ? '' : String(entry.value);
              const existing = merged.get(key);
              const nextRow = {
                name: this.normalizePlaceholderName(entry.name),
                value,
                encode: !!entry.encode
              };
              if (!existing) {
                merged.set(key, nextRow);
                return;
              }
              // Empty values should not override an existing non-empty inherited value.
              if (value.trim() || !String(existing.value || '').trim()) {
                merged.set(key, nextRow);
              }
            });
          });
          return Array.from(merged.values());
        },
        buildPlaceholderRowsForTemplate(urlTemplate, scopedRows, inheritedRows = []) {
          const templateNames = this.extractUrlPlaceholderNames(urlTemplate);
          const scoped = this.normalizePlaceholderList(scopedRows || []);
          const inherited = this.normalizePlaceholderList(inheritedRows || []);
          const scopedByKey = new Map(scoped.map(row => [this.placeholderNameKey(row.name), row]));
          const orderedNames = [];
          const seenKeys = new Set();
          const addName = (rawName) => {
            const normalizedName = this.normalizePlaceholderName(rawName);
            const key = this.placeholderNameKey(normalizedName);
            if (!normalizedName || seenKeys.has(key)) return;
            seenKeys.add(key);
            orderedNames.push(normalizedName);
          };

          templateNames.forEach(addName);
          inherited.forEach((row) => addName(row.name));
          scoped.forEach((row) => addName(row.name));

          return orderedNames.map((name) => {
            const key = this.placeholderNameKey(name);
            const existing = scopedByKey.get(key);
            return existing
              ? { name: existing.name || name, value: existing.value || '', encode: !!existing.encode }
              : { name, value: '', encode: false };
          });
        },
        getGlobalPlaceholderList(overrideRows = null) {
          const source = overrideRows !== null ? overrideRows : (this.data?.options?.links?.globalPlaceholders || []);
          return this.normalizePlaceholderList(source);
        },
        getGroupPlaceholderList(group, overrideRows = null) {
          const source = overrideRows !== null ? overrideRows : (group?.urlPlaceholders || []);
          return this.normalizePlaceholderList(source);
        },
        getLinkPlaceholderList(link, overrideRows = null) {
          const source = overrideRows !== null ? overrideRows : (link?.urlPlaceholders || []);
          return this.normalizePlaceholderList(source);
        },
        mergePlaceholderLayers(layers) {
          const merged = new Map();
          (Array.isArray(layers) ? layers : []).forEach((layer) => {
            this.normalizePlaceholderList(layer).forEach((entry) => {
              const key = this.placeholderNameKey(entry.name);
              if (!key) return;
              const value = (entry.value === undefined || entry.value === null) ? '' : String(entry.value);
              // Empty = not set -> do not override lower layers
              if (!value.trim()) return;
              merged.set(key, {
                name: this.normalizePlaceholderName(entry.name),
                value,
                encode: !!entry.encode
              });
            });
          });
          return merged;
        },
        resolveUrlTemplatePlaceholders(urlTemplate, placeholderMap) {
          const template = (typeof urlTemplate === 'string') ? urlTemplate : '';
          if (!template) return { url: '', unresolved: [] };

          const unresolved = [];
          const unresolvedKeys = new Set();
          const regex = /\{\{([^{}]+)\}\}/g;
          const url = template.replace(regex, (fullMatch, rawName) => {
            const name = this.normalizePlaceholderName(rawName);
            const key = this.placeholderNameKey(name);
            if (!key) return '';
            const entry = (placeholderMap instanceof Map) ? placeholderMap.get(key) : null;
            if (!entry || !String(entry.value || '').trim()) {
              if (!unresolvedKeys.has(key)) {
                unresolvedKeys.add(key);
                unresolved.push(name);
              }
              return '';
            }
            const value = String(entry.value);
            return entry.encode ? encodeURIComponent(value) : value;
          });

          return { url, unresolved };
        },
        getEffectiveLinkUrlTemplate(link) {
          if (!link) return '';
          if (this.isNonUrlLink(link)) return '';
          if (this.isReferenceLink(link)) {
            const source = this.getReferenceSourceLink(link);
            if (source && typeof source.url === 'string') return source.url;
            return (typeof link.url === 'string') ? link.url : '';
          }
          return (typeof link.url === 'string') ? link.url : '';
        },
        getEffectiveLinkUrlDetails(link, overrides = {}) {
          if (!link) return { url: '', unresolved: [], template: '' };
          if (this.isNonUrlLink(link)) return { url: '', unresolved: [], template: '' };
          const template = this.getEffectiveLinkUrlTemplate(link);
          if (!template || template.indexOf('{{') === -1) {
            return { url: template || '', unresolved: [], template: template || '' };
          }
          const globalRows = this.getGlobalPlaceholderList(overrides.globalRows ?? null);

          if (this.isReferenceLink(link)) {
            const sourceLink = this.getReferenceSourceLink(link);
            const refGroup = this.findGroupContainingLinkUuid(link.uuid);
            const refGroupRows = this.getGroupPlaceholderList(refGroup, overrides.refGroupRows ?? null);
            const sourceLinkRows = this.getLinkPlaceholderList(sourceLink, overrides.sourceLinkRows ?? null);
            const refLinkRows = this.getLinkPlaceholderList(link, overrides.refLinkRows ?? null);
            const merged = this.mergePlaceholderLayers([globalRows, refGroupRows, sourceLinkRows, refLinkRows]);
            const resolved = this.resolveUrlTemplatePlaceholders(template, merged);
            return { ...resolved, template };
          }

          const group = this.findGroupContainingLinkUuid(link.uuid);
          const groupRows = this.getGroupPlaceholderList(group, overrides.groupRows ?? null);
          const linkRows = this.getLinkPlaceholderList(link, overrides.linkRows ?? null);
          const merged = this.mergePlaceholderLayers([globalRows, groupRows, linkRows]);
          const resolved = this.resolveUrlTemplatePlaceholders(template, merged);
          return { ...resolved, template };
        },
        getEffectiveLinkText(link) {
          if (!link) return '';
          if (this.isSeparatorLink(link)) return (typeof link.text === 'string') ? link.text : '';
          if (this.isReferenceLink(link)) {
            const alias = typeof link.text === 'string' ? link.text : '';
            if (alias.trim()) return alias;
          }
          const base = this.getEffectiveLink(link);
          const text = typeof base?.text === 'string' ? base.text : '';
          if (text.trim()) return text;
          const url = typeof base?.url === 'string' ? base.url : '';
          return url || '';
        },
        getEffectiveLinkUrl(link) {
          return this.getEffectiveLinkUrlDetails(link).url || '';
        },
        getEffectiveLinkKeywords(link) {
          if (!link) return '';
          if (this.isSeparatorLink(link)) return '';
          const localKeywords = (typeof link.keywords === 'string') ? link.keywords : '';
          if (!this.isReferenceLink(link)) return localKeywords;

          const inheritSourceKeywords = link.inheritSourceKeywords !== false;
          if (!inheritSourceKeywords) return localKeywords;

          const source = this.getReferenceSourceLink(link);
          const sourceKeywords = (typeof source?.keywords === 'string') ? source.keywords : '';
          if (!sourceKeywords) return localKeywords;
          if (!localKeywords) return sourceKeywords;

          return this.joinKeywords([
            ...this.parseKeywords(sourceKeywords),
            ...this.parseKeywords(localKeywords)
          ]);
        },
        getEffectiveLinkInfoHtml(link) {
          if (this.isSeparatorLink(link)) return '';
          const base = this.getEffectiveLink(link);
          return (base && typeof base.infoHtml === 'string') ? base.infoHtml : '';
        },
        getEffectiveLinkEmoji(link) {
          if (this.isSeparatorLink(link)) return '';
          const base = this.getEffectiveLink(link);
          return (base && typeof base.emoji === 'string') ? base.emoji : '';
        },
        getEffectiveLinkFavicon(link) {
          if (this.isSeparatorLink(link)) return '';
          const base = this.getEffectiveLink(link);
          return (base && typeof base.favicon === 'string') ? base.favicon : '';
        },
        getEffectiveLinkFaviconError(link) {
          if (this.isSeparatorLink(link)) return false;
          const base = this.getEffectiveLink(link);
          return !!base?.faviconError;
        },
        getEffectiveLinkRawUrlInput(link) {
          if (this.isSeparatorLink(link)) return '';
          const base = this.getEffectiveLink(link);
          return (base && typeof base.rawUrlInput === 'string') ? base.rawUrlInput : '';
        },
        getReferenceMarkerTitle(link) {
          if (!this.isReferenceLink(link)) return '';
          const source = this.getReferenceSourceLink(link);
          if (!source) return this.getTranslation('link.ref.missing') || 'Reference link (original missing)';
          const sourceTitle = this.getLinkDisplayTitle(source);
          return (this.getTranslation('link.ref.markerTitle') || 'Reference link') + `: ${sourceTitle}`;
        },
        getLinkDisplayTitle(link) {
          if (!link) return '';
          const text = this.getEffectiveLinkText(link).trim();
          if (text) return text;
          if (this.isSeparatorLink(link)) return this.getTranslation('link.separator.defaultLabel') || 'Separator';
          if (this.isNoteLink(link)) return this.getTranslation('link.note.defaultLabel') || 'Note';

          const url = (this.getEffectiveLinkUrl(link) || '').trim();
          if (!url) return this.getTranslation('link.popover.untitled') || 'Untitled link';

          try {
            const parsed = new URL(url);
            const host = (parsed.hostname || '').replace(/^www\./i, '');
            const segments = (parsed.pathname || '').split('/').filter(Boolean);
            const lastSegment = segments.length ? segments[segments.length - 1] : '';
            const candidate = lastSegment || host;
            if (!candidate) return url;
            return candidate.replace(/[-_]+/g, ' ');
          } catch {
            return url;
          }
        },
        buildLinkDisplayUrl(url) {
          if (!url) return '';
          try {
            const parsed = new URL(url);
            const host = (parsed.hostname || '').replace(/^www\./i, '');
            let display = host;
            if (parsed.pathname && parsed.pathname !== '/') display += parsed.pathname;
            if (parsed.search) display += parsed.search;
            if (display.length > 80) display = display.slice(0, 77) + '…';
            return display;
          } catch {
            return url.length > 80 ? url.slice(0, 77) + '…' : url;
          }
        },
        formatPopoverTimestamp(value) {
          const notAvailable = this.getTranslation('link.popover.notAvailable') || '—';
          const normalized = this.normalizeTimestampValue(value);
          if (normalized === null) {
            return { full: notAvailable, relative: '', raw: null };
          }

          const locale = (this.data?.options?.common?.language || navigator.language || 'en').toString();
          let full = '';
          try {
            full = new Intl.DateTimeFormat(locale, { dateStyle: 'medium', timeStyle: 'medium' }).format(new Date(normalized));
          } catch {
            try {
              full = new Date(normalized).toLocaleString();
            } catch {
              full = String(normalized);
            }
          }

          let relative = '';
          if (typeof Intl !== 'undefined' && typeof Intl.RelativeTimeFormat === 'function') {
            try {
              const diffSeconds = Math.round((normalized - Date.now()) / 1000);
              const absSeconds = Math.abs(diffSeconds);
              const units = [
                { unit: 'year', value: 31557600 },
                { unit: 'month', value: 2629800 },
                { unit: 'week', value: 604800 },
                { unit: 'day', value: 86400 },
                { unit: 'hour', value: 3600 },
                { unit: 'minute', value: 60 }
              ];
              let selectedUnit = 'second';
              let divisor = 1;
              for (const entry of units) {
                if (absSeconds >= entry.value) {
                  selectedUnit = entry.unit;
                  divisor = entry.value;
                  break;
                }
              }
              const formatter = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
              const valueInUnit = selectedUnit === 'second'
                ? diffSeconds
                : Math.round(diffSeconds / divisor);
              relative = formatter.format(valueInUnit, selectedUnit);
            } catch {}
          }

          return { full, relative, raw: normalized };
        },
        getPopoverFavicon(link) {
          if (!link) return '';
          if (this.data?.options?.links?.allowExternalFaviconService === false) {
            return '';
          }
          const effectiveFavicon = this.getEffectiveLinkFavicon(link);
          if (effectiveFavicon) return effectiveFavicon;

          const utils = (typeof MB !== 'undefined' && MB && MB.Utils) ? MB.Utils : null;
          const rawUrl = this.getEffectiveLinkUrl(link) || '';
          const ensuredUrl = utils?.ensureProtocol ? utils.ensureProtocol(rawUrl) : rawUrl;
          const isValid = utils?.isValidHttpUrl ? utils.isValidHttpUrl(ensuredUrl) : /^https?:\/\//i.test(ensuredUrl);
          if (!isValid) {
            return '';
          }

          try {
            const parsed = new URL(ensuredUrl);
            const domainParam = encodeURIComponent(parsed.origin || parsed.href);
            return `https://www.google.com/s2/favicons?sz=64&domain_url=${domainParam}`;
          } catch {
            return '';
          }
        },
        showLinkPopover(event, link) {
          try {
            if (!this.shouldShowLinkPopover()) {
              this.hideLinkPopover();
              return;
            }
            if (!link || link.editing || this.isSeparatorLink(link)) {
              this.hideLinkPopover();
              return;
            }

            if (this.linkPopoverHideTimer) {
              clearTimeout(this.linkPopoverHideTimer);
              this.linkPopoverHideTimer = null;
            }

            const isPointerCoarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
            if (isPointerCoarse && event?.type !== 'focusin') return;

            const target = event?.currentTarget || (event?.target && typeof event.target.closest === 'function'
              ? event.target.closest('.linkContainerListItem')
              : null);
            if (!target) return;

            const popover = this.linkPopover;
            popover.link = link;
            popover.url = this.getEffectiveLinkUrl(link) || '';
            popover.displayUrl = this.buildLinkDisplayUrl(this.getEffectiveLinkUrl(link) || '');
            popover.titleHtml = this.sanitizeInlineNoAnchor(this.getLinkDisplayTitle(link));
            popover.rawUrlInput = this.getEffectiveLinkRawUrlInput(link) || '';
            popover.favicon = this.getPopoverFavicon(link);
            let needsSave = false;
            let createdDisplay = this.formatPopoverTimestamp(link.createdAt);
            if (createdDisplay.raw === null) {
              const fallbackCreated = this.touchLink(link);
              createdDisplay = this.formatPopoverTimestamp(fallbackCreated);
              needsSave = true;
            }

            let updatedDisplay = this.formatPopoverTimestamp(link.lastModified ?? link.updatedAt ?? link.modifiedAt ?? null);
            if (updatedDisplay.raw === null) {
              const fallbackUpdated = this.touchLink(link);
              updatedDisplay = this.formatPopoverTimestamp(fallbackUpdated);
              needsSave = true;
            }

            if (createdDisplay.raw && updatedDisplay.raw && updatedDisplay.raw < createdDisplay.raw) {
              updatedDisplay = createdDisplay;
            }

            popover.createdAt = createdDisplay;
            popover.updatedAt = updatedDisplay;
            if (needsSave) {
              const parentGroup = (this.data.groups || []).find(g => Array.isArray(g.links) && g.links.includes(link));
              const referenceTs = updatedDisplay.raw || createdDisplay.raw;
              if (parentGroup && referenceTs) {
                this.touchGroup(parentGroup, referenceTs);
              }
              this.saveData();
            }
            popover.keywords = this.parseKeywords(this.getEffectiveLinkKeywords(link));
            popover.emoji = (this.getEffectiveLinkEmoji(link) || '').trim();
            popover.uuid = link.uuid || '';

            const rect = target.getBoundingClientRect();
            const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            const margin = 16;
            const widthHint = 320;

            let left = rect.right + margin;
            let top = rect.top;

            if (left + widthHint > viewportWidth - margin) {
              left = rect.left - widthHint - margin;
            }
            if (left < margin) left = Math.max(margin, rect.left);
            if (top < margin) top = margin;

            popover.style = {
              top: `${top}px`,
              left: `${left}px`
            };
            popover.visible = true;

            this.$nextTick(() => {
              const el = document.querySelector('.link-detail-popover');
              if (!el) return;
              const popRect = el.getBoundingClientRect();
              let adjustedLeft = popRect.left;
              let adjustedTop = popRect.top;

              if (popRect.right > viewportWidth - margin) {
                adjustedLeft = Math.max(margin, viewportWidth - popRect.width - margin);
              }
              if (popRect.left < margin) {
                adjustedLeft = margin;
              }
              if (popRect.bottom > viewportHeight - margin) {
                adjustedTop = Math.max(margin, viewportHeight - popRect.height - margin);
              }
              if (popRect.top < margin) {
                adjustedTop = margin;
              }

              if (adjustedLeft !== popRect.left || adjustedTop !== popRect.top) {
                this.linkPopover.style = {
                  top: `${adjustedTop}px`,
                  left: `${adjustedLeft}px`
                };
              }
            });
          } catch (e) {
            debugLog('warn', '[POPOVER] Failed to show link popover', e);
          }
        },
        queueHideLinkPopover() {
          if (this.linkPopoverHideTimer) {
            clearTimeout(this.linkPopoverHideTimer);
          }
          this.linkPopoverHideTimer = setTimeout(() => {
            this.hideLinkPopover();
          }, 150);
        },
        cancelHideLinkPopover() {
          if (this.linkPopoverHideTimer) {
            clearTimeout(this.linkPopoverHideTimer);
            this.linkPopoverHideTimer = null;
          }
        },
        hideLinkPopover() {
          this.cancelHideLinkPopover();
          if (this.linkPopover.visible) {
            this.linkPopover.visible = false;
            this.linkPopover.link = null;
          }
        },
        touchGroup(group, timestamp = Date.now()) {
          if (!group) return;
          const normalized = this.normalizeTimestampValue(timestamp);
          const ts = normalized ?? Date.now();
          const created = this.normalizeTimestampValue(group.createdAt) ?? ts;
          this.$set(group, 'createdAt', created);
          this.$set(group, 'lastModified', ts);
          return ts;
        },
        touchLink(link, timestamp = Date.now()) {
          if (!link) return Date.now();
          const normalized = this.normalizeTimestampValue(timestamp);
          const ts = normalized ?? Date.now();
          const created = this.normalizeTimestampValue(link.createdAt) ?? ts;
          this.$set(link, 'createdAt', created);
          this.$set(link, 'lastModified', ts);
          return ts;
        },
        ensureAllTimestamps() {
          const now = Date.now();
          let updated = false;
          (this.data.groups || []).forEach(group => {
            const groupCreated = this.normalizeTimestampValue(group.createdAt);
            const groupModified = this.normalizeTimestampValue(group.lastModified);
            if (groupCreated === null) {
              this.$set(group, 'createdAt', now);
              updated = true;
            } else if (group.createdAt !== groupCreated) {
              this.$set(group, 'createdAt', groupCreated);
            }
            if (groupModified === null) {
              this.$set(group, 'lastModified', groupCreated ?? now);
              updated = true;
            } else if (group.lastModified !== groupModified) {
              this.$set(group, 'lastModified', groupModified);
            }
            (group.links || []).forEach(link => {
              const linkCreated = this.normalizeTimestampValue(link.createdAt);
              const linkModified = this.normalizeTimestampValue(link.lastModified);
              if (linkCreated === null) {
                this.$set(link, 'createdAt', now);
                updated = true;
              } else if (link.createdAt !== linkCreated) {
                this.$set(link, 'createdAt', linkCreated);
              }
              if (linkModified === null) {
                this.$set(link, 'lastModified', linkCreated ?? now);
                updated = true;
              } else if (link.lastModified !== linkModified) {
                this.$set(link, 'lastModified', linkModified);
              }
            });
          });
          return updated;
        },
        
        // Info popup methods
        showInfoPopup(event, htmlContent) {
          if (this.infoPopupTimer) {
            clearTimeout(this.infoPopupTimer);
          }
          
          this.infoPopupContent = this.sanitizeHtml(String(htmlContent || ''));
          const popup = document.getElementById('infoPopup');
          if (!popup) return;
          
          popup.classList.add('show');
          
          // Position the popup near the cursor
          const rect = event.target.getBoundingClientRect();
          const popupWidth = 400; // max-width from CSS
          const popupHeight = 300; // max-height from CSS
          
          let left = rect.right + 10;
          let top = rect.top;
          
          // Adjust if popup would go off screen
          if (left + popupWidth > window.innerWidth) {
            left = rect.left - popupWidth - 10;
          }
          if (top + popupHeight > window.innerHeight) {
            top = window.innerHeight - popupHeight - 10;
          }
          
          popup.style.left = left + 'px';
          popup.style.top = top + 'px';
        },
        
        hideInfoPopup() {
          // Add a small delay to prevent flickering when moving between elements
          this.infoPopupTimer = setTimeout(() => {
            const popup = document.getElementById('infoPopup');
            if (popup) {
              popup.classList.remove('show');
              this.infoPopupContent = '';
            }
          }, 200);
        },
        
        toggleGroupInfo(group) {
          this.$set(group, 'infoExpanded', !group.infoExpanded);
        },
        
        // Helper methods for JSON serialization to avoid redundancy
        serializeLinkForSync(link) {
          const safe = link || {};
          const normalized = this.normalizeLinkDataForItemType(Object.assign({}, safe), this.normalizeLinkItemType(safe));
          const payload = {
            uuid: normalized.uuid || '',
            itemType: normalized.itemType || 'link',
            text: normalized.text || normalized.url || '',
            url: normalized.url || '',
            rawUrlInput: normalized.rawUrlInput || '',
            keywords: normalized.keywords || '',
            emoji: normalized.emoji || '',
            shortcut: normalized.shortcut || '',
            infoHtml: normalized.infoHtml || '',
            color: normalized.color || '',
            refTargetUuid: normalized.refTargetUuid || '',
            inheritSourceKeywords: normalized.inheritSourceKeywords !== false,
            urlPlaceholders: this.normalizePlaceholderList(normalized.urlPlaceholders || []),
            column: normalized.column || 0,
            index: typeof normalized.index === 'number' ? normalized.index : 0
          };
          const createdAt = this.normalizeTimestampValue(normalized.createdAt);
          const lastModified = this.normalizeTimestampValue(normalized.lastModified ?? normalized.updatedAt ?? normalized.modifiedAt ?? null);
          if (createdAt !== null) payload.createdAt = createdAt;
          if (lastModified !== null) payload.lastModified = lastModified;
          return payload;
        },
        
        serializeGroupMetaForSync(group) {
          return {
            name: group.name || '',
            emoji: group.emoji || '',
            shortcut: group.shortcut || '',
            color: group.color || '',
            favicon: group.favicon || '',
            faviconSource: group.faviconSource || null,
            faviconRuleId: group.faviconRuleId || null,
            infoHtml: group.infoHtml || '',
            urlPlaceholders: this.normalizePlaceholderList(group.urlPlaceholders || [])
          };
        },
        
        serializeGroupForSync(group) {
          return {
            ...this.serializeGroupMetaForSync(group),
            groupId: group.groupId || group.uuid,
            links: (group.links || []).map(l => this.serializeLinkForSync(l)),
            version: group.version || 0,  // CRITICAL: Always include version for sync
            // Include event-log data if available
            useEventLog: group.useEventLog || false,
            eventLog: group.eventLog || [],
            snapshot: group.snapshot || null,
            headEventId: group.headEventId || null,
            vectorClock: group.vectorClock || {}
          };
        },
        // Innerhalb von methods: { ... } der Vue-Instanz 'app'
        showGroupEditModal(group, options = {}) {
          const originalGroup = this.data.groups.find(g => g.uuid === group.uuid);
          if (originalGroup) {
            // Prepare group data with defaults
            const groupData = JSON.parse(JSON.stringify(originalGroup));
            // Ensure prefs structure exists
            if (!groupData.prefs) groupData.prefs = { inbound: { perMember: {} } };
            if (!groupData.prefs.inbound) groupData.prefs.inbound = { perMember: {} };
            if (!groupData.prefs.inbound.perMember) groupData.prefs.inbound.perMember = {};
            if (groupData.emoji === undefined) groupData.emoji = '';
            if (groupData.keywords === undefined) groupData.keywords = '';
            if (groupData.shortcut === undefined) groupData.shortcut = '';
            if (groupData.manualHeightResizeOverride === undefined) groupData.manualHeightResizeOverride = false;
            if (groupData.color === undefined) groupData.color = '';
            if (groupData.titleFormatting === undefined) groupData.titleFormatting = '';
            if (groupData.linkColor === undefined) groupData.linkColor = '';
            if (groupData.infoHtml === undefined) groupData.infoHtml = '';
            if (groupData.favicon === undefined) groupData.favicon = '';
            if (groupData.faviconError === undefined) groupData.faviconError = false;
            if (groupData.faviconLoading === undefined) groupData.faviconLoading = false;
            if (groupData.faviconSource === undefined) groupData.faviconSource = null;
            if (groupData.faviconRuleId === undefined) groupData.faviconRuleId = null;
            const inheritedGroupRows = this.mergePlaceholderRowsForEditor([
              this.getGlobalPlaceholderList()
            ]);
            groupData.urlPlaceholders = this.buildPlaceholderRowsForTemplate(
              '',
              this.getGroupPlaceholderList(originalGroup),
              inheritedGroupRows
            );
            
            // Use the generic dialog
            this.openGenericEditDialog(
              'group',
              groupData,
              this.groupEditDesign,
              this.getTranslation('menu.group.editGroup'),
              (editedData) => {
                editedData.shortcut = this.normalizeShortcutText(editedData.shortcut || '');
                // Apply changes to the original group
                const nowTs = Date.now();
                Object.assign(originalGroup, editedData);
                this.$set(originalGroup, 'keywords', (editedData.keywords || '').trim());
                this.$set(originalGroup, 'shortcut', editedData.shortcut || '');
                originalGroup.lastEdited = nowTs;
                this.touchGroup(originalGroup, nowTs);

                // Save and sync
                this.saveData();
                this.maybeAutoAdjustGroupHeightAfterLinkChange(originalGroup);
                
                // Sync to group members if this is a shared/synced group with proper topic/key
                try {
                  const sharing = window.sharing;
                  const canSyncGroup = sharing && originalGroup && originalGroup.shared && originalGroup.groupId && originalGroup.groupTopic && originalGroup.groupKey && !originalGroup.groupKey.startsWith('contact:');
                  if (canSyncGroup) {
                    const snapshot = {
                      action: 'update',
                      element: 'group',
                      group: this.serializeGroupMetaForSync(originalGroup),
                      ts: Date.now()
                    };
                    sharing.sendToGroup(originalGroup, snapshot);
                  }
                } catch {}
              },
              {
                groupUuid: originalGroup?.uuid || '',
                groupName: originalGroup?.name || ''
              }
            );
            if (options?.focusSection) {
              this.$nextTick(() => {
                this.focusGenericEditSection(options.focusSection, this.groupEditDesign);
              });
            }
          } else {
            debugLog('error', "Original group not found for editing:", group.uuid);
          }
          this.hideMenus(); // Menü trotzdem schließen
        },
        saveGroupEditModal() {
          if (!this.editGroup) return;
          const originalGroup = this.data.groups.find(g => g.uuid === this.editGroup.uuid);
          if (originalGroup) {
            const nowTs = Date.now();
            this.$set(originalGroup, 'name', this.editGroup.name.trim() || 'Group');
            this.$set(originalGroup, 'keywords', this.editGroup.keywords?.trim() || '');
            this.$set(originalGroup, 'shortcut', this.normalizeShortcutText(this.editGroup.shortcut || ''));
            this.$set(originalGroup, 'color', this.editGroup.color || '');
            this.$set(originalGroup, 'titleFormatting', this.editGroup.titleFormatting || '');
            this.$set(originalGroup, 'infoHtml', this.sanitizeHtml(this.editGroup.infoHtml?.trim() || ''));
            // Persist formatting fields correctly (override precedence: defaults < group < link)
            this.$set(originalGroup, 'linkFormatting', this.editGroup.linkFormatting || '');
            this.$set(originalGroup, 'badgeFormatting', this.editGroup.badgeFormatting || '');
            this.$set(originalGroup, 'pillFormatting', this.editGroup.pillFormatting || '');
            this.$set(originalGroup, 'infoHtml', this.editGroup.infoHtml?.trim() || '');
            const op = Number(this.editGroup.opacity);
            const clamped = isNaN(op) ? 100 : Math.max(0, Math.min(100, op));
            this.$set(originalGroup, 'opacity', clamped);
            this.touchGroup(originalGroup, nowTs);
            this.saveData();
            // Broadcast group-meta and snapshot if shared (Owner only)
            try {
              if (originalGroup.shared && originalGroup.groupTopic && originalGroup.groupKey && this.isOwnerOfGroup(originalGroup)) {
                const from = { uuid: this.data.identity?.uuid, name:this.data.identity?.name||'' };
                sharing.sendToGroup(originalGroup, { 
                  v:1, 
                  type:'group-meta', 
                  ts:Date.now(), 
                  from, 
                  groupId: originalGroup.groupId||originalGroup.uuid, 
                  ...this.serializeGroupMetaForSync(originalGroup) 
                });
                const snapshot = { 
                  v:1, 
                  type:'group-update', 
                  ts:Date.now(), 
                  from, 
                  ...this.serializeGroupForSync(originalGroup), 
                  msgId:(Math.random().toString(36).slice(2)+Date.now()) 
                };
                sharing.sendToGroup(originalGroup, snapshot);
              }
            } catch {}
          }
          // Use Bootstrap 5 JS API
          const modalElement = document.getElementById('groupEditModal');
          const modalInstance = bootstrap.Modal.getInstance(modalElement);
          if (modalInstance) {
            modalInstance.hide();
          }
          this.editGroup = null; // Clear edit state
        },
        
        // JSON Inspector methods
        inspectGroupJSON(group) {
          const originalGroup = this.data.groups.find(g => g.uuid === group.uuid);
          if (originalGroup) {
            this.inspectedGroup = originalGroup;
            // Pretty print JSON with 2 space indentation
            this.inspectedGroupJSON = JSON.stringify(originalGroup, null, 2);
            
            // Show the modal
            this.$nextTick(() => {
              const modalElement = document.getElementById('jsonInspectorModal');
              if (modalElement) {
                const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
                modalInstance.show();
              }
            });
          }
        },
        
        copyGroupJSON() {
          if (!this.inspectedGroupJSON) return;
          
          // Create a temporary textarea to copy from
          const textarea = document.createElement('textarea');
          textarea.value = this.inspectedGroupJSON;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          
          try {
            document.execCommand('copy');
            // Show success feedback
            const copyBtn = event.target.closest('button');
            if (copyBtn) {
              const originalText = copyBtn.innerHTML;
              copyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16"><path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.267.267 0 0 1 .02-.022z"/></svg> Copied!';
              setTimeout(() => {
                copyBtn.innerHTML = originalText;
              }, 2000);
            }
          } catch (err) {
            debugLog('error', 'Failed to copy JSON:', err);
            alert('Failed to copy JSON to clipboard');
          } finally {
            document.body.removeChild(textarea);
          }
        },
        
        formatBytes(bytes) {
          if (bytes === 0) return '0 Bytes';
          const k = 1024;
          const sizes = ['Bytes', 'KB', 'MB', 'GB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        },
        
        // Event Log Helper Methods
        getSortedEventLog(eventLog) {
          if (!eventLog || !Array.isArray(eventLog)) return [];
          // Sort by timestamp descending (newest first)
          return [...eventLog].sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        },
        
        formatEventTime(timestamp) {
          if (!timestamp) return 'N/A';
          const date = new Date(timestamp);
          const now = new Date();
          const diffMs = now - date;
          const diffMins = Math.floor(diffMs / CONSTS.MINUTE_MS);
          const diffHours = Math.floor(diffMs / 3600000);
          const diffDays = Math.floor(diffMs / 86400000);
          
          // Format full date and time with seconds
          const fullDateTime = moment(date).format('L LTS'); // Date + time with seconds
          
          // Calculate relative time
          let relativeTime;
          if (diffMins < 1) relativeTime = 'Just now';
          else if (diffMins < 60) relativeTime = `${diffMins} min ago`;
          else if (diffHours < 24) relativeTime = `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
          else if (diffDays < 7) relativeTime = `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
          else relativeTime = null;
          
          // Return both: full date/time and relative time (if recent)
          if (relativeTime) {
            return `${fullDateTime} (${relativeTime})`;
          } else {
            return fullDateTime;
          }
        },
        
        getEventTypeBadgeClass(type) {
          const typeClasses = {
            'link-add': 'bg-success',
            'link-edit': 'bg-primary',
            'link-delete': 'bg-danger',
            'snapshot': 'bg-info',
            'member-join': 'bg-warning',
            'member-leave': 'bg-secondary'
          };
          return typeClasses[type] || 'bg-secondary';
        },
        
        getAuthorName(authorId) {
          if (!authorId) return 'System';
          if (authorId === 'system') return 'System';
          if (authorId === this.data.identity?.uuid) return 'You';
          
          // Try to find in contacts
          const contact = this.data.contacts?.find(c => c.uuid === authorId);
          if (contact) return contact.name;
          
          // Try to find in group members
          if (this.inspectedGroup && this.inspectedGroup.members) {
            const member = this.inspectedGroup.members.find(m => m.uuid === authorId);
            if (member) return member.name;
          }
          
          // Show shortened UUID as fallback
          return authorId.substring(0, 8) + '...';
        },
        
        getEventDetailsFormatted(event) {
          const details = this.getEventDetails(event);
          
          // Support both event structures
          const eventType = event.operation?.type || event.type;
          const eventData = event.operation?.data || event.data;
          
          // For multi-field edits, format as list
          if (eventType === 'link-edit' && eventData) {
            // For operation structure, data contains changes directly
            // For legacy structure, data.changes contains the changes
            const changes = event.operation ? eventData : (eventData.changes || eventData);
            const lines = [];
            
            if (!eventData.oldValues) {
              // Reconstruct old values from history
              const eventLog = this.inspectedGroup?.eventLog;
              const reconstructed = this.reconstructOldValues(event, eventLog);
              const oldValues = reconstructed || {};
              
              // Show reconstructed old → new format
              if (changes.text !== undefined) {
                const oldText = oldValues.text || '';
                const newText = changes.text || '';
                const oldDisplay = oldText ? `"${this.escapeHtml(oldText)}"` : '<em>empty</em>';
                const newDisplay = newText ? `"${this.escapeHtml(newText)}"` : '<em>empty</em>';
                lines.push(`<strong>Text:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.url !== undefined) {
                const oldUrl = oldValues.url || '';
                const newUrl = changes.url || '';
                const shortOld = oldUrl.length > 40 ? oldUrl.substring(0, 40) + '...' : oldUrl;
                const shortNew = newUrl.length > 40 ? newUrl.substring(0, 40) + '...' : newUrl;
                const oldDisplay = oldUrl ? `"${this.escapeHtml(shortOld)}"` : '<em>empty</em>';
                const newDisplay = newUrl ? `"${this.escapeHtml(shortNew)}"` : '<em>empty</em>';
                lines.push(`<strong>URL:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.keywords !== undefined) {
                const oldKeywords = oldValues.keywords || '';
                const newKeywords = changes.keywords || '';
                const oldDisplay = oldKeywords ? `"${this.escapeHtml(oldKeywords)}"` : '<em>empty</em>';
                const newDisplay = newKeywords ? `"${this.escapeHtml(newKeywords)}"` : '<em>empty</em>';
                lines.push(`<strong>Keywords:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.color !== undefined) {
                const oldColor = oldValues.color || 'default';
                const newColor = changes.color || 'default';
                lines.push(`<strong>Color:</strong> <span style="background-color: ${oldColor === 'default' ? '#f8f9fa' : oldColor}; padding: 2px 6px; border-radius: 3px;">${this.escapeHtml(oldColor)}</span> → <span style="background-color: ${newColor === 'default' ? '#f8f9fa' : newColor}; padding: 2px 6px; border-radius: 3px;">${this.escapeHtml(newColor)}</span>`);
              }
              if (changes.infoHtml !== undefined) {
                lines.push(`<strong>Info text:</strong> updated`);
              }
            } else {
              // New events with oldValues - show old → new format
              const oldValues = eventData.oldValues;
              
              if (changes.text !== undefined) {
                const oldText = oldValues.text || '';
                const newText = changes.text || '';
                const oldDisplay = oldText ? `"${this.escapeHtml(oldText)}"` : '<em>empty</em>';
                const newDisplay = newText ? `"${this.escapeHtml(newText)}"` : '<em>empty</em>';
                lines.push(`<strong>Text:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.url !== undefined) {
                const oldUrl = oldValues.url || '';
                const newUrl = changes.url || '';
                const shortOld = oldUrl.length > 40 ? oldUrl.substring(0, 40) + '...' : oldUrl;
                const shortNew = newUrl.length > 40 ? newUrl.substring(0, 40) + '...' : newUrl;
                const oldDisplay = oldUrl ? `"${this.escapeHtml(shortOld)}"` : '<em>empty</em>';
                const newDisplay = newUrl ? `"${this.escapeHtml(shortNew)}"` : '<em>empty</em>';
                lines.push(`<strong>URL:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.keywords !== undefined) {
                const oldKeywords = oldValues.keywords || '';
                const newKeywords = changes.keywords || '';
                const oldDisplay = oldKeywords ? `"${this.escapeHtml(oldKeywords)}"` : '<em>empty</em>';
                const newDisplay = newKeywords ? `"${this.escapeHtml(newKeywords)}"` : '<em>empty</em>';
                lines.push(`<strong>Keywords:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.color !== undefined) {
                const oldColor = oldValues.color || 'default';
                const newColor = changes.color || 'default';
                lines.push(`<strong>Color:</strong> <span style="background-color: ${oldColor === 'default' ? '#f8f9fa' : oldColor}; padding: 2px 6px; border-radius: 3px;">${this.escapeHtml(oldColor)}</span> → <span style="background-color: ${newColor === 'default' ? '#f8f9fa' : newColor}; padding: 2px 6px; border-radius: 3px;">${this.escapeHtml(newColor)}</span>`);
              }
              if (changes.infoHtml !== undefined) {
                lines.push(`<strong>Info text:</strong> updated`);
              }
            }
            
            return this.sanitizeHtml(lines.join('<br>'));
          }
          
          // For simple cases, escape HTML and return sanitized
          return this.sanitizeHtml(this.escapeHtml(details));
        },
        
        escapeHtml(text) {
          const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
          };
          return text.replace(/[&<>"']/g, m => map[m]);
        },
        // Sanitize strings for safe v-html usage (small allowlist)
        sanitizeHtml(input) {
          try {
            const html = String(input || '');
            const allowedTags = new Set(['b','i','strong','em','u','br','p','ul','ol','li','span','a','small','code','pre']);
            const allowedAttrs = { a: new Set(['href','title','target','rel']) };
            const div = document.createElement('div');
            div.innerHTML = html;
            const traverse = (node) => {
              // Remove script/style and disallowed nodes
              if (node.nodeType === 1) {
                const tag = node.tagName.toLowerCase();
                if (!allowedTags.has(tag)) {
                  node.replaceWith(document.createTextNode(node.textContent || ''));
                  return;
                }
                // Remove event handlers and non-allowed attributes
                [...node.attributes].forEach(attr => {
                  const name = attr.name.toLowerCase();
                  if (name.startsWith('on')) node.removeAttribute(attr.name);
                  if (tag === 'a') {
                    if (!allowedAttrs.a.has(name)) node.removeAttribute(attr.name);
                    if (name === 'href') {
                      const href = (attr.value || '').trim();
                      const safe = /^(https?:|mailto:)/i.test(href) ? href : '#';
                      node.setAttribute('href', safe);
                      node.setAttribute('rel', 'noopener noreferrer');
                    }
                    if (name === 'target') {
                      node.setAttribute('target', '_blank');
                    }
                  } else {
                    if (name !== 'title') node.removeAttribute(attr.name);
                  }
                });
              }
              // Recurse children
              for (const child of [...node.childNodes]) traverse(child);
            };
            for (const child of [...div.childNodes]) traverse(child);
            return div.innerHTML;
          } catch (e) {
            debugLog('warn', 'sanitizeHtml failed', e);
            return '';
          }
        },
        // Sanitize inline HTML for link text inside an <a>: unwrap any nested anchors
        sanitizeInlineNoAnchor(input) {
          try {
            const html = this.sanitizeHtml(input || '');
            const div = document.createElement('div');
            div.innerHTML = html;
            const anchors = div.querySelectorAll('a');
            anchors.forEach(a => {
              const span = document.createElement('span');
              span.innerHTML = a.innerHTML; // keep inner formatting, drop href/target
              a.parentNode.replaceChild(span, a);
            });
            return div.innerHTML;
          } catch (e) {
            debugLog('warn', 'sanitizeInlineNoAnchor failed', e);
            return '';
          }
        },
        // Central keyword parsing helper
        parseKeywords(value) {
          if (!value) return [];
          if (Array.isArray(value)) return value.map(s => String(s).trim()).filter(Boolean);
          if (typeof value === 'string') return value.split(/[,;]+/).map(s => s.trim()).filter(Boolean);
          return [];
        },
        
        reconstructOldValues(event, allEvents) {
          // Find the previous state of this link by going through history
          // Support both event structures
          const linkId = event.operation?.linkId || event.data?.linkId;
          if (!linkId || !allEvents) return null;
          
          // Find events for this link before the current event
          const linkEvents = allEvents.filter(e => {
            const eLinkId = e.operation?.linkId || e.data?.linkId;
            return eLinkId === linkId && e.timestamp < event.timestamp;
          }).sort((a, b) => a.timestamp - b.timestamp);
          
          // Start with initial values (from link-add or snapshot)
          let currentState = {
            text: '',
            url: '', 
            keywords: '',
            color: '',
            infoHtml: ''
          };
          
          // Apply all changes up to (but not including) this event
          for (const evt of linkEvents) {
            const evtType = evt.operation?.type || evt.type;
            const evtData = evt.operation?.data || evt.data;
            
            if (evtType === 'link-add') {
              // Initial creation - data is either directly in evtData or in evtData.data
              const linkData = evt.operation ? evtData : (evtData?.data || evtData);
              if (linkData) {
                currentState = {
                  text: linkData.text || '',
                  url: linkData.url || '',
                  keywords: linkData.keywords || '',
                  color: linkData.color || '',
                  infoHtml: linkData.infoHtml || ''
                };
              }
            } else if (evtType === 'link-edit') {
              // Apply changes - for operation structure, changes are directly in evtData
              // For legacy structure, changes are in evtData.changes
              const changes = evt.operation ? evtData : (evtData?.changes || evtData);
              if (changes) {
                if (changes.text !== undefined) currentState.text = changes.text;
                if (changes.url !== undefined) currentState.url = changes.url;
                if (changes.keywords !== undefined) currentState.keywords = changes.keywords;
                if (changes.color !== undefined) currentState.color = changes.color;
                if (changes.infoHtml !== undefined) currentState.infoHtml = changes.infoHtml;
              }
            }
          }
          
          return currentState;
        },
        
        getEventDetails(event) {
          // Support both event structures
          const eventType = event.operation?.type || event.type;
          const eventData = event.operation?.data || event.data;
          
          if (!event || !eventData) return '';
          
          switch(eventType) {
            case 'link-add':
              // For operation structure, data contains link data directly
              // For legacy structure, data.data contains the link data
              const addedLink = event.operation ? eventData : (eventData.data || eventData);
              if (!addedLink) return 'Added link';
              return `Added: "${addedLink.text || 'Untitled'}" → ${addedLink.url || 'No URL'}`;
            
            case 'link-edit':
              // For operation structure, data contains changes directly
              // For legacy structure, data.changes contains the changes  
              const changes = event.operation ? eventData : (eventData.changes || eventData);
              if (!changes) return 'Edited link';
              
              const changeDetails = [];
              
              // For old events without oldValues, reconstruct from history
              if (!eventData.oldValues) {
                // Get the event log from the current inspected group
                const eventLog = this.inspectedGroup?.eventLog;
                const reconstructed = this.reconstructOldValues(event, eventLog);
                const oldValues = reconstructed || {};
                // Use reconstructed old values
                if (changes.text !== undefined) {
                  const oldText = oldValues.text || '';
                  const newText = changes.text || '';
                  const oldDisplay = oldText || '(empty)';
                  const newDisplay = newText || '(empty)';
                  changeDetails.push(`Text: "${oldDisplay}" → "${newDisplay}"`);
                }
                
                if (changes.url !== undefined) {
                  const oldUrl = oldValues.url || '';
                  const newUrl = changes.url || '';
                  const shortOld = oldUrl ? (oldUrl.length > 30 ? oldUrl.substring(0, 30) + '...' : oldUrl) : '(empty)';
                  const shortNew = newUrl ? (newUrl.length > 30 ? newUrl.substring(0, 30) + '...' : newUrl) : '(empty)';
                  changeDetails.push(`URL: ${shortOld} → ${shortNew}`);
                }
                
                if (changes.keywords !== undefined) {
                  const oldKeywords = oldValues.keywords || '';
                  const newKeywords = changes.keywords || '';
                  const oldDisplay = oldKeywords || '(empty)';
                  const newDisplay = newKeywords || '(empty)';
                  changeDetails.push(`Keywords: "${oldDisplay}" → "${newDisplay}"`);
                }
                
                if (changes.color !== undefined) {
                  const oldColor = oldValues.color || '';
                  const newColor = changes.color || '';
                  if (!((!oldColor || oldColor === 'default') && (!newColor || newColor === 'default'))) {
                    const oldDisplay = oldColor || 'default';
                    const newDisplay = newColor || 'default';
                    changeDetails.push(`Color: ${oldDisplay} → ${newDisplay}`);
                  }
                }
                
                if (changes.infoHtml !== undefined) {
                  const oldInfo = oldValues.infoHtml || '';
                  const newInfo = changes.infoHtml || '';
                  if (oldInfo || newInfo) {
                    changeDetails.push('Info text updated');
                  }
                }
              } else {
                // New events with oldValues - show old → new format
                const oldValues = eventData.oldValues;
                if (changes.text !== undefined) {
                  const oldText = oldValues.text || '';
                  const newText = changes.text || '';
                  const oldDisplay = oldText || '(empty)';
                  const newDisplay = newText || '(empty)';
                  changeDetails.push(`Text: "${oldDisplay}" → "${newDisplay}"`);
                }
                
                if (changes.url !== undefined) {
                  const oldUrl = oldValues.url || '';
                  const newUrl = changes.url || '';
                  // Shorten URLs if too long
                  const shortOld = oldUrl ? (oldUrl.length > 30 ? oldUrl.substring(0, 30) + '...' : oldUrl) : '(empty)';
                  const shortNew = newUrl ? (newUrl.length > 30 ? newUrl.substring(0, 30) + '...' : newUrl) : '(empty)';
                  changeDetails.push(`URL: ${shortOld} → ${shortNew}`);
                }
                
                if (changes.keywords !== undefined) {
                  const oldKeywords = oldValues.keywords || '';
                  const newKeywords = changes.keywords || '';
                  const oldDisplay = oldKeywords || '(empty)';
                  const newDisplay = newKeywords || '(empty)';
                  changeDetails.push(`Keywords: "${oldDisplay}" → "${newDisplay}"`);
                }
                
                if (changes.color !== undefined) {
                  const oldColor = oldValues.color || '';
                  const newColor = changes.color || '';
                  // Only show if really changed
                  if (!((!oldColor || oldColor === 'default') && (!newColor || newColor === 'default'))) {
                    const oldDisplay = oldColor || 'default';
                    const newDisplay = newColor || 'default';
                    changeDetails.push(`Color: ${oldDisplay} → ${newDisplay}`);
                  }
                }
                
                if (changes.infoHtml !== undefined) {
                  const oldInfo = oldValues.infoHtml || '';
                  const newInfo = changes.infoHtml || '';
                  if (oldInfo || newInfo) {
                    changeDetails.push('Info text updated');
                  }
                }
              }
              
              if (changeDetails.length === 0) {
                return 'Link edited';
              }
              
              // If only one change, show it directly
              if (changeDetails.length === 1) {
                return changeDetails[0];
              }
              
              // Multiple changes: show count and first change
              return `${changeDetails.length} changes: ${changeDetails[0]}`;
            
            case 'link-delete':
              // For operation structure, data.deletedLink contains the deleted link
              // For legacy structure, data.deletedLink also contains it
              const deletedLink = eventData.deletedLink || eventData;
              const linkId = event.operation?.linkId || eventData.linkId;
              if (!deletedLink || !deletedLink.text) return `Deleted link ID: ${linkId}`;
              return `Deleted: "${deletedLink.text || 'Untitled'}" (${deletedLink.url || 'No URL'})`;
            
            case 'snapshot':
              const snapshotData = eventData.data || eventData;
              if (!snapshotData) return 'Created snapshot';
              return `Snapshot: ${snapshotData.links?.length || 0} links, ${snapshotData.members?.length || 0} members`;
            
            default:
              return JSON.stringify(eventData).substring(0, 100);
          }
        },
        
        showQrCodeModal(url) {
          this.hideMenus();
          if (!url) return;
          this.qrCodeUrl = url;
          Vue.nextTick(() => { // Ensure modal structure is ready
            const qrCodeDiv = document.getElementById('qrCodeDiv');
            if (qrCodeDiv) {
              qrCodeDiv.innerHTML = ''; // Clear previous QR code
              try {
                new QRCode(qrCodeDiv, {
                  text: url,
                  width: 256, // Adjust size as needed
                  height: 256,
                  colorDark: "#000000",
                  colorLight: "#ffffff",
                  correctLevel: QRCode.CorrectLevel.H
                });
              } catch (e) {
                debugLog('error', "QR Code generation failed:", e);
                qrCodeDiv.innerHTML = "Could not generate QR Code.";
              }
            }
            // Use Bootstrap 5 JS API
            const modalElement = document.getElementById('qrCodeModal');
            const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
            modalInstance.show();
          });
        },

        copyLinkToClipboard(link, explicitUrl = null) {
          const effectiveUrl = explicitUrl || this.getEffectiveLinkUrl(link);
          if (!link || !effectiveUrl) return;

          // Get customizable format from options
          const format = this.data.options?.links?.copyUrlFormat || '{title}: {url}';

          // Replace placeholders with actual values
          const title = this.getEffectiveLinkText(link) || effectiveUrl;
          const keywords = this.getEffectiveLinkKeywords(link) || '';
          const clipboardText = format
            .replace('{title}', title)
            .replace('{url}', effectiveUrl)
            .replace('{text}', title) // Alternative placeholder
            .replace('{keywords}', keywords)
            .replace('{date}', new Date().toLocaleDateString())
            .replace('{time}', new Date().toLocaleTimeString());

          // Copy to clipboard
          navigator.clipboard.writeText(clipboardText).then(() => {
            // Show success toast
            toastManager.success(
              this.getTranslation('link.urlCopied') || 'URL copied',
              `<code style="word-break: break-all;">${this.escapeHtml(clipboardText.substring(0, 100))}${clipboardText.length > 100 ? '...' : ''}</code>`,
              3000
            );
            debugLog('log', `Copied to clipboard: ${clipboardText}`);
          }).catch(err => {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = clipboardText;
            textArea.style.position = 'fixed';
            textArea.style.top = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand('copy');
              toastManager.success(
                this.getTranslation('link.urlCopied') || 'URL copied',
                `<code style="word-break: break-all;">${this.escapeHtml(clipboardText.substring(0, 100))}${clipboardText.length > 100 ? '...' : ''}</code>`,
                3000
              );
              debugLog('log', `Copied to clipboard (fallback): ${clipboardText}`);
            } catch (fallbackErr) {
              debugLog('error', 'Failed to copy to clipboard:', fallbackErr);
              toastManager.error(
                this.getTranslation('link.copyFailed') || 'Failed to copy URL',
                this.getTranslation('link.copyError') || 'Could not access clipboard',
                5000
              );
            }
            document.body.removeChild(textArea);
          });
        },

        normalizeShortcutKeyName(key) {
          const raw = String(key || '').trim();
          if (!raw) return '';
          const lower = raw.toLowerCase();
          const mapped = {
            ' ': 'Space',
            'space': 'Space',
            'spacebar': 'Space',
            'esc': 'Escape',
            'escape': 'Escape',
            'arrowup': 'ArrowUp',
            'arrowdown': 'ArrowDown',
            'arrowleft': 'ArrowLeft',
            'arrowright': 'ArrowRight'
          };
          if (mapped[lower]) return mapped[lower];
          if (raw.length === 1) {
            if (/\s/.test(raw)) return 'Space';
            return raw.toUpperCase();
          }
          if (/^f([1-9]|1[0-2])$/i.test(raw)) return raw.toUpperCase();
          if (/^digit[0-9]$/i.test(raw)) return raw.slice(-1);
          if (/^key[a-z]$/i.test(raw)) return raw.slice(3).toUpperCase();
          return raw.length <= 24 ? raw : '';
        },
        normalizeShortcutText(value) {
          if (typeof value !== 'string') return '';
          const parts = value.split('+').map((part) => part.trim()).filter(Boolean);
          if (!parts.length) return '';
          const mods = { Ctrl: false, Alt: false, Shift: false, Meta: false };
          let keyPart = '';
          parts.forEach((part) => {
            const lower = part.toLowerCase();
            if (['ctrl', 'control', 'strg', '⌃'].includes(lower)) { mods.Ctrl = true; return; }
            if (['alt', 'option', '⌥'].includes(lower)) { mods.Alt = true; return; }
            if (['shift', 'umschalt', '⇧'].includes(lower)) { mods.Shift = true; return; }
            if (['meta', 'cmd', 'command', 'win', 'super', '⌘'].includes(lower)) { mods.Meta = true; return; }
            keyPart = this.normalizeShortcutKeyName(part);
          });
          if (!keyPart) return '';
          if (!mods.Ctrl && !mods.Alt && !mods.Meta) return '';
          const ordered = [];
          if (mods.Ctrl) ordered.push('Ctrl');
          if (mods.Alt) ordered.push('Alt');
          if (mods.Shift) ordered.push('Shift');
          if (mods.Meta) ordered.push('Meta');
          ordered.push(keyPart);
          return ordered.join('+');
        },
        normalizeShortcutFromEvent(event) {
          if (!event) return '';
          const keyPart = this.normalizeShortcutKeyName(event.key);
          if (!keyPart || ['Control', 'Shift', 'Alt', 'Meta'].includes(keyPart) || keyPart === 'Tab') return '';
          if (!event.ctrlKey && !event.altKey && !event.metaKey) return '';
          const parts = [];
          if (event.ctrlKey) parts.push('Ctrl');
          if (event.altKey) parts.push('Alt');
          if (event.shiftKey) parts.push('Shift');
          if (event.metaKey) parts.push('Meta');
          parts.push(keyPart);
          return this.normalizeShortcutText(parts.join('+'));
        },
        isReservedShortcutCombo(combo) {
          const reserved = new Set([
            'Ctrl+L', 'Ctrl+T', 'Ctrl+W', 'Ctrl+R', 'Ctrl+Shift+R', 'Ctrl+N', 'Ctrl+Shift+N',
            'Ctrl+P', 'Ctrl+F', 'Ctrl+S', 'Ctrl+O', 'Ctrl+J',
            'Meta+L', 'Meta+T', 'Meta+W', 'Meta+R', 'Meta+Shift+R', 'Meta+N', 'Meta+Shift+N',
            'Meta+P', 'Meta+F', 'Meta+S', 'Meta+O', 'Meta+J'
          ]);
          return reserved.has(combo);
        },
        parseShortcutUrlsInput(value) {
          if (Array.isArray(value)) return value.map(v => String(v || '').trim()).filter(Boolean);
          const text = String(value || '');
          return text
            .split(/\r?\n|[,;]/)
            .map(part => part.trim())
            .filter(Boolean);
        },
        normalizeShortcutUrlListFromText(value) {
          const tokens = this.parseShortcutUrlsInput(value);
          const urls = [];
          tokens.forEach((token) => {
            const normalized = MB.Utils.ensureProtocol(token);
            if (!MB.Utils.isValidHttpUrl(normalized)) return;
            urls.push(normalized);
          });
          return [...new Set(urls)];
        },
        normalizeGlobalShortcutList(list, { ensureId = false } = {}) {
          if (!Array.isArray(list)) return [];
          const indexData = this.getShortcutTargetIndex();
          const merged = new Map();
          list.forEach((entry) => {
            const combo = this.normalizeShortcutText(entry?.combo || entry?.shortcut || '');
            if (!combo) return;
            const selectedGroupIds = this.normalizeShortcutIdList(entry?.groupIds || entry?.groups || [])
              .filter((groupId) => indexData.groupIds.has(groupId));
            const coveredLinkIds = new Set();
            selectedGroupIds.forEach((groupId) => {
              (indexData.groupToLinks.get(groupId) || []).forEach((linkId) => coveredLinkIds.add(linkId));
            });
            const selectedLinkIds = this.normalizeShortcutIdList(entry?.linkIds || entry?.links || [])
              .filter((linkId) => indexData.linkIds.has(linkId) && !coveredLinkIds.has(linkId));
            const urls = this.normalizeShortcutUrlListFromText(entry?.urls || entry?.urlsText || '');
            if (!selectedGroupIds.length && !selectedLinkIds.length && !urls.length) return;
            const current = merged.get(combo) || {
              id: '',
              combo,
              name: '',
              groupIds: [],
              linkIds: [],
              urls: []
            };
            if (!current.id && entry?.id) current.id = String(entry.id);
            if (!current.name && entry?.name) current.name = String(entry.name || '').trim();
            current.groupIds = [...new Set([...(current.groupIds || []), ...selectedGroupIds])];
            current.linkIds = [...new Set([...(current.linkIds || []), ...selectedLinkIds])];
            current.urls = [...new Set([...(current.urls || []), ...urls])];
            merged.set(combo, current);
          });
          return Array.from(merged.values())
            .map((entry) => {
              const groupIds = this.normalizeShortcutIdList(entry.groupIds || [])
                .filter((groupId) => indexData.groupIds.has(groupId));
              const coveredLinkIds = new Set();
              groupIds.forEach((groupId) => {
                (indexData.groupToLinks.get(groupId) || []).forEach((linkId) => coveredLinkIds.add(linkId));
              });
              const linkIds = this.normalizeShortcutIdList(entry.linkIds || [])
                .filter((linkId) => indexData.linkIds.has(linkId) && !coveredLinkIds.has(linkId));
              const urls = this.normalizeShortcutUrlListFromText(entry.urls || []);
              return {
                id: entry.id || (ensureId ? this.generateUUID() : ''),
                combo: entry.combo,
                name: entry.name || '',
                groupIds,
                linkIds,
                urls
              };
            })
            .sort((a, b) => a.combo.localeCompare(b.combo));
        },
        collectUrlsForShortcutCombo(combo) {
          const urls = [];
          const normalizedCombo = this.normalizeShortcutText(combo || '');
          if (!normalizedCombo) return [];
          (this.data.groups || []).forEach((group) => {
            const groupCombo = this.normalizeShortcutText(group?.shortcut || '');
            const groupMatched = groupCombo === normalizedCombo;
            (group.links || []).forEach((link) => {
              if (link?.deleted) return;
              const linkCombo = this.normalizeShortcutText(link.shortcut || '');
              if (!groupMatched && linkCombo !== normalizedCombo) return;
              const normalizedUrl = MB.Utils.ensureProtocol((this.getEffectiveLinkUrl(link) || '').trim());
              if (!MB.Utils.isValidHttpUrl(normalizedUrl)) return;
              urls.push(normalizedUrl);
            });
          });
          const globalShortcuts = this.normalizeGlobalShortcutList(this.data?.options?.links?.globalShortcuts || []);
          globalShortcuts.forEach((entry) => {
            if (entry.combo !== normalizedCombo) return;
            const entryUrls = this.collectUrlsFromShortcutTargets({
              groupIds: entry.groupIds || [],
              linkIds: entry.linkIds || [],
              legacyUrls: entry.urls || []
            });
            entryUrls.forEach((url) => urls.push(url));
          });
          return [...new Set(urls)];
        },
        captureShortcutField(sectionKey, fieldKey, event) {
          if (!event) return;
          if (event.key === 'Tab') return;
          if (event.key === 'Escape' || event.key === 'Backspace' || event.key === 'Delete') {
            event.preventDefault();
            this.setGenericFieldValue(sectionKey, fieldKey, '');
            return;
          }
          const combo = this.normalizeShortcutFromEvent(event);
          if (!combo) {
            event.preventDefault();
            return;
          }
          if (this.isReservedShortcutCombo(combo)) {
            event.preventDefault();
            this.showToast(this.getTranslation('link.shortcut.reserved') || 'This shortcut is reserved by the browser/system.', 'warning');
            return;
          }
          event.preventDefault();
          this.setGenericFieldValue(sectionKey, fieldKey, combo);
        },
        clearShortcutField(sectionKey, fieldKey) {
          this.setGenericFieldValue(sectionKey, fieldKey, '');
        },
        tryHandleLinkShortcut(event) {
          const active = document.activeElement;
          if (active && (active.isContentEditable || ['INPUT', 'TEXTAREA', 'SELECT'].includes(active.tagName))) return false;
          if (document.querySelector('.modal.show')) return false;

          const combo = this.normalizeShortcutFromEvent(event);
          if (!combo) return false;
          if (this.isReservedShortcutCombo(combo)) return false;

          const uniqueUrls = this.collectUrlsForShortcutCombo(combo);
          if (!uniqueUrls.length) return false;

          event.preventDefault();
          event.stopPropagation();

          const confirmThreshold = 8;
          if (uniqueUrls.length > confirmThreshold) {
            const confirmText = (this.getTranslation('link.shortcut.confirmMany') || 'Open {count} links at once?')
              .replace('{count}', uniqueUrls.length);
            if (!confirm(confirmText)) {
              this.shortcutOpenQueue = null;
              return true;
            }
          }

          const openInNewTab = this.data?.options?.links?.openInNewTab !== false;
          const queueKey = `combo:${combo}`;
          const result = this.openShortcutUrls(uniqueUrls, openInNewTab, queueKey);
          this.showShortcutOpenResultToast(result);
          return true;
        },
        handleGlobalKeyDown(event) {
          if (this.localSecurity.locked) return;
          if (this.tryHandleLinkShortcut(event)) return;
          if (this.data?.options?.common?.searchAsYouType &&
            !event.ctrlKey && !event.metaKey && !event.altKey && // Ignore modifier keys
            event.key.length === 1 && // Detect printable characters
            !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) // Ignore if typing in input/textarea
          {
            const searchInput = document.getElementById('searchFilter');
            if (searchInput && document.activeElement !== searchInput) {
              searchInput.focus();
              // Note: The character typed won't automatically appear,
              // but focus is now set for subsequent typing.
              // To add the first char: searchInput.value += event.key; this.filterText = searchInput.value;
            }
          }
        },
        // Debounced saving to reduce IndexedDB writes
        saveData() {
          if (!this._debouncedSave) {
            this._debouncedSave = debounce(this.saveDataImmediate, 300).bind(this);
          }
          this._debouncedSave();
        },
        async saveDataImmediate() {
          try {
            if (!this.dataLoaded && !this._allowSaveDuringLoad) {
              debugLog('warn', '[SAVE] Skipping save: data not loaded yet.');
              return;
            }
            if (this.loadFailed) {
              debugLog('warn', '[SAVE] Skipping save: last load failed.');
              return;
            }
            const savableData = this.getSavableData();
            const plainJson = JSON.stringify(savableData);
            let parsed = plainJson;
            const shouldEncryptLocalData = this.isLocalSecurityEnabled();
            if (shouldEncryptLocalData) {
              if (!this._localEncryptionKey || !this._localEncryptionKdf) {
                debugLog('warn', '[SAVE] Encryption enabled but no active key is available. Save skipped.');
                return;
              }
              const envelope = await this.encryptLocalSecurityEnvelope(savableData, this._localEncryptionKey, this._localEncryptionKdf);
              parsed = JSON.stringify(envelope);
              this.localSecurity.isEncryptedStore = true;
              this.localSecurity.encryptedEnvelope = envelope;
              this.localSecurity.encryptedDataId = this.dataId;
            } else {
              this.localSecurity.isEncryptedStore = false;
              this.localSecurity.encryptedEnvelope = null;
              this.localSecurity.encryptedDataId = -1;
            }
            // History tracking
            if (this.appInitialized && !this.historyLock) {
              if (this.lastSavedJson && this.lastSavedJson !== plainJson) {
                try { this.historyPast.push(JSON.parse(this.lastSavedJson)); } catch { }
                if (this.historyPast.length > 20) this.historyPast.shift();
                this.historyFuture = [];
              }
            }
            if (this.dataId === -1) {
              const newId = await linksDb.links.add({ data: parsed });
              this.dataId = newId;
              if (this.localSecurity.isEncryptedStore) this.localSecurity.encryptedDataId = newId;
            } else {
              const updated = await linksDb.links.update(this.dataId, { data: parsed });
              if (!updated) {
                debugLog('warn', '[SAVE] Update returned 0 rows. Creating new record.');
                const newId = await linksDb.links.add({ data: parsed });
                this.dataId = newId;
                if (this.localSecurity.isEncryptedStore) this.localSecurity.encryptedDataId = newId;
              }
            }
            if (this.localSecurity.isEncryptedStore) this.localSecurity.encryptedDataId = this.dataId;
            this.lastSavedJson = plainJson;
            // Update storage usage after save (debounced to reduce repeated JSON work)
            this.scheduleStorageUsageRecalc(parsed);
          } catch (error) {
            debugLog('error', "Error saving data:", error);
          }
        },

      }, // end methods
    });

    // Make app global for options access (simple approach)
    window.app = app;

  </script>

  <script>
    let footer = new Vue({
      el: '#footer',
      data: {
        version: '2026-02-27', // Updated version string
      },
    });
  </script>

  <!-- Toast Notification (outside of Vue app) -->
  <div id="toast-notification" style="position: fixed; bottom: 20px; right: 20px; z-index: 11000; display: none;">
    <div class="toast show bg-light text-dark border shadow-sm" role="alert" style="min-width: 250px; border-radius: 8px;">
      <div class="toast-body d-flex align-items-center" style="gap: 8px;">
        <span id="toast-icon" class="me-2"></span>
        <span id="toast-message"></span>
      </div>
    </div>
  </div>

  <script>
    // Simple global toast function for Vue app
    window.showAppToast = function(message, type) {
      const toastEl = document.getElementById('toast-notification');
      const innerToast = toastEl ? toastEl.querySelector('.toast') : null;
      const toastBody = toastEl ? toastEl.querySelector('.toast-body') : null;
      const iconEl = document.getElementById('toast-icon');
      const messageEl = document.getElementById('toast-message');

      if (toastEl && iconEl && messageEl) {
        // Determine theme (dark vs light)
        const selectedTpl = (localStorage.getItem('selectedVisualTemplate') || '').toLowerCase();
        const isDark = (
          (document.documentElement.getAttribute('data-theme') === 'dark') ||
          (localStorage.getItem('darkMode') === 'true') ||
          (document.body.classList && document.body.classList.contains('dark-mode')) ||
          (selectedTpl === 'dark-mode')
        );

        // Apply theme-specific styles for good defaults across templates
        if (innerToast) {
          innerToast.classList.remove('bg-dark','text-white','bg-light','text-dark');
          innerToast.classList.add(isDark ? 'bg-dark' : 'bg-light', isDark ? 'text-white' : 'text-dark');
          innerToast.classList.add('border','shadow-sm');
          innerToast.style.background = isDark ? '#2d3748' : '#ffffff';
          innerToast.style.color = isDark ? '#f7fafc' : '#212529';
          innerToast.style.border = isDark ? '1px solid rgba(255, 255, 255, 0.15)' : '1px solid #dee2e6';
          innerToast.style.borderRadius = '8px';
        }
        if (toastBody) {
          toastBody.style.alignItems = 'center';
          toastBody.style.gap = '8px';
        }

        // Set icon based on type
        if (type === 'success') {
          iconEl.innerHTML = '<span style="color: #198754;">✓</span>';
        } else if (type === 'error') {
          iconEl.innerHTML = '<span style="color: #dc3545;">✗</span>';
        } else if (type === 'warning') {
          iconEl.innerHTML = '<span style="color: #ffc107;">⚠</span>';
        } else {
          iconEl.innerHTML = '<span style="color: #0d6efd;">ℹ</span>';
        }

        messageEl.textContent = message;
        toastEl.style.display = 'block';

        // Auto-hide after 3 seconds
        setTimeout(() => {
          toastEl.style.display = 'none';
        }, 3000);
      }
    };
 </script>

 </body>

</html>

<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ title }}</title>
  <!-- Favicon Placeholder - Replace FAVICON_BASE64_HERE with your base64 data -->
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="stylesheet" href="style.css">
  <script src="external.js"></script>
  <style rel="stylesheet">
    /* Enhanced CSS Variables System - Override these in Custom CSS without !important */
    :root {
      /* Core Colors */
      --bg-primary: #fafbfc;
      --bg-secondary: #ffffff;
      --bg-header-start: #ffffff;
      --bg-header-end: #f8f9fa;
      --text-primary: #1a1a1a;
      --text-secondary: #555;
      --text-muted: #aaa;
      --text-subtle: #bbb;
      --border-color: #e9ecef;
      --border-light: #dee2e6;
      --shadow-sm: rgba(0, 0, 0, 0.03);
      --shadow-md: rgba(0, 0, 0, 0.1);
      --card-bg: #fff;
      --input-bg: #fff;
      --input-border: #ced4da;
      --btn-primary-bg: #007bff;
      --btn-primary-hover: #0056b3;
      --link-color: #007bff;
      --link-hover: #0056b3;
      
      /* Layout & Spacing */
      --container-padding: 0;
      --toolbar-padding: 0;
      --titlebar-padding: 0;
      --group-padding: 16px 8px 16px 12px;
      --group-margin-bottom: 0;
      --group-border-radius: 16px;
      --group-shadow: 0 1px 2px rgba(0, 0, 0, 0.04), 0 8px 16px -4px rgba(0, 0, 0, 0.08);
      --group-shadow-hover: 0 1px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.1), 0 20px 40px -10px rgba(0, 0, 0, 0.15);
      
      /* Group Header */
      --group-header-bg: linear-gradient(135deg, rgba(255, 255, 255, 0.6) 0%, rgba(250, 250, 251, 0.4) 100%);
      --group-header-border: 1px solid rgba(0, 0, 0, 0.05);
      
      /* Links */
      --link-padding: 2px 8px;
      --link-font-size: inherit;
      --link-border-bottom: 1px solid rgba(0, 0, 0, 0.02);
      --link-hover-bg: rgba(0, 0, 0, 0.02);
      
      /* Buttons */
      --btn-padding: 0.375rem 0.75rem;
      --btn-font-size: 0.875rem;
      --btn-border-radius: 8px;
      --btn-gap: 0.5rem;
      
      /* Typography */
      --font-family-base: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      --font-family-mono: 'Courier New', Courier, Monaco, Menlo, monospace;
      --font-size-base: 14px;
      --font-size-sm: 12px;
      --font-size-lg: 16px;
      --line-height-base: 1.5;
      
      /* Transitions */
      --transition-speed: 0.3s;
      --transition-timing: ease;
      
      /* App-level dynamic variables (set via JS) */
      --app-bg: var(--bg-primary);
      --app-bg-image: none;
      --app-text-color: var(--text-primary);
    }

    /* Modal Scrollability and Height Constraints */
    .modal-dialog {
      max-height: 90vh;
      display: flex;
      flex-direction: column;
    }
    
    .modal-content {
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .modal-header {
      flex-shrink: 0;
    }
    
    .modal-body {
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1 1 auto;
      max-height: calc(90vh - 120px); /* Account for header and footer */
    }
    
    .modal-footer {
      flex-shrink: 0;
    }

    .mb-edit-favicon-preview {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .mb-edit-favicon-actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-left: 1rem;
      flex-shrink: 0;
    }

    .mb-edit-favicon-actions button {
      white-space: nowrap;
    }

    @media (max-width: 576px) {
      .mb-edit-favicon-actions {
        flex-wrap: wrap;
        justify-content: flex-end;
        margin-left: 0.5rem;
        row-gap: 0.25rem;
      }
    }

    /* Ensure centered modals respect height constraints */
    .modal-dialog-centered {
      min-height: calc(100% - 3.5rem);
      max-height: 90vh;
    }
    
    /* For large modals, ensure they don't exceed viewport */
    .modal-lg .modal-body {
      max-height: calc(90vh - 140px);
    }
    
    /* Prevent content from making dialog too wide */
    .modal-body > * {
      max-width: 100%;
      overflow-wrap: break-word;
    }

    /* Base styles */
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    body {
      /* Default styles - can be overridden by custom CSS */
      background-color: #fafbfc;
      color: #1a1a1a;
    }

    #app {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      min-height: calc(100vh - 45px);
      /* Ensure content pushes footer down */
      box-sizing: border-box;
      padding: 0 15px 80px 15px;
      /* Top padding removed, managed by header */
      /* Removed CSS variables to allow custom CSS to override */
    }
    
    /* App container - custom CSS can override these */
    #app.container-fluid {
      /* Default styles - can be overridden by custom CSS */
      min-height: 100vh;
    }
    
    /* Modern Header Bar Styling */
    #app > h1 {
      font-size: 1.25rem;
      font-weight: 700;
      margin: 0;
      padding: var(--custom-titlebar-bg-padding, 0.75rem 1rem 0 0rem);  /* Increased left padding */
      color: #1a1a1a;
      /* Removed CSS variables to allow custom CSS to override */
      opacity: var(--custom-titlebar-bg-opacity, 1);
      border-style: var(--custom-titlebar-bg-border_style, none);
      border-width: var(--custom-titlebar-bg-border_width, 0);
      border-color: var(--custom-titlebar-bg-border_color, transparent);
      border-radius: var(--custom-titlebar-bg-border_radius, 0);
      font-family: var(--custom-title-color-font_family, inherit);
      font-size: var(--custom-title-color-font_size, 1.25rem);
      font-weight: var(--custom-title-color-font_weight, 700);
      letter-spacing: -0.5px;
      display: flex;
      align-items: center;
      justify-content: flex-start;  /* Changed to flex-start for left alignment */
      background: var(--custom-titlebar-bg-background_color, var(--custom-titlebar-bg, linear-gradient(135deg, var(--bg-header-start) 0%, var(--bg-header-end) 100%)));
      border-bottom: 1px solid var(--border-color);
      text-align: left;  /* Ensure text is left-aligned */
    }
    
    /* Compact Toolbar Container */
    .container-fluid.mt-3.mb-3 {
      background: var(--custom-toolbar-bg-background_color, var(--custom-toolbar-bg, var(--bg-secondary)));
      color: var(--custom-toolbar-bg-color, inherit);
      opacity: var(--custom-toolbar-bg-opacity, 1);
      border-style: var(--custom-toolbar-bg-border_style, none);
      border-width: var(--custom-toolbar-bg-border_width, 0);
      border-color: var(--custom-toolbar-bg-border_color, transparent);
      border-radius: var(--custom-toolbar-bg-border_radius, 0);
      padding: var(--custom-toolbar-bg-padding, 0.5rem 0);
      margin-top: 0 !important;
      border-bottom: 1px solid var(--border-color);
      box-shadow: 0 1px 2px var(--shadow-sm);
      flex-shrink: 0;  /* Don't shrink */
    }
    
    /* Row adjustments for compact layout */
    .container-fluid.mt-3.mb-3 .row {
      margin: 0;
      --bs-gutter-x: 0;
    }
    
    .container-fluid.mt-3.mb-3 .col-md-auto,
    .container-fluid.mt-3.mb-3 .col {
      padding: 0.25rem 0;
      --bs-gutter-x: 0;
    }
    
    /* Keywords row optimization */
    .row.mt-2 {
      margin-top: 0.5rem !important;
    }
    
    .input-group-sm .input-group-text + .form-control[style*="height:auto"] {
      min-height: 32px;
      max-height: 60px;
      overflow-y: auto;
      padding: 0.25rem 0.5rem;
    }
    
    /* Keyword badges more compact */
    .keyword-badge {
      padding: 0.15rem 0.4rem !important;
      font-size: 0.75rem !important;
      margin: 0.1rem !important;
      opacity: 1 !important;
    }
    
    /* Ensure badge colors are not overridden */
    .badge.keyword-badge {
      opacity: 1 !important;
    }
    
    /* Integrate title and toolbar visually */
    #app {
      padding-top: 0;
    }
    
    /* Create a unified header section */
    #app > h1 + .container-fluid {
      border-top-left-radius: 0;
      border-top-right-radius: 0;
    }
    
    /* Adjust button toolbar spacing */
    .btn-toolbar {
      gap: 0.5rem;
    }
        
    /* Link count badge in group headers */
    .groupLinkCount {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background-color: #6c757d;
      color: white;
      border-radius: 10px;
      padding: 2px 8px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-left: 8px;
      min-width: 24px;
      height: 20px;
    }
    
    .groupLinkCount.empty {
      background-color: #dee2e6;
      color: #6c757d;
    }
    
    /* Keyword badges */
    .keyword-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25em 0.6em;
      font-size: 0.75rem;
      font-weight: 600;
      border-radius: 0.375rem;
      background-color: #6c757d;
      color: white;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }
    
    .keyword-badge:hover {
      opacity: 0.8;
    }
    
    /* General badge styles */
    .badge {
      display: inline-block;
      padding: 0.35em 0.65em;
      font-size: 0.75em;
      font-weight: 700;
      line-height: 1;
      text-align: center;
      white-space: nowrap;
      vertical-align: baseline;
      border-radius: 0.375rem;
    }
    
    .badge.rounded-pill {
      border-radius: 50rem;
    }
    
    /* Make reset button less prominent */
    .btn-toolbar .btn-danger {
      background-color: #fff;
      color: #dc3545;
      border-color: #dc3545;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      opacity: 0.8;
      transition: all 0.2s ease;
    }
    
    .btn-toolbar .btn-danger:hover {
      background-color: #dc3545;
      color: #fff;
      opacity: 1;
      box-shadow: 0 2px 4px rgba(220, 53, 69, 0.2);
    }
    
    /* Compact add group button */
    .btn-toolbar .btn-success {
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
      background-color: #28a745;
      border-color: #28a745;
      transition: all 0.2s ease;
    }
    
    .btn-toolbar .btn-success:hover {
      background-color: #218838;
      box-shadow: 0 2px 4px rgba(40, 167, 69, 0.2);
    }

    /* Text and Link Styles */
    .text-strikethrough {
      text-decoration: line-through;
    }

    .groupName {
      cursor: move;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      /* font-size removed - now controlled by inline styles */
      margin-bottom: 15px;
      display: flex;
      /* Use flex for alignment */
      align-items: center;
      /* Vertically align items */
    }

    .groupLinkCount {
      display: inline-block;
      /* Background now controlled via inline style from getPillStyle */
      color: white;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 12px;
      min-width: 24px;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-left: 8px;
      vertical-align: middle;
      position: relative;
      top: 1px;
      transition: all 0.2s ease;
    }
    
    .groupLinkCount:hover {
      transform: scale(1.05);
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
    }
    
    .groupLinkCount.empty {
      /* Default for empty pills comes from getPillStyle; keep class for semantics */
    }

    .linkText {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 1em;
      display: flex;
      /* Use flex for alignment */
      align-items: center;
      /* Vertically align items */
      flex: 1;
      min-width: 0;
      position: relative;
    }
    
    /* URL preview on hover */
    .link-url-preview {
      display: none;
      color: #6b7280;
      font-size: 0.85em;
      white-space: nowrap;
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
      margin-left: 8px;
      margin-right: auto;
      flex-shrink: 1;
      min-width: 0;
    }
    
    .linkContainerListItem:hover .link-url-preview {
      display: inline-block;
    }
    
    .linkText > span:first-child {
      display: inline-block;
      width: fit-content;
      max-width: 100%;
    }
    
    /* Allow badges to wrap if needed but keep inline when possible */
    .linkText .badge.keyword-badge {
      white-space: nowrap;
      flex-shrink: 0;
    }

    .linkTextCategory {
      font-weight: bold;
      font-style: italic;
      /* Differentiate categories */
      color: var(--text-secondary);
    }

    .linkTextGrip {
      cursor: grab;
      width: 12px;
      /* Slightly wider */
      height: 20px;
      padding: 0px;
      margin: 0px 5px 0px -5px;
      /* Adjust spacing */
      color: #bbb;
      /* Make grip subtle */
    }

    .qrCodeUrl {
      font-size: 1.5em;
      /* Adjusted for better readability */
      word-wrap: break-word;
      /* Allow long URLs to wrap */
    }

    /* Buttons and Icons */
    .svg-button {
      cursor: pointer;
      vertical-align: middle;
      /* Align icons nicely */
    }
    
    /* Make action button icons properly sized */
    .groupActions .svg-button.actionIcon {
      width: 18px !important;
      height: 18px !important;
      margin: 0;
    }
    
    .groupActions .svg-button.actionIconLink {
      width: 16px !important;
      height: 16px !important;
      margin: 0;
    }
    
    /* Elegant Tool Buttons Styling */
    .btn-group-sm .btn-outline-secondary {
      border-color: #dee2e6;
      background-color: #ffffff;
      color: #6c757d;
      transition: all 0.2s ease-in-out;
      position: relative;
      overflow: hidden;
      border-radius: 6px;
      padding: 0.25rem 0.5rem;  /* Standard btn-sm padding für einheitliche Größe */
    }
    
    /* Fix border-radius for buttons inside button groups */
    .btn-group > .btn:not(:first-child),
    .btn-group > .btn-group:not(:first-child) {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }
    
    .btn-group > .btn:not(:last-child):not(.dropdown-toggle),
    .btn-group > .btn-group:not(:last-child) > .btn {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
    
    /* Ensure middle buttons have no radius */
    .btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) {
      border-radius: 0;
    }
    
    .btn-group-sm .btn-outline-secondary:hover {
      background-color: #f8f9fa;
      border-color: #adb5bd;
      color: #495057;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
    }
    
    .btn-group-sm .btn-outline-secondary:active {
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    
    .btn-group-sm .btn-outline-secondary svg {
      transition: transform 0.2s ease;
    }
    
    .btn-group-sm .btn-outline-secondary:hover svg {
      opacity: 1;
    }
    
    /* Button group styling */
    .btn-group {
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      border-radius: 8px;
    }
    
    .btn-group .btn:first-child {
      border-top-left-radius: 8px !important;
      border-bottom-left-radius: 8px !important;
    }
    
    .btn-group .btn:last-child {
      border-top-right-radius: 8px !important;
      border-bottom-right-radius: 8px !important;
    }
    
    .btn-group .btn:not(:first-child) {
      margin-left: -1px;
    }
    
    /* Dropdown button special styling */
    .btn-group .dropdown-toggle {
      border-left: 1px solid #dee2e6;
    }
    
    .btn-group .dropdown-toggle::after {
      transition: transform 0.2s ease;
    }
    
    .btn-group .dropdown-toggle[aria-expanded="true"]::after {
      transform: rotate(180deg);
    }
    
    /* Focus state for accessibility */
    .btn-group-sm .btn-outline-secondary:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.1);
    }
    
    /* Separator between button groups */
    .btn-group + .btn-group {
      margin-left: 0.5rem;
    }
    
    /* Undo/Redo special styling - same size as other buttons */
    .btn-group-sm .btn-outline-secondary[title*="undo"],
    .btn-group-sm .btn-outline-secondary[title*="redo"],
    .btn-group-sm .btn-outline-secondary[title*="Undo"],
    .btn-group-sm .btn-outline-secondary[title*="Redo"] {
      font-size: 0.875rem;  /* Standard btn-sm font-size statt 1.1rem */
      padding: 0.25rem 0.5rem;
      line-height: 1.5;
    }
    
    /* Smooth icon rotation for expand/collapse buttons */
    .btn-group-sm .btn-outline-secondary svg[viewBox="0 0 16 16"] {
      transition: transform 0.3s ease;
    }
    
    /* Tooltip-like effect on hover (optional) */
    .btn-group-sm .btn-outline-secondary {
      position: relative;
    }
    
    .btn-group-sm .btn-outline-secondary:hover::before {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.25rem 0.5rem;
      background-color: #333;
      color: white;
      font-size: 0.75rem;
      border-radius: 4px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      margin-bottom: 5px;
      z-index: 1000;
    }
    
    /* Disable tooltip for buttons with native tooltips */
    .btn-group-sm .btn-outline-secondary[data-bs-toggle]:hover::before {
      display: none;
    }
    
    /* Search input group styling to match tool buttons */
    .input-group-sm .btn-outline-secondary {
      border-color: #dee2e6;
      background-color: #ffffff;
      color: #6c757d;
      transition: all 0.2s ease-in-out;
      position: relative;
      overflow: hidden;
      padding: 0.25rem 0.5rem !important;  /* Standard btn-sm padding für einheitliche Größe */
      font-size: 0.875rem !important;      /* Standard btn-sm font-size */
      line-height: 1.5 !important;
    }
    
    .input-group-sm .btn-outline-secondary:hover {
      background-color: #f8f9fa;
      border-color: #adb5bd;
      color: #495057;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
    }
    
    .input-group-sm .btn-outline-secondary:active {
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    
    .input-group-sm .btn-outline-secondary svg {
      transition: transform 0.2s ease;
    }
    
    .input-group-sm .btn-outline-secondary:hover svg {
      transform: scale(1.1);
    }
    
    /* Search input group special styling */
    .input-group-sm {
      box-shadow: none;
      border-radius: 6px;
    }
    
    .input-group-sm:focus-within {
      box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.08);
      border-color: #adb5bd;
    }
    
    .input-group-sm .input-group-text {
      background-color: #f8f9fa;
      border-color: #dee2e6;
      color: #6c757d;
      font-weight: 500;
      padding: 0.25rem 0.5rem;  /* Standard btn-sm padding für einheitliche Größe */
      font-size: 0.875rem;
      line-height: 1.5;
    }

    .input-group-sm .form-control {
      border-color: #dee2e6;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      padding: 0.25rem 0.5rem;  /* Standard btn-sm padding für einheitliche Größe */
      font-size: 0.875rem;
      height: calc(1.5em + 0.5rem + 2px);  /* Angepasst an das neue Padding */
      line-height: 1.5;
    }
    
    /* Ensure search buttons match the height */
    .input-group-sm .btn {
      padding: 0.25rem 0.5rem;  /* Standard btn-sm padding für einheitliche Größe */
      font-size: 0.875rem;
      height: calc(1.5em + 0.5rem + 2px);  /* Angepasst an das neue Padding */
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1.5;
    }
    
    .input-group-sm .form-control:focus {
      border-color: #adb5bd;
      box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.1);
    }
    
    /* Clear button special effect */
    .input-group-sm .btn-outline-secondary[title*="Clear"],
    .input-group-sm .btn-outline-secondary[title*="clear"] {
      border-radius: 0;
    }
    
    .input-group-sm .btn-outline-secondary[title*="Clear"]:hover svg,
    .input-group-sm .btn-outline-secondary[title*="clear"]:hover svg {
      transform: rotate(90deg) scale(1.1);
    }
    
    /* Save search button special effect */
    .input-group-sm .btn-outline-secondary[title*="save"],
    .input-group-sm .btn-outline-secondary[title*="Save"] {
      border-radius: 0;
    }
    
    /* Delete button in search group */
    .input-group-sm .btn-outline-danger {
      border-color: #dc3545;
      color: #dc3545;
      background-color: #ffffff;
      transition: all 0.2s ease-in-out;
    }
    
    .input-group-sm .btn-outline-danger:hover {
      background-color: #dc3545;
      color: #ffffff;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(220, 53, 69, 0.2);
    }
    
    .input-group-sm .btn-outline-danger:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      transform: none;
    }
    
    /* Select dropdown in search group */
    .input-group-sm .form-select {
      border-color: #dee2e6;
      transition: border-color 0.2s ease;
      cursor: pointer;
      padding: 0.25rem 0.5rem;  /* Standard btn-sm padding für einheitliche Größe */
      font-size: 0.875rem;
      height: calc(1.5em + 0.5rem + 2px);  /* Angepasst an das neue Padding */
      line-height: 1.5;
    }

    .input-group-sm .form-select:hover {
      border-color: #adb5bd;
    }

    .input-group-sm .form-select:focus {
      border-color: #adb5bd;
      box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.1);
    }

    /* Ensure all dropdown toggles have consistent size */
    .btn-group-sm .dropdown-toggle {
      padding: 0.25rem 0.5rem !important;  /* Standard btn-sm padding */
      font-size: 0.875rem !important;
      line-height: 1.5 !important;
      height: calc(1.5em + 0.5rem + 2px) !important;  /* Explizite Höhe für Konsistenz */
    }

    /* Make the app take full height and prevent body scrolling */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;  /* Prevent body scrolling */
    }

    #app {
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;  /* Prevent app scrolling */
    }

    /* Ensure main app container uses flexbox properly */
    #app.container-fluid {
      max-width: 100%;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .actionAdd {
      width: 28px;
      height: 28px;
      color: #10b981;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      filter: drop-shadow(0 2px 4px rgba(16, 185, 129, 0.15));
    }
    
    .actionAdd:hover {
      transform: rotate(90deg) scale(1.1);
      color: #059669;
      filter: drop-shadow(0 4px 8px rgba(16, 185, 129, 0.25));
    }

    .actionIcon {
      width: 18px;
      height: 18px;
      padding: 0;
      margin: 0 2px;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      border-radius: 6px;
      transition: all 0.2s ease;
      opacity: 0.7;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-sizing: content-box;
    }
    
    .groupContainer:hover .actionIcon {
      opacity: 1;
      background: transparent;
      color: var(--text-primary);
    }
    
    .actionIcon:hover {
      color: var(--link-color);
      background: var(--bg-secondary);
      opacity: 1;
      transform: scale(1.1);
    }
    
    .actionIcon:active {
      transform: scale(0.95);
      opacity: 0.8;
    }

    .actionIconLink {
      width: 16px;
      height: 16px;
      padding: 0;
      margin: 0 1px;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      border-radius: 4px;
      transition: all 0.15s ease;
      opacity: 0.7;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-sizing: content-box;
    }
    
    .linkContainerListItem:hover .actionIconLink {
      opacity: 1;
      background: transparent;
      color: var(--text-primary);
    }
    
    .actionIconLink:hover {
      color: var(--link-color);
      background: var(--bg-secondary);
      opacity: 1;
      transform: scale(1.1);
    }
    
    .actionIconLink:active {
      transform: scale(0.92);
      opacity: 0.8;
    }

    .collapseIcon {
      cursor: pointer;
      color: #999;
      transition: transform 0.3s ease;
    }
    
    /* Rotate icon when collapsed - for settings dialog */
    .modal .collapsed .collapseIcon {
      transform: rotate(-90deg);
    }

    /* Layout and Containers */
    .groupsTable {
      width: 100%;
      table-layout: fixed;
      border-spacing: 0 10px;
      padding: 0px 8px 50px 8px;
      /* Add vertical space between groups */
      min-height: 100%;  /* Ensure table takes at least full height */
    }

    .groupCell {
      vertical-align: top;
      padding-right: 0; /* Remove padding - spacing handled by vertical dropzones */
    }

    .groupCell:last-child {
      padding-right: 0;
    }

    .linkCell {
      vertical-align: top;
      padding: 0;
      margin: 0;
    }

    .linksList {
      list-style: none;
      /* Ensure no list bullets */
      padding: 0px;
      margin: 0px;
    }

    .linksTable {
      width: 100%;
      table-layout: fixed;
    }
    
    /* Link colors - manual or default */
    .groupContainer .linkText a {
      transition: all 0.2s ease;
      text-decoration: none;
      position: relative;
    }
    
    .groupContainer .linkText a:hover {
      text-decoration: underline;
      text-underline-offset: 2px;
      text-decoration-thickness: 1px;
      opacity: 0.8;
    }

    .groupContainer {
      border: none;
      border-radius: 16px;
      margin-bottom: 0;
      /* removed - spacing handled by dropzones */
      padding: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 
        0 0.5px 2px rgba(0, 0, 0, 0.05),
        0 2px 8px rgba(0, 0, 0, 0.08),
        0 10px 20px -5px rgba(0, 0, 0, 0.1);
      transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
      position: relative;
      transform-style: preserve-3d;
    }
    
    .groupContainer::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 16px;
      padding: 1px;
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.2) 0%, 
        rgba(255, 255, 255, 0) 100%);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask-composite: exclude;
      pointer-events: none;
    }

    .groupContainer:hover {
      box-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.05),
        0 4px 12px rgba(0, 0, 0, 0.1),
        0 20px 40px -10px rgba(0, 0, 0, 0.15);
    }

    .groupContainerHeader {
      padding: 16px 8px 16px 12px;
      margin: 0;
      position: relative;
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.6) 0%, 
        rgba(250, 250, 251, 0.4) 100%);
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      transition: all 0.3s ease;
      z-index: 1;
    }
    
    .groupContainerHeader:hover {
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.8) 0%, 
        rgba(250, 250, 251, 0.6) 100%);
    }
    
    /* Modern integrated group title design */
    .groupContainerHeader .groupTitle {
      /* Font styling removed - now controlled by inline styles from formatting settings */
      /* Inherit font properties from parent h2 element which has the inline styles */
      font-family: inherit;
      font-weight: inherit;
      font-size: inherit;
      color: inherit;
      letter-spacing: inherit;
      transition: all 0.25s ease;
      display: inline-block;
      position: relative;
      padding: 2px 0;
      margin-left: 4px;
    }
    
    /* Hover effect on title - subtle opacity change */
    .groupContainer:hover .groupTitle {
      opacity: 0.9;
    }
    
    /* Integrate collapse icon with title */
    .groupContainerHeader .collapseIcon {
      opacity: 0.75;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      width: 24px;
      height: 24px;
      padding: 2px;
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.02);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    .groupContainerHeader .collapseIcon:hover {
      opacity: 1;
      background: rgba(0, 0, 0, 0.06);
    }
    
    /* Icon animation for collapse state */
    .groupContainer .collapseIcon {
      transform: rotate(0deg);
    }
    
    .groupContainer .collapseIcon path {
      transition: d 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    

    .linkContainerListItem {
      padding: 2px 8px;
      margin: 0;
      /* no margin - spacing handled by dropzones */
      border: 0;
      border-bottom: none;
      transition: all 0.2s ease;
      position: relative;
      background: transparent;
      display: flex;
      align-items: center;
      gap: 8px;
      min-height: 24px;
      width: 100%;
    }
    
    .linkContainerListItem:hover {
      background: rgba(0, 0, 0, 0.015);
    }
    
    /* Subtle accent indicator */
    .linkContainerListItem::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 2px;
      height: 0;
      background: var(--group-accent-color, #6c757d);
      transition: height 0.2s ease;
      border-radius: 1px;
    }
    
    .linkContainerListItem:hover::before {
      height: 60%;
    }

    /* Make headers and link rows easy drag targets */
    .groupContainerHeader {
      cursor: grab;
    }

    .linkContainerListItem {
      cursor: grab;
    }
    
    .linkContainerListItem a {
      color: #334155;
      text-decoration: none;
      transition: all 0.2s ease;
      font-size: 0.875rem;
      font-weight: 450;
      letter-spacing: -0.01em;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .linkContainerListItem:hover a {
      color: var(--group-text-hover-color, var(--group-accent-color, #2563eb));
    }
    
    .linkContainerListItem .link-favicon {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      flex-shrink: 0;
      filter: saturate(0.9);
      transition: all 0.2s ease;
    }
    
    .linkText {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      display: flex;
      align-items: center;
    }

    .linkanchor {
      min-width: 50px;
    }
    
    .linkText .text-truncate {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      display: inline-block;
      width: fit-content;
      max-width: 100%;
    }
    
    .linkContainerListItem:hover .link-favicon {
      filter: saturate(1.2);
    }

    /* Hide tiny drag handle icons */
    .groupDragHandle,
    .linkTextGrip {
      display: none !important;
    }

    .linkContainerListItem:last-child {
      border-bottom: none;
    }

    /* Vertical spacing and separators between link columns */
    .linksTable {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0px 0;
      /* horizontal gap between columns */
    }

    .linksTable td.linkCell {
      vertical-align: top;
      padding: 0px;
    }

    .linksTable td.linkVerticalDropZone {
      vertical-align: top;
      padding: 0;
    }

    .linksTable td:first-child {
      border-left: 0;
    }

    .linkContainer {
      padding: 0;
      border: 0px solid #ccc;
    }

    /* Conflict Resolution Indicators */
    .conflict-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #fbbf24;
      margin-left: 4px;
      animation: pulse 2s infinite;
      cursor: help;
      vertical-align: middle;
    }
    
    .conflict-resolved {
      background-color: #10b981;
      animation: none;
    }
    
    @keyframes pulse {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.1); }
      100% { opacity: 1; transform: scale(1); }
    }
    
    .conflict-notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 12px 16px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 9999;
      max-width: 300px;
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    .conflict-notification-title {
      font-weight: 600;
      margin-bottom: 4px;
      color: #111827;
    }
    
    .conflict-notification-text {
      font-size: 0.875rem;
      color: #6b7280;
    }
    
    .addLinkContainer {
      padding: 16px 20px;
      background: linear-gradient(135deg, 
        rgba(250, 250, 251, 0.6) 0%, 
        rgba(255, 255, 255, 0.9) 100%);
      border-top: 1px solid rgba(0, 0, 0, 0.03);
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      position: relative;
    }
    
    .addLinkContainer::before {
      content: '';
      position: absolute;
      top: 0;
      left: 20px;
      right: 20px;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent 0%, 
        var(--group-accent-color, #cbd5e1) 50%, 
        transparent 100%);
      opacity: 0.3;
    }
    
    .addLinkContainer:hover {
      background: linear-gradient(135deg, 
        rgba(250, 250, 251, 0.8) 0%, 
        rgba(255, 255, 255, 1) 100%);
    }
    
    .addLinkContainer .form-control {
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      font-size: 0.875rem;
      border-radius: 10px;
      padding: 8px 12px;
    }
    
    .addLinkContainer .form-control:focus {
      border-color: var(--group-accent-color, #3b82f6);
      background: rgba(255, 255, 255, 1);
      box-shadow: 
        0 0 0 3px color-mix(in srgb, var(--group-accent-color, #3b82f6) 15%, transparent),
        0 1px 2px rgba(0, 0, 0, 0.05);
    }
    
    .addLinkContainer .btn-primary {
      background: linear-gradient(135deg, 
        var(--group-accent-color, #3b82f6) 0%, 
        color-mix(in srgb, var(--group-accent-color, #3b82f6) 85%, #000) 100%);
      border: none;
      padding: 8px 16px;
      font-size: 0.875rem;
      font-weight: 600;
      border-radius: 10px;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      box-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.1),
        0 4px 6px -2px color-mix(in srgb, var(--group-accent-color, #3b82f6) 30%, transparent);
      position: relative;
      overflow: hidden;
    }
    
    .addLinkContainer .btn-primary::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.3) 50%, 
        transparent 100%);
      transition: left 0.5s ease;
    }
    
    .addLinkContainer .btn-primary:hover {
      box-shadow: 
        0 4px 8px rgba(0, 0, 0, 0.15),
        0 8px 16px -4px color-mix(in srgb, var(--group-accent-color, #3b82f6) 40%, transparent);
    }
    
    .addLinkContainer .btn-primary:hover::before {
      left: 100%;
    }
    
    .addLinkContainer .btn-primary:active {
      box-shadow:
        0 1px 3px rgba(0, 0, 0, 0.1),
        0 2px 4px -2px color-mix(in srgb, var(--group-accent-color, #3b82f6) 30%, transparent);
    }

    /* Vertical drop zones between columns - acts as permanent spacing */
    .verticalDropZone {
      width: 10px !important;
      min-width: 10px !important;
      max-width: 10px !important;
      padding: 0 !important;
      margin: 0 !important;
      border: 0 !important;
      background: transparent;
      position: relative;
      vertical-align: top;
      pointer-events: none;
      transition: all 0.2s ease;
      height: 100%;
    }

    .verticalDropZoneIndicator {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 0px;
      background: transparent;
      transition: all 0.2s ease;
    }

    /* Active state when dragging groups */
    #app.dragging-group .verticalDropZone {
      pointer-events: auto;
    }

    /* Expanded hit area for easier dropping */
    #app.dragging-group .verticalDropZone::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: -15px;
      right: -15px;
      background: transparent;
      pointer-events: auto;
      z-index: 1;
    }

    #app.dragging-group .verticalDropZone.drag-over-active .verticalDropZoneIndicator {
      width: 10px;
      background: linear-gradient(to right,
        transparent 0%,
        rgba(51, 153, 255, 0.25) 20%,
        rgba(51, 153, 255, 0.25) 80%,
        transparent 100%);
      box-shadow:
        inset 2px 0 0 #3399ff,
        inset -2px 0 0 #3399ff;
    }

    /* Vertical dropzones for link columns */
    .linkVerticalDropZone {
      position: relative;
      width: 6px;
      min-width: 6px;
      padding: 0;
      vertical-align: top;
      pointer-events: none;
      min-height: 50px;
    }

    .linkVerticalDropZoneIndicator {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      background: transparent;
      transition: all 0.2s ease;
      pointer-events: none;
    }

    #app.dragging-link .linkVerticalDropZone {
      pointer-events: auto;
    }

    /* Expanded hit area for easier dropping */
    #app.dragging-link .linkVerticalDropZone::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: -10px;
      right: -10px;
      background: transparent;
      pointer-events: auto;
      z-index: 1;
    }

    #app.dragging-link .linkVerticalDropZone.drag-over-active .linkVerticalDropZoneIndicator {
      width: 100%;
      background: linear-gradient(to right,
        transparent 0%,
        rgba(0, 204, 153, 0.25) 20%,
        rgba(0, 204, 153, 0.25) 80%,
        transparent 100%);
      box-shadow:
        inset 1px 0 0 #00cc99,
        inset -1px 0 0 #00cc99;
    }

    /* Drag and Drop Styles: permanent spacers that replace normal margins */
    .group-drop-zone,
    .linkContainerDragAndDrop {
      display: block !important;
      /* always visible as spacer */
      padding: 0 !important;
      margin: 0 !important;
      border: 0 !important;
      background: transparent;
      color: transparent;
      /* hide any text */
      line-height: 0 !important;
      font-size: 0 !important;
      pointer-events: none;
      /* only active during drag */
      position: relative;
      transition: background 0.15s ease, box-shadow 0.15s ease;
      overflow: hidden;
      box-sizing: border-box !important;
    }

    /* Drop zones act as normal spacing between elements */
    .groupContainerDragAndDrop,
    .group-drop-zone {
      height: 10px !important;
      min-height: 10px !important;
      max-height: 10px !important;
      /* fixed spacing between groups - matches vertical dropzone width */
    }
    
    .linkContainerDragAndDrop,
    .link-drop-zone {
      height: 6px !important;
      min-height: 6px !important;
      max-height: 6px !important;
      /* fixed spacing between links */
    }
    
    /* Enable pointer events only when dragging */
    #app.dragging-group .group-drop-zone,
    #app.dragging-group .groupContainerDragAndDrop,
    #app.dragging-link .linkContainerDragAndDrop {
      pointer-events: auto;
    }

    /* Visual feedback only when actively dragging over the zone - no height change */
    #app.dragging-group .groupContainerDragAndDrop.drag-over-active,
    #app.dragging-group .group-drop-zone.drag-over-active {
      background: linear-gradient(to bottom, 
        transparent, 
        rgba(51, 153, 255, 0.25) 30%, 
        rgba(51, 153, 255, 0.25) 70%, 
        transparent);
      box-shadow: 
        inset 0 2px 0 #3399ff,
        inset 0 -2px 0 #3399ff;
    }

    /* Visual feedback for link drop zones when dragging over - no height change */
    #app.dragging-link .linkContainerDragAndDrop.drag-over-active {
      background: linear-gradient(to bottom, 
        transparent, 
        rgba(0, 204, 153, 0.25) 30%, 
        rgba(0, 204, 153, 0.25) 70%, 
        transparent);
      box-shadow: 
        inset 0 1px 0 #00cc99,
        inset 0 -1px 0 #00cc99;
    }

    /* Expanded hit area for easier dropping - only active when dragging */
    #app.dragging-group .group-drop-zone::before,
    #app.dragging-link .linkContainerDragAndDrop::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: -10px;
      height: calc(100% + 20px);
      /* use height instead of bottom to avoid layout issues */
      background: transparent;
      pointer-events: auto;
      z-index: 2;
    }

    /* Deprecated - these classes are no longer used */

    /* Removed - handled by main dropzone styles above */

    /* .isDragged class deprecated - dropzones are permanent spacers now */

    .drag-over-active {
      border-color: #0288d1 !important;
    }

    /* Deprecated isDragged classes */

    /* Optional: Klasse für die Zone, über der *aktiv* geschwebt wird
    (kannst du behalten oder entfernen, je nachdem, ob du eine zusätzliche Hervorhebung willst) */
    .drag-over-active {
      border-color: #0288d1 !important;
      background-color: transparent;
    }

    /* Remove redundant styles - handled above */

    .group-drag-el {
      /* Style for the item being dragged (optional) */
      opacity: 0.7;
      background-color: #fff3cd;
    }

    .grabbing * {
      cursor: grabbing !important;
    }

    .grabbing {
      cursor: grabbing !important;
    }

    /* Keyword cloud */
    .keyword-badge {
      cursor: pointer;
      user-select: none;
    }
    
    /* Keywords container badges alignment */
    .form-control .keyword-badge {
      position: relative;
      top: 2px;
    }

    /* Ensure badges are visible even without bootstrap color helpers */
    .groupName .keyword-badge,
    h2 .keyword-badge {
      border: 1px solid rgba(0, 0, 0, 0.08);
      font-size: 0.65rem;
      line-height: 0.95rem;
      padding: 0.1rem 0.35rem;
      vertical-align: middle;
      position: relative;
      top: 1px;
    }

    .link-favicon {
      width: 16px;
      height: 16px;
      margin-right: 6px;
      vertical-align: -2px;
      border-radius: 3px;
      /* Ensure base64 favicons display correctly */
      object-fit: contain;
      background-color: transparent;
    }

    .link-favicon-wrap {
      position: relative;
      display: inline-block;
      vertical-align: -2px;
      margin-right: 6px;
    }
    .link-favicon-wrap .link-favicon { margin-right: 0; }
    .link-favicon-dot {
      position: absolute;
      top: 0;
      right: 0;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      border: 1px solid #fff;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.08);
      z-index: 2;
    }
    .link-favicon-dot.src-rule { background-color: #0d6efd; }
    .link-favicon-dot.src-upload { background-color: #6f42c1; }
    .link-favicon-dot.src-extension { background-color: #6c757d; }

    .link-favicon-error {
      display: inline-block;
      width: 16px;
      height: 16px;
      margin-right: 6px;
      vertical-align: -2px;
      font-size: 14px;
      line-height: 16px;
      text-align: center;
      opacity: 0.6;
      cursor: help;
    }

    .mb-group-favicon-wrap {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      margin-right: 6px;
    }

    .mb-group-favicon {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      object-fit: contain;
      background-color: #fff;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.12);
    }

    .mb-group-favicon-placeholder {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px dashed #c8cdd5;
      background: linear-gradient(135deg, #f8f9fa 0%, #f1f3f5 100%);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      color: #adb5bd;
    }

    .mb-group-emoji {
      font-size: 1.1rem;
      line-height: 1;
      margin-right: 6px;
    }

    /* Actions and Visibility */
    .groupActions {
      display: inline-flex;
      align-items: center;
      justify-content: flex-end;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      margin-left: auto;
      pointer-events: all; /* Ensure mouse events work even when invisible */
    }
    
    .groupActions:hover {
      opacity: 1;
    }
    
    .groupActionsVisibleOnMouseOver {
      opacity: 1 !important;
    }
    
    .linkContainerListItem:hover .groupActions {
      opacity: 1;
    }
    
    /* Show group actions when hovering over the group header */
    .groupContainer .card-header:hover .groupActions {
      opacity: 1;
    }

    /* Dark Mode Toggle Button */
    .dark-mode-toggle {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      padding: 5px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.875rem;
      color: var(--text-primary);
      transition: all 0.3s ease;
    }
    
    .dark-mode-toggle:hover {
      background: var(--bg-primary);
      border-color: var(--border-light);
      box-shadow: 0 2px 4px var(--shadow-sm);
    }
    
    .dark-mode-toggle .icon {
      font-size: 1rem;
      transition: transform 0.3s ease;
    }
    
    .dark-mode-toggle:hover .icon {
      transform: rotate(20deg);
    }
    
    /* Options Modal */
    .optionsGroupRow {
      padding: 0;
      margin-top: 15px;
    }

    .optionsGroupSettingContainer {
      margin-bottom: 15px;
      margin-left: 25px;
      margin-right: 25px;
    }

    .optionsGroupSetting {
      width: 250px;
      white-space: normal;
      word-wrap: break-word;
      /* Consistent width for labels with text wrapping */
    }

    /* Limit width for checkbox settings */
    .optionsGroupSettingContainer .input-group:has(input[type="checkbox"]) {
      width: auto;
      display: inline-flex;
      max-width: 400px;
    }
    
    /* Wider color picker settings for better color visibility */
    .optionsGroupSettingContainer .input-group:has(input[type="color"]) {
      width: auto;
      display: inline-flex;
      max-width: 600px;
    }
    
    .optionsGroupSettingContainer input[type="color"] {
      min-width: 100px;
      width: 100px;
    }
    
    /* Consistent color picker design across all dialogs */
    #groupEditModal input[type="color"] {
      min-width: 100px;
      width: 100px;
      height: 38px;
      padding: 0.25rem;
      border: 1px solid var(--input-border);
      border-radius: 0.25rem;
    }

    /* Visual CSS Editor: normalize heights in color property input-group */
    .visual-css-editor .input-group.input-group-sm .input-group-text {
      display: flex;
      align-items: center;
      height: calc(1.5em + 0.5rem + 2px);
      padding-top: 0.25rem;
      padding-bottom: 0.25rem;
    }
    .visual-css-editor .input-group.input-group-sm .form-control,
    .visual-css-editor .input-group.input-group-sm .form-select {
      height: calc(1.5em + 0.5rem + 2px);
      padding-top: 0.25rem;
      padding-bottom: 0.25rem;
    }
    .visual-css-editor .input-group.input-group-sm .form-control-color {
      width: 2rem;
      height: calc(1.5em + 0.5rem + 2px);
      padding: 0;
      border-radius: 0 !important;
    }

    /* Visual CSS Editor: more compact collapsed rule card */
    .visual-css-editor .css-rule-card.collapsed {
      padding-top: 6px !important;
      padding-bottom: 6px !important;
    }
    .visual-css-editor .css-rule-card.collapsed .rule-header {
      margin-bottom: 0 !important;
    }

    /* Visual CSS Editor: compact Design Tokens when collapsed */
    .visual-css-editor .design-tokens-section.collapsed {
      padding-top: 6px !important;
      padding-bottom: 6px !important;
    }
    .visual-css-editor .design-tokens-section.collapsed .design-tokens-header {
      margin-bottom: 0 !important;
    }
    
    /* Role scope badges for sync settings */
    .role-badge {
      display: inline-block;
      padding: 2px 6px;
      margin-left: 8px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      border-radius: 4px;
      vertical-align: middle;
    }
    
    .role-badge.role-all {
      background-color: #3b82f6;
      color: white;
    }
    
    .role-badge.role-owner {
      background-color: #fbbf24;
      color: #78350f;
    }
    
    .role-badge.role-member {
      background-color: #10b981;
      color: white;
    }
    
    .option-row.role-disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    
    .role-info {
      display: inline-block;
      margin-left: 4px;
      color: #6b7280;
      cursor: help;
    }


    /* Context Menus */
    .context-menu {
      display: none;
      position: absolute;
      background-color: white;
      border: 1px solid #ccc;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 9999;
      min-width: 150px;
      /* Ensure minimum width */
      border-radius: 4px;
    }

    .context-menu ul {
      list-style: none;
      padding: 5px 0;
      /* Padding around list items */
      margin: 0;
    }

    .context-menu ul li {
      padding: 8px 15px;
      /* Increased padding */
      cursor: pointer;
      font-size: 0.9em;
    }

    .context-menu ul li:hover {
      background-color: #f0f0f0;
    }

    .context-menu-visible {
      display: block;
    }
    .context-menu .separator {
      border-top: 1px solid #e5e7eb;
      margin: 4px 0;
      padding: 0;
    }
    .context-menu .submenu { position: relative; }
    .context-menu .submenu::after {
      content: '▸';
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: #9aa0a6;
      pointer-events: none;
    }
    .context-menu .submenu.open-left::after { content: '◂'; }
    .context-menu .submenu > .context-submenu {
      list-style: none;
      margin: 0;
      padding: 5px 0;
      position: absolute;
      left: 100%;
      top: 0;
      min-width: 220px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      display: none;
      z-index: 10000;
    }
    .context-menu .submenu.open-left > .context-submenu {
      left: auto;
      right: 100%;
    }
    .context-menu .submenu:hover > .context-submenu,
    .context-menu .submenu:focus-within > .context-submenu,
    .context-menu .submenu.open > .context-submenu { display: block; }
    .context-menu .context-submenu li { padding: 8px 15px; white-space: nowrap; }

    /* Footer */
    .copyrightBar {
      position: fixed;
      bottom: 0;
      left: 0;
      /* Ensure it spans full width */
      width: 100%;
      background-color: #f8f9fa;
      text-align: center;
      border-top: 1px solid #e7e7e7;
      padding: 8px 0;
      /* Add some padding */
      font-size: 0.85em;
      color: #666;
      z-index: 1010;
      /* Ensure it's above context menus if needed */
      /* Calculate total height: padding (16px) + font-size (~14px) + line-height + border (1px) ≈ 35-40px */
      height: auto;
      min-height: 35px;
    }

    /* QR Code Modal */
    #qrCodeDiv {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 300px;
      /* Ensure space for QR code */
    }

    #qrCodeDiv img {
      max-width: 100%;
      /* Ensure QR code image is responsive */
      height: auto;
    }

    .disabled-arrow {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
      /* Verhindert Klick-Events auf dem SVG selbst */
    }
    
    .cursor-pointer {
      cursor: pointer;
    }

    /* Remove after legacy icons are deleted */

    /* Rounded look across UI */
    .btn,
    .form-control,
    .input-group-text,
    .dropdown-menu,
    .modal-content,
    .context-menu,
    .groupContainer,
    .linkContainer,
    .linksTable td {
      border-radius: 8px;
    }

    .badge {
      border-radius: 999px;
    }

    .groupContainer {
      overflow: hidden;
    }

    .input-group .btn {
      border-radius: 8px;
    }

    .input-group .form-control {
      border-top-left-radius: 8px;
      border-bottom-left-radius: 8px;
    }

    .input-group .input-group-text {
      border-radius: 8px;
    }

    /* Hide legacy inline icons if still present */
    .btn-toolbar>svg.svg-button {
      display: none !important;
    }

    .btn-toolbar>.dropdown.ms-2 {
      display: none !important;
    }
    
    /* Info popup styles */
    .info-popup {
      position: fixed;
      background: white;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 10000;
      max-width: 400px;
      max-height: 300px;
      overflow-y: auto;
      font-size: 0.9rem;
      display: none;
    }
    
    .info-popup.show {
      display: block;
    }

    .info-icon-trigger {
      transition: transform 0.2s ease;
    }

    .info-icon-trigger:hover {
      transform: scale(1.1);
    }

    /* Link detail popover */
    .link-detail-popover {
      position: fixed;
      min-width: 260px;
      max-width: 320px;
      background: var(--popover-bg, #ffffff);
      color: var(--text-primary, #1a1a1a);
      border-radius: 14px;
      padding: 16px 18px;
      box-shadow:
        0 18px 45px rgba(15, 23, 42, 0.18),
        0 2px 12px rgba(15, 23, 42, 0.12);
      border: 1px solid rgba(15, 23, 42, 0.06);
      z-index: 8000;
      backdrop-filter: blur(8px);
      transition: opacity 0.18s ease, transform 0.18s ease;
      pointer-events: auto;
    }

    .link-detail-popover__title {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 0 8px 0;
      display: flex;
      align-items: flex-start;
      gap: 6px;
      vertical-align: top;
    }

    .link-detail-popover__title-emoji {
      font-size: 1.2rem;
      line-height: 1;
    }

    .link-detail-popover__url {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9rem;
      color: var(--link-color, #0d6efd);
      text-decoration: none;
      word-break: break-all;
      margin: 6px 0;
    }

    .link-detail-popover__url svg {
      flex-shrink: 0;
      align-items: flex-start;
      width: 14px;
      height: 14px;
    }

    .link-detail-popover__url:hover,
    .link-detail-popover__url:focus {
      text-decoration: underline;
    }

    .link-detail-popover__meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 10px;
      font-size: 0.82rem;
      color: var(--text-secondary, #555);
    }

    .link-detail-popover__row {
      display: flex;
      gap: 8px;
      align-items: flex-start;
    }

    .link-detail-popover__label {
      width: 110px;
      flex-shrink: 0;
      font-weight: 500;
      color: var(--text-muted, #888);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .link-detail-popover__value {
      flex: 1;
      color: var(--text-primary, #1a1a1a);
      word-break: break-word;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .link-detail-popover__value--muted {
      font-size: 0.75rem;
      color: var(--text-muted, #888);
    }

    .link-detail-popover__keywords {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }

    .link-detail-popover__badge {
      padding: 4px 8px;
      background: rgba(13, 110, 253, 0.12);
      border-radius: 999px;
      font-size: 0.75rem;
      color: var(--link-color, #0d6efd);
    }

    .link-detail-popover__favicon {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      object-fit: contain;
      box-shadow: 0 2px 6px rgba(15, 23, 42, 0.18);
      flex-shrink: 0;
      vertical-align: top;
    }

    .favicon-rule-actions .btn {
      width: 32px;
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.25rem;
    }

    @media (max-width: 768px) {
      .link-detail-popover {
        left: 16px !important;
        right: 16px !important;
        width: auto;
      }
    }

    
    /* Generic Options Dialog Styles */
    .options-section {
      margin-bottom: 1rem;
      border: 1px solid #dee2e6;
      border-radius: 0.375rem;
    }
    /* Sync progress (bottom-right) */
    .mb-sync-progress {
      position: fixed;
      right: 16px;
      bottom: 24px;
      z-index: 1050;
      width: 280px;
      background: rgba(33, 37, 41, 0.9);
      border-radius: 8px;
      padding: 10px 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      color: #fff;
    }
    .mb-sync-progress .mb-sync-title { font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    .mb-sync-progress .progress { height: 8px; background: rgba(255,255,255,0.15); }
    .mb-sync-progress .progress-bar { background-color: #0d6efd; }
    
    .options-section-header {
      background-color: #f8f9fa;
      padding: 0.75rem 1rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background-color 0.2s;
    }
    
    .options-section-header:hover {
      background-color: #e9ecef;
    }
    
    .options-section-body {
      padding: 1rem;
      background-color: white;
    }
    
    .option-row {
      margin-bottom: 1rem;
    }
    
    .option-row:last-child {
      margin-bottom: 0;
    }
    
    .chevron-icon {
      transition: transform 0.3s;
    }
    
    .collapsed .chevron-icon {
      transform: rotate(-90deg);
    }
    
    .css-sidebar {
      position: fixed;
      top: 0;
      right: -400px;
      width: 400px;
      height: 100vh;
      background-color: #ffffff;
      box-shadow: -2px 0 5px rgba(0,0,0,0.1);
      transition: right 0.3s ease;
      z-index: 1040;
      display: flex;
      flex-direction: column;
    }

    /* When sidebar is open, shift the main content */
    body.css-sidebar-open {
      transition: margin-right 0.3s ease;
    }

    body.css-sidebar-open .css-sidebar {
      right: 0;
    }
    
    .css-sidebar-resize-handle {
      position: absolute;
      left: 0;
      top: 0;
      width: 5px;
      height: 100%;
      cursor: ew-resize;
      background: transparent;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .css-sidebar-resize-handle::before {
      content: '';
      width: 2px;
      height: 40px;
      background-color: #adb5bd;
      border-radius: 1px;
    }
    
    .css-sidebar-resize-handle:hover {
      background-color: rgba(0, 123, 255, 0.1);
    }
    
    .css-sidebar-resize-handle:hover::before {
      background-color: #007bff;
      height: 60px;
    }
    
    .css-sidebar-resize-handle.resizing {
      background-color: rgba(0, 123, 255, 0.2);
    }
    
    .css-sidebar-resize-handle.resizing::before {
      background-color: #0056b3;
      height: 80px;
    }
    
    .css-sidebar.resizing {
      transition: none;
    }
    
    /* Removed - now handled by body.css-sidebar-open */
    
    .css-sidebar .sidebar-header {
      padding: 1rem;
      margin: 0.5rem;
      margin-bottom: 0;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 0.25rem 0.25rem 0 0;
    }
    
    .css-sidebar .sidebar-split-container {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 60px);
      padding: 0.5rem;
      padding-top: 0;
    }
    
    .css-sidebar .sidebar-top-section {
      min-height: 100px;
      overflow-y: auto;
      position: relative;
      padding: 0.75rem;
      background-color: #f8f9fa;
      border-radius: 0.25rem;
      margin-bottom: 0.5rem;
    }
    
    .css-sidebar .sidebar-divider {
      height: 8px;
      background-color: #e9ecef;
      cursor: ns-resize;
      position: relative;
      user-select: none;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .css-sidebar .sidebar-divider::before {
      content: '';
      width: 40px;
      height: 2px;
      background-color: #adb5bd;
      border-radius: 1px;
    }
    
    .css-sidebar .sidebar-divider:hover {
      background-color: #dee2e6;
    }
    
    .css-sidebar .sidebar-divider:hover::before {
      background-color: #6c757d;
    }
    
    .css-sidebar .sidebar-divider.resizing {
      background-color: #ced4da;
    }
    
    .css-sidebar .sidebar-bottom-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 100px;
      padding: 0.75rem;
      background-color: #ffffff;
      border-radius: 0.25rem;
      border: 1px solid #dee2e6;
    }
    
    .css-sidebar .editor-header {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #dee2e6;
      background-color: #f8f9fa;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .css-sidebar .editor-content {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
    }
    
    .css-sidebar .sidebar-content {
      padding: 0.5rem;
    }
    
    /* Feature Overview Sidebar */
    .feature-sidebar {
      position: fixed;
      top: 0;
      right: -450px;
      width: 450px;
      height: 100vh;
      background-color: #ffffff;
      box-shadow: -2px 0 5px rgba(0,0,0,0.1);
      transition: right 0.3s ease;
      z-index: 1040;
      display: flex;
      flex-direction: column;
    }
    
    .feature-sidebar.sidebar-open {
      right: 0;
    }
    
    .feature-sidebar .sidebar-header {
      padding: 15px 20px;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #f8f9fa;
    }

    /* Toast Notification Styles */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 350px;
    }

    .toast-notification {
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      padding: 0;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      min-width: 300px;
    }

    .toast-notification.toast-show {
      opacity: 1;
      transform: translateX(0);
    }

    .toast-notification.toast-hide {
      opacity: 0;
      transform: translateX(100%);
    }

    .toast-content {
      padding: 12px 40px 12px 16px;
    }

    .toast-title {
      font-weight: 600;
      margin-bottom: 4px;
      color: #212529;
      font-size: 14px;
    }

    .toast-body {
      color: #6c757d;
      font-size: 13px;
      line-height: 1.4;
    }

    .toast-close {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      font-size: 24px;
      line-height: 1;
      color: #6c757d;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .toast-close:hover {
      opacity: 1;
    }

    .toast-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .toast-progress-fill {
      height: 100%;
      width: 100%;
      background: currentColor;
      transition: width linear;
    }

    /* Toast type variations */
    .toast-success {
      border-left: 4px solid #28a745;
    }

    .toast-success .toast-progress-fill {
      background: #28a745;
    }

    .toast-error {
      border-left: 4px solid #dc3545;
    }

    .toast-error .toast-progress-fill {
      background: #dc3545;
    }

    .toast-warning {
      border-left: 4px solid #ffc107;
    }

    .toast-warning .toast-progress-fill {
      background: #ffc107;
    }

    .toast-info {
      border-left: 4px solid #17a2b8;
    }

    .toast-info .toast-progress-fill {
      background: #17a2b8;
    }

    /* Dark mode support for toasts */
    body.dark-mode .toast-notification {
      background: #2d3748;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    body.dark-mode .toast-title {
      color: #f7fafc;
    }

    body.dark-mode .toast-body {
      color: #a0aec0;
    }

    body.dark-mode .toast-close {
      color: #a0aec0;
    }

    body.dark-mode .toast-progress {
      background: rgba(255, 255, 255, 0.1);
    }

    .feature-sidebar .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    
    .feature-section {
      margin-bottom: 25px;
    }
    
    .feature-section-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .feature-list {
      list-style: none;
      padding-left: 0;
      margin: 0;
    }
    
    .feature-list li {
      margin-bottom: 10px;
      padding-left: 20px;
      position: relative;
    }
    
    .feature-list li::before {
      content: "▸";
      position: absolute;
      left: 0;
      color: var(--bs-primary);
    }
    
    .feature-list li strong {
      color: var(--bs-dark);
    }
    
    .feature-list.small {
      font-size: 0.9rem;
    }

    .link-shorteners-list .link-shorteners-item {
      background-color: var(--bs-body-bg, #fff);
      border-radius: 0.5rem;
      border: 1px solid rgba(0, 0, 0, 0.05);
      margin-bottom: 0.75rem;
    }

    .link-shorteners-list .badge {
      font-size: 0.75rem;
    }

    .link-security-summary {
      padding: 0.35rem 0.75rem;
    }

    .link-security-summary .badge {
      font-size: 0.75rem;
      width: 100%;
      justify-content: flex-start;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }


    .mb-edit-link-security {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.25rem;
    }

    .mb-edit-link-security .badge {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
    }

    .text-purple {
      color: #6f42c1;
    }
    
    /* Online Status Indicators */
    .online-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-left: 0.5rem;
      position: relative;
    }
    
    .online-indicator.online {
      background-color: #28a745;
      box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.2);
    }
    
    .online-indicator.offline {
      background-color: #6c757d;
    }
    
    .online-indicator.checking {
      background-color: #ffc107;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .contact-row {
      position: relative;
    }
    
    .contact-row.offline {
      opacity: 0.6;
    }
    
    .contact-status-text {
      font-size: 0.85rem;
      margin-left: 0.5rem;
    }
    
    .contact-status-text.online {
      color: #28a745;
    }
    
    .contact-status-text.offline {
      color: #6c757d;
    }

    .title-bar {
      padding: 0px 8px 0px 8px;
    }
    
    .toolbar {
      padding: 0px 8px 0px 8px;
    }

    .keywords-cloud {
      padding: 0px 8px 0px 8px;
    }

    /* Make mainContainer vertically scrollable */
    .mainContainer {
      height: calc(100vh - 200px); /* Adjust based on header/toolbar height */
      overflow-y: auto;
      overflow-x: hidden;
    }
  </style>
  <style id="user-custom-css"></style>
</head>

<body>
  <div id="app"
    :class="['container-fluid', 'app', 'mb-app', {'dragging-group': dragState === 'group', 'dragging-link': dragState === 'link'}]"
    @click.self="hideMenus">
    <!-- Dark Mode Toggle -->
    <!-- <button class="dark-mode-toggle" @click="toggleDarkMode" :title="isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'">
      <svg v-if="isDarkMode" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
        <path d="M12 8a4 4 0 1 1-8 0 4 4 0 0 1 8 0zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
      </svg>
      <svg v-else xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
        <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
      </svg>
    </button> -->
    
    <div class="title-bar mb-titlebar">
      <h1 class="text-start">
        <!-- Placeholder favicon -->
        {{ title }}
      </h1>
    </div>

    <div class="container-fluid toolbar mb-toolbar">
      <div class="btn-toolbar" role="toolbar" aria-label="Toolbar">
        <div class="d-flex align-items-center w-100" style="gap: 0.25rem;">
          <button @click="addGroup" type="button" class="btn btn-sm btn-success mb-btn mb-btn--add-group text-nowrap" style="border-radius: 8px;">
            {{ getTranslation('addGroup') }}
          </button>
          
          <!-- Options & Find duplicates group -->
          <div class="btn-group btn-group-sm mb-tools" role="group" aria-label="Options" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--options" :title="getTranslation('options')"
              @click="showOptionsDialog">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-gear-fill" viewBox="0 0 16 16">
                <path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--favicon-rules" :title="getTranslation('options.links.faviconRules.manage') || 'Favicon rules'"
              @click="openFaviconRulesModal">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-image" viewBox="0 0 16 16">
                <path d="M6.002 5.5a1.5 1.5 0 1 1-3.002 0 1.5 1.5 0 0 1 3.002 0"/>
                <path d="M1 2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2zm0 1h14a1 1 0 0 1 1 1v5.5l-3.146-3.147a.5.5 0 0 0-.708 0L8 10 5.854 7.854a.5.5 0 0 0-.708 0L0 13V4a1 1 0 0 1 1-1"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--custom-css" :title="getTranslation('css.custom.open') || 'Custom CSS'"
              @click="openCssSidebar">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M6.5 0a.5.5 0 0 1 .5.5V2h2V.5a.5.5 0 0 1 1 0V2h.5A2.5 2.5 0 0 1 13 4.5V5h.5a.5.5 0 0 1 0 1H13v2h.5a.5.5 0 0 1 0 1H13v.5A2.5 2.5 0 0 1 10.5 12H10v1.5a.5.5 0 0 1-1 0V12H7v1.5a.5.5 0 0 1-1 0V12h-.5A2.5 2.5 0 0 1 3 9.5V9h-.5a.5.5 0 0 1 0-1H3V6h-.5a.5.5 0 0 1 0-1H3v-.5A2.5 2.5 0 0 1 5.5 2H6V.5a.5.5 0 0 1 .5-.5ZM4 6v3.5A1.5 1.5 0 0 0 5.5 11h5A1.5 1.5 0 0 0 12 9.5V6H4Z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--find-duplicates" :title="getTranslation('duplicates.find')"
              @click="findAndResolveDuplicates">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-binoculars-fill" viewBox="0 0 16 16">
                <path d="M4.5 1A1.5 1.5 0 0 0 3 2.5V3h4v-.5A1.5 1.5 0 0 0 5.5 1zM7 4v1h2V4h4v.882a.5.5 0 0 0 .276.447l.895.447A1.5 1.5 0 0 1 15 7.118V13H9v-1.5a.5.5 0 0 1 .146-.354l.854-.853V9.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v.793l.854.853A.5.5 0 0 1 7 11.5V13H1V7.118a1.5 1.5 0 0 1 .83-1.342l.894-.447A.5.5 0 0 0 3 4.882V4zM1 14v.5A1.5 1.5 0 0 0 2.5 16h3A1.5 1.5 0 0 0 7 14.5V14zm8 0v.5a1.5 1.5 0 0 0 1.5 1.5h3a1.5 1.5 0 0 0 1.5-1.5V14zm4-11H9v-.5A1.5 1.5 0 0 1 10.5 1h1A1.5 1.5 0 0 1 13 2.5z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--clear-ext-cache" :title="getTranslation('extension.clearCache') || 'Extension Cache leeren'"
              @click="clearExtensionCache">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
              </svg>
            </button>
          </div>

          <!-- CardDAV Sync group (only when extension available and enabled) -->
          <div class="btn-group btn-group-sm" role="group" aria-label="Sync" style="margin-left: 0.25rem;"
               v-if="extensionAvailable && data.options?.sync?.backend">
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--sync-now"
                    :title="getTranslation('carddav.syncNow')"
                    @click="syncNowGeneric">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-repeat" viewBox="0 0 16 16">
                <path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41m-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9"/>
                <path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5 5 0 0 0 8 3M3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9z"/>
              </svg>
            </button>
          </div>

          <!-- Contacts group -->
          <div class="btn-group btn-group-sm position-relative" role="group" aria-label="Contacts" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary mb-btn mb-btn--contacts" title="Contacts & Quick-Connect" @click="openContactsDialog" data-bs-toggle="modal" data-bs-target="#contactsModal">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3Zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/>
              </svg>
            </button>
            <!--
            <button type="button" class="btn btn-outline-secondary" 
              :title="syncAllCooldown > 0 ? `Sync All (wait ${syncAllCooldown}s)` : 'Sync All Groups'" 
              @click="syncAllGroups"
              :disabled="syncAllCooldown > 0 || isSyncingAll">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                <circle v-if="isSyncingAll" cx="8" cy="8" r="2" fill="none" stroke="currentColor" stroke-width="1">
                  <animateTransform attributeName="transform" type="rotate" from="0 8 8" to="360 8 8" dur="1s" repeatCount="indefinite"/>
                </circle>
              </svg>
            </button>
          -->
            <!-- Countdown badge outside button but inside btn-group -->
             <!--
            <span v-if="syncAllCooldown > 0" 
                  class="position-absolute badge rounded-pill bg-danger"
                  style="font-size: 0.65em; z-index: 1050; top: -8px; right: -8px;">
              {{ syncAllCooldown }}
            </span>
          -->
          </div>
          
          <!-- Open all & Close all group -->
          <div class="btn-group btn-group-sm" role="group" aria-label="Expand Collapse" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('groups.openAll')"
              @click="expandAllGroups">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                viewBox="0 0 16 16">
                <path fill-rule="evenodd"
                  d="M1.646 3.646a.5.5 0 0 1 .708 0L8 9.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708Z" />
                <path fill-rule="evenodd"
                  d="M1.646 7.646a.5.5 0 0 1 .708 0L8 13.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708Z" />
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('groups.closeAll')"
              @click="collapseAllGroups">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                viewBox="0 0 16 16">
                <path fill-rule="evenodd"
                  d="M14.354 12.354a.5.5 0 0 1-.708 0L8 6.707l-5.646 5.647a.5.5 0 0 1-.708-.708l6-6a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708Z" />
                <path fill-rule="evenodd"
                  d="M14.354 8.354a.5.5 0 0 1-.708 0L8 2.707l-5.646 5.647a.5.5 0 1 1-.708-.708l6-6a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708Z" />
              </svg>
            </button>
          </div>
          
          <!-- Import & Export group -->
          <div class="btn-group btn-group-sm" role="group" aria-label="Import Export" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('exportToFile')"
              @click="exportAndDownload">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-download" viewBox="0 0 16 16">
                <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/>
                <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('import')" @click="openPasteModal">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-upload" viewBox="0 0 16 16">
                <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/>
                <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708z"/>
              </svg>
            </button>
          </div>
          
          <!-- Bookmarklet group -->
          <div class="btn-group btn-group-sm" role="group" aria-label="Bookmarklet" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary"
              :title="getTranslation('bookmarklet.addCurrentTab')" @click="showBookmarkletHelp">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bookmark-check-fill" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M2 15.5V2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v13.5a.5.5 0 0 1-.74.439L8 13.069l-5.26 2.87A.5.5 0 0 1 2 15.5m8.854-9.646a.5.5 0 0 0-.708-.708L7.5 7.793 6.354 6.646a.5.5 0 1 0-.708.708l1.5 1.5a.5.5 0 0 0 .708 0z"/>
              </svg>
            </button>
          </div>

          <!-- Snapshots dropdown as a grouped item -->
          <div class="btn-group btn-group-sm mb-snapshots-dropdown" role="group" aria-label="Snapshots" style="margin-left: 0.25rem;">
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('undo')" @click="undo">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-outline-secondary" :title="getTranslation('redo')" @click="redo">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/>
                <path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/>
              </svg>
            </button>
            <button class="btn btn-outline-secondary dropdown-toggle mb-snapshots-btn" type="button" data-bs-toggle="dropdown"
              aria-expanded="false">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-plus-fill me-1" viewBox="0 0 16 16">
                <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5z"/>
                <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5zm4.5 6V9H10a.5.5 0 0 1 0 1H8.5v1.5a.5.5 0 0 1-1 0V10H6a.5.5 0 0 1 0-1h1.5V7.5a.5.5 0 0 1 1 0"/>
              </svg>
              {{ getTranslation('snapshots.title') }}
            </button>
            <ul class="dropdown-menu mb-snapshots-menu">
              <li><a class="dropdown-item" href="#" @click.prevent="saveSnapshot">{{
                  getTranslation('snapshots.save') }}</a></li>
              <li>
                <hr class="dropdown-divider">
              </li>
              <li v-if="!data.snapshots || !data.snapshots.length" class="dropdown-item text-muted">{{
                getTranslation('snapshots.none') }}</li>
              <li v-for="s in (data.snapshots || [])" :key="'snap-'+s.id" class="dropdown-item">
                <div class="d-flex align-items-center justify-content-between">
                  <a href="#" @click.prevent="restoreSnapshot(s.id)">{{ formatSnapshotLabel(s) }}</a>
                  <button class="btn btn-xs btn-link text-danger ms-2"
                    @click.stop.prevent="deleteSnapshot(s.id)">×</button>
                </div>
              </li>
            </ul>
          </div>

          <!-- Search group -->
          <div class="input-group input-group-sm align-items-stretch flex-grow-1 mb-toolbar__search" style="margin-left: 0.25rem;">
            <span class="input-group-text" id="search-addon">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-search me-1" viewBox="0 0 16 16">
                <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/>
              </svg>
              <span>
              {{ getTranslation('search') }}
              </span>
            </span>
            <button class="btn btn-outline-secondary" type="button" @click="onClearClick"
              :title="getTranslation('clear')">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path
                  d="M2.5 2.5a.7.7 0 0 1 .99 0L8 7.01l4.51-4.51a.7.7 0 1 1 .99.99L8.99 8l4.51 4.51a.7.7 0 0 1-.99.99L8 8.99l-4.51 4.51a.7.7 0 1 1-.99-.99L7.01 8 2.5 3.49a.7.7 0 0 1 0-.99Z" />
              </svg>
            </button>
            <input type="text" class="form-control" v-model="filterText" :aria-label="getTranslation('search')"
              aria-describedby="search-addon" id="searchFilter">
            <button class="btn btn-outline-secondary" type="button" @click="saveCurrentSearch"
              :title="getTranslation('savedSearches.save')">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-floppy-fill" viewBox="0 0 16 16">
                <path d="M0 1.5A1.5 1.5 0 0 1 1.5 0H3v5.5A1.5 1.5 0 0 0 4.5 7h7A1.5 1.5 0 0 0 13 5.5V0h.086a1.5 1.5 0 0 1 1.06.44l1.415 1.414A1.5 1.5 0 0 1 16 2.914V14.5a1.5 1.5 0 0 1-1.5 1.5H14v-5.5A1.5 1.5 0 0 0 12.5 9h-9A1.5 1.5 0 0 0 2 10.5V16h-.5A1.5 1.5 0 0 1 0 14.5z"/>
                <path d="M3 16h10v-5.5a.5.5 0 0 0-.5-.5h-9a.5.5 0 0 0-.5.5zm9-16H4v5.5a.5.5 0 0 0 .5.5h7a.5.5 0 0 0 .5-.5zM9 1h2v4H9z"/>
              </svg>
            </button>
            <select class="form-select" v-model="selectedSavedSearch" @change="applySavedSearch"
              style="max-width: 220px;">
              <option value="">{{ getTranslation('savedSearches.placeholder') }}</option>
              <option v-for="s in savedSearches" :key="'ss-'+s.id" :value="s.id">{{ s.name }}</option>
            </select>
            <button class="btn btn-outline-danger" type="button" :disabled="!selectedSavedSearch"
              @click="deleteSavedSearch" :title="getTranslation('savedSearches.delete')">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash-fill" viewBox="0 0 16 16">
                <path d="M2.5 1a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1H3v9a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V4h.5a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H10a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1zm3 4a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5M8 5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7A.5.5 0 0 1 8 5m3 .5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 1 0"/>
              </svg>
            </button>
            
            <!-- Storage indicator (show used only) -->
            <div class="ms-2 me-2 d-flex align-items-center text-muted small mb-toolbar__storage" :title="getStorageTooltip()" style="min-width: auto;">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-database-fill me-1" viewBox="0 0 16 16">
                <path d="M3.904 1.777C4.978 1.289 6.427 1 8 1s3.022.289 4.096.777C13.125 2.245 14 2.993 14 4s-.875 1.755-1.904 2.223C11.022 6.711 9.573 7 8 7s-3.022-.289-4.096-.777C2.875 5.755 2 5.007 2 4s.875-1.755 1.904-2.223Z"/>
                <path d="M2 6.161V7c0 1.007.875 1.755 1.904 2.223C4.978 9.71 6.427 10 8 10s3.022-.289 4.096-.777C13.125 8.755 14 8.007 14 7v-.839c-.457.432-1.004.751-1.49.972C11.278 7.693 9.682 8 8 8s-3.278-.307-4.51-.867c-.486-.22-1.033-.54-1.49-.972Z"/>
                <path d="M2 9.161V10c0 1.007.875 1.755 1.904 2.223C4.978 12.711 6.427 13 8 13s3.022-.289 4.096-.777C13.125 11.755 14 11.007 14 10v-.839c-.457.432-1.004.751-1.49.972-1.232.56-2.828.867-4.51.867s-3.278-.307-4.51-.867c-.486-.22-1.033-.54-1.49-.972Z"/>
                <path d="M2 12.161V13c0 1.007.875 1.755 1.904 2.223C4.978 15.711 6.427 16 8 16s3.022-.289 4.096-.777C13.125 14.755 14 14.007 14 13v-.839c-.457.432-1.004.751-1.49.972-1.232.56-2.828.867-4.51.867s-3.278-.307-4.51-.867c-.486-.22-1.033-.54-1.49-.972Z"/>
              </svg>
              <span>{{ formatStorageSize(storageUsed) }}</span>
            </div>
            
            <!-- Help/Feature Overview Button (moved to right end) -->
            <button type="button" class="btn btn-sm btn-outline-secondary mb-btn mb-btn--features ms-2" :title="getTranslation('features.open') || 'Hilfe / Help'"
              @click="openFeatureSidebar">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.93-9.412-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2"/>
              </svg>
            </button>
          </div>              
        </div>
      </div>
    </div>

    <!-- Keywords Cloud -->
    <div class="container-fluid keywords-cloud mb-keywords-cloud">
      <div class="input-group input-group-sm">
        <span class="input-group-text mb-keyword-label">Keywords</span>
        <div class="form-control p-1 keyword-container">
          <div class="d-flex flex-wrap align-items-center">
            <span v-for="kw in allKeywords" :key="'kw-'+kw" role="button" 
              :class="['badge','me-1','mb-1','keyword-badge','mb-keyword', keywordClass(kw)]"
              :data-keyword="keywordSlug(kw)"
              :style="getKeywordGradientStyle(kw)"
              @click="onKeywordClick(kw)">{{ kw }}</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Groups and Links Content Container -->
    <div class="container-fluid m-0 p-0 mainContainer mb-groups-links-container">
      <table class="groupsTable">
        <tr>
          <!-- Vertikale Dropzone vor der ersten Spalte -->
          <td class="verticalDropZone"
              @drop.stop.prevent="handleDropToNewColumn($event, -1)"
              @dragover.prevent
              @dragenter.prevent="dropManager.handleDragEnterVerticalZone($event)"
              @dragleave="dropManager.handleDragLeaveVerticalZone($event)">
            <div class="verticalDropZoneIndicator"></div>
          </td>

          <template v-for="(colIndex, groupColumnIndex) in getGroupColumns()" :key="'groupColumn-' + groupColumnIndex">
            <td class="groupCell">

            <div v-if="getGroupsByColumn(colIndex).length === 0"
              :class="['groupContainerDragAndDrop', 'group-drop-zone']"
              @drop.stop.prevent="dropManager.onDrop($event, data.groups, null, 0, colIndex, 'group'); saveData()"
              @dragover.prevent @dragenter.prevent="dropManager.handleDragEnterZone($event)"
              @dragleave="dropManager.handleDragLeaveZone($event)"> {{ getTranslation('group.dropAfter') }}
            </div>

            <template v-for="(group, groupIndex) in getGroupsByColumn(colIndex)" :key="'group-template-' + group.uuid">
              <div :key="'group-drop-before-' + group.uuid"
                :class="['groupContainerDragAndDrop', 'group-drop-zone']"
                @drop.stop.prevent="dropManager.onDrop($event, data.groups, null, groupIndex, colIndex, 'group'); saveData()"
                @dragover.prevent @dragenter.prevent="dropManager.handleDragEnterZone($event)"
                @dragleave="dropManager.handleDragLeaveZone($event)">
                {{ getTranslation('group.dropAfter') }}
              </div>

              <div :key="'group-' + group.uuid" :class="['groupContainer', 'mb-group', cssClassFromUuid('group', group.uuid)]"
                :data-uuid="group.uuid"
                :data-group-id="group.id"
                @mouseover="group.isMouseOver = true"
                @mouseleave="group.isMouseOver = false" @dragover.prevent="handleGroupDragOver(group)"
                @dragenter.prevent="handleGroupDragEnter(group)" @dragleave="handleGroupDragLeave(group)"
                @drop.stop.prevent="handleLinkDrop($event, group, getLinksByColumn(group.links, (getLinkColumns(group.links)[0] ?? 0)).length, (getLinkColumns(group.links)[0] ?? 0))">

                <div class="container-fluid groupContainerHeader p-0 mb-group__header" 
                  draggable="true"
                  :data-drag-id="'group-' + group.uuid"
                  @mouseover="group.isMouseOver = true; prepareForDrag($event, $event.currentTarget)"
                  @mouseleave="group.isMouseOver = false"
                  @mousedown="prepareForDrag($event, $event.currentTarget)"
                  @dragstart="dropManager.startDrag($event, data.groups, group, 'group')" 
                  @dragend="handleDragEnd($event)"
                  style="cursor: grab;">
                  <div class="row align-items-center g-0">
                    <div class="col">
                      <div class="d-flex align-items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none"
                          class="collapseIcon flex-shrink-0" viewBox="0 0 24 24"
                          data-bs-toggle="collapse" :href="'#collapseGroup-' + group.uuid" role="button" tabindex="0"
                          @keydown="onKeyActivate($event, () => toggleGroupCollapse(group))"
                          :aria-expanded="!group.collapsed" :aria-controls="'#collapseGroup-' + group.uuid"
                          @click.prevent="toggleGroupCollapse(group)">
                          <path v-if="group.collapsed && group.searchCollapsed"
                            stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                            d="M9 6l6 6-6 6" />
                          <path v-else
                            stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                            d="M6 9l6 6 6-6" />
                          <title>{{ getTranslation('group.toggleGroupCollapse') }}</title>
                        </svg>
                        <!-- Drag Handle Icon für Gruppen-Drag & Drop (div für stabilere Drag Events) -->
                        <div class="groupDragHandle flex-shrink-0 me-1" :draggable="'true'"
                          @dragstart="dropManager.startDrag($event, data.groups, group, 'group')"
                          @dragend="handleDragEnd()" @mousedown="prepareForDrag($event, $event.currentTarget); $event.stopPropagation()"
                          @click="$event.stopPropagation()"
                          style="cursor: grab; display: inline-flex; align-items: center; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; padding: 2px; min-width: 24px; min-height: 24px; justify-content: center;">
                          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor"
                            class="bi bi-grip-vertical" viewBox="0 0 16 16" style="pointer-events: none;">
                            <title>Drag to move group</title>
                            <path
                              d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0m3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0M7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0m3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0M7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0m3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0m-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0m3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0m-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0m3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0" />
                          </svg>
                        </div>
                        <h2 v-if="!group.editing" class="groupName mb-0 d-flex align-items-center"
                          @dblclick="startEditing(group)"
                          @mouseover="group.isMouseOver = true"
                          @mouseleave="group.isMouseOver = false">
                          <span class="flex-grow-1 d-flex align-items-center groupTitle mb-group__title">
                            <span v-if="group.favicon" class="mb-group-favicon-wrap" :title="faviconSourceTooltip(group)">
                              <img :src="group.favicon" alt="" class="mb-group-favicon">
                            </span>
                            <span v-else-if="group.emoji" class="mb-group-emoji">{{ group.emoji }}</span>
                            <span class="text-truncate" v-html="sanitizeHtml(group.name || '')"></span>
                            <!-- Shared group icon -->
                            <svg v-if="group.shared" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" 
                              class="bi bi-share-fill text-primary ms-2" viewBox="0 0 16 16" style="vertical-align: middle;">
                              <title>{{ getTranslation('group.shared') }}</title>
                              <path d="M11 2.5a2.5 2.5 0 1 1 .603 1.628l-6.718 3.12a2.5 2.5 0 0 1 0 1.504l6.718 3.12a2.5 2.5 0 1 1-.488.876l-6.718-3.12a2.5 2.5 0 1 1 0-3.256l6.718-3.12A2.5 2.5 0 0 1 11 2.5"/>
                            </svg>
                            <!-- Link count pill -->
                            <span :class="['groupLinkCount', 'mb-linkcount-badge', { 'empty': group.links.length === 0 }]"
                              :data-group-uuid="group.uuid"
                              :data-group-name="keywordSlug(group.name)"
                              :data-link-count="group.links.length">
                              {{ group.links.length }}
                            </span>
                          </span>
                          <span class="ms-2 d-flex align-items-center mb-group__badges">
                            <span v-for="kw in groupKeywordsArray(group)" :key="'gkw-'+group.uuid+'-'+kw"
                              :class="['badge','keyword-badge','mb-group__keyword-badge', keywordClass(kw)]"
                              :data-group-uuid="group.uuid"
                              :data-group-name="keywordSlug(group.name)"
                              :data-keyword="keywordSlug(kw)"
                              @click.stop="onKeywordClick(kw)" role="button">{{ kw }}</span>
                          </span>
                        </h2>
                        <input v-else v-model="group.name" type="text" class="form-control form-control-sm"
                          aria-label="GroupName" @blur="saveEditing(group)" @keyup.enter="saveEditing(group)"
                          @keyup.esc="cancelEditing(group)" v-focus="group.editing">
                      </div>
                    </div>
                    <div
                      :class="['col-auto', 'text-end', 'ps-2', 'groupActions', {'groupActionsVisibleOnMouseOver': group.isMouseOver}]" 
                      style="margin-left: auto;">
                      <!-- Add link button (dialog mode) -->
                      <svg v-if="data.options?.buttons?.showAddLink" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                        :class="['bi bi-node-plus-fill fw-bold actionIcon ms-2 me-1', canAdd(group) ? 'text-success' : 'text-muted']"
                        :style="{ cursor: canAdd(group) ? 'pointer' : 'not-allowed', opacity: canAdd(group) ? 1 : 0.5 }"
                        viewBox="0 0 16 16"
                        role="button" tabindex="0"
                        @keydown="canAdd(group) ? onKeyActivate($event, () => openAddLinkDialog(group)) : null"
                        @click="canAdd(group) ? openAddLinkDialog(group) : null"
                        :title="canAdd(group) ? getTranslation('group.addLink') : getTranslation('error.perm.add')">
                        <path d="M11 13a5 5 0 1 0-4.975-5.5H4A1.5 1.5 0 0 0 2.5 6h-1A1.5 1.5 0 0 0 0 7.5v1A1.5 1.5 0 0 0 1.5 10h1A1.5 1.5 0 0 0 4 8.5h2.025A5 5 0 0 0 11 13m.5-7.5v2h2a.5.5 0 0 1 0 1h-2v2a.5.5 0 0 1-1 0v-2h-2a.5.5 0 0 1 0-1h2v-2a.5.5 0 0 1 1 0"/>
                      </svg>
                      <!-- Delete group button -->
                      <svg v-if="data.options?.buttons?.showDeleteGroup" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                        :class="['bi bi-trash-fill fw-bold actionIcon ms-1 me-1', isOwnerOfGroup(group) ? 'text-danger' : 'text-muted']"
                        :style="{ cursor: isOwnerOfGroup(group) ? 'pointer' : 'not-allowed', opacity: isOwnerOfGroup(group) ? 1 : 0.5 }"
                        viewBox="0 0 16 16"
                        role="button" tabindex="0"
                        @keydown.stop="isOwnerOfGroup(group) ? onKeyActivate($event, () => delGroup(group)) : null"
                        @click.stop="isOwnerOfGroup(group) ? delGroup(group) : null"
                        :title="isOwnerOfGroup(group) ? getTranslation('group.deleteGroup') : (group.shared ? getTranslation('menu.group.leaveGroup') : getTranslation('error.perm.delete'))">
                        <path d="M2.5 1a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1H3v9a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V4h.5a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H10a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1zm3 4a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5M8 5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7A.5.5 0 0 1 8 5m3 .5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 1 0"/>
                      </svg>
                      <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor"
                        class="bi bi-three-dots-vertical svg-button actionIcon mb-group-menu-btn me-2" viewBox="0 0 16 16" 
                        role="button" tabindex="0" @keydown.stop="onKeyActivate($event, () => showGroupMenu($event, group))"
                        @click.stop="showGroupMenu($event, group)">
                        <path
                          d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0" />
                      </svg>
                    </div>
                  </div>
                </div>
                <div :class="['collapse', 'linkContainer', 'mb-group__body', {'show': !group.collapsed}]"
                  :id="'collapseGroup-' + group.uuid">
                  <!-- Collapsible info section -->
                  <div v-if="group.infoHtml" class="group-info-section mb-group-info-section">
                    <div class="d-flex align-items-center px-1 py-0 mb-group-info-header" 
                         role="button"
                         @click="toggleGroupInfo(group)">
                      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" 
                           class="bi bi-info-circle me-1 text-info" viewBox="0 0 16 16">
                        <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                        <path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
                      </svg>
                      <span class="text-info mb-group-info-label">{{ getTranslation('group.info.toggle') || 'Information' }}</span>
                      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" 
                           class="bi ms-auto text-info" viewBox="0 0 16 16">
                        <path v-if="!group.infoExpanded" fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                        <path v-else fill-rule="evenodd" d="M7.646 4.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1-.708.708L8 5.707l-5.646 5.647a.5.5 0 0 1-.708-.708l6-6z"/>
                      </svg>
                    </div>
                    <div v-show="group.infoExpanded" class="px-2 py-1 mb-1 mb-group-info-content" 
                         v-html="group.infoHtml"></div>
                  </div>
                  <table class="linksTable mb-links">
                    <tr>
                      <!-- Vertikale Dropzone vor der ersten Link-Spalte -->
                      <td class="linkVerticalDropZone"
                          @drop.stop.prevent="handleLinkDropToNewColumn($event, group, -1)"
                          @dragover.prevent
                          @dragenter.prevent="dropManager.handleDragEnterVerticalZone($event)"
                          @dragleave="dropManager.handleDragLeaveVerticalZone($event)">
                        <div class="linkVerticalDropZoneIndicator"></div>
                      </td>

                      <template v-for="(linkColIndex, linkColumnIndex) in getLinkColumns(group.links)">
                        <td :key="'linkColumn-' + linkColumnIndex" class="linkCell">

                        <div v-if="getLinksByColumn(group.links, linkColIndex).length === 0"
                          :class="['linkContainerDragAndDrop', 'link-drop-zone']"
                          @drop.stop.prevent="handleLinkDrop($event, group, 0, linkColIndex)" @dragover.prevent
                          @dragenter.prevent="dropManager.handleDragEnterZone($event)"
                          @dragleave="dropManager.handleDragLeaveZone($event)">
                          {{ getTranslation('group.link.dropAfter') }}
                        </div>

                        <template v-for="(link, linkIndex) in getLinksByColumn(group.links, linkColIndex)">
                          <div :key="'link-drop-before-' + link.uuid"
                            :class="['linkContainerDragAndDrop', 'link-drop-zone']"
                            @drop.stop.prevent="handleLinkDrop($event, group, linkIndex, linkColIndex)"
                            @dragover.prevent @dragenter.prevent="dropManager.handleDragEnterZone($event)"
                            @dragleave="dropManager.handleDragLeaveZone($event)">
                            {{ getTranslation('group.link.dropAfter') }}
                          </div>

                          <div :key="'link-' + link.uuid" :class="['linkContainerListItem', 'mb-link', cssClassFromUuid('link', link.uuid)]"
                            :data-uuid="link.uuid"
                            :data-link-id="link.id"
                            :data-drag-id="'link-' + link.uuid"
                            @mouseover="link.isMouseOver = true; prepareForDrag($event, $event.currentTarget); if (shouldShowLinkPopover()) { cancelHideLinkPopover(); showLinkPopover($event, link); }" 
                            @mouseleave="link.isMouseOver = false; if (shouldShowLinkPopover()) queueHideLinkPopover()"
                            @focusin="if (shouldShowLinkPopover()) { cancelHideLinkPopover(); showLinkPopover($event, link); }"
                            @focusout="if (shouldShowLinkPopover()) queueHideLinkPopover()"
                            @dblclick="startEditing(link)"
                            :draggable="!link.editing"
                            @mousedown="prepareForDrag($event, $event.currentTarget)"
                            @dragstart="hideLinkPopover(); dropManager.startDrag($event, group.links, link, 'link')"
                            @dragend="handleDragEnd($event)" 
                            @dragover.prevent @dragenter.prevent
>
                                <div class="linkText mb-link__url">
                                  <template v-if="!link.editing">
                                    <span 
                                      :class="[{'linkTextCategory': !link.url}, 'text-truncate']" style="min-width: 0; overflow: hidden;">
                                      <a v-if="link.url" :href="link.url" :title="link.url"
                                        :target="data.options?.links?.openInNewTab ? '_blank' : null"
                                        :rel="data.options?.links?.openInNewTab ? 'noopener noreferrer' : null"
                                        class="text-decoration-none linkanchor mb-link__anchor" draggable="false"
                                        @click.stop>
                                        <img
                                          v-if="data.options?.links?.autoFetchFavicon && link.favicon"
                                          :src="link.favicon" alt="" class="link-favicon" />
                                        <span
                                          v-else-if="data.options?.links?.autoFetchFavicon && link.faviconError"
                                          class="link-favicon-error" title="Favicon konnte nicht geladen werden (Extension erforderlich)">⚠️</span>
                                        <span v-html="sanitizeInlineNoAnchor(link.text || '')"></span>
                                      </a>
                                      <span v-else>
                                        <span v-html="sanitizeHtml(link.text || '')"></span>
                                      </span>
                                    </span>
                                    <!-- URL preview on hover - moved before badges -->
                                    <span v-if="link.url" class="link-url-preview">{{ link.url }}</span>
                                    <!-- Link keyword badges - moved outside text-truncate to stay visible -->
                                    <span v-if="data.options?.links?.showLinkBadges && link.keywords" 
                                      class="margin-left ms-3 mb-link__badges">
                                      <span v-for="kw in parseKeywords(link.keywords)" 
                                        :key="'lkw-' + link.uuid + '-' + kw"
                                        :class="['badge','keyword-badge','mb-link__keyword-badge', keywordClass(kw)]" 
                                        :data-group-uuid="group.uuid"
                                        :data-group-name="keywordSlug(group.name)"
                                        :data-link-uuid="link.uuid"
                                        :data-link-text="keywordSlug(link.text)"
                                        :data-keyword="keywordSlug(kw)"
                                        @click.stop="onKeywordClick(kw)" role="button">{{ kw }}</span>
                                    </span>
                                  </template>
                                  <input v-else v-model="link.text" type="text" ref="linkTextInput"
                                    class="form-control form-control-sm flex-grow-1" aria-label="LinkText"
                                    @blur="saveEditing(link)" @keyup.enter="saveEditing(link)"
                                    @keyup.esc="cancelEditing(link)" v-focus="link.editing">
                                </div>
                              <div
                                :class="['groupActions', {'groupActionsVisibleOnMouseOver': link.isMouseOver && !link.editing}]" style="display: flex; align-items: center; gap: 2px; flex-shrink: 0;">
                                <!-- Info button - shows HTML popup on hover -->
                                <svg v-if="link.infoHtml" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" 
                                  class="bi bi-info-circle-fill text-info actionIcon" viewBox="0 0 16 16"
                                  style="cursor: help;"
                                  @mouseover="showInfoPopup($event, link.infoHtml)"
                                  @mouseleave="hideInfoPopup()">
                                  <title>{{ getTranslation('link.info') || 'Info' }}</title>
                                  <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.93-9.412-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2"/>
                                </svg>

                                <!-- Copy URL button -->
                                <svg v-if="link.url && data.options?.buttons?.showCopyUrl" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                  class="bi bi-clipboard actionIcon" viewBox="0 0 16 16" role="button"
                                  tabindex="0" @keydown.stop="onKeyActivate($event, () => copyLinkToClipboard(link))"
                                  @click.stop="copyLinkToClipboard(link)">
                                  <title>{{ getTranslation('link.copyUrl') || 'Copy URL' }}</title>
                                  <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
                                  <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
                                </svg>

                                <!-- QR code button -->
                                <svg v-if="link.url && data.options?.buttons?.showQrCode" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                  class="bi bi-qr-code actionIcon" viewBox="0 0 16 16" role="button"
                                  tabindex="0" @keydown.stop="onKeyActivate($event, () => showQrCodeModal(link.url))"
                                  @click.stop="showQrCodeModal(link.url)">
                                  <title>{{ getTranslation('link.qrCode') || 'Generate QR Code' }}</title>
                                  <path d="M2 2h2v2H2z"/>
                                  <path d="M6 0v6H0V0zM5 1H1v4h4zM4 12H2v2h2z"/>
                                  <path d="M6 10v6H0v-6zm-5 1v4h4v-4zm11-9h2v2h-2z"/>
                                  <path d="M10 0v6h6V0zm5 1v4h-4V1zM8 1V0h1v2H8v2H7V1zm0 5V4h1v2zM6 8V7h1V6h1v2h1V7h5v1h-4v1H7V8zm0 0v1H2V8H1v1H0V7h3v1zm10 1h-1V7h1zm-1 0h-1v2h2v-1h-1zm-4 0h2v1h-1v1h-1zm2 3v-1h-1v1h-1v1H9v1h3v-2zm0 0h3v1h-2v1h-1zm-4-1v1h1v-2H7v1z"/>
                                  <path d="M7 12h1v3h4v1H7zm9 2v2h-3v-1h2v-1z"/>
                                </svg>
                                
                                <!-- Delete link button -->
                                <svg v-if="data.options?.buttons?.showDeleteLink" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                  :class="['bi bi-trash-fill svg-button fw-bold actionIcon', canDelete(group) ? 'text-danger' : 'text-muted']"
                                  :style="{ cursor: canDelete(group) ? 'pointer' : 'not-allowed', opacity: canDelete(group) ? 1 : 0.5 }"
                                  viewBox="0 0 16 16"
                                  role="button" tabindex="0"
                                  @keydown.stop="canDelete(group) ? onKeyActivate($event, () => deleteLink(link)) : null"
                                  @click.stop="canDelete(group) ? deleteLink(link) : null">
                                  <title>{{ canDelete(group) ? getTranslation('menu.link.deleteLink') : getTranslation('error.perm.delete') }}</title>
                                  <path d="M2.5 1a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1H3v9a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V4h.5a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H10a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1zm3 4a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5M8 5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7A.5.5 0 0 1 8 5m3 .5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 1 0"/>
                                </svg>

                                <!-- Context menu button -->
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" 
                                  class="bi bi-three-dots-vertical svg-button actionIconLink mb-link-menu-btn" viewBox="0 0 16 16"
                                  @click.stop="showLinkMenu($event, group, link)">
                                  <path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0"/>
                                </svg>
                              </div>
                          </div>
                        </template>
                        <div v-if="getLinksByColumn(group.links, linkColIndex).length > 0"
                          :class="['linkContainerDragAndDrop', 'link-drop-zone']"
                          @drop.stop.prevent="handleLinkDrop($event, group, getLinksByColumn(group.links, linkColIndex).length, linkColIndex)"
                          @dragover.prevent @dragenter.prevent="dropManager.handleDragEnterZone($event)"
                          @dragleave="dropManager.handleDragLeaveZone($event)">
                          {{ getTranslation('group.link.dropAfter') }}
                        </div>
                      </td>

                        <!-- Vertikale Dropzone nach jeder Link-Spalte -->
                        <td :key="'linkVerticalDropZone-' + linkColumnIndex"
                            class="linkVerticalDropZone"
                            @drop.stop.prevent="handleLinkDropToNewColumn($event, group, linkColIndex + 1)"
                            @dragover.prevent
                            @dragenter.prevent="dropManager.handleDragEnterVerticalZone($event)"
                            @dragleave="dropManager.handleDragLeaveVerticalZone($event)">
                          <div class="linkVerticalDropZoneIndicator"></div>
                        </td>
                      </template>
                    </tr>
                  </table>

                  <!-- Show more/less button for progressive loading (full width at bottom) -->
                  <div v-if="shouldShowExpandButton(group)"
                    class="mb-progressive-btn-wrapper">
                    <button
                      @click="toggleGroupExpansion(group)"
                      class="btn btn-sm w-100 mb-progressive-btn">
                      <span v-if="!group.linksExpanded">
                        {{ getTranslation('group.showMore') || 'Show more' }}
                      </span>
                      <span v-else>
                        {{ getTranslation('group.showLess') || 'Show less' }}
                      </span>
                    </button>
                  </div>



                  <div v-if="!data.options?.links?.addViaDialog"
                    class="input-group input-group-sm addLinkContainer mt-2">
                    <input v-model="group.newLinkText" type="text" class="form-control"
                      :placeholder="getTranslation('group.link.linkText')"
                      :aria-label="getTranslation('group.link.linkText')" :aria-describedby="'groupNewLink' + group.uuid"
                      @keyup.enter="addLink(group)">
                    <input v-model="group.newLinkUrl" type="text" class="form-control"
                      :placeholder="getTranslation('group.link.linkUrl')"
                      :aria-label="getTranslation('group.link.linkUrl')" :aria-describedby="'groupNewLink' + group.uuid"
                      @keyup.enter="addLink(group)">
                    <button @click="addLink(group)" :id="'groupNewLink' + group.uuid" type="button"
                      class="btn btn-sm btn-success">{{ getTranslation('group.link.add') }}</button>
                  </div>
                </div>
              </div>
            </template>
            <div v-if="getGroupsByColumn(colIndex).length > 0"
              :class="['groupContainerDragAndDrop', 'group-drop-zone']"
              @drop.stop.prevent="dropManager.onDrop($event, data.groups, null, getGroupsByColumn(colIndex).length, colIndex, 'group'); saveData()"
              @dragover.prevent @dragenter.prevent="dropManager.handleDragEnterZone($event)"
              @dragleave="dropManager.handleDragLeaveZone($event)">
              {{ getTranslation('group.dropAfter') }}
            </div>
    </div>
    </td>

    <!-- Vertikale Dropzone nach jeder Spalte -->
    <td class="verticalDropZone"
        @drop.stop.prevent="handleDropToNewColumn($event, colIndex + 1)"
        @dragover.prevent
        @dragenter.prevent="dropManager.handleDragEnterVerticalZone($event)"
        @dragleave="dropManager.handleDragLeaveVerticalZone($event)">
      <div class="verticalDropZoneIndicator"></div>
    </td>
    </template>
    </tr>
    </table>
    </div>
    <!-- End of Groups and Links Content Container -->

  <div id="groupMenu" class="context-menu mb-context-menu" :style="contextMenuStyle"
    :class="{ 'context-menu-visible': isGroupMenuVisible }">
    <ul v-if="contextGroup">
      <li @click="showGroupEditModal(contextGroup); hideMenus()">{{ getTranslation('menu.group.editGroup') }}</li>
      <li @click="duplicateGroup(contextGroup); hideMenus()">{{ getTranslation('menu.group.duplicate') }}</li>
      <li class="separator mb-context-menu-separator"></li>
      <li v-if="hasNtfyUrl()" @click="shareGroup(contextGroup); hideMenus()">{{ getTranslation('menu.group.sendGroup') }}</li>
      <li v-if="hasNtfyUrl() && (!contextGroup?.shared || isOwnerOfGroup(contextGroup))" @click="inviteMembers(contextGroup); hideMenus()">{{ getTranslation('menu.group.inviteMembers') }}</li>
      <li v-if="hasNtfyUrl() && contextGroup?.shared && isOwnerOfGroup(contextGroup)" @click="openOwnerTransferDialog(contextGroup); hideMenus()">{{ getTranslation('menu.group.transferOwnership') || 'Transfer ownership…' }}</li>
      <li v-if="hasNtfyUrl()" @click="openMembersModal(contextGroup); hideMenus()">{{ getTranslation('menu.group.members') }}</li>
      <li v-if="hasNtfyUrl()" class="separator mb-context-menu-separator"></li>
      <li class="submenu" tabindex="0">
        {{ getTranslation('menu.group.sort') || 'Sort links' }}
        <ul class="context-submenu mb-context-submenu">
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'within-columns', direction: 'asc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.withinColumns') || 'Within columns (A→Z)' }}
          </li>
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'preserve-counts', direction: 'asc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.preserveCounts') || 'Global A→Z, preserve column sizes' }}
          </li>
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'rebalance-columns', direction: 'asc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.rebalance') || 'Global A→Z, rebalance columns' }}
          </li>
          <li class="separator mb-context-menu-separator"></li>
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'within-columns', direction: 'desc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.withinColumnsDesc') || 'Within columns (Z→A)' }}
          </li>
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'preserve-counts', direction: 'desc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.preserveCountsDesc') || 'Global Z→A, preserve column sizes' }}
          </li>
          <li @click="sortGroupLinksByText(contextGroup, { strategy: 'rebalance-columns', direction: 'desc', ignoreArticles: true }); hideMenus()">
            {{ getTranslation('menu.group.sort.rebalanceDesc') || 'Global Z→A, rebalance columns' }}
          </li>
        </ul>
      </li>
      <li class="separator mb-context-menu-separator"></li>
      <li @click="inspectGroupJSON(contextGroup); hideMenus()">{{ getTranslation('menu.group.inspectJSON') || 'Inspect JSON' }}</li>
      <li class="separator mb-context-menu-separator"></li>
      <li class="submenu" tabindex="0">
        {{ getTranslation('menu.group.copyForCss') || 'Copy for CSS' }}
        <ul class="context-submenu mb-context-submenu">
          <li @click="copyGroupCssClass(contextGroup); hideMenus()">{{ getTranslation('menu.group.copyCssClass') || 'Copy CSS class' }}</li>
          <li @click="copyGroupUuid(contextGroup); hideMenus()">{{ getTranslation('menu.group.copyUuid') || 'Copy UUID' }}</li>
          <li @click="copyGroupUuid(contextGroup, {shiftKey: true}); hideMenus()">{{ getTranslation('menu.group.copyCssSelector') || 'Copy CSS selector [data-group-uuid]' }}</li>
        </ul>
      </li>
      <li class="separator mb-context-menu-separator"></li>
      <li v-if="contextGroup?.shared && !isOwnerOfGroup(contextGroup)" @click="delGroup(contextGroup); hideMenus()">{{ getTranslation('menu.group.leaveGroup') || 'Leave group' }}</li>
      <li v-if="isOwnerOfGroup(contextGroup)" @click="delGroup(contextGroup); hideMenus()">{{ getTranslation('group.deleteGroup') }}</li>
    </ul>
  </div>
  
  <!-- Visual CSS Editor Sidebar -->
  <div v-if="cssSidebarVisible" class="css-sidebar mb-css-sidebar visual-css-editor-sidebar sidebar-open" :class="{ 'resizing': isCssSidebarWidthResizing }" :style="{ width: cssSidebarWidth + 'px' }">
    <!-- Resize Handle -->
    <div class="css-sidebar-resize-handle" :class="{ 'resizing': isCssSidebarWidthResizing }" @mousedown="startCssSidebarWidthResize"></div>
    <div class="sidebar-header mb-css-sidebar-header">
      <h5 class="mb-css-sidebar-title">{{ getTranslation('css.visual.title') || 'Visual CSS Editor' }}</h5>
      <button type="button" class="btn-close mb-css-sidebar-close" @click="closeCssSidebar()" aria-label="Close"></button>
    </div>
    <div class="sidebar-split-container mb-css-sidebar-container">
      <!-- Visual CSS Rules Editor -->
      <div class="visual-css-editor" style="height: 100%; overflow-y: auto; padding: 15px;">

        <!-- Template Selection -->
        <div class="template-section mb-3">
          <h6 class="mb-2">{{ getTranslation('css.visual.templates') || 'CSS Vorlagen' }}</h6>
          <select v-model="selectedVisualTemplate"
                  @change="loadVisualTemplate"
                  class="form-select form-select-sm">
            <option :value="null">{{ getTranslation('css.visual.selectTemplate') || '-- Vorlage wählen --' }}</option>
            <optgroup :label="getTranslation('css.visual.defaultTemplates') || 'Standard-Vorlagen'">
              <option value="dark-mode">Dark Mode</option>
              <option value="minimal">Minimal</option>
              <option value="colorful">Colorful</option>
            </optgroup>
          </select>
        </div>

        <!-- CSS Rules List -->
      <div class="css-rules-container">
        <h6 class="mb-3">{{ getTranslation('css.visual.rules') || 'CSS Regeln' }}</h6>

        <!-- Design Tokens -->
        <div class="mb-3 p-2 border rounded design-tokens-section" :class="{ 'collapsed': designTokensCollapsed }">
          <div class="d-flex align-items-center justify-content-between mb-2 design-tokens-header">
            <div class="d-flex align-items-center gap-2">
              <button @click="toggleDesignTokensCollapse"
                      class="btn btn-sm btn-link p-0"
                      :title="getTranslation('css.visual.toggleCollapse') || 'Ein-/Ausklappen'"
                      style="width: 20px;">
                <span v-if="!designTokensCollapsed">▼</span>
                <span v-else>▶</span>
              </button>
              <strong class="mb-0">{{ getTranslation('css.visual.designTokens') || 'Design Tokens' }}</strong>
            </div>
            <button class="btn btn-sm btn-outline-primary" @click="addDesignToken">+
              {{ getTranslation('css.visual.addToken') || 'Token' }}</button>
          </div>
          <div v-show="!designTokensCollapsed">
            <div v-if="designTokens.length === 0" class="text-muted small mb-2">
              {{ getTranslation('css.visual.noTokens') || 'Noch keine Tokens. Füge welche hinzu (z. B. brand-primary (ohne --), #3b82f6)' }}
            </div>
            <div class="input-group input-group-sm mb-2" v-for="(t, ti) in designTokens" :key="'tok-'+ti">
              <span class="input-group-text">{{ getTranslation('css.visual.tokenName') || 'Name' }}</span>
              <input class="form-control"
                     :value="t.name"
                     @input="onTokenNameInput(t, $event)"
                     placeholder="token-name"
                     autocomplete="off"
                     spellcheck="false">
              <span class="input-group-text">{{ getTranslation('css.visual.tokenValue') || 'Wert' }}</span>
              <input class="form-control"
                     :class="{ 'is-invalid': !isTokenValueValid(t.value) }"
                     :value="t.value"
                     @input="onTokenValueInput(t, $event)"
                     placeholder="#rrggbb oder Wert"
                     autocomplete="off"
                     spellcheck="false">
              <span class="input-group-text p-0">
                <input type="color"
                       :value="getValidHexColor(t.value)"
                       @input="t.value = $event.target.value; saveDesignTokens()"
                       class="form-control form-control-color border-0"
                       style="width: 2rem; padding: 0;">
              </span>
              <button class="btn btn-outline-danger" @click="removeDesignToken(ti)">×</button>
            </div>
            <div v-for="(t, ti) in designTokens" :key="'tokhint-'+ti"
                 v-if="!isTokenValueValid(t.value)"
                 class="invalid-feedback d-block small mt-1">
              {{ getTokenValidationHint(t.value) }}
            </div>
            <div class="small text-muted">
              {{ getTranslation('css.visual.tokensHint') || 'Tokens per Dropdown neben den Properties einsetzen (var(--token)).' }}
            </div>
          </div>
        </div>

          <!-- Rule Sets Management -->
          <div class="rule-sets-section mb-3">
            <div class="d-flex align-items-center gap-2 mb-2">
              <label class="form-label small mb-0 text-nowrap">{{ getTranslation('css.visual.ruleSets') || 'Regel-Sätze' }}:</label>
              <select v-model="selectedRuleSetName"
                      @change="if(selectedRuleSetName) loadRuleSet(selectedRuleSetName)"
                      class="form-select form-select-sm flex-grow-1">
                <option :value="null">{{ getTranslation('css.visual.selectRuleSet') || '-- Wählen --' }}</option>
                <option v-for="(ruleSet, name) in customRuleSets"
                        :key="name"
                        :value="name">
                  {{ name }}
                </option>
              </select>
              <button @click="saveRuleSet"
                      class="btn btn-sm btn-outline-primary px-2"
                      :title="getTranslation('css.visual.saveCurrentRules') || 'Speichern'">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v7.293l2.646-2.647a.5.5 0 0 1 .708.708l-3.5 3.5a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L7.5 9.293V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1H2z"/>
                </svg>
              </button>
              <button @click="if(selectedRuleSetName) deleteRuleSet(selectedRuleSetName)"
                      :disabled="!selectedRuleSetName"
                      class="btn btn-sm btn-outline-danger px-2"
                      :title="getTranslation('css.visual.deleteRuleSet') || 'Löschen'">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                  <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                </svg>
              </button>
            </div>
          </div>

          <!-- Collapse/Expand All Buttons -->
          <div class="d-flex gap-2 mb-2 align-items-center">
            <button @click="expandAllRules()"
                    class="btn btn-sm btn-outline-secondary"
                    :title="getTranslation('css.visual.expandAll') || 'Alle aufklappen'">
              ▼
            </button>
            <button @click="collapseAllRules()"
                    class="btn btn-sm btn-outline-secondary"
                    :title="getTranslation('css.visual.collapseAll') || 'Alle zuklappen'">
              ▶
            </button>
            <input
              v-model="rulesFilterQuery"
              type="text"
              class="form-control form-control-sm flex-grow-1"
              style="min-width: 0;"
              :placeholder="getTranslation('css.visual.searchRules') || 'Rules durchsuchen…'"
            >
            
          </div>

          <!-- Each CSS Rule -->
          <div v-for="(rule, index) in visualCssRules"
               :key="rule.id"
               class="css-rule-card mb-3 p-3 border rounded"
               :class="{ 'opacity-50': !rule.enabled, 'collapsed': isRuleCollapsed(rule) }"
               v-show="matchesRuleSearch(rule)">

            <!-- Rule Header -->
            <div class="rule-header d-flex justify-content-between align-items-center mb-2">
              <div class="d-flex align-items-center flex-grow-1">
                <button @click="toggleRuleCollapse(rule)"
                        class="btn btn-sm btn-link p-0 me-2"
                        :title="getTranslation('css.visual.toggleCollapse') || 'Ein-/Ausklappen'"
                        style="width: 20px;">
                  <span v-if="!isRuleCollapsed(rule)">▼</span>
                  <span v-else>▶</span>
                </button>
                <div v-if="editingRuleId !== rule.id"
                     @dblclick="startEditingRuleName(rule)"
                     class="rule-number fw-bold"
                     style="cursor: pointer;"
                     :title="getTranslation('css.visual.doubleClickToEdit') || 'Doppelklick zum Bearbeiten'">
                  {{ rule.name || `${getTranslation('css.visual.rule') || 'Regel'} ${index + 1}` }}
                </div>
                <input v-else
                       v-model="editingRuleName"
                       @blur="saveRuleName(rule)"
                       @keyup.enter="saveRuleName(rule)"
                       @keyup.esc="cancelEditingRuleName()"
                       class="form-control form-control-sm"
                       style="max-width: 200px;"
                       type="text"
                       ref="ruleNameInput">
                <span v-if="!getRuleSelector(rule).base"
                      class="badge bg-warning text-dark ms-2"
                      :title="getTranslation('css.visual.selectElement') || '-- Element wählen --'">
                  {{ getTranslation('css.visual.selectElementShort') || 'Element wählen' }}
                </span>
              </div>
              <div class="rule-actions btn-group btn-group-sm">
                <button @click="startElementPicker(rule)"
                        class="btn btn-outline-secondary"
                        :class="{ active: elementPickerActive && currentPickerRule && currentPickerRule.id === rule.id }"
                        :title="getTranslation('css.visual.pickElement') || 'Element wählen'">🎯</button>
                <button @click="moveCssRuleUp(index)"
                        class="btn btn-outline-secondary"
                        :disabled="index === 0"
                        :title="getTranslation('css.visual.moveUp') || 'Nach oben'">▲</button>
                <button @click="moveCssRuleDown(index)"
                        class="btn btn-outline-secondary"
                        :disabled="index === visualCssRules.length - 1"
                        :title="getTranslation('css.visual.moveDown') || 'Nach unten'">▼</button>
                <button @click="toggleCssRule(rule)"
                        class="btn btn-outline-secondary"
                        :title="rule.enabled ? getTranslation('css.visual.deactivate') : getTranslation('css.visual.activate')">
                  {{ rule.enabled ? '👁️' : '👁️‍🗨️' }}
                </button>
                <button @click="duplicateCssRule(rule)"
                        class="btn btn-outline-secondary"
                        :title="getTranslation('css.visual.duplicate') || 'Duplizieren'">📋</button>
                <button @click="deleteCssRule(rule)"
                        class="btn btn-outline-danger"
                        :title="getTranslation('css.visual.delete') || 'Löschen'">×</button>
              </div>
            </div>

            <!-- Rule Content (Collapsible) -->
            <div v-show="!isRuleCollapsed(rule)">
              <!-- Selector Dropdowns -->
              <div class="selector-section mb-3">
              <!-- Base Selector -->
              <div class="selector-row mb-2 d-flex align-items-center">
                <label class="form-label small mb-0 me-2" style="min-width: 60px;">{{ getTranslation('css.visual.element') || 'Element' }}:</label>
                <select v-model="rule.selector.base"
                        @change="updateRuleBase(rule, $event)"
                        :ref="'baseSelector-' + rule.id"
                        class="form-select form-select-sm flex-grow-1">
                  <option value="">{{ getTranslation('css.visual.selectElement') || '-- Element wählen --' }}</option>
                  <optgroup :label="getTranslation('css.visual.appLevel') || 'App-Ebene'">
                    <option value="app">App Container</option>
                    <option value="header">Header</option>
                    <option value="toolbar">Toolbar</option>
                    <option value="footer">Footer</option>
                    <option value="groups-links-container">Groups & Links Container</option>
                  </optgroup>
                  <optgroup :label="getTranslation('css.visual.groupLevel') || 'Gruppen-Ebene'">
                    <option value="groups">{{ getTranslation('css.visual.allGroups') || 'Alle Gruppen' }}</option>
                    <option value="group-header">{{ getTranslation('css.visual.groupHeader') || 'Gruppen Header' }}</option>
                    <option value="group-title">{{ getTranslation('css.visual.groupTitle') || 'Gruppen Titel' }}</option>
                    <option value="group-body">{{ getTranslation('css.visual.groupContent') || 'Gruppen Inhalt' }}</option>
                  </optgroup>
                  <optgroup :label="getTranslation('css.visual.linkLevel') || 'Link-Ebene'">
                    <option value="links">{{ getTranslation('css.visual.allLinks') || 'Alle Links' }}</option>
                    <option value="link-hover">{{ getTranslation('css.visual.linkHover') || 'Link (Hover)' }}</option>
                    <option value="link-anchor">{{ getTranslation('css.visual.linkAnchor') || 'Link Anchor' }}</option>
                    <option value="link-url">{{ getTranslation('css.visual.linkUrl') || 'Link URL' }}</option>
                    <option value="link-icon">{{ getTranslation('css.visual.linkIcon') || 'Link Icon' }}</option>
                  </optgroup>
                  <optgroup :label="getTranslation('css.visual.popoverLevel') || 'Link-Popover'">
                    <option value="link-popover">{{ getTranslation('css.visual.linkPopover') || 'Popover Container' }}</option>
                    <option value="link-popover-title">{{ getTranslation('css.visual.linkPopoverTitle') || 'Popover Titelzeile' }}</option>
                    <option value="link-popover-url">{{ getTranslation('css.visual.linkPopoverUrl') || 'Popover URL' }}</option>
                    <option value="link-popover-meta">{{ getTranslation('css.visual.linkPopoverMeta') || 'Popover Metadaten' }}</option>
                    <option value="link-popover-row">{{ getTranslation('css.visual.linkPopoverRow') || 'Popover Zeile' }}</option>
                    <option value="link-popover-label">{{ getTranslation('css.visual.linkPopoverLabel') || 'Popover Label' }}</option>
                    <option value="link-popover-value">{{ getTranslation('css.visual.linkPopoverValue') || 'Popover Wert' }}</option>
                    <option value="link-popover-value-muted">{{ getTranslation('css.visual.linkPopoverValueMuted') || 'Popover Wert (relativ)' }}</option>
                    <option value="link-popover-keywords">{{ getTranslation('css.visual.linkPopoverKeywords') || 'Popover Keywords' }}</option>
                    <option value="link-popover-badge">{{ getTranslation('css.visual.linkPopoverBadge') || 'Popover Keyword Badge' }}</option>
                    <option value="link-popover-favicon">{{ getTranslation('css.visual.linkPopoverFavicon') || 'Popover Favicon' }}</option>
                  </optgroup>
                  <optgroup :label="getTranslation('css.visual.keywords') || 'Keywords'">
                    <option value="keywords">{{ getTranslation('css.visual.allKeywords') || 'Alle Keywords (Keyword-Bar)' }}</option>
                    <option value="keywords-hierarchical">{{ getTranslation('css.visual.keywordsHierarchical') || 'Keywords (Hierarchisch)' }}</option>
                    <option value="keyword-by-name">{{ getTranslation('css.visual.keywordByName') || 'Keyword nach Name' }}</option>
                  </optgroup>
                </select>
              </div>

              <!-- Group Selector (conditional) -->
              <div v-if="canSelectGroup(rule)"
                   class="selector-row mb-2 d-flex align-items-center">
                <label class="form-label small mb-0 me-2" style="min-width: 60px;">{{ getTranslation('css.visual.group') || 'Gruppe' }}:</label>
                <select :value="getRuleSelector(rule).groupId"
                        @change="updateRuleGroupId(rule, $event)"
                        class="form-select form-select-sm flex-grow-1">
                  <option :value="null">{{ getTranslation('css.visual.selectGroup') || '-- Alle Gruppen --' }}</option>
                  <option v-for="group in data.groups"
                          :key="group.id || group.uuid"
                          :value="group.id || group.uuid">
                    {{ group.name }}
                  </option>
                </select>
              </div>

              <!-- Link Selector (conditional) -->
              <div v-if="canSelectLink(rule)"
                   class="selector-row mb-2 d-flex align-items-center">
                <label class="form-label small mb-0 me-2" style="min-width: 60px;">{{ getTranslation('css.visual.link') || 'Link' }}:</label>
                <select :value="getRuleSelector(rule).linkId"
                        @change="updateRuleLinkId(rule, $event)"
                        class="form-select form-select-sm flex-grow-1">
                  <option :value="null">{{ getTranslation('css.visual.selectLink') || '-- Alle Links --' }}</option>
                  <option v-for="link in getLinksForRule(rule)"
                          :key="link.id || link.uuid"
                          :value="link.id || link.uuid">
                    {{ link.text || link.url }}
                  </option>
                </select>
              </div>

              <!-- Keyword Selector (for keyword selectors) -->
              <div v-if="getRuleSelector(rule).base === 'keyword-by-name' ||
                         getRuleSelector(rule).base === 'keywords-hierarchical'"
                   class="selector-row mb-2 d-flex align-items-center">
                <label class="form-label small mb-0 me-2" style="min-width: 60px;">{{ getTranslation('css.visual.keyword') || 'Keyword' }}:</label>
                <select :value="getRuleSelector(rule).keywordSlug || ''"
                        @change="updateRuleKeywordSlug(rule, $event)"
                        class="form-select form-select-sm flex-grow-1">
                  <option value="">-- Alle Keywords --</option>
                  <option v-for="kw in getKeywordsForRule(rule)"
                          :key="keywordSlug(kw)"
                          :value="keywordSlug(kw)">
                    {{ kw }}
                  </option>
                </select>
              </div>
            </div>

            <!-- CSS Properties -->
            <div class="properties-section">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <label class="form-label small mb-0">{{ getTranslation('css.visual.properties') || 'CSS Eigenschaften' }}:</label>
                <button v-if="Object.keys(rule.properties).length > 0 || rule.customCss"
                        @click="clearRuleProperties(rule)"
                        class="btn btn-sm btn-outline-danger px-2"
                        :title="getTranslation('css.visual.clearPropertiesTitle') || 'Alle Eigenschaften dieser Regel löschen'">
                  <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M2.5 1a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1H3v9a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V4h.5a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H10a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1H2.5zm3 4a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5zM8 5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7A.5.5 0 0 1 8 5zm3 .5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 1 0z"/>
                  </svg>
                  {{ getTranslation('css.visual.clearProperties') || 'Eigenschaften löschen' }}
                </button>
              </div>
              <div class="properties-grid">
                <!-- Existing Properties as Bootstrap 5 Input Groups -->
                <div v-for="(value, prop) in rule.properties"
                     :key="prop"
                     class="property-item mb-2"
                     :class="{ 'opacity-50': isPropertyDisabled(rule, prop) }">
                  <!-- Color property: text + color picker + token + important + remove in one input-group -->
                  <div v-if="isColorProperty(prop)" class="input-group input-group-sm">
                    <span class="input-group-text">{{ formatPropertyName(prop) }}</span>
                    <input
                      :id="'prop-' + rule.id + '-' + prop"
                      type="text"
                      v-model="rule.properties[prop]"
                      @input="saveVisualCss"
                      @blur="validateProperty(rule, prop)"
                      class="form-control"
                      :class="{ 'is-invalid': !isPropertyValid(rule, prop) }"
                      :placeholder="getTranslation('css.visual.valuePlaceholder') || 'Wert eingeben (z. B. #ff0000, rgb(), var(--...))'">
                    <span class="input-group-text p-0">
                      <input type="color"
                             :value="getValidHexColor(rule.properties[prop])"
                             @input="onColorPickerChange(rule, prop, $event)"
                             class="form-control form-control-color border-0"
                             style="width: 2rem; padding: 0;">
                    </span>
                    <select class="form-select" style="max-width: 170px;"
                            @change="applyTokenToProperty(rule, prop, $event.target.value)">
                      <option value="">{{ getTranslation('css.visual.tokensSelect') || '-- Token wählen --' }}</option>
                      <option v-for="t in designTokens" :value="t.name">{{ t.name }}</option>
                    </select>
                    <span class="input-group-text" v-if="prop !== 'custom'">
                      <input type="checkbox"
                             :id="'important-' + rule.id + '-' + prop"
                             class="form-check-input mt-0"
                             :checked="getPropertyImportant(rule, prop)"
                             @change="togglePropertyImportant(rule, prop)"
                             :title="getTranslation('css.visual.importantHint') || 'Override other styles with !important'">
                    </span>
                    <button v-if="prop !== 'custom'"
                            @click="togglePropertyDisabled(rule, prop)"
                            class="btn btn-outline-secondary"
                            :title="isPropertyDisabled(rule, prop) ? (getTranslation('css.visual.activateProperty') || 'Aktivieren') : (getTranslation('css.visual.deactivateProperty') || 'Deaktivieren')">
                      {{ isPropertyDisabled(rule, prop) ? '👁️‍🗨️' : '👁️' }}
                    </button>
                    <button @click="removeProperty(rule, prop)"
                            class="btn btn-outline-danger">×</button>
                  </div>
                  <div v-if="isColorProperty(prop) && !isPropertyValid(rule, prop)"
                       class="invalid-feedback d-block small mt-1">
                    {{ getPropertyValidationHint(rule, prop) }}
                  </div>

                  <!-- Custom CSS (multiline) with delete button -->
                  <div v-else-if="prop === 'custom'">
                    <div class="d-flex justify-content-between align-items-center mb-1">
                      <label class="form-label small mb-0">{{ formatPropertyName(prop) }}</label>
                      <button type="button" @click="removeProperty(rule, 'custom')"
                              class="btn btn-sm btn-outline-danger px-2">×</button>
                    </div>
                    <textarea
                      :id="'prop-' + rule.id + '-' + prop"
                      v-model="rule.properties[prop]"
                      @input="saveVisualCss"
                      class="form-control form-control-sm"
                      style="height: 84px; font-family: monospace; font-size: 12px;"
                      :placeholder="getTranslation('css.visual.customPropertiesHint') || 'z.B. display: flex;\njustify-content: center;'">
                    </textarea>
                  </div>

                  <!-- Default text property -->
                  <div v-else class="input-group input-group-sm">
                    <span class="input-group-text">{{ formatPropertyName(prop) }}</span>
                    <input
                      :id="'prop-' + rule.id + '-' + prop"
                      type="text"
                      v-model="rule.properties[prop]"
                      @input="saveVisualCss"
                      @blur="validateProperty(rule, prop)"
                      class="form-control"
                      :class="{ 'is-invalid': !isPropertyValid(rule, prop) }"
                      :placeholder="getTranslation('css.visual.valuePlaceholder') || 'Wert eingeben'">
                    <select class="form-select" style="max-width: 170px;"
                            @change="applyTokenToProperty(rule, prop, $event.target.value)">
                      <option value="">{{ getTranslation('css.visual.tokensSelect') || '-- Token wählen --' }}</option>
                      <option v-for="t in designTokens" :value="t.name">{{ t.name }}</option>
                    </select>
                    <span class="input-group-text">
                      <input type="checkbox"
                             :id="'important-' + rule.id + '-' + prop"
                             class="form-check-input mt-0"
                             :checked="getPropertyImportant(rule, prop)"
                             @change="togglePropertyImportant(rule, prop)"
                             :title="getTranslation('css.visual.importantHint') || 'Override other styles with !important'">
                    </span>
                    <button @click="togglePropertyDisabled(rule, prop)"
                            class="btn btn-outline-secondary"
                            :title="isPropertyDisabled(rule, prop) ? (getTranslation('css.visual.activateProperty') || 'Aktivieren') : (getTranslation('css.visual.deactivateProperty') || 'Deaktivieren')">
                      {{ isPropertyDisabled(rule, prop) ? '👁️‍🗨️' : '👁️' }}
                    </button>
                    <button @click="removeProperty(rule, prop)"
                            class="btn btn-outline-danger">×</button>
                  </div>
                  <div v-if="!isColorProperty(prop) && prop !== 'custom' && !isPropertyValid(rule, prop)"
                       class="invalid-feedback d-block small mt-1">
                    {{ getPropertyValidationHint(rule, prop) }}
                  </div>
                </div>

                <!-- Add New Property -->
                <div class="property-add">
                  <select @change="addPropertyToRule(rule, $event)"
                          class="form-select form-select-sm">
                    <option value="">{{ getTranslation('css.visual.addProperty') || '+ Eigenschaft hinzufügen...' }}</option>
                    <option value="custom" :disabled="rule.properties && rule.properties['custom'] !== undefined">{{ getTranslation('css.visual.customCss') || 'Custom CSS' }}</option>
                    <optgroup :label="getTranslation('css.visual.colors') || 'Farben'">
                      <option value="background" :disabled="rule.properties && rule.properties['background'] !== undefined">{{ getTranslation('css.background') || 'Hintergrund' }}</option>
                      <option value="background-color" :disabled="rule.properties && rule.properties['background-color'] !== undefined">{{ getTranslation('css.backgroundColor') || 'Hintergrundfarbe' }}</option>
                      <option value="color" :disabled="rule.properties && rule.properties['color'] !== undefined">{{ getTranslation('css.textColor') || 'Textfarbe' }}</option>
                      <option value="border-color" :disabled="rule.properties && rule.properties['border-color'] !== undefined">{{ getTranslation('css.borderColor') || 'Rahmenfarbe' }}</option>
                    </optgroup>
                    <optgroup :label="getTranslation('css.visual.borders') || 'Rahmen (Border)'">
                      <option value="border" :disabled="isPropertyInRule(rule, 'border')">{{ getTranslation('css.border') || 'Rahmen' }} ({{ getTranslation('css.visual.complete') || 'komplett' }})</option>
                      <option value="border-width" :disabled="isPropertyInRule(rule, 'border-width')">{{ getTranslation('css.borderWidth') || 'Rahmenbreite' }}</option>
                      <option value="border-style" :disabled="isPropertyInRule(rule, 'border-style')">{{ getTranslation('css.borderStyle') || 'Rahmenstil' }}</option>
                      <option value="border-color" :disabled="isPropertyInRule(rule, 'border-color')">{{ getTranslation('css.borderColor') || 'Rahmenfarbe' }}</option>
                      <option value="border-radius" :disabled="isPropertyInRule(rule, 'border-radius')">{{ getTranslation('css.borderRadius') || 'Eckenradius' }}</option>
                      <option value="border-top">{{ getTranslation('css.border') || 'Rahmen' }} {{ getTranslation('css.top') || 'oben' }}</option>
                      <option value="border-right">{{ getTranslation('css.border') || 'Rahmen' }} {{ getTranslation('css.right') || 'rechts' }}</option>
                      <option value="border-bottom">{{ getTranslation('css.border') || 'Rahmen' }} {{ getTranslation('css.bottom') || 'unten' }}</option>
                      <option value="border-left">{{ getTranslation('css.border') || 'Rahmen' }} {{ getTranslation('css.left') || 'links' }}</option>
                      <option value="border-top-width">{{ getTranslation('css.borderWidth') || 'Rahmenbreite' }} {{ getTranslation('css.top') || 'oben' }}</option>
                      <option value="border-right-width">{{ getTranslation('css.borderWidth') || 'Rahmenbreite' }} {{ getTranslation('css.right') || 'rechts' }}</option>
                      <option value="border-bottom-width">{{ getTranslation('css.borderWidth') || 'Rahmenbreite' }} {{ getTranslation('css.bottom') || 'unten' }}</option>
                      <option value="border-left-width">{{ getTranslation('css.borderWidth') || 'Rahmenbreite' }} {{ getTranslation('css.left') || 'links' }}</option>
                      <option value="border-top-style">{{ getTranslation('css.borderStyle') || 'Rahmenstil' }} {{ getTranslation('css.top') || 'oben' }}</option>
                      <option value="border-right-style">{{ getTranslation('css.borderStyle') || 'Rahmenstil' }} {{ getTranslation('css.right') || 'rechts' }}</option>
                      <option value="border-bottom-style">{{ getTranslation('css.borderStyle') || 'Rahmenstil' }} {{ getTranslation('css.bottom') || 'unten' }}</option>
                      <option value="border-left-style">{{ getTranslation('css.borderStyle') || 'Rahmenstil' }} {{ getTranslation('css.left') || 'links' }}</option>
                      <option value="border-top-color">{{ getTranslation('css.borderColor') || 'Rahmenfarbe' }} {{ getTranslation('css.top') || 'oben' }}</option>
                      <option value="border-right-color">{{ getTranslation('css.borderColor') || 'Rahmenfarbe' }} {{ getTranslation('css.right') || 'rechts' }}</option>
                      <option value="border-bottom-color">{{ getTranslation('css.borderColor') || 'Rahmenfarbe' }} {{ getTranslation('css.bottom') || 'unten' }}</option>
                      <option value="border-left-color">{{ getTranslation('css.borderColor') || 'Rahmenfarbe' }} {{ getTranslation('css.left') || 'links' }}</option>
                      <option value="border-top-left-radius">{{ getTranslation('css.borderRadius') || 'Eckenradius' }} {{ getTranslation('css.topLeft') || 'oben links' }}</option>
                      <option value="border-top-right-radius">{{ getTranslation('css.borderRadius') || 'Eckenradius' }} {{ getTranslation('css.topRight') || 'oben rechts' }}</option>
                      <option value="border-bottom-left-radius">{{ getTranslation('css.borderRadius') || 'Eckenradius' }} {{ getTranslation('css.bottomLeft') || 'unten links' }}</option>
                      <option value="border-bottom-right-radius">{{ getTranslation('css.borderRadius') || 'Eckenradius' }} {{ getTranslation('css.bottomRight') || 'unten rechts' }}</option>
                      <option value="outline">{{ getTranslation('css.outline') || 'Umrisslinie' }}</option>
                      <option value="outline-width">{{ getTranslation('css.outlineWidth') || 'Umrissbreite' }}</option>
                      <option value="outline-style">{{ getTranslation('css.outlineStyle') || 'Umrissstil' }}</option>
                      <option value="outline-color">{{ getTranslation('css.outlineColor') || 'Umrissfarbe' }}</option>
                      <option value="outline-offset">{{ getTranslation('css.outlineOffset') || 'Umrissabstand' }}</option>
                    </optgroup>
                    <optgroup :label="getTranslation('css.visual.sizes') || 'Größen'">
                      <option value="font-size">{{ getTranslation('css.fontSize') || 'Schriftgröße' }}</option>
                      <option value="padding">{{ getTranslation('css.padding') || 'Innenabstand' }}</option>
                      <option value="margin">{{ getTranslation('css.margin') || 'Außenabstand' }}</option>
                      <option value="width">{{ getTranslation('css.width') || 'Breite' }}</option>
                      <option value="height">{{ getTranslation('css.height') || 'Höhe' }}</option>
                    </optgroup>
                    <optgroup :label="getTranslation('css.visual.effects') || 'Effekte'">
                      <option value="box-shadow">{{ getTranslation('css.boxShadow') || 'Schatten' }}</option>
                      <option value="opacity">{{ getTranslation('css.opacity') || 'Transparenz' }}</option>
                    </optgroup>
                    <optgroup :label="getTranslation('css.visual.typography') || 'Text'">
                      <option value="font-weight">{{ getTranslation('css.fontWeight') || 'Schriftstärke' }}</option>
                      <option value="text-decoration">{{ getTranslation('css.textDecoration') || 'Textdekoration' }}</option>
                      <option value="text-align">{{ getTranslation('css.textAlign') || 'Textausrichtung' }}</option>
                    </optgroup>
                  </select>
                </div>

                <!-- Apply preset to rule -->
                <div class="property-add mt-2">
                  <select @change="applyPresetToRule(rule, $event)" class="form-select form-select-sm">
                    <option value="">{{ getTranslation('css.visual.applyPreset') || 'Preset anwenden…' }}</option>
                    <option v-for="p in cssPresets" :value="p.id">{{ p.name }}</option>
                  </select>
                </div>

                
              </div>
            </div>

            
            </div> <!-- End of collapsible content -->
          </div>

          <!-- Add New Rule and Clear All Buttons -->
          <div class="d-flex gap-2 mb-3">
            <button @click="addNewCssRule" class="btn btn-success flex-grow-1">
              + {{ getTranslation('css.visual.addRule') || 'Neue CSS Regel hinzufügen' }}
            </button>
            <button @click="clearAllCssSettings"
                    class="btn btn-outline-danger"
                    :title="getTranslation('css.visual.clearAllTooltip') || 'Alle CSS Einstellungen löschen'">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828l6.879-6.879zm2.121.707a1 1 0 0 0-1.414 0L4.16 7.547l5.293 5.293 4.633-4.633a1 1 0 0 0 0-1.414l-3.879-3.879zM8.746 13.547 3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293l.16-.16z"/>
              </svg>
              {{ getTranslation('css.visual.clearAll') || 'Alles löschen' }}
            </button>
          </div>
        </div>

        

        <!-- Migration Notice (if old CSS exists) -->
        <div v-if="showMigrationNotice" class="alert alert-info mt-3">
          {{ getTranslation('css.visual.migrationNotice') || 'Hinweis: Ihr bisheriges Custom CSS wurde importiert. Sie können es oben als "Legacy CSS" Regel bearbeiten oder löschen.' }}
        </div>
      </div>
    </div>
  </div>

  <!-- Sync Progress (bottom-right) -->
  <div v-if="syncInProgress" class="mb-sync-progress" role="status" aria-live="polite">
    <div class="mb-sync-title">{{ syncProgressText || (getTranslation('sync.progress') || 'Sync in progress…') }}</div>
    <div class="progress">
      <div class="progress-bar" role="progressbar" :style="{ width: Math.max(0, Math.min(100, syncProgress)) + '%' }" :aria-valuenow="Math.round(syncProgress)" aria-valuemin="0" aria-valuemax="100"></div>
    </div>
    <div class="text-end mt-1" style="font-size: 11px; opacity: .8;">{{ Math.round(syncProgress) }}%</div>
  </div>

  <!-- Feature Overview Sidebar -->
  <div v-if="featureSidebarVisible" class="feature-sidebar mb-feature-sidebar"
       :class="{ 'sidebar-open': featureSidebarVisible }"
       :style="{ width: '450px', right: featureSidebarVisible ? 0 : '-450px' }">
    <div class="sidebar-header mb-feature-sidebar-header">
      <h5 class="mb-feature-sidebar-title">🚀 Feature Overview / Hilfe</h5>
      <button type="button" class="btn-close mb-feature-sidebar-close" @click="featureSidebarVisible=false" aria-label="Close"></button>
    </div>

    <!-- Language Tabs -->
    <ul class="nav nav-tabs px-3 pt-2" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link" :class="{'active': helpLanguageTab === 'de'}"
                @click="helpLanguageTab = 'de'" type="button">
          🇩🇪 Deutsch
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" :class="{'active': helpLanguageTab === 'en'}"
                @click="helpLanguageTab = 'en'" type="button">
          🇬🇧 English
        </button>
      </li>
    </ul>

    <div class="sidebar-content mb-feature-sidebar-content" style="height: calc(100% - 110px); overflow-y: auto; padding: 20px;">
      <!-- Feature content will be added here -->
    </div>
  </div>

  <!-- Feature Overview Sidebar -->
  <div v-if="featureSidebarVisible" class="feature-sidebar mb-feature-sidebar" 
       :class="{ 'sidebar-open': featureSidebarVisible }" 
       :style="{ width: '450px', right: featureSidebarVisible ? 0 : '-450px' }">
    <div class="sidebar-header mb-feature-sidebar-header">
      <h5 class="mb-feature-sidebar-title">🚀 Feature Overview / Hilfe</h5>
      <button type="button" class="btn-close mb-feature-sidebar-close" @click="featureSidebarVisible=false" aria-label="Close"></button>
    </div>
    
    <!-- Language Tabs -->
    <ul class="nav nav-tabs px-3 pt-2" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link" :class="{'active': helpLanguageTab === 'de'}" 
                @click="helpLanguageTab = 'de'" type="button">
          🇩🇪 Deutsch
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" :class="{'active': helpLanguageTab === 'en'}" 
                @click="helpLanguageTab = 'en'" type="button">
          🇬🇧 English
        </button>
      </li>
    </ul>
    
    <div class="sidebar-content mb-feature-sidebar-content" style="height: calc(100% - 110px); overflow-y: auto; padding: 20px;">
      
      <!-- German Content -->
      <div v-if="helpLanguageTab === 'de'">
        <!-- Kernfunktionen -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-primary mb-3">
            <i class="bi bi-star-fill"></i> Kernfunktionen
          </h6>
          <ul class="feature-list">
            <li><strong>Gruppen & Links:</strong> Organisieren Sie Ihre Lesezeichen in einklappbaren Gruppen mit mehrspaltigen Layout</li>
            <li><strong>Drag & Drop:</strong> Verschieben Sie Gruppen und Links einfach per Mausziehen zwischen Gruppen</li>
            <li><strong>Schlüsselwörter:</strong> Vergeben Sie Tags für Links und Gruppen zur schnellen Suche</li>
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-search me-1" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/></svg>Suche & Filter:</strong> Schnelle Filterung nach Text, URL oder Schlüsselwörtern</li>
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-download me-1" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708z"/></svg> <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-upload me-1" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/><path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708z"/></svg>Import/Export:</strong> Unterstützung für JSON und Browser-Lesezeichen-Format</li>
          </ul>
        </div>
        
        <!-- Zusammenarbeit -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-success mb-3">
            <i class="bi bi-people-fill"></i> Zusammenarbeit
          </h6>
          <ul class="feature-list">
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3Zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/></svg> Gruppen teilen:</strong> Teilen Sie Lesezeichen-Gruppen mit Teammitgliedern über verschlüsselte NTFY-Nachrichten</li>
            <li><strong>Berechtigungen:</strong> Der Besitzer kontrolliert Mitglieder-Berechtigungen (Hinzufügen/Bearbeiten/Löschen)</li>
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: -2px;"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg> Echtzeit-Sync:</strong> Änderungen werden sofort bei allen Mitgliedern synchronisiert</li>
            <li><strong>Ereignisprotokoll:</strong> Verfolgen Sie alle Änderungen mit Autor und Zeitstempel</li>
            <li><strong>Konfliktlösung:</strong> Vektoruhren behandeln gleichzeitige Bearbeitungen automatisch</li>
          </ul>
        </div>
        
        <!-- Anpassung -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-warning mb-3">
            <i class="bi bi-palette-fill"></i> Anpassung
          </h6>
          <ul class="feature-list">
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M6.5 0a.5.5 0 0 1 .5.5V2h2V.5a.5.5 0 0 1 1 0V2h.5A2.5 2.5 0 0 1 13 4.5V5h.5a.5.5 0 0 1 0 1H13v2h.5a.5.5 0 0 1 0 1H13v.5A2.5 2.5 0 0 1 10.5 12H10v1.5a.5.5 0 0 1-1 0V12H7v1.5a.5.5 0 0 1-1 0V12h-.5A2.5 2.5 0 0 1 3 9.5V9h-.5a.5.5 0 0 1 0-1H3V6h-.5a.5.5 0 0 1 0-1H3v-.5A2.5 2.5 0 0 1 5.5 2H6V.5a.5.5 0 0 1 .5-.5ZM4 6v3.5A1.5 1.5 0 0 0 5.5 11h5A1.5 1.5 0 0 0 12 9.5V6H4Z"/></svg> Eigenes CSS:</strong> Volle Kontrolle über das Design mit Live-Vorschau und Vorlagen</li>
            <li><strong>Dunkler Modus:</strong> Augenschonendes dunkles Design</li>
            <li><strong>Farbthemen:</strong> Anpassbare Farben für Gruppen und Links</li>
            <li><strong>Flexibles Layout:</strong> Mehrspaltige Unterstützung, einklappbare Gruppen</li>
            <li><strong>Formatierung:</strong> Individuelle Stile pro Gruppe/Link</li>
          </ul>
        </div>
        
        <!-- Erweiterte Funktionen -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-info mb-3">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-gear-fill me-1" viewBox="0 0 16 16">
              <path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/>
            </svg> Erweiterte Funktionen
          </h6>
          <ul class="feature-list">
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-clipboard-plus-fill me-1" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5zm4.5 6V9H10a.5.5 0 0 1 0 1H8.5v1.5a.5.5 0 0 1-1 0V10H6a.5.5 0 0 1 0-1h1.5V7.5a.5.5 0 0 1 1 0"/></svg> Schnappschüsse:</strong> Automatische und manuelle Sicherungspunkte</li>
            <li><strong>Rückgängig/Wiederholen:</strong> Vollständiger Verlauf mit Strg+Z/Strg+Y Unterstützung</li>
            <li><strong>QR-Codes:</strong> Generieren Sie QR-Codes für jeden Link</li>
            <li><strong>Auto-Favicon:</strong> Automatisches Abrufen von Website-Icons</li>
            <li><strong>Datenschutz:</strong> Alle Daten lokal gespeichert, Ende-zu-Ende-Verschlüsselung beim Teilen</li>
          </ul>
        </div>
        
        <!-- Tastenkürzel -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-secondary mb-3">
            <i class="bi bi-keyboard-fill"></i> Tastenkürzel
          </h6>
          <ul class="feature-list small">
            <li><kbd>Strg</kbd>+<kbd>Z</kbd> - Rückgängig</li>
            <li><kbd>Strg</kbd>+<kbd>Y</kbd> - Wiederholen</li>
            <li><kbd>Strg</kbd>+<kbd>F</kbd> - Suche fokussieren</li>
            <li><kbd>Strg</kbd>+<kbd>S</kbd> - Speichern (beim Bearbeiten)</li>
            <li><kbd>Esc</kbd> - Dialoge/Menüs schließen</li>
            <li><kbd>Entf</kbd> - Ausgewähltes löschen</li>
          </ul>
        </div>
        
        <!-- Tipps & Tricks -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-purple mb-3">
            <i class="bi bi-lightbulb-fill"></i> Tipps & Tricks
          </h6>
          <ul class="feature-list small">
            <li>💡 Ziehen Sie URLs direkt aus der Adressleiste in Gruppen</li>
            <li>💡 Rechtsklick für Kontextmenüs mit erweiterten Optionen</li>
            <li>💡 Nutzen Sie Schlüsselwörter für gruppenübergreifende Filterung</li>
            <li>💡 Eigenes CSS bleibt über Sitzungen hinweg erhalten</li>
            <li>💡 Teilen Sie Kontaktkarten per QR-Code für einfache Verbindung</li>
            <li>💡 Das Ereignisprotokoll zeigt vollständige Änderungshistorie mit Diffs</li>
          </ul>
        </div>
      </div>
      
      <!-- English Content -->
      <div v-if="helpLanguageTab === 'en'">
        <!-- Core Features -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-primary mb-3">
            <i class="bi bi-star-fill"></i> Core Features
          </h6>
          <ul class="feature-list">
            <li><strong>Groups & Links:</strong> Organize bookmarks in collapsible groups with multi-column layout</li>
            <li><strong>Drag & Drop:</strong> Reorder groups and links, move links between groups</li>
            <li><strong>Keywords:</strong> Tag links and groups with searchable keywords</li>
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-search me-1" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/></svg>Search & Filter:</strong> Fast filtering by text, URL, or keywords</li>
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-download me-1" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708z"/></svg> <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-upload me-1" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/><path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708z"/></svg>Import/Export:</strong> JSON and browser bookmark format support</li>
          </ul>
        </div>
        
        <!-- Collaboration Features -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-success mb-3">
            <i class="bi bi-people-fill"></i> Collaboration
          </h6>
          <ul class="feature-list">
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3Zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/></svg> Group Sharing:</strong> Share bookmark groups with team members via encrypted NTFY messages</li>
            <li><strong>Permissions:</strong> Owner controls member permissions (Add/Edit/Delete)</li>
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: -2px;"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg> Real-time Sync:</strong> Changes sync instantly across all members</li>
            <li><strong>Event Log:</strong> Track all changes with author and timestamp</li>
            <li><strong>Conflict Resolution:</strong> Vector clocks handle concurrent edits</li>
          </ul>
        </div>
        
        <!-- Customization Features -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-warning mb-3">
            <i class="bi bi-palette-fill"></i> Customization
          </h6>
          <ul class="feature-list">
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M6.5 0a.5.5 0 0 1 .5.5V2h2V.5a.5.5 0 0 1 1 0V2h.5A2.5 2.5 0 0 1 13 4.5V5h.5a.5.5 0 0 1 0 1H13v2h.5a.5.5 0 0 1 0 1H13v.5A2.5 2.5 0 0 1 10.5 12H10v1.5a.5.5 0 0 1-1 0V12H7v1.5a.5.5 0 0 1-1 0V12h-.5A2.5 2.5 0 0 1 3 9.5V9h-.5a.5.5 0 0 1 0-1H3V6h-.5a.5.5 0 0 1 0-1H3v-.5A2.5 2.5 0 0 1 5.5 2H6V.5a.5.5 0 0 1 .5-.5ZM4 6v3.5A1.5 1.5 0 0 0 5.5 11h5A1.5 1.5 0 0 0 12 9.5V6H4Z"/></svg> Custom CSS:</strong> Full styling control with live preview and templates</li>
            <li><strong>Dark Mode:</strong> Eye-friendly dark theme</li>
            <li><strong>Color Themes:</strong> Customize colors for groups and links</li>
            <li><strong>Flexible Layout:</strong> Multi-column support, collapsible groups</li>
            <li><strong>Rich Formatting:</strong> Custom styles per group/link</li>
          </ul>
        </div>
        
        <!-- Advanced Features -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-info mb-3">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-gear-fill me-1" viewBox="0 0 16 16">
              <path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/>
            </svg> Advanced
          </h6>
          <ul class="feature-list">
            <li><strong><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-clipboard-plus-fill me-1" viewBox="0 0 16 16" style="vertical-align: -2px;"><path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5zm4.5 6V9H10a.5.5 0 0 1 0 1H8.5v1.5a.5.5 0 0 1-1 0V10H6a.5.5 0 0 1 0-1h1.5V7.5a.5.5 0 0 1 1 0"/></svg> Snapshots:</strong> Automatic and manual backup points</li>
            <li><strong>Undo/Redo:</strong> Full history with Ctrl+Z/Ctrl+Y support</li>
            <li><strong>QR Codes:</strong> Generate QR codes for any link</li>
            <li><strong>Auto Favicon:</strong> Automatic favicon fetching</li>
            <li><strong>Privacy First:</strong> All data stored locally, E2E encryption for sharing</li>
          </ul>
        </div>
        
        <!-- Keyboard Shortcuts -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-secondary mb-3">
            <i class="bi bi-keyboard-fill"></i> Keyboard Shortcuts
          </h6>
          <ul class="feature-list small">
            <li><kbd>Ctrl</kbd>+<kbd>Z</kbd> - Undo</li>
            <li><kbd>Ctrl</kbd>+<kbd>Y</kbd> - Redo</li>
            <li><kbd>Ctrl</kbd>+<kbd>F</kbd> - Focus search</li>
            <li><kbd>Ctrl</kbd>+<kbd>S</kbd> - Save (when editing)</li>
            <li><kbd>Esc</kbd> - Close dialogs/menus</li>
            <li><kbd>Del</kbd> - Delete selected</li>
          </ul>
        </div>
        
        <!-- Tips & Tricks -->
        <div class="feature-section mb-4">
          <h6 class="feature-section-title text-purple mb-3">
            <i class="bi bi-lightbulb-fill"></i> Tips & Tricks
          </h6>
          <ul class="feature-list small">
            <li>💡 Drop URLs directly from browser address bar into groups</li>
            <li>💡 Right-click for context menus with advanced options</li>
            <li>💡 Use keywords for powerful filtering across groups</li>
            <li>💡 Custom CSS persists across sessions</li>
            <li>💡 Share contact cards via QR codes for easy connection</li>
            <li>💡 Event log shows full change history with diffs</li>
          </ul>
        </div>
      </div>
      
    </div>
  </div>
  
  <!-- Invitation Dialog (replaces Inbox Modal) -->
  <div class="modal fade" id="invitationModal" tabindex="-1" aria-labelledby="invitationModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="invitationModalLabel">
            <span v-if="invitationDialog.type === 'group'">{{ getTranslation('invitation.groupTitle') || 'Einladung zur geteilten Gruppe' }}</span>
            <span v-else-if="invitationDialog.type === 'link' && invitationDialog.groupName">{{ getTranslation('share.groupTitle') || 'Gruppe erhalten' }}</span>
            <span v-else-if="invitationDialog.type === 'link'">{{ getTranslation('share.linkTitle') || 'Links erhalten' }}</span>
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" @click="rejectInvitation()"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <p>
              <strong>{{ getTranslation('invitation.from') || 'Von' }}:</strong> 
              {{ invitationDialog.fromName }}
            </p>
            <div v-if="invitationDialog.type === 'group'">
              <p>
                <strong>{{ getTranslation('invitation.groupName') || 'Gruppenname' }}:</strong> 
                {{ invitationDialog.groupName }}
              </p>
              <p v-if="invitationDialog.linkCount > 0">
                <strong>{{ getTranslation('invitation.linkCount') || 'Anzahl Links' }}:</strong> 
                {{ invitationDialog.linkCount }}
              </p>
            </div>
            <div v-else-if="invitationDialog.type === 'link'">
              <p v-if="invitationDialog.groupName">
                <strong>{{ getTranslation('invitation.groupName') || 'Gruppenname' }}:</strong> 
                {{ invitationDialog.groupName }}
              </p>
              <p v-if="invitationDialog.linkCount > 0">
                <strong>{{ getTranslation('invitation.linkCount') || 'Anzahl Links' }}:</strong> 
                {{ invitationDialog.linkCount }}
              </p>
              <div v-if="invitationDialog.preview.length > 0">
                <p><strong>{{ getTranslation('invitation.linksToAdd') || 'Zu hinzufügende Links' }}:</strong></p>
                <div class="border rounded p-2" style="max-height: 200px; overflow-y: auto;">
                  <div v-for="(link, idx) in invitationDialog.preview" :key="idx" class="mb-1">
                    <small>• {{ link.text || link.url }}</small>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="alert alert-info" role="alert">
            <span v-if="invitationDialog.type === 'group'">
              {{ getTranslation('invitation.groupDescription') || 'Möchten Sie diese geteilte Gruppe hinzufügen? Sie können dann Links mit anderen Mitgliedern der Gruppe teilen.' }}
            </span>
            <span v-else-if="invitationDialog.type === 'link'">
              <span v-if="invitationDialog.groupName">
                {{ getTranslation('share.groupDescription') || 'Möchten Sie diese Gruppe mit allen Links hinzufügen?' }}
              </span>
              <span v-else>
                {{ getTranslation('share.linkDescription') || 'Möchten Sie diese Links hinzufügen?' }}
              </span>
            </span>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" @click="rejectInvitation()">
            <span v-if="invitationDialog.type === 'group'">{{ getTranslation('invitation.reject') || 'Ablehnen' }}</span>
            <span v-else>{{ getTranslation('share.cancel') || 'Abbrechen' }}</span>
          </button>
          <button type="button" class="btn btn-primary" @click="acceptInvitation()">
            <span v-if="invitationDialog.type === 'group'">{{ getTranslation('invitation.accept') || 'Annehmen' }}</span>
            <span v-else>{{ getTranslation('share.add') || 'Hinzufügen' }}</span>
          </button>
        </div>
      </div>
    </div>
  </div>


  <!-- Contacts & Quick-Connect Modal -->
  <div class="modal fade" id="contactsModal" tabindex="-1" aria-labelledby="contactsModalLabel" aria-hidden="true" v-show="contactsDialog.visible">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="contactsModalLabel">{{ getTranslation('dialog.contacts.title') || 'Contacts' }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" @click="closeContactsDialog()"></button>
        </div>
        <div class="modal-body">
          <!-- Tab Navigation -->
          <ul class="nav nav-tabs mb-3" role="tablist">
            <li class="nav-item" role="presentation">
              <button class="nav-link" :class="{'active': contactsDialog.tab === 'contacts'}" 
                      @click="contactsDialog.tab = 'contacts'" type="button">
                {{ getTranslation('dialog.contacts.tabTitle') || 'Contacts' }}
              </button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" :class="{'active': contactsDialog.tab === 'quickconnect'}" 
                      @click="contactsDialog.tab = 'quickconnect'" type="button">
                {{ getTranslation('dialog.quickconnect.tabTitle') || 'Quick-Connect' }}
              </button>
            </li>
          </ul>
          
          <!-- Contacts Tab -->
          <div v-if="contactsDialog.tab === 'contacts'">
            <div v-if="!data.contacts || data.contacts.length===0" class="text-muted">{{ getTranslation('dialog.contacts.empty') }}</div>
            <table class="table table-sm" v-else>
              <thead>
                <tr>
                  <th>{{ getTranslation('dialog.contacts.name') }}</th>
                  <th>{{ getTranslation('dialog.contacts.status') || 'Status' }}</th>
                  <th>{{ getTranslation('dialog.contacts.uuid') }}</th>
                  <th>{{ getTranslation('dialog.contacts.actions') }}</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="c in data.contacts" :key="c.uuid" :class="{ 'contact-row': true, 'offline': !isContactOnline(c.uuid) }">
                  <td>{{ c.name || '(no name)' }}</td>
                  <td>
                    <span :class="getContactStatusClass(c.uuid)"></span>
                    <span :class="getContactStatusTextClass(c.uuid)">
                      {{ getContactStatusText(c.uuid) }}
                    </span>
                  </td>
                  <td class="text-monospace" :title="c.uuid">…{{ c.uuid.slice(-5) }}</td>
                  <td>
                    <button class="btn btn-sm btn-outline-primary me-1" 
                            :disabled="!isContactOnline(c.uuid)"
                            @click="sendTestToContact(c)"
                            :title="!isContactOnline(c.uuid) ? getTranslation('dialog.contacts.offlineTooltip') || 'Contact is offline' : ''">
                      {{ getTranslation('dialog.contacts.sendTest') }}
                    </button>
                    <button class="btn btn-sm btn-outline-danger" @click="confirmRemoveContact(c)">
                      {{ getTranslation('dialog.contacts.remove') }}
                    </button>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          
          <!-- Quick-Connect Tab -->
          <div v-if="contactsDialog.tab === 'quickconnect'">
            <div class="row mb-3">
              <div class="col-6">
                <div class="card" :class="qcDialog.mode==='receive' ? 'border-primary border-2' : 'border-secondary'" 
                     @click="qcDialog.mode='receive'" style="cursor: pointer;">
                  <div class="card-body text-center p-2">
                    <h6 class="card-title mb-1">
                      <span class="badge" :class="qcDialog.mode==='receive' ? 'bg-primary' : 'bg-secondary'">
                        {{ getTranslation('qc.receive') || 'RECEIVE' }}
                      </span>
                    </h6>
                    <small class="text-muted">{{ getTranslation('qc.receive.desc') || 'Show code' }}</small>
                  </div>
                </div>
              </div>
              <div class="col-6">
                <div class="card" :class="qcDialog.mode==='send' ? 'border-primary border-2' : 'border-secondary'" 
                     @click="qcDialog.mode='send'" style="cursor: pointer;">
                  <div class="card-body text-center p-2">
                    <h6 class="card-title mb-1">
                      <span class="badge" :class="qcDialog.mode==='send' ? 'bg-primary' : 'bg-secondary'">
                        {{ getTranslation('qc.send') || 'SEND' }}
                      </span>
                    </h6>
                    <small class="text-muted">{{ getTranslation('qc.send.desc') || 'Enter code' }}</small>
                  </div>
                </div>
              </div>
            </div>
            
            <div v-if="qcDialog.mode==='receive'" class="text-center">
              <p class="text-muted mb-2">{{ getTranslation('qc.receive.instruction') || 'Share this code:' }}</p>
              <div class="mb-3">
                <input type="text" class="form-control form-control-lg text-center font-monospace fw-bold" 
                       :value="qcDialog.code || '------'" readonly 
                       style="letter-spacing: 0.2em; font-size: 1.5rem;">
              </div>
              <button class="btn btn-success me-2" @click="qcStartReceive" v-if="!qcDialog.code">
                {{ getTranslation('qc.generate') || 'Generate Code' }}
              </button>
              <button class="btn btn-danger" @click="qcCancel" v-else>
                {{ getTranslation('qc.stop') || 'Stop' }}
              </button>
            </div>
            
            <div v-else class="text-center">
              <p class="text-muted mb-2">{{ getTranslation('qc.send.instruction') || 'Enter the code:' }}</p>
              <div class="mb-3">
                <input type="text" class="form-control form-control-lg text-center font-monospace fw-bold" 
                       v-model="qcDialog.code" placeholder="abc123" maxlength="6"
                       style="letter-spacing: 0.2em; font-size: 1.5rem;">
              </div>
              <button class="btn btn-primary me-2" @click="qcStartSend" :disabled="!qcDialog.code || qcDialog.code.length !== 6">
                {{ getTranslation('qc.connect') || 'Connect' }}
              </button>
              <button class="btn btn-secondary" @click="qcCancel">
                {{ getTranslation('qc.cancel') || 'Cancel' }}
              </button>
            </div>
            
            <hr class="my-3">
            <div class="border rounded p-2 bg-light" style="height: 120px; overflow: auto;" id="qcStatusBox">
              <small>
                <div v-for="s in qcDialog.status" :key="s.t" class="text-muted">
                  {{ formatMessageTime(s.t) }} — {{ s.m }}
                </div>
              </small>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" @click="closeContactsDialog()">{{ getTranslation('dialog.close') || 'Close' }}</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Share Modal -->
  <div class="modal fade" id="shareModal" tabindex="-1" aria-labelledby="shareModalLabel" aria-hidden="true" v-show="shareDialog.visible">
    <div class="modal-dialog modal-md modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="shareModalLabel">
            <span v-if="shareDialog.mode === 'link'">{{ getTranslation('dialog.send.linkTitle') || 'Send Link' }}</span>
            <span v-else-if="shareDialog.mode === 'group'">{{ getTranslation('dialog.send.groupTitle') || 'Send Group' }}</span>
            <span v-else-if="shareDialog.mode === 'invite-group'">{{ getTranslation('dialog.invite.title') || 'Invite Members' }}</span>
            <span v-else-if="shareDialog.mode === 'owner-transfer'">{{ getTranslation('dialog.transfer.title') || 'Transfer Ownership' }}</span>
            <span v-else>{{ getTranslation('dialog.share.title') || 'Share' }}</span>
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" @click="shareDialog.visible=false"></button>
        </div>
        <div class="modal-body">
          <template v-if="shareDialog.mode === 'owner-transfer'">
            <div class="mb-3">{{ getTranslation('dialog.transfer.select') || 'Select new owner:' }}</div>
            <div class="form-check" v-for="c in (data.contacts||[]).filter(ct=> (shareDialog.group?.members||[]).some(m=>m.uuid===ct.uuid) && ct.uuid!==data.identity?.uuid)" :key="'sc-'+c.uuid" 
                 :class="{ 'contact-row': true, 'offline': !isContactOnline(c.uuid) }">
              <input class="form-check-input" type="checkbox" :id="'sc-'+c.uuid" v-model="shareDialog.selectedContacts[c.uuid]" :disabled="!isContactOnline(c.uuid)">
              <label class="form-check-label" :for="'sc-'+c.uuid">
                {{ c.name || '(no name)' }} 
                <span class="text-monospace text-muted">…{{ c.uuid.slice(-5) }}</span>
                <span :class="getContactStatusClass(c.uuid)"></span>
                <span :class="getContactStatusTextClass(c.uuid)" v-if="!isContactOnline(c.uuid)">
                  ({{ getContactStatusText(c.uuid) }})
                </span>
              </label>
            </div>
            <div v-if="!(data.contacts||[]).some(ct=> (shareDialog.group?.members||[]).some(m=>m.uuid===ct.uuid) && ct.uuid!==data.identity?.uuid)" class="text-muted">
              {{ getTranslation('dialog.transfer.noCandidates') || 'No eligible members found.' }}
            </div>
          </template>
          <template v-else>
            <div class="mb-3">{{ getTranslation('dialog.send.selectContacts') || 'Select contacts to send to:' }}</div>
            <div class="form-check" v-for="c in data.contacts" :key="'sc-'+c.uuid" 
                 :class="{ 'contact-row': true, 'offline': !isContactOnline(c.uuid) }">
              <input class="form-check-input" type="checkbox" 
                     :id="'sc-'+c.uuid" 
                     v-model="shareDialog.selectedContacts[c.uuid]"
                     :disabled="!isContactOnline(c.uuid)">
              <label class="form-check-label" :for="'sc-'+c.uuid">
                {{ c.name || '(no name)' }} 
                <span class="text-monospace text-muted">…{{ c.uuid.slice(-5) }}</span>
                <span :class="getContactStatusClass(c.uuid)"></span>
                <span :class="getContactStatusTextClass(c.uuid)" v-if="!isContactOnline(c.uuid)">
                  ({{ getContactStatusText(c.uuid) }})
                </span>
              </label>
            </div>
            <div v-if="!data.contacts || data.contacts.length === 0" class="text-muted">
              {{ getTranslation('dialog.send.noContacts') || 'No contacts available. Add contacts first.' }}
            </div>
          </template>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" @click="confirmShare">
            <span v-if="shareDialog.mode === 'owner-transfer'">{{ getTranslation('dialog.transfer.transfer') || 'Transfer' }}</span>
            <span v-else>{{ getTranslation('dialog.send.send') || 'Send' }}</span>
          </button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" @click="shareDialog.visible=false">{{ getTranslation('dialog.send.cancel') || 'Cancel' }}</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Members Modal -->
  <div class="modal fade" id="membersModal" tabindex="-1" aria-labelledby="membersModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="membersModalLabel">{{ getTranslation('members.title') }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" v-if="editGroup">
          <div v-if="Array.isArray(editGroup.members) && editGroup.members.length">
            <div class="border rounded p-2 mb-2" v-for="m in editGroup.members" :key="'mem-'+m.uuid">
              <div class="d-flex align-items-center justify-content-between">
                <div class="d-flex align-items-center">
                  <div v-if="isOwnerOfGroup(editGroup) && m.role !== 'owner'" class="form-check me-3">
                    <input class="form-check-input" type="checkbox" :id="'mem-'+m.uuid" :checked="(editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='allow'" @change="toggleMemberInbound(m)">
                    <label class="form-check-label" :for="'mem-'+m.uuid">
                      <strong>{{ m.name || m.uuid }}</strong>
                    </label>
                  </div>
                  <div v-else>
                    <strong>{{ m.name || m.uuid }}</strong>
                  </div>
                  <span class="badge bg-secondary ms-2 me-2">{{ m.role||'member' }}</span>
                  <span v-if="isOwnerOfGroup(editGroup) && m.role !== 'owner'" class="badge" :class="{
                    'bg-success': (editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='allow',
                    'bg-danger': (editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='deny',
                    'bg-secondary': (editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='unset'
                  }">
                    {{ (editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='allow' ? getTranslation('members.filter.allow') : (editGroup.prefs.inbound.perMember[m.uuid]||'unset')==='deny' ? getTranslation('members.filter.deny') : getTranslation('members.filter.unset') }}
                  </span>
                </div>
                <button v-if="isOwnerOfGroup(editGroup)" class="btn btn-sm btn-outline-danger" :disabled="m.role==='owner' || m.uuid===data.identity.uuid" @click="confirmRemoveMember(m)">{{ getTranslation('members.remove') }}</button>
              </div>
              <div v-if="isOwnerOfGroup(editGroup)" class="mt-2 d-flex align-items-center">
                <small class="text-muted me-2">Permissions:</small>
                <div class="form-check form-check-inline">
                  <input class="form-check-input" type="checkbox" :id="'perm-add-'+m.uuid"
                         :checked="(m.role==='owner') ? true : !!m.canAdd"
                         :disabled="m.role==='owner'"
                         @change="toggleMemberPerm(m, 'canAdd')">
                  <label class="form-check-label" :for="'perm-add-'+m.uuid">{{ getTranslation('members.perm.add') }}</label>
                </div>
                <div class="form-check form-check-inline">
                  <input class="form-check-input" type="checkbox" :id="'perm-edit-'+m.uuid"
                         :checked="(m.role==='owner') ? true : !!m.canEdit"
                         :disabled="m.role==='owner'"
                         @change="toggleMemberPerm(m, 'canEdit')">
                  <label class="form-check-label" :for="'perm-edit-'+m.uuid">{{ getTranslation('members.perm.edit') }}</label>
                </div>
                <div class="form-check form-check-inline">
                  <input class="form-check-input" type="checkbox" :id="'perm-del-'+m.uuid"
                         :checked="(m.role==='owner') ? true : !!m.canDelete"
                         :disabled="m.role==='owner'"
                         @change="toggleMemberPerm(m, 'canDelete')">
                  <label class="form-check-label" :for="'perm-del-'+m.uuid">{{ getTranslation('members.perm.delete') }}</label>
                </div>
              </div>
            </div>
          </div>
          <div v-else class="text-muted">{{ getTranslation('members.noRoster') }}</div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Removed from Group Modal -->
  <div class="modal fade" id="removedFromGroupModal" tabindex="-1" aria-labelledby="removedFromGroupModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header bg-warning">
          <h5 class="modal-title" id="removedFromGroupModalLabel">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-exclamation-triangle me-2" viewBox="0 0 16 16">
              <path d="M7.938 2.016A.13.13 0 0 1 8.002 2a.13.13 0 0 1 .063.016.146.146 0 0 1 .054.057l6.857 11.667c.036.06.035.124.002.183a.163.163 0 0 1-.054.06.116.116 0 0 1-.066.017H1.146a.115.115 0 0 1-.066-.017.163.163 0 0 1-.054-.06.176.176 0 0 1 .002-.183L7.884 2.073a.147.147 0 0 1 .054-.057zm1.044-.45a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566z"/>
              <path d="M7.002 12a1 1 0 1 1 2 0 1 1 0 0 1-2 0zM7.1 5.995a.905.905 0 1 1 1.8 0l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995z"/>
            </svg>
            {{ getTranslation('removedFromGroup.title') || 'Group Membership Removed' }}
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="alert alert-warning" role="alert">
            <p class="mb-2">
              {{ getTranslation('removedFromGroup.message') || 'You have been removed from the following group while you were offline:' }}
            </p>
            <div class="card">
              <div class="card-body">
                <h6 class="card-title">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-folder-x me-2" viewBox="0 0 16 16">
                    <path d="M.54 3.87.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3h3.982a2 2 0 0 1 1.992 2.181L15.546 8H14.54l.265-2.91A1 1 0 0 0 13.81 4H9.828a3 3 0 0 1-2.122-.879l-.827-.828A1 1 0 0 0 6.172 2H2.5a1 1 0 0 0-1 .981l.006.04z"/>
                    <path d="M1 7v9a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7H1zm5.646 5.646a.5.5 0 0 0 .708.708L8 12.707l.646.647a.5.5 0 0 0 .708-.708L8.707 12l.647-.646a.5.5 0 0 0-.708-.708L8 11.293l-.646-.647a.5.5 0 0 0-.708.708l.647.646-.647.646z"/>
                  </svg>
                  {{ removedGroupInfo.groupName }}
                </h6>
                <p class="card-text mb-1">
                  <small class="text-muted">
                    <strong>{{ getTranslation('removedFromGroup.owner') || 'Group Owner:' }}</strong> {{ removedGroupInfo.ownerName }}
                  </small>
                </p>
                <p class="card-text">
                  <small class="text-muted">
                    <strong>{{ getTranslation('removedFromGroup.removedAt') || 'Removed:' }}</strong> {{ formatDate(removedGroupInfo.removedAt) }}
                  </small>
                </p>
              </div>
            </div>
            <p class="mt-3 mb-0">
              <small>{{ getTranslation('removedFromGroup.explanation') || 'The group will be removed from your list. If you need access again, please contact the group owner.' }}</small>
            </p>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" data-bs-dismiss="modal" @click="acknowledgeGroupRemoval">
            {{ getTranslation('removedFromGroup.acknowledge') || 'I Understand' }}
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="linkMenu" class="context-menu mb-context-menu" :style="contextMenuStyle"
    :class="{ 'context-menu-visible': isLinkMenuVisible }">
    <ul v-if="contextLink">
      <li @click="canEdit(contextGroup) ? showLinkEditModal(contextLink) : null" 
          :class="{ 'disabled': !canEdit(contextGroup) }"
          :title="!canEdit(contextGroup) ? getTranslation('error.perm.edit') : ''">
        {{ getTranslation('menu.link.editLink') }}
        <span v-if="!canEdit(contextGroup)" class="text-muted"> ({{ getTranslation('permission.denied') || 'No permission' }})</span>
      </li>
      <li v-if="hasNtfyUrl() && contextLink.url" class="separator mb-context-menu-separator"></li>
      <li v-if="hasNtfyUrl() && contextLink.url" @click="shareLink(contextLink)">{{ getTranslation('menu.link.sendLink') }}</li>
      <li class="separator mb-context-menu-separator" v-if="contextLink.url"></li>
      <li @click="showQrCodeModal(contextLink.url)" v-if="contextLink.url">{{ getTranslation('menu.link.createQrCode') }}</li>
      <li class="separator mb-context-menu-separator" v-if="(linkShortenerEnabledSet.size > 0)"></li>
      <li class="submenu" tabindex="0" v-if="(linkShortenerEnabledSet.size > 0) || (linkShortenerServices && linkShortenerServices.length)">
        {{ getTranslation('menu.link.shorten') || 'Shorten URL via…' }}
        <ul class="context-submenu mb-context-submenu">
          <li v-if="linkShortenerEnabledSet.size === 0" class="disabled">
            {{ getTranslation('menu.link.shorten.disabled') || 'Configure providers in the settings to enable shortening' }}
          </li>
          <li v-for="service in linkShortenerMenuEntries" :key="'shortener-' + service.id"
              :class="{ 'disabled': !contextLink || !contextLink.url }"
              @click.prevent="contextLink && contextLink.url ? shortenLinkWithService(service) : null">
            {{ service.name }}
          </li>
          <li v-if="contextLink && !contextLink.url" class="disabled">
            {{ getTranslation('menu.link.shorten.noUrl') || 'No URL available' }}
          </li>
        </ul>
      </li>
      <li class="separator mb-context-menu-separator"></li>
      <li class="submenu" tabindex="0">
        {{ getTranslation('menu.link.copyForCss') || 'Copy for CSS' }}
        <ul class="context-submenu mb-context-submenu">
          <li @click="copyLinkCssClass(contextLink); hideMenus()">{{ getTranslation('menu.link.copyCssClass') || 'Copy CSS class' }}</li>
          <li @click="copyLinkUuid(contextLink); hideMenus()">{{ getTranslation('menu.link.copyUuid') || 'Copy UUID' }}</li>
          <li @click="copyLinkUuid(contextLink, {shiftKey: true}); hideMenus()">{{ getTranslation('menu.link.copyCssSelector') || 'Copy CSS selector [data-link-uuid]' }}</li>
        </ul>
      </li>
      <li class="separator mb-context-menu-separator"></li>
      <li @click="canDelete(contextGroup) ? (deleteLink(contextLink), hideMenus()) : null" 
          :class="{ 'disabled': !canDelete(contextGroup) }"
          :title="!canDelete(contextGroup) ? getTranslation('error.perm.delete') : ''">
        {{ getTranslation('menu.link.deleteLink') }}
        <span v-if="!canDelete(contextGroup)" class="text-muted"> ({{ getTranslation('permission.denied') || 'No permission' }})</span>
      </li>
    </ul>
  </div>

  <div id="options">
  </div>

  <div id="qrCode">
    <div class="modal fade" id="qrCodeModal" tabindex="-1" aria-labelledby="qrCodeModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content mb-modal">
          <div class="modal-header">
            <h5 class="modal-title" id="qrCodeModalLabel">QR code</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body text-center">
            <div id="qrCodeDiv"></div>
            <p class="mt-3 qrCodeUrl">{{ qrCodeUrl }}</p>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Bookmarklet Modal -->
  <div id="bookmarklet">
    <div class="modal fade" id="bookmarkletModal" tabindex="-1" aria-labelledby="bookmarkletModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content mb-modal">
          <div class="modal-header">
            <h5 class="modal-title" id="bookmarkletModalLabel">{{ getTranslation('bookmarklet.helpTitle') }}</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <p class="mb-2">{{ getTranslation('bookmarklet.instructions') }}</p>
            <p class="mb-2"><a :href="bookmarkletHref" draggable="true" class="btn btn-sm btn-primary">{{ getTranslation('bookmarklet.dragThis') }}</a></p>
            <div class="input-group input-group-sm">
              <span class="input-group-text">JS</span>
              <input type="text" class="form-control" :value="bookmarkletHref" readonly onclick="this.select()">
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- JSON Inspector Modal -->
  <div class="modal fade" id="jsonInspectorModal" tabindex="-1" aria-labelledby="jsonInspectorModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-centered modal-dialog-scrollable">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <h5 class="modal-title" id="jsonInspectorModalLabel">
            {{ getTranslation('json.inspector.title') || 'Group JSON Inspector' }}
            <span v-if="inspectedGroup" class="text-muted ms-2">- {{ inspectedGroup.name }}</span>
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div v-if="inspectedGroup">
            <!-- Tabs -->
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#json-tab" type="button" role="tab">
                  JSON
                </button>
              </li>
              <li class="nav-item" role="presentation" v-if="inspectedGroup.eventLog && inspectedGroup.eventLog.length > 0">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#eventlog-tab" type="button" role="tab">
                  Event Log ({{ inspectedGroup.eventLog.length }})
                </button>
              </li>
              <li class="nav-item" role="presentation" v-if="inspectedGroup.snapshot">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#snapshot-tab" type="button" role="tab">
                  Snapshot
                </button>
              </li>
            </ul>
            
            <!-- Tab Content -->
            <div class="tab-content mt-3">
              <!-- JSON Tab -->
              <div class="tab-pane fade show active" id="json-tab" role="tabpanel">
                <!-- Copy button and info -->
                <div class="d-flex justify-content-between align-items-center mb-3">
                  <div class="text-muted">
                    <small>
                      {{ getTranslation('json.inspector.info') || 'Complete JSON representation of the group object' }}
                    </small>
                  </div>
                  <button type="button" class="btn btn-sm btn-outline-primary" @click="copyGroupJSON">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16">
                      <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
                      <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
                    </svg>
                    {{ getTranslation('json.inspector.copy') || 'Copy JSON' }}
                  </button>
                </div>
                
                <!-- JSON display -->
                <pre class="bg-light p-3 rounded" style="max-height: 50vh; overflow-y: auto; font-size: 0.875rem;">{{ inspectedGroupJSON }}</pre>
                
                <!-- Statistics -->
                <div class="mt-3 p-3 bg-light rounded">
                  <h6>{{ getTranslation('json.inspector.stats') || 'Statistics' }}</h6>
                  <div class="row">
                    <div class="col-md-6">
                      <ul class="list-unstyled mb-0">
                        <li><strong>Links:</strong> {{ inspectedGroup.links ? inspectedGroup.links.length : 0 }}</li>
                        <li><strong>Members:</strong> {{ inspectedGroup.members ? inspectedGroup.members.length : 0 }}</li>
                        <li><strong>Shared:</strong> {{ inspectedGroup.shared ? 'Yes' : 'No' }}</li>
                        <li><strong>Version:</strong> {{ inspectedGroup.version || CONSTS.VERSION_FALLBACK }}</li>
                      </ul>
                    </div>
                    <div class="col-md-6">
                      <ul class="list-unstyled mb-0">
                        <li><strong>Has Event Log:</strong> {{ inspectedGroup.eventLog ? 'Yes' : 'No' }}</li>
                        <li v-if="inspectedGroup.eventLog"><strong>Events:</strong> {{ inspectedGroup.eventLog.length }}</li>
                        <li v-if="inspectedGroup.snapshot"><strong>Has Snapshot:</strong> Yes</li>
                        <li><strong>Size:</strong> {{ formatBytes(inspectedGroupJSON.length) }}</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Event Log Tab -->
              <div class="tab-pane fade" id="eventlog-tab" role="tabpanel" v-if="inspectedGroup.eventLog">
                <div class="table-responsive">
                  <table class="table table-sm table-hover">
                    <thead>
                      <tr>
                        <th>{{ getTranslation('eventlog.time') || 'Time' }}</th>
                        <th>{{ getTranslation('eventlog.type') || 'Type' }}</th>
                        <th>{{ getTranslation('eventlog.author') || 'Author' }}</th>
                        <th>{{ getTranslation('eventlog.details') || 'Details' }}</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr v-for="event in getSortedEventLog(inspectedGroup.eventLog)" :key="event.eventId">
                        <td class="text-nowrap">{{ formatEventTime(event.timestamp) }}</td>
                        <td>
                          <span class="badge" :class="getEventTypeBadgeClass(event.operation?.type || event.type)">
                            {{ event.operation?.type || event.type || 'unknown' }}
                          </span>
                        </td>
                        <td>{{ getAuthorName(event.author || event.authorId) }}</td>
                        <td>
                          <div v-if="(event.operation?.type || event.type) === 'link-edit' && ((event.operation && Object.keys(event.operation.data || {}).length > 1) || (!event.operation && event.data?.changes && Object.keys(event.data.changes).length > 1))">
                            <details>
                              <summary class="cursor-pointer">
                                <small class="text-muted">{{ Object.keys(event.operation?.data || event.data?.changes || {}).length }} {{ getTranslation('eventlog.changes') || 'changes' }}</small>
                              </summary>
                              <div class="mt-1">
                                <small class="text-muted" v-html="getEventDetailsFormatted(event)"></small>
                              </div>
                            </details>
                          </div>
                          <div v-else>
                            <small class="text-muted" v-html="getEventDetailsFormatted(event)"></small>
                          </div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              
              <!-- Snapshot Tab -->
              <div class="tab-pane fade" id="snapshot-tab" role="tabpanel" v-if="inspectedGroup.snapshot">
                <div class="p-3 bg-light rounded">
                  <h6>{{ getTranslation('snapshot.info') || 'Snapshot Information' }}</h6>
                  <ul class="list-unstyled">
                    <li><strong>{{ getTranslation('snapshot.created') || 'Created' }}:</strong> {{ formatEventTime(inspectedGroup.snapshot.timestamp) }}</li>
                    <li><strong>{{ getTranslation('snapshot.eventId') || 'Event ID' }}:</strong> <code>{{ inspectedGroup.snapshot.eventId || 'N/A' }}</code></li>
                    <li><strong>{{ getTranslation('snapshot.links') || 'Links in snapshot' }}:</strong> {{ inspectedGroup.snapshot.data?.links?.length || 0 }}</li>
                    <li><strong>{{ getTranslation('snapshot.members') || 'Members in snapshot' }}:</strong> {{ inspectedGroup.snapshot.data?.members?.length || 0 }}</li>
                    <li><strong>{{ getTranslation('snapshot.version') || 'Version' }}:</strong> {{ inspectedGroup.snapshot.data?.version || CONSTS.VERSION_FALLBACK }}</li>
                  </ul>
                  
                  <h6 class="mt-3">{{ getTranslation('snapshot.vectorClock') || 'Vector Clock' }}</h6>
                  <div class="table-responsive">
                    <table class="table table-sm" v-if="inspectedGroup.snapshot.vectorClock && Object.keys(inspectedGroup.snapshot.vectorClock).length > 0">
                      <thead>
                        <tr>
                          <th>{{ getTranslation('snapshot.member') || 'Member' }}</th>
                          <th>{{ getTranslation('snapshot.eventCount') || 'Event Count' }}</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr v-for="(count, memberId) in inspectedGroup.snapshot.vectorClock" :key="memberId">
                          <td>{{ getAuthorName(memberId) }}</td>
                          <td>{{ count }}</td>
                        </tr>
                      </tbody>
                    </table>
                    <p v-else class="text-muted">{{ getTranslation('snapshot.noVectorClock') || 'No vector clock data' }}</p>
                  </div>
                  
                  <details class="mt-3">
                    <summary class="cursor-pointer">{{ getTranslation('snapshot.showData') || 'Show snapshot data' }}</summary>
                    <pre class="bg-white p-2 mt-2 rounded" style="max-height: 30vh; overflow-y: auto; font-size: 0.875rem;">{{ JSON.stringify(inspectedGroup.snapshot.data, null, 2) }}</pre>
                  </details>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{{ getTranslation('close') || 'Close' }}</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Paste from Clipboard Modal -->
  <div id="pasteClipboard">
    <div class="modal fade" id="pasteClipboardModal" tabindex="-1" aria-labelledby="pasteClipboardModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content mb-modal">
          <div class="modal-header">
            <h5 class="modal-title" id="pasteClipboardModalLabel">{{ getTranslation('clipboard.modalTitle') || 'Import Links' }}</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" @click="resetImportDialog"></button>
          </div>
          <div class="modal-body">
            <p class="mb-2">{{ getTranslation('clipboard.instructions') || 'Import from file or paste JSON, CSV, or HTML bookmarks:' }}</p>
            
            <!-- File upload option -->
            <div class="mb-3">
              <label class="form-label">{{ getTranslation('import.fromFile') || 'Import from file:' }}</label>
              <input type="file" class="form-control form-control-sm" 
                accept=".json,.csv,.html,.htm" 
                @change="handleFileUpload"
                ref="fileInput">
            </div>
            
            <div class="text-center mb-2">
              <small class="text-muted">{{ getTranslation('import.or') || '— OR —' }}</small>
            </div>
            
            <!-- URL import option -->
            <div class="mb-3">
              <label class="form-label">{{ getTranslation('import.fromUrl') || 'Import from URL:' }}</label>
              <div class="input-group">
                <input type="url" class="form-control form-control-sm" 
                  v-model="importUrl"
                  :placeholder="getTranslation('import.urlPlaceholder') || 'https://example.com/bookmarks.json'"
                  @keyup.enter="fetchFromUrl">
                <button type="button" class="btn btn-sm btn-outline-secondary" 
                  @click="fetchFromUrl"
                  :disabled="!importUrl || fetchingUrl">
                  <span v-if="fetchingUrl">{{ getTranslation('import.fetching') || 'Fetching...' }}</span>
                  <span v-else>{{ getTranslation('import.fetch') || 'Fetch' }}</span>
                </button>
              </div>
              <div v-if="urlFetchError" class="text-danger small mt-1">{{ urlFetchError }}</div>
            </div>
            
            <div v-if="extensionAvailable" class="text-center mb-2">
              <small class="text-muted">{{ getTranslation('import.or') || '— OR —' }}</small>
            </div>

            <!-- Browser bookmarks option (if extension available) -->
            <div v-if="extensionAvailable" class="mb-3">
              <label class="form-label">{{ getTranslation('import.fromBrowser') || 'Import from browser:' }}</label>
              <div>
                <button type="button" class="btn btn-sm btn-outline-primary"
                  @click="fetchBrowserBookmarks"
                  :disabled="fetchingBrowserBookmarks">
                  <span v-if="fetchingBrowserBookmarks">
                    <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                    {{ getTranslation('import.fetchingBookmarks') || 'Loading bookmarks...' }}
                  </span>
                  <span v-else>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bookmark-star me-1" viewBox="0 0 16 16">
                      <path d="M7.84 4.1a.178.178 0 0 1 .32 0l.634 1.285a.178.178 0 0 0 .134.098l1.42.206c.145.021.204.2.098.303L9.42 6.993a.178.178 0 0 0-.051.158l.242 1.414a.178.178 0 0 1-.258.187l-1.27-.668a.178.178 0 0 0-.165 0l-1.27.668a.178.178 0 0 1-.257-.187l.242-1.414a.178.178 0 0 0-.05-.158l-1.03-1.001a.178.178 0 0 1 .098-.303l1.42-.206a.178.178 0 0 0 .134-.098L7.84 4.1z"/>
                      <path d="M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v13.5a.5.5 0 0 1-.777.416L8 13.101l-5.223 2.815A.5.5 0 0 1 2 15.5V2zm2-1a1 1 0 0 0-1 1v12.566l4.723-2.482a.5.5 0 0 1 .554 0L13 14.566V2a1 1 0 0 0-1-1H4z"/>
                    </svg>
                    {{ getTranslation('import.browserBookmarks') || 'Import Browser Bookmarks' }}
                  </span>
                </button>
                <div v-if="browserBookmarksInfo" class="text-muted small mt-1">
                  {{ browserBookmarksInfo }}
                </div>
              </div>
            </div>

            <div class="text-center mb-2">
              <small class="text-muted">{{ getTranslation('import.or') || '— OR —' }}</small>
            </div>

            <!-- Clipboard option -->
            <div class="mb-2">
              <label class="form-label">{{ getTranslation('import.fromClipboard') || 'Paste from clipboard:' }}</label>
              <button type="button" class="btn btn-sm btn-outline-secondary ms-2" @click="readFromClipboard">{{ getTranslation('clipboard.read') || 'Read from Clipboard' }}</button>
            </div>
            <div class="mb-3">
              <textarea class="form-control" rows="5" v-model="pasteContent" @input="parsePastedContent" :placeholder="getTranslation('clipboard.placeholder') || 'Paste your data here...'"></textarea>
            </div>
            <div class="text-muted small mb-2" v-if="pasteHint">{{ pasteHint }}</div>
            
            <!-- Format detection -->
            <div v-if="detectedFormat" class="alert alert-info py-2">
              <small>{{ getTranslation('clipboard.detectedFormat') || 'Detected format:' }} <strong>{{ detectedFormat }}</strong></small>
            </div>
            
            <!-- Warning for full export -->
            <div v-if="isFullExport" class="alert alert-warning py-2">
              <strong>{{ getTranslation('import.fullExportWarning.title') || 'Warning!' }}</strong>
              {{ getTranslation('import.fullExportWarning.message') || 'This is a full database export. It should only be imported into an EMPTY database to avoid conflicts. All existing data will be replaced.' }}
            </div>
            
            <!-- New group title input (only show when not doing full import) -->
            <div v-if="parsedLinks && parsedLinks.length > 0 && !isFullExport" class="mb-3">
              <label class="form-label">{{ getTranslation('import.newGroupTitle') || 'New group title:' }}</label>
              <input type="text" class="form-control form-control-sm" 
                v-model="importGroupTitle" 
                :placeholder="getDefaultImportGroupTitle()"
                @keypress.enter.prevent="importSelected">
            </div>
            
            <!-- Preview section -->
            <div v-if="parsedLinks && parsedLinks.length > 0" class="border rounded p-2" style="max-height: 300px; overflow-y: auto;">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="mb-0">{{ getTranslation('clipboard.preview') || 'Preview' }} ({{ parsedLinks.filter(l => l.selected).length }}/{{ parsedLinks.length }})</h6>
                <div>
                  <button type="button" class="btn btn-sm btn-outline-primary me-1" @click="selectAllLinks">{{ getTranslation('clipboard.selectAll') || 'Select All' }}</button>
                  <button type="button" class="btn btn-sm btn-outline-secondary" @click="deselectAllLinks">{{ getTranslation('clipboard.deselectAll') || 'Deselect All' }}</button>
                </div>
              </div>
              
              <!-- Group by existing groups if available -->
              <div v-if="getImportGroups().length > 0" class="mb-2">
                <div class="alert alert-info py-2">
                  <small>{{ getTranslation('import.groupsFound') || 'Found links from the following groups:' }}</small>
                  <div class="mt-1">
                    <span v-for="groupName in getImportGroups()" :key="groupName" 
                          class="badge bg-secondary me-1">{{ groupName }}</span>
                  </div>
                  <small class="d-block mt-2">{{ getTranslation('import.groupsWillBeCreated') || 'These groups will be created automatically if they don\'t exist.' }}</small>
                </div>
              </div>
              
              <div class="list-group list-group-flush">
                <!-- Group links by groupName -->
                <template v-for="groupName in getUniqueGroupNames()">
                  <!-- Group header with checkbox and toggle -->
                  <div v-if="groupName" :key="'group-' + groupName"
                       class="list-group-item py-2 bg-light">
                    <div class="d-flex align-items-center">
                      <!-- Group checkbox -->
                      <input type="checkbox"
                             class="form-check-input me-2"
                             :checked="isGroupSelected(groupName)"
                             @change="toggleGroupSelection(groupName)"
                             :id="'import-group-' + groupName">

                      <!-- Toggle button -->
                      <button type="button"
                              class="btn btn-sm btn-link p-0 me-2 text-decoration-none"
                              @click="toggleImportGroupCollapse(groupName)"
                              :aria-expanded="!isImportGroupCollapsed(groupName)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                          <path v-if="isImportGroupCollapsed(groupName)" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                          <path v-else d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                        </svg>
                      </button>

                      <!-- Group name and count -->
                      <strong class="text-primary flex-grow-1">
                        📁 {{ getGroupDisplayName(groupName) }}
                        <span class="text-muted small">({{ getLinksForGroup(groupName).length }})</span>
                      </strong>
                    </div>
                    <!-- Full path display for browser bookmarks -->
                    <div v-if="getGroupFullPath(groupName)" class="ms-4 mt-1">
                      <small class="text-muted">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-folder-fill me-1" viewBox="0 0 16 16">
                          <path d="M9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.825a2 2 0 0 1-1.991-1.819l-.637-7a1.99 1.99 0 0 1 .342-1.31L.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3zm-8.322.12C1.72 3.042 1.95 3 2.19 3h5.396l-.707-.707A1 1 0 0 0 6.172 2H2.5a1 1 0 0 0-1 .981l.006.139z"/>
                        </svg>
                        {{ getGroupFullPath(groupName) }}
                      </small>
                    </div>
                  </div>

                  <!-- Collapsible links in this group -->
                  <div v-show="!isImportGroupCollapsed(groupName)">
                    <label v-for="(link, index) in getLinksForGroup(groupName)"
                           :key="'link-' + groupName + '-' + index"
                           class="list-group-item py-1"
                           :style="groupName ? 'padding-left: 3rem;' : ''">
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" v-model="link.selected"
                               :id="'import-link-' + parsedLinks.indexOf(link)">
                        <div class="ms-2">
                          <div class="d-flex align-items-center">
                            <div class="fw-bold small">{{ link.text || link.url }}</div>
                          </div>
                          <div class="text-muted small text-truncate" style="max-width: 100%;">{{ link.url }}</div>
                          <div v-if="link.keywords && link.keywords.length" class="small">
                            <span v-for="kw in parseKeywords(link.keywords)"
                              :key="kw" class="badge me-1" style="background-color: #e9ecef; color: #212529;">{{ kw }}</span>
                          </div>
                        </div>
                      </div>
                    </label>
                  </div>
                </template>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" @click="confirmPasteAdd" :disabled="!parsedLinks || parsedLinks.filter(l => l.selected).length === 0">
              {{ getTranslation('clipboard.import') || 'Import Selected' }} 
              <span v-if="parsedLinks && parsedLinks.filter(l => l.selected).length > 0">({{ parsedLinks.filter(l => l.selected).length }})</span>
            </button>
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" @click="resetImportDialog">{{ getTranslation('clipboard.cancel') || 'Cancel' }}</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Export Dialog -->
  <div id="exportDialog">
    <div class="modal fade" id="exportModal" tabindex="-1" aria-labelledby="exportModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content mb-modal">
          <div class="modal-header">
            <h5 class="modal-title" id="exportModalLabel">{{ getTranslation('export.title') || 'Export Bookmarks' }}</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div v-if="exportFormat !== 'json'">
              <p class="mb-3">{{ getTranslation('export.selectItems') || 'Select groups and links to export:' }}</p>
              <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="mb-0">{{ getTranslation('export.groups') || 'Groups' }}</h6>
                <div>
                  <button type="button" class="btn btn-sm btn-outline-primary me-1" @click="selectAllExportGroups">
                    {{ getTranslation('export.selectAll') || 'Select All' }}
                  </button>
                  <button type="button" class="btn btn-sm btn-outline-secondary" @click="deselectAllExportGroups">
                    {{ getTranslation('export.deselectAll') || 'Deselect All' }}
                  </button>
                </div>
              </div>
              <div class="border rounded p-2" style="max-height: 400px; overflow-y: auto;">
                <div v-for="(group, gIndex) in exportSelection" :key="'export-g-' + gIndex" class="mb-3">
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" v-model="group.selected" 
                      @change="onExportGroupChange(gIndex)" :id="'export-group-' + gIndex">
                    <label class="form-check-label fw-bold" :for="'export-group-' + gIndex">
                      {{ group.name || 'Untitled Group' }}
                      <span class="text-muted small">({{ group.links.filter(l => l.selected).length }}/{{ group.links.length }})</span>
                    </label>
                  </div>
                  <div class="ms-4 mt-1" v-if="group.links && group.links.length > 0">
                    <div v-for="(link, lIndex) in group.links" :key="'export-l-' + gIndex + '-' + lIndex" 
                      class="form-check form-check-sm">
                      <input class="form-check-input" type="checkbox" v-model="link.selected" 
                        @change="onExportLinkChange(gIndex)" :id="'export-link-' + gIndex + '-' + lIndex">
                      <label class="form-check-label small" :for="'export-link-' + gIndex + '-' + lIndex">
                        {{ link.text || link.url }}
                        <span class="text-muted d-block small text-truncate" style="max-width: 500px;">{{ link.url }}</span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div v-else>
              <p class="mb-2 fw-bold">Full JSON (Preview)</p>
              <textarea class="form-control" rows="12" readonly :value="getFullJsonPreview()"></textarea>
            </div>

            <div class="mt-3">
              <label class="form-label">{{ getTranslation('export.format') || 'Export Format:' }}</label>
              <select class="form-select form-select-sm" v-model="exportFormat">
                <option value="json">JSON (Full)</option>
                <option value="json-array">JSON Array (Links only)</option>
                <option value="csv">CSV</option>
                <option value="html">HTML Bookmarks</option>
              </select>
            </div>
          </div>
          <div class="modal-footer">
            <span v-if="exportFormat !== 'json'" class="me-auto text-muted">
              {{ getExportSelectionCount() }} {{ getTranslation('export.selected') || 'selected' }}
            </span>
            <button type="button" class="btn btn-primary" @click="confirmExport" 
              :disabled="exportFormat !== 'json' && !hasExportSelection()">
              {{ getTranslation('export.export') || 'Export' }}
            </button>
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
              {{ getTranslation('export.cancel') || 'Cancel' }}
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  
  <!-- Unified Generic Edit Dialog -->
  <div class="modal fade" id="genericEditModal" tabindex="-1" aria-labelledby="genericEditModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
      <div class="modal-content mb-modal">
        <div class="modal-header">
          <div class="d-flex align-items-center flex-grow-1">
            <!-- Favicon display for link & group edit dialog -->
            <div v-if="genericEditData && ['link','group'].includes(genericEditConfig.type)" class="me-3 mb-edit-favicon-preview">
              <div v-if="genericEditData.faviconLoading"
                class="link-edit-favicon-loading"
                style="width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">
                <div class="spinner-border spinner-border-sm text-primary" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
              </div>
              <span v-else-if="genericEditData.favicon && !genericEditData.faviconError" class="link-favicon-wrap" :title="faviconSourceTooltip(genericEditData)">
                <img
                  :src="genericEditData.favicon"
                  alt="Favicon"
                  class="link-edit-favicon"
                  style="width: 32px; height: 32px; object-fit: contain; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                <span v-if="genericEditData.faviconSource" class="link-favicon-dot" :class="faviconSourceClass(genericEditData)"></span>
              </span>
              <span v-else-if="genericEditData.emoji"
                class="link-edit-emoji"
                style="font-size: 32px; display: inline-block; width: 32px; height: 32px; line-height: 32px; text-align: center;">
                {{ genericEditData.emoji }}
              </span>
              <span v-else-if="genericEditData.faviconError"
                class="link-edit-favicon-error"
                style="font-size: 24px; display: inline-block; width: 32px; height: 32px; line-height: 32px; text-align: center; opacity: 0.5;"
                :title="getTranslation('favicon.loadError') || 'Favicon konnte nicht geladen werden'">
                ⚠️
              </span>
              <span v-else
                class="link-edit-favicon-placeholder"
                style="display: inline-block; width: 32px; height: 32px; background: #f0f0f0; border-radius: 4px; border: 1px dashed #ccc;">
              </span>
            </div>
            <h5 class="modal-title mb-edit-modal-title mb-0" id="genericEditModalLabel">{{ genericEditConfig.title }}</h5>
          </div>
          <div v-if="genericEditData && ['link','group'].includes(genericEditConfig.type)" class="mb-edit-favicon-actions">
            <button type="button" class="btn btn-sm btn-outline-secondary" @click="$refs.faviconFile && $refs.faviconFile.click()">
              {{ getFaviconText('upload') }}
            </button>
            <button type="button" class="btn btn-sm btn-outline-danger" @click="clearEditedFavicon" :disabled="!genericEditData.favicon && !genericEditData.faviconError">
              {{ getFaviconText('remove') }}
            </button>
            <input ref="faviconFile" type="file" accept="image/*" class="d-none" @change="onFaviconFileSelected">
          </div>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body mb-edit-modal-body">
          <form @submit.prevent="saveGenericEditDialog" v-if="genericEditData" class="mb-edit-form">
            <!-- Filter Input -->
            <div class="mb-3 mb-edit-filter-container">
              <div class="input-group mb-edit-filter-group">
                <span class="input-group-text">
                  <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                  </svg>
                </span>
                <input 
                  type="text" 
                  class="form-control mb-edit-filter-input" 
                  v-model="genericFilterText"
                  placeholder="Filter settings..."
                >
                <button class="btn btn-outline-secondary" type="button" @click="genericFilterText = ''" 
                  v-if="genericFilterText">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M2.5 2.5a.7.7 0 0 1 .99 0L8 7.01l4.51-4.51a.7.7 0 1 1 .99.99L8.99 8l4.51 4.51a.7.7 0 0 1-.99.99L8 8.99l-4.51 4.51a.7.7 0 1 1-.99-.99L7.01 8 2.5 3.49a.7.7 0 0 1 0-.99Z"/>
                  </svg>
                </button>
              </div>
            </div>
            
            <!-- Generic Edit Sections -->
            <div v-for="(section, sectionKey) in getFilteredGenericSettings()" :key="sectionKey" class="options-section mb-edit-section">
              <div 
                class="options-section-header mb-edit-section-header"
                :class="{ collapsed: !isGenericSectionExpanded(sectionKey) }"
                @click="toggleGenericSection(sectionKey)"
              >
                <span>{{ getTranslation(section.translateKey) || sectionKey }}</span>
                <svg class="chevron-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                </svg>
              </div>
              
              <div v-show="isGenericSectionExpanded(sectionKey)" class="options-section-body mb-edit-section-body">
                <div v-for="(field, fieldKey) in section.fields" :key="fieldKey" 
                     :class="['option-row mb-edit-field-row', field.rowClass || '', { 'role-disabled': isFieldDisabled(sectionKey, fieldKey) }]">
                  
                  <!-- Text Field -->
                  <div v-if="field.type === 'text'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                      <span v-if="field.roleScope" :class="['role-badge mb-edit-role-badge', 'role-' + field.roleScope]">
                        {{ getRoleScopeBadgeText(field.roleScope) }}
                      </span>
                    </label>
                    <input 
                      type="text" 
                      class="form-control form-control-sm mb-edit-text-input"
                      :value="getGenericFieldValue(sectionKey, fieldKey)"
                      @input="setGenericFieldValue(sectionKey, fieldKey, $event.target.value)"
                      :placeholder="field.placeholder"
                      :disabled="isFieldDisabled(sectionKey, fieldKey)"
                    >
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>
                  
                  <!-- URL Field -->
                  <div v-else-if="field.type === 'url'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                      <span v-if="field.roleScope" :class="['role-badge', 'role-' + field.roleScope]">
                        {{ getRoleScopeBadgeText(field.roleScope) }}
                      </span>
                    </label>
                    <input 
                      type="url" 
                      class="form-control form-control-sm mb-edit-url-input"
                      :data-autofocus="field.autofocus ? 'true' : null"
                      :data-field="fieldKey"
                      :value="getGenericFieldValue(sectionKey, fieldKey)"
                      @input="setGenericFieldValue(sectionKey, fieldKey, $event.target.value)"
                      :placeholder="field.placeholder"
                      :disabled="isFieldDisabled(sectionKey, fieldKey)"
                    >
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                    <div v-if="genericEditConfig.type === 'link'" class="form-text mb-edit-field-help mb-edit-link-security">
                      <span :class="['badge', linkSecurityBadgeClass(genericEditData, { asPill: true })]" :title="linkSecurityScoreLabel(genericEditData)">
                        {{ linkSecurityScore(genericEditData) }}/100
                      </span>
                      <span>{{ linkSecuritySummary(genericEditData) }}</span>
                    </div>
                  </div>
                  
                  <!-- Number Field -->
                  <div v-else-if="field.type === 'number'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                      <span v-if="field.roleScope" :class="['role-badge', 'role-' + field.roleScope]">
                        {{ getRoleScopeBadgeText(field.roleScope) }}
                      </span>
                    </label>
                    <div class="input-group input-group-sm">
                      <input 
                        type="number" 
                        class="form-control mb-edit-number-input"
                        :value="getGenericFieldValue(sectionKey, fieldKey)"
                        @input="setGenericFieldValue(sectionKey, fieldKey, Number($event.target.value))"
                        :min="field.min"
                        :max="field.max"
                        :step="field.step"
                        :disabled="isFieldDisabled(sectionKey, fieldKey)"
                      >
                      <span v-if="field.suffix" class="input-group-text">{{ getTranslation(field.suffix) || field.suffix }}</span>
                    </div>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>
                  
                  <!-- Checkbox Field -->
                  <div v-else-if="field.type === 'checkbox'">
                    <div class="form-check">
                      <input 
                        type="checkbox" 
                        class="form-check-input mb-edit-checkbox"
                        :id="field.id"
                        :checked="getGenericFieldValue(sectionKey, fieldKey)"
                        @change="setGenericFieldValue(sectionKey, fieldKey, $event.target.checked)"
                      >
                      <label class="form-check-label mb-edit-checkbox-label" :for="field.id">
                        {{ getTranslation(field.translateKey) || fieldKey }}
                        <span v-if="field.roleScope" :class="['role-badge', 'role-' + field.roleScope]">
                          {{ getRoleScopeBadgeText(field.roleScope) }}
                        </span>
                      </label>
                    </div>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>
                  
                  <!-- Select Field -->
                  <div v-else-if="field.type === 'select'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                      <span v-if="field.roleScope" :class="['role-badge', 'role-' + field.roleScope]">
                        {{ getRoleScopeBadgeText(field.roleScope) }}
                      </span>
                    </label>
                    <select 
                      class="form-select form-select-sm mb-edit-select"
                      :value="getGenericFieldValue(sectionKey, fieldKey)"
                      @change="setGenericFieldValue(sectionKey, fieldKey, $event.target.value)"
                    >
                      <option v-for="(optLabel, optValue) in field.values" :key="optValue" :value="optValue">
                        {{ getTranslation(optLabel) || optLabel }}
                      </option>
                    </select>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>
                  
                  <!-- Textarea Field -->
                  <div v-else-if="field.type === 'textarea'">
                    <label class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                      <span v-if="field.roleScope" :class="['role-badge', 'role-' + field.roleScope]">
                        {{ getRoleScopeBadgeText(field.roleScope) }}
                      </span>
                    </label>
                    <textarea
                      class="form-control form-control-sm"
                      :value="getGenericFieldValue(sectionKey, fieldKey)"
                      @input="setGenericFieldValue(sectionKey, fieldKey, $event.target.value)"
                      :placeholder="getTranslation(field.placeholder) || field.placeholder"
                      :rows="field.rows || 3"
                    ></textarea>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>

                  <!-- Link Shorteners Field -->
                  <div v-else-if="field.type === 'linkShorteners'" class="link-shorteners-field">
                    <label class="form-label mb-edit-field-label d-flex justify-content-between align-items-center flex-wrap gap-2">
                      <span>{{ getTranslation(field.translateKey) || fieldKey }}</span>
                      <small class="text-muted">{{ getTranslation('options.linkShorteners.menuHint') }}</small>
                    </label>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                    <div class="list-group link-shorteners-list">
                      <div v-for="service in linkShortenerServices" :key="service.id" class="list-group-item link-shorteners-item">
                        <div class="d-flex flex-column flex-md-row align-items-md-start gap-3">
                          <div class="flex-grow-1">
                            <div class="form-check form-switch mb-2">
                              <input class="form-check-input" type="checkbox" :id="'shortener-toggle-' + service.id"
                                :checked="isShortenerEnabled(service.id, true)"
                                @change="toggleShortenerService(service.id, $event.target.checked)">
                              <label class="form-check-label fw-semibold" :for="'shortener-toggle-' + service.id">
                                {{ service.name }}
                              </label>
                            </div>
                            <div class="small text-muted">{{ getTranslation('options.linkShorteners.summary') }}: {{ getServiceText(service, 'summary') }}</div>
                            <div class="small mt-1">{{ getTranslation('options.linkShorteners.audience') }}: {{ getServiceText(service, 'audience') }}</div>
                            <div class="mt-2" v-if="service.integrations && service.integrations.length">
                              <span class="badge rounded-pill bg-light text-secondary border me-1" v-for="integration in service.integrations" :key="service.id + '-' + integration.name">
                                {{ integration.name }}
                                <span v-if="integration.score !== null && integration.score !== undefined" class="ms-1 text-muted">{{ formatIntegrationScore(integration.score) }}</span>
                              </span>
                            </div>
                          </div>
                          <div class="text-md-end small flex-shrink-0">
                            <span v-if="service.accountRequired" class="badge bg-warning text-dark">{{ getTranslation('options.linkShorteners.requiresAccount') }}</span>
                            <span v-else class="badge bg-success text-white">{{ getTranslation('options.linkShorteners.optionalAccount') }}</span>
                            <div v-if="!isShortenerEnabled(service.id, true)" class="mt-2 text-muted">
                              {{ getTranslation('options.linkShorteners.notEnabled') }}
                            </div>
                          </div>
                        </div>
                        <div class="row g-2 mt-3">
                          <div class="col-md-6">
                            <input type="text" class="form-control form-control-sm"
                              :placeholder="getTranslation('options.linkShorteners.accountLabel')"
                              :value="getShortenerAccount(service.id, true).label"
                              :disabled="!isShortenerEnabled(service.id, true)"
                              @input="updateShortenerAccount(service.id, 'label', $event.target.value)">
                            <div class="form-text" v-if="getTranslation('options.linkShorteners.accountLabel.help')">{{ getTranslation('options.linkShorteners.accountLabel.help') }}</div>
                          </div>
                          <div class="col-md-6">
                            <input type="text" class="form-control form-control-sm"
                              :placeholder="getTranslation('options.linkShorteners.apiKey')"
                              :value="getShortenerAccount(service.id, true).apiKey"
                              :disabled="!isShortenerEnabled(service.id, true)"
                              @input="updateShortenerAccount(service.id, 'apiKey', $event.target.value)">
                            <div class="form-text" v-if="getTranslation('options.linkShorteners.apiKey.help')">{{ getTranslation('options.linkShorteners.apiKey.help') }}</div>
                          </div>
                        </div>
                        <div class="d-flex justify-content-end mt-2">
                          <button type="button" class="btn btn-sm btn-outline-secondary"
                            :disabled="!getShortenerAccount(service.id, true).label && !getShortenerAccount(service.id, true).apiKey"
                            @click="clearShortenerAccount(service.id)">
                            {{ getTranslation('clear') || 'Leeren' }}
                          </button>
                        </div>
                      </div>
                    </div>
                  </div>

                  <!-- Action/Button Field -->
                  <div v-else-if="field.type === 'action'">
                    <label v-if="!field.hideLabel" class="form-label mb-edit-field-label">
                      {{ getTranslation(field.translateKey) || fieldKey }}
                    </label>
                    <div class="d-flex align-items-center justify-content-end">
                      <button type="button" :class="['btn btn-sm', field.buttonClass || 'btn-warning']" @click="handleGenericAction(sectionKey, fieldKey)">
                        {{ getTranslation(field.buttonLabel) || getTranslation(field.translateKey) || 'Run' }}
                      </button>
                    </div>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>

                  <!-- Multiple Actions in one row -->
                  <div v-else-if="field.type === 'actions'">
                    <div class="d-flex justify-content-end gap-2">
                      <button v-for="(action, idx) in field.actions" :key="idx"
                              type="button"
                              :class="['btn btn-sm', action.buttonClass || 'btn-outline-secondary']"
                              @click="handleGenericAction(sectionKey, action.key)">
                        {{ getTranslation(action.buttonLabel) || getTranslation(action.translateKey) || 'Run' }}
                      </button>
                    </div>
                    <div v-if="field.helpText" class="form-text mb-edit-field-help">{{ getTranslation(field.helpText) }}</div>
                  </div>


                </div>
              </div>
            </div>
          </form>
        </div>
        <div class="modal-footer mb-edit-modal-footer">
          <button v-if="genericEditConfig.type === 'options'" type="button" class="btn btn-danger me-auto mb-edit-reset-btn" @click="resetDataFromOptions">
            {{ getTranslation('eraseDatabase') }}
          </button>
          <button type="button" class="btn btn-primary mb-edit-save-btn" @click="saveGenericEditDialog">{{ getTranslation('save') || 'Save' }}</button>
          <button type="button" class="btn btn-secondary mb-edit-cancel-btn" data-bs-dismiss="modal">{{ getTranslation('cancel') || 'Cancel' }}</button>
        </div>
      </div>
    </div>
  </div>

  <!-- NC Folder Picker Modal -->
  <div class="modal fade" id="ncFolderPickerModal" tabindex="-1" aria-labelledby="ncFolderPickerLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="ncFolderPickerLabel">{{ getTranslation('bookmarks.pickFolder') }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="d-flex mb-2">
            <button class="btn btn-sm btn-outline-secondary ms-auto" @click="loadNcFolders">{{ getTranslation('bookmarks.refresh') }}</button>
          </div>
          <div v-if="ncFoldersLoading" class="text-center py-3">Loading…</div>
          <div v-else>
            <div class="list-group">
              <label v-for="f in ncFolders" :key="'f-'+f.id" class="list-group-item d-flex align-items-center" style="cursor: pointer;">
                <input class="form-check-input me-2" type="radio" name="ncFolder" :value="f.id" v-model="ncFolderSelected">
                <span class="flex-grow-1">{{ f.title || ('ID '+f.id) }}</span>
                <small class="text-muted">#{{ f.id }}</small>
              </label>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" :disabled="!ncFolderSelected" @click="applyNcFolderSelection">{{ getTranslation('bookmarks.select') }}</button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{{ getTranslation('cancel') || 'Cancel' }}</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Favicon Rules Modal -->
  <div class="modal fade" id="faviconRulesModal" tabindex="-1" aria-labelledby="faviconRulesLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-centered modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="faviconRulesLabel">{{ getTranslation('favicon.rules.title') || 'Favicon Rules' }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="d-flex align-items-center justify-content-between mb-2">
            <div class="d-flex align-items-center gap-2 flex-wrap">
              <label class="form-label mb-0 me-2">{{ getTranslation('favicon.rules.test') || 'Test URL' }}</label>
              <input class="form-control form-control-sm" style="min-width: 320px;" v-model="faviconRulesTestUrl" placeholder="https://example.com/path">
              <div v-if="faviconRulesTestUrl" class="d-flex align-items-center gap-2">
                <span class="badge bg-secondary">{{ getTranslation('favicon.rules.matchPreview') || 'Matched rule preview' }}</span>
                <img :src="findRuleIconForUrl(faviconRulesTestUrl) || ''" v-if="findRuleIconForUrl(faviconRulesTestUrl)" style="width: 20px; height: 20px; object-fit: contain; border-radius: 3px;">
              </div>
            </div>
            <div class="d-flex align-items-center gap-2">
              <button type="button" class="btn btn-sm btn-outline-primary" @click="addFaviconRule">+ {{ getTranslation('favicon.rules.add') || 'Add rule' }}</button>
              <button type="button" class="btn btn-sm btn-outline-secondary" @click="restoreDefaultFaviconRules">{{ getTranslation('favicon.rules.restoreDefaults') || 'Restore defaults' }}</button>
              <button
                type="button"
                class="btn btn-sm btn-outline-secondary"
                :title="getTranslation('favicon.rules.export') || 'Export rules'"
                :aria-label="getTranslation('favicon.rules.export') || 'Export rules'"
                @click="exportFaviconRules"
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.6a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-2.6a.5.5 0 0 1 1 0v2.6A1.5 1.5 0 0 1 14.5 15h-13A1.5 1.5 0 0 1 0 13v-2.6a.5.5 0 0 1 .5-.5Z"/>
                  <path d="M7.646 11.354a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 9.293V1.5a.5.5 0 0 0-1 0v7.793L5.354 7.646a.5.5 0 1 0-.708.708Z"/>
                </svg>
              </button>
              <button
                type="button"
                class="btn btn-sm btn-outline-secondary"
                :title="getTranslation('favicon.rules.import') || 'Import rules'"
                :aria-label="getTranslation('favicon.rules.import') || 'Import rules'"
                @click="$refs.faviconRulesImport && $refs.faviconRulesImport.click()"
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.6a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-2.6a.5.5 0 0 1 1 0v2.6A1.5 1.5 0 0 1 14.5 15h-13A1.5 1.5 0 0 1 0 13v-2.6a.5.5 0 0 1 .5-.5Z"/>
                  <path d="M8.354 4.646a.5.5 0 0 0-.708 0l-3 3a.5.5 0 0 0 .708.708L7.5 6.707V14.5a.5.5 0 0 0 1 0V6.707l2.146 2.147a.5.5 0 0 0 .708-.708Z"/>
                </svg>
              </button>
              <input ref="faviconRulesImport" type="file" class="d-none" accept="application/json" @change="onImportFaviconRules">
            </div>
          </div>

          <div class="table-responsive">
            <table class="table table-sm align-middle">
              <thead>
                <tr>
                  <th style="width: 70px;">{{ getTranslation('favicon.rules.enabled') || 'Enabled' }}</th>
                  <th style="width: 140px;">{{ getTranslation('favicon.rules.type') || 'Type' }}</th>
                  <th>{{ getTranslation('favicon.rules.pattern') || 'Pattern' }}</th>
                  <th style="width: 110px;">{{ getTranslation('favicon.rules.icon') || 'Icon' }}</th>
                  <th style="width: 220px;">{{ getTranslation('favicon.rules.comment') || 'Comment' }}</th>
                  <th style="width: 200px;"></th>
                </tr>
              </thead>
              <tbody>
                <tr v-if="!faviconRulesWorking.length">
                  <td colspan="6" class="text-center text-muted py-3">{{ getTranslation('favicon.rules.none') || 'No favicon rules yet.' }}</td>
                </tr>
                <tr v-for="(r, ri) in faviconRulesWorking" :key="r.id || ri">
                  <td>
                    <input type="checkbox" class="form-check-input" v-model="r.enabled">
                  </td>
                  <td>
                    <select class="form-select form-select-sm" v-model="r.patternType">
                      <option value="domain">{{ getTranslation('favicon.rules.domain') || 'Domain' }}</option>
                      <option value="prefix">{{ getTranslation('favicon.rules.prefix') || 'URL prefix' }}</option>
                      <option value="regex">{{ getTranslation('favicon.rules.regex') || 'Regex' }}</option>
                    </select>
                  </td>
                  <td>
                    <input class="form-control form-control-sm" v-model="r.pattern" placeholder="e.g. example.com or https://example.com/path">
                  </td>
                  <td>
                    <img v-if="r.iconDataUrl" :src="r.iconDataUrl" style="width: 20px; height: 20px; object-fit: contain; border-radius: 3px;">
                  </td>
                  <td>
                    <input class="form-control form-control-sm" v-model="r.comment" :placeholder="getTranslation('favicon.rules.commentPlaceholder') || 'Optional comment'">
                  </td>
                  <td>
                    <div class="d-flex gap-1 justify-content-end favicon-rule-actions">
                      <button
                        type="button"
                        class="btn btn-sm btn-outline-secondary"
                        :title="getTranslation('favicon.rules.autofetch') || 'Auto-fetch'"
                        :aria-label="getTranslation('favicon.rules.autofetch') || 'Auto-fetch'"
                        @click="autoFetchRuleIcon(r)"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 1.874 5.293 4.311C14.758 4.687 16 6.137 16 7.891 16 9.918 14.355 11.5 12.438 11.5H9.5a.5.5 0 0 1 0-1h2.938C13.94 10.5 15 9.463 15 7.891c0-1.528-1.226-2.637-2.443-2.637h-.5l-.049-.498C12.012 2.826 10.211 1 8 1a4.53 4.53 0 0 0-3.594 1.64l-.342.406-.525-.111C2.784 2.79 2 3.604 2 4.63c0 .65.26 1.216.682 1.59l.356.315-.27.43A3.063 3.063 0 0 0 3.062 11H6.5a.5.5 0 0 1 0 1H3.062c-2.086 0-3.384-2.286-2.288-4.238a2.724 2.724 0 0 1-.532-1.636c0-1.6 1.157-2.862 2.637-3.101A5.53 5.53 0 0 1 4.406 1.342Z"/>
                          <path d="M7.5 5.5a.5.5 0 0 1 1 0v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 0 1 .708-.708L7.5 9.293z"/>
                          <path d="M3.5 15a.5.5 0 0 1 0-1H12a.5.5 0 0 1 0 1H3.5Z"/>
                        </svg>
                      </button>
                      <button
                        type="button"
                        class="btn btn-sm btn-outline-secondary"
                        :title="getTranslation('favicon.rules.upload') || 'Upload'"
                        :aria-label="getTranslation('favicon.rules.upload') || 'Upload'"
                        @click="openFaviconRuleFile(ri)"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.6a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-2.6a.5.5 0 0 1 1 0v2.6A1.5 1.5 0 0 1 14.5 15h-13A1.5 1.5 0 0 1 0 13v-2.6a.5.5 0 0 1 .5-.5Z"/>
                          <path d="m7.646 11.354-3-3a.5.5 0 0 1 .708-.708L7.5 9.793V1.5a.5.5 0 0 1 1 0v8.293l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0Z"/>
                        </svg>
                      </button>
                      <input type="file" class="d-none" ref="frFile" accept="image/*" @change="onFaviconRuleFileSelected(ri, $event)">
                      <button
                        type="button"
                        class="btn btn-sm btn-outline-danger"
                        :title="getTranslation('favicon.rules.delete') || 'Delete'"
                        :aria-label="getTranslation('favicon.rules.delete') || 'Delete'"
                        @click="deleteFaviconRule(ri)"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5Zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5Zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6Z"/>
                          <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1ZM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118Z"/>
                        </svg>
                      </button>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary" @click="saveFaviconRules">{{ getTranslation('save') || 'Save' }}</button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{{ getTranslation('cancel') || 'Cancel' }}</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Duplicates Result Dialog -->
  <div class="modal fade" id="duplicatesModal" tabindex="-1" aria-labelledby="duplicatesModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="duplicatesModalLabel">{{ getTranslation('duplicates.title') || 'Duplicate Links Found' }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div v-if="Object.keys(duplicatesFound).length === 0" class="text-center py-4">
            <p class="text-muted">{{ getTranslation('duplicates.none') }}</p>
          </div>
          <div v-else>
            <p class="mb-3">{{ getTranslation('duplicates.description') || 'The following links appear in multiple groups:' }}</p>
            
            <!-- Duplicates list -->
            <div v-for="(duplicateGroup, url) in duplicatesFound" :key="url" class="card mb-3">
              <div class="card-header">
                <div class="d-flex align-items-center justify-content-between">
                  <div class="text-truncate" style="max-width: 70%;">
                    <strong>{{ duplicateGroup[0].link.text }}</strong>
                    <br>
                    <small class="text-muted text-truncate d-block">{{ url }}</small>
                  </div>
                  <span class="badge bg-warning text-dark">
                    {{ duplicateGroup.length }} {{ getTranslation('duplicates.copies') || 'copies' }}
                  </span>
                </div>
              </div>
              <div class="card-body">
                <div class="list-group list-group-flush">
                  <div v-for="(item, index) in duplicateGroup" :key="index" 
                       class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                      <span class="badge">
                        {{ item.group.name }}
                      </span>
                      <span v-if="!item.selected" class="badge bg-success ms-2">
                        {{ getTranslation('duplicates.keep') || 'Keep' }}
                      </span>
                      <span v-else class="badge bg-danger ms-2">
                        {{ getTranslation('duplicates.remove') || 'Remove' }}
                      </span>
                    </div>
                    <div class="form-check">
                      <input class="form-check-input" type="checkbox" 
                             :id="'dup-' + url + '-' + index"
                             :checked="item.selected"
                             @change="toggleDuplicateSelection(url, index)">
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="alert alert-info">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-info-circle me-2" viewBox="0 0 16 16">
                <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                <path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
              </svg>
              {{ getTranslation('duplicates.info') || 'Unchecked items will be kept, checked items will be removed.' }}
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
            {{ getTranslation('cancel') || 'Cancel' }}
          </button>
          <button type="button" class="btn btn-danger" @click="removeDuplicates" 
                  :disabled="Object.keys(duplicatesFound).length === 0">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash me-2" viewBox="0 0 16 16">
              <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
              <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
            </svg>
            {{ getTranslation('duplicates.removeSelected') || 'Remove Selected Duplicates' }}
          </button>
        </div>
      </div>
    </div>
  </div>

  
  <!-- Info popup for HTML content -->
  <div id="infoPopup" class="info-popup" v-html="infoPopupContent"></div>

  <!-- Link detail popover -->
  <div v-if="linkPopover.visible"
       class="link-detail-popover"
       :style="linkPopover.style"
       @mouseenter="cancelHideLinkPopover()"
       @mouseleave="hideLinkPopover()">
    <div class="link-detail-popover__title">
      <img v-if="linkPopover.favicon" :src="linkPopover.favicon" alt="" class="link-detail-popover__favicon">
      <span v-if="linkPopover.emoji" class="link-detail-popover__title-emoji">{{ linkPopover.emoji }}</span>
      <span v-html="linkPopover.titleHtml"></span>
    </div>

    <a v-if="linkPopover.url"
       :href="linkPopover.url"
       class="link-detail-popover__url"
       target="_blank"
       rel="noopener noreferrer">
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
        <path d="M6.354 11.354a.5.5 0 0 0 .707-.708L4.707 8l2.354-2.646a.5.5 0 1 0-.707-.708l-2.5 2.812a.5.5 0 0 0 0 .696z"/>
        <path d="M9.5 11a.5.5 0 0 0 0-1H3.707l2.147-2.417a.5.5 0 1 0-.708-.706l-3 3.375a.5.5 0 0 0 0 .706l3 3.375a.5.5 0 0 0 .708-.706L3.707 11z"/>
        <path d="M12.5 3a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-.5a.5.5 0 0 0-1 0V12a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7a2 2 0 0 0-2 2v.5a.5.5 0 0 0 1 0V4a1 1 0 0 1 1-1z"/>
      </svg>
      <span>{{ linkPopover.displayUrl }}</span>
    </a>

    <div v-else class="link-detail-popover__meta">
      <div class="link-detail-popover__row">
        <span class="link-detail-popover__label">{{ getTranslation('link.popover.url') || 'URL' }}</span>
        <span class="link-detail-popover__value text-muted">{{ getTranslation('link.popover.noUrl') || 'No URL available' }}</span>
      </div>
    </div>

    <div class="link-detail-popover__meta">
      <div class="link-detail-popover__row">
        <span class="link-detail-popover__label">{{ getTranslation('link.popover.created') || 'Created' }}</span>
        <span class="link-detail-popover__value">
          <span>{{ linkPopover.createdAt.full }}</span>
          <span v-if="linkPopover.createdAt.relative" class="link-detail-popover__value--muted">({{ linkPopover.createdAt.relative }})</span>
        </span>
      </div>
      <div class="link-detail-popover__row">
        <span class="link-detail-popover__label">{{ getTranslation('link.popover.updated') || 'Updated' }}</span>
        <span class="link-detail-popover__value">
          <span>{{ linkPopover.updatedAt.full }}</span>
          <span v-if="linkPopover.updatedAt.relative" class="link-detail-popover__value--muted">({{ linkPopover.updatedAt.relative }})</span>
        </span>
      </div>
      <div v-if="linkPopover.rawUrlInput" class="link-detail-popover__row">
        <span class="link-detail-popover__label">{{ getTranslation('link.popover.originalUrl') || 'Original Input' }}</span>
        <span class="link-detail-popover__value">{{ linkPopover.rawUrlInput }}</span>
      </div>
      <div v-if="linkPopover.uuid" class="link-detail-popover__row">
        <span class="link-detail-popover__label">UUID</span>
        <span class="link-detail-popover__value">{{ linkPopover.uuid }}</span>
      </div>
    </div>

    <div v-if="linkPopover.keywords && linkPopover.keywords.length" class="link-detail-popover__keywords">
      <span v-for="kw in linkPopover.keywords"
            :key="'link-popover-kw-' + kw"
            class="link-detail-popover__badge">{{ kw }}</span>
    </div>
  </div>
  
  <!-- Conflict Resolution Notifications -->
  <transition name="fade">
    <div v-if="false && showConflictNotification" class="conflict-notification">
      <div class="conflict-notification-title">
        {{ getTranslation('sync.conflictResolved') || 'Sync Conflict Resolved' }}
      </div>
      <div class="conflict-notification-text">
        {{ conflictNotificationText }}
      </div>
    </div>
  </transition>
  
  </div> <!-- /#app -->

  <footer id="footer" class="copyrightBar mb-footer">
    <span>&copy; 2024-2025 <a href="mailto:mybookmarks@msging.de">Jörg Pannbacker</a>. Check for <a href="https://github.com/akdk7/mybookmarks" target="_blank">new version</a>. Version: {{ version }}</span>
  </footer>
  <script>
    // Should be placed inside the <script type="module"> where 'app' is defined,
    // or defined separately and imported if using a module system.
    // Innerhalb deines <script type="module">

    // Debug logging utility
    const DEBUG_ENABLED = true; // Set to true to enable debug logging
    
    function debugLog(level, ...args) {
      if (!DEBUG_ENABLED) return;
      
      const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
      const prefix = `[${timestamp}] [${level.toUpperCase()}]`;
      
      switch(level) {
        case 'log':
          console.log(prefix, ...args);
          break;
        case 'warn':
          console.warn(prefix, ...args);
          break;
        case 'error':
          console.error(prefix, ...args);
          break;
        default:
          console.log(prefix, ...args);
      }
    }

    // Centralized constants used across features
const CONSTS = {
  MINUTE_MS: 60000,
      BACKOFF_MAX_MS: 30000,
      // Keep small to avoid ntfy turning messages into attachments over SSE
      NTFY_CHUNK_SIZE: 2000,
      MAX_CONCURRENT_TRANSFERS: 32,
      MAX_TRANSFER_SIZE: 8 * 1024 * 1024, // 8 MB safety cap for chunked transfers

      // Progressive Loading & Display
      PROGRESSIVE_LOADING_THRESHOLD: 100, // Default number of links to show initially
      EXPANDED_LINK_LIMIT: 500, // Number of links to show when expanded
      PAGE_SIZE: 200, // Default page size for pagination
      INITIAL_LIMIT: 200, // Initial display limit

      // Event Log
      EVENT_LOG_MAX_EVENTS: 500, // Maximum events to keep in log
      EVENT_LOG_SNAPSHOT_INTERVAL: 50, // Create snapshot every N events

      // Sharing & Sync
      QUICK_CODE_TTL_SEC: 180, // Quick share code expiration (3 minutes)
      CONTACT_ONLINE_TIMEOUT_SEC: 30, // Contact online status timeout
      DEFAULT_NTFY_TTL: undefined, // Default NTFY message TTL

      // UI Delays & Timeouts
      HOVER_EXPAND_DELAY_MS: 1000, // Delay before expanding on hover
      FOCUS_DELAY_SHORT_MS: 300, // Short focus delay
      FOCUS_DELAY_MEDIUM_MS: 500, // Medium focus delay
      FOCUS_DELAY_LONG_MS: 700, // Long focus delay
      UI_UPDATE_DELAY_MS: 100, // General UI update delay
      NETWORK_DELAY_MS: 200, // Network operation delay

      // Storage Keys
      STORAGE_KEY_LINKS: 'links',
      STORAGE_KEY_DARK_MODE: 'darkMode',
      STORAGE_KEY_CUSTOM_COLORS: 'customColors',
      STORAGE_KEY_SIDEBAR_HEIGHT: 'sidebarTopHeight',
      STORAGE_KEY_CSS_SIDEBAR_WIDTH: 'cssSidebarWidth',
      STORAGE_KEY_CSS_SIDEBAR_HEIGHT: 'cssSidebarTopHeight',

      // Defaults
      VERSION_FALLBACK: 0, // Default version for unversioned data
      DEFAULT_GROUP_COLUMNS: 1, // Default number of columns in a group
      DEFAULT_STORAGE_WARNING_MB: 4, // Show warning at 4MB localStorage usage
      MAX_STORAGE_MB: 5, // Maximum localStorage size (browser limit)

  DEFAULT_URL_PREFIX: 'http://'
};

const DEFAULT_FAVICON_RULES = Object.freeze([
  {
    id: 'preset-google',
    enabled: true,
    patternType: 'regex',
    pattern: '(?:www\\.)?google\\.',
    iconDataUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsSAAALEgHS3X78AAAE3ElEQVRYhc2XW2xUVRSGv30uU9rTMhUaCuVixQSMpLYmPIhYwAcTIyKFROI1KQmkxBgj8UEf5MEYiSYmPvhAfCASY02MUaFEHjSRQYtGNDAqIhKxQJVeodPLMJ2Zc/by4cz91tZ4+5Od2Wf2Xuv/z9lrr722EhFmiTagA9gEbCwz5wQQAg4D4Vl5FZGZWqeIhGXuCKdsK/qvNNgsIqG/QFyIUMrXnAR0iEjkbyBPI5LyWcSlpDgGOoG3S67XV71wshd+CMPwEAiAAShoXIy0tsL6dtS6u8qt+E7gUO4fhQI6gI+LzM6ehjf2w9AQJC1QgCi/KRMwQZmIYSLKRBYvwXj2KVTLmlIituEHaZGAZvzIDeZN/+BVOPwhTAX850QgS44CZWWaoBDTRgzbd77lfoxdTxYKGMffUZfA/35pHCoif+8F+Pxdvx/wSr1NPpSR/3z2HERvFM4KkrMMaYtOCvf2p8/A5W5ouAHz4+AkoDoJpguGB6QEpT6GAKJUVsstKzBe2QdOTSmpG1OcmSUIA62Z4eEeCD0BV+pgnoahOhhwwBCwVsL23bCuHZxaf340Cl9/g+5+H0YjcOvKSuRpfA+0KRFpA87kDX2xCgYHIWpDNOALmLLhju2w4/kscSGiUeTIMdTWzTORp3GnhR/5WYwdhUA/NBhQKzDtQZUHddvhkZcru3Mc1GMPz4Y4jQ4LP7dnETkK8wywACVgu2DUwQOvzcXxbLHJojD4pnuz/WoBF1j2KATyN0ga310p41pAkc0xCqEpqFhcr3JnbbSK7OJ9oAyUpcAEAsDSLWVfYXd3OQGFGVaxpx262vP/Ldi4KelCZk+LoWDeirICykKpbEs/l0CRABGd7aeMhNLGcxJTxk/xFxAN4uJpl6R4TIuLG79U0b+gEbxU06TSUqpVRlEMEGhGJy4zJRpLmVzXHtWRIzTUbSjpoOueNInK++35EQbGZ+THwi+jMjtB17bjXesDDKLaT7f9I+9Q37QPy6wvcrCnXeWQ+5ichu5v08IkM7725iLzEwZ+DZeB1G9lVAv9nseg1vziac7EJ/nk1z0zv04KB89EGXVjRO0pkkYCVyVJGgnWFsdyyCDnbAaw6zsYtldwUQtXtTCshUEx+HL0Mw5e2MuUO1mR/MBPf7A//DvjNcNMVI8QC0zhGR4PtZQM5MMlD6OJiRDHz91LRBTjYtAnDtd1DWPikAi0squ5i/sa1hO0nIynnoGLvHn+Ar0DMQKx5VhuNbZbg5MIYno2x3fXsTSYJyJzGEGJMizUt5fjVw8wLjaXJciEOEyKw5DXSJwASapI6lpqzflEkh6SDEJ8CYiJii3HdB0CroMdX0BXy0Je2lAUPzuBQ7kVUYiCtNx9oYuPhnoYkIV4YjGmb2JSGnBReFKFxsbVVSgE8Rz09BJQGuJNWLEmPMOlrXYZJ7fdXkh+gtQZlJsHOvHLpQweX/UWmxp3ABCXQHZAzEzXUG6mr6yJTN+1x3lw+SKObV5dSD6e4vJtZlOUnoqc5rmfX+e32AQxCSIYCCag0NryT01dhXjVSHIBtbKUF29bx9OrVxW6ggpFaRqdlCnLj42c4uhImN6x8/RPXwMUIgYKYb5Zz93BNrY0ruHBRS0E7apSLorK8v/8YvK/vZr9a5fTUjFQDv/I9fxPxUx0d1WRkbMAAAAASUVORK5CYII=',
    comment: 'Standard-Favicon Google'
  },
  {
    id: 'preset-youtube',
    enabled: true,
    patternType: 'domain',
    pattern: 'youtube.com',
    iconDataUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAACklpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAAEiJnVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/stRzjPAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAJcEhZcwAACxMAAAsTAQCanBgAAAGvSURBVFiF7de/jwxhAMbxzzu5OO5uSYSN36GQSzRyt9GJRqFhV+EPEJQKlWhUEqIQ0YqcQqJxxQURjYLa7EUi5Cj8KBQbDXvWnmJHMTMKIbGzmx3FPcnkfTOZ532+xfvOPBOSJFGmolLTVwH+B4CQTxK1cRzFLHajigoms3FD9nzA+r+s9xUJetm8jW/Z2MJ7NPEwiFd+ASRq+7GQBY9CH9AI4hchUVuHN9gxovBcHzEd4XgJ4bAL9QgHSgjPdTDCvhIB9kbY3pelupHTDaKhnOCtETb1ZZlYy62LPL/DodlBAaoRpgpZZ6Z5epN7V9mzrSjAVHGAXCcO83qeK2epTPTrrgznVTy+hgsnebvAqXpf+6P0b8HYUFZZ+cH1u1yeo93pG2DZIPtg/gnnb/DuUxF3uzjA4hLnrvGsWSQ41/IYPmPLP1s6Xc5c4vYDer1BwqEVErXHODLoSgX1KMKrksLhZYS4RIBmXkiWsHPE4WkhCeLvOCbta6MMrwdx9/dS2sCMtBtulpbPyezKS2kkLal/Ul5KE3yRHvFOdr8l7YKLuB/EXQirv2arAGUD/ASKFWPTtIUJ1AAAAABJRU5ErkJggg==',
    comment: 'Standard-Favicon Youtube'
  },
  {
    id: 'preset-github',
    enabled: true,
    patternType: 'domain',
    pattern: 'github.com',
    iconDataUrl: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNiAwQzcuMTYgMCAwIDcuMTYgMCAxNkMwIDIzLjA4IDQuNTggMjkuMDYgMTAuOTQgMzEuMThDMTEuNzQgMzEuMzIgMTIuMDQgMzAuODQgMTIuMDQgMzAuNDJDMTIuMDQgMzAuMDQgMTIuMDIgMjguNzggMTIuMDIgMjcuNDRDOCAyOC4xOCA2Ljk2IDI2LjQ2IDYuNjQgMjUuNTZDNi40NiAyNS4xIDUuNjggMjMuNjggNSAyMy4zQzQuNDQgMjMgMy42NCAyMi4yNiA0Ljk4IDIyLjI0QzYuMjQgMjIuMjIgNy4xNCAyMy40IDcuNDQgMjMuODhDOC44OCAyNi4zIDExLjE4IDI1LjYyIDEyLjEgMjUuMkMxMi4yNCAyNC4xNiAxMi42NiAyMy40NiAxMy4xMiAyMy4wNkM5LjU2IDIyLjY2IDUuODQgMjEuMjggNS44NCAxNS4xNkM1Ljg0IDEzLjQyIDYuNDYgMTEuOTggNy40OCAxMC44NkM3LjMyIDEwLjQ2IDYuNzYgOC44MiA3LjY0IDYuNjJDNy42NCA2LjYyIDguOTggNi4yIDEyLjA0IDguMjZDMTMuMzIgNy45IDE0LjY4IDcuNzIgMTYuMDQgNy43MkMxNy40IDcuNzIgMTguNzYgNy45IDIwLjA0IDguMjZDMjMuMSA2LjE4IDI0LjQ0IDYuNjIgMjQuNDQgNi42MkMyNS4zMiA4LjgyIDI0Ljc2IDEwLjQ2IDI0LjYgMTAuODZDMjUuNjIgMTEuOTggMjYuMjQgMTMuNCAyNi4yNCAxNS4xNkMyNi4yNCAyMS4zIDIyLjUgMjIuNjYgMTguOTQgMjMuMDZDMTkuNTIgMjMuNTYgMjAuMDIgMjQuNTIgMjAuMDIgMjYuMDJDMjAuMDIgMjguMTYgMjAgMjkuODggMjAgMzAuNDJDMjAgMzAuODQgMjAuMyAzMS4zNCAyMS4xIDMxLjE4QzI3LjQyIDI5LjA2IDMyIDIzLjA2IDMyIDE2QzMyIDcuMTYgMjQuODQgMCAxNiAwVjBaIiBmaWxsPSIjMjQyOTJFIi8+Cjwvc3ZnPgo=',
    comment: 'Standard-Favicon Github'
  },
  {
    id: 'preset-wikipedia',
    enabled: true,
    patternType: 'domain',
    pattern: 'wikipedia.org',
    iconDataUrl: 'data:image/svg+xml;base64,AAABAAMAMDAQAAEABABoBgAANgAAACAgEAABAAQA6AIAAJ4GAAAQEBAAAQAEACgBAACGCQAAKAAAADAAAABgAAAAAQAEAAAAAAAABgAAAAAAAAAAAAAQAAAAAAAAAAEBAQAXFxcAMDAwAEdHRwBYWFgAZ2dnAHZ2dgCHh4cAlZWVAKmpqQC3t7cAx8fHANfX1wDo6OgA/v7+AAAAAAD////+7u7u7u7u7u7u7u7u7u7u7u///////+7u7u7u7u7u7u7u7u7u7u7u7u7u/////u7u7u7u7u7u7u7u7u7u7u7u7u7u7///7u7u7u7u7u7u7u7u7u7u7u7u7u7u7v/+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u/+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u/+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u/u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7sa+7u7u7u1b7u7u7u7u7u7u7u7u7u7u7p9u7u7u7ugG7u7u7u7u7u7u7u7u7u7u7TAa7u7u7tQBzu7u7u7u7u7u7u7u7u7u6wAF7u7u7pAAju7u7u7u7u7u7u7u7u7u1AAAru7u7U//Le7u7u7u7u7u7u7u7u7uz/8RPe7u6gAB+e7u7u7u7u7u7u7u7u7ubw94Ce7u1QAIIu7u7u7u7u7u7u7u7u7tH/G+Mt7usAAtcL7u7u7u7u7u7u7u7u7n8ATun47uQACO0T7u7u7u7u7u7u7u7u7hDxnu4x3sAPLO5Qzu7u7u7u7u7u7u7u6P/z7u6wXk/wfu7ATu7u7u7u7u7u7u7u4QAY7u7kCQADzu7kDO7u7u7u7u7u7u7uoA8u7u7sAAAG7u7r9e7u7u7u7u7u7u7uIPB+7u7uUAAs7u7uMd7u7u7u7u7u7u7rEAHe7u7uQABu7u7un37u7u7u7u7u7u7kAAXu7u7sAPHe7u7u4S3u7u7u7u7u7u7BAA3u7u7k8AHO7u7u6Aju7u7u7u7u7u5g/07u7u7B8BBe7u7u7RLu7u7u7u7u7u0v/87u7u5QAGQa7u7u7nCe7u7u7u7u7ugAA+7u7uwQ8dsE7u7u7rBO7u7u7u7u7tP/++7u7uYAB+5Qnu7u7tQa7u7u7u7u7pH/Lu7u7sLwHe6xPe7u7ur27u7u7u7u7V//ru7u7mAAju7n+e7u7u0yvu7u7u7u6h8C3u7u6yAB3u7rEs7u7u6Pfu7u7u7u1AAE7u7u5g/27u7tQG3u7u6QHO7u7u7tbwAB3u7ukfAH7u7sIAju7u5wA97u7utiAAAAF76lAA/wWeyDAA84zqUAABfO7uMiNERDIm4iNERDIrkiNEQybiI0RDJO7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u/+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u/+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u//7u7u7u7u7u7u7u7u7u7u7u7u7u7u7v///u7u7u7u7u7u7u7u7u7u7u7u7u7u7////+7u7u7u7u7u7u7u7u7u7u7u7u7u///////+7u7u7u7u7u7u7u7u7u7u7u/////+AAAAAH8AAPAAAAAADwAA4AAAAAAHAADAAAAAAAMAAIAAAAAAAQAAgAAAAAABAACAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAABAACAAAAAAAEAAIAAAAAAAQAAwAAAAAADAADgAAAAAAcAAPAAAAAADwAA/gAAAAB/AAAoAAAAIAAAAEAAAAABAAQAAAAAAIACAAAAAAAAAAAAABAAAAAAAAAAAQEBABYWFgAnJycANTU1AEdHRwBZWVkAZWVlAHh4eACIiIgAmZmZAK6urgDMzMwA19fXAOnp6QD+/v4AAAAAAP//7u7u7u7u7u7u7u7u////7u7u7u7u7u7u7u7u7u7//u7u7u7u7u7u7u7u7u7u7/7u7u7u7u7u7u7u7u7u7u/u7u7u7u7u7u7u7u7u7u7u7u7u7u7X3u7u7I7u7u7u7u7u7u7uYF7u7uIK7u7u7u7u7u7u7QAM7u6vBO7u7u7u7u7u7ucABe7uMA/O7u7u7u7u7u7R8q/O6gCEbu7u7u7u7u7ukAnibuTx6g3u7u7u7u7u7hAe6gzP+O4Y7u7u7u7u7urwju4mXx7uge7u7u7u7u7jAd7uoACO7tCe7u7u7u7uoPfu7uEB3u7mPu7u7u7u7k8N7u7QBu7u6wru7u7u7uwAXu7ufwbu7u407u7u7u7lAM7u7RBQzu7ur87u7u7u0ATu7ucA0l7u7uFu7u7u7n/67u7RB+oL7u7nHe7u7u0fPu7ucA3uJO7u7Qju7u7o/67u7Q9u7q+u7u5R3u7u0Q/e7ub/vu7PLO7uX13u4w//Be4v/xnoH/+ekv//Xu7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7+7u7u7u7u7u7u7u7u7u7v/u7u7u7u7u7u7u7u7u7u7//u7u7u7u7u7u7u7u7u7v///+7u7u7u7u7u7u7u7v//8AAAD8AAAAOAAAABgAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAGAAAABwAAAA/AAAA8oAAAAEAAAACAAAAABAAQAAAAAAMAAAAAAAAAAAAAAABAAAAAAAAAAAQEBABcXFwAnJycAOzs7AElJSQBpaWkAeXl5AIaGhgCVlZUApqamALOzswDMzMwA2dnZAObm5gD+/v4AAAAAAP/u7u7u7u7//u7u7u7u7u/u7uzu7t7u7u7u4Y7lTu7u7u6QTtA77u7u7iaoctXu7u7qDOQZ5d7u7uRO5R7rbu7uv77iLu5O7u5D7pGn7pju7QrtKOTe4+6z+OT40z2RTO7u7u7u7u7u7u7u7u7u7u7+7u7u7u7u7//u7u7u7u7/wAMAD4ABAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAQAPwAMADw==',
    comment: 'Standard-Favicon Wikipedia'
  },
  {
    id: 'preset-amazon',
    enabled: true,
    patternType: 'regex',
    pattern: '(?:www\\.)?amazon\\.',
    iconDataUrl: 'data:image/svg+xml;base64,AAABAAQAMDAAAAEAIACoJQAARgAAACAgAAABACAAqBAAAO4lAAAYGAAAAQAgAIgJAACWNgAAEBAAAAEAIABoBAAAHkAAACgAAAAwAAAAYAAAAAEAIAAAAAAAgCUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///0X///+Z////zP////P////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////w////zP///5P///8/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8k////wP//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////t////x4AAAAAAAAAAAAAAAAAAAAAAAAAAP///0L////z///////////////////////////////////////////////////////////////////////////X7///u+T//5DV//+R1f//csr//1C+//+Cz///kdX//5/Z///L6v//8vr//////////////////////////////////////////////////////////////////////////////////////+3///85AAAAAAAAAAAAAAAA////Lf////D///////////////////////////////////////////////////////////////+85f//csr//xOt//8AqP//AKj//wCn//8Ap///AKf+/wCn//8AqP//AKf//wCn//8Ap///AKj//z64//+Q1f//2PD////////////////////////////////////////////////////////////////////////////q////JAAAAAAAAAAA////zP/////////////////////////////////////////////////////y+v//kNX//xOs//8Ap///AKf//wCo//8Ap///AKf//wCo//8AqP//AKf//wCn/v8Ap///AKj//wCn//8AqP//AKf//wCn//8Ap///AKf//z64//+u4P//////////////////////////////////////////////////////////////////////vQAAAAD///9R////////////////////////////////////////////////8vr//5HV//8TrP//AKj//wCo//8AqP//AKj//wCo//8Ap///AKf//wCn//8AqP//AKf//wCo//8AqP//AKj//wCn//8Ap/7/AKf//wCo//8AqP//AKf//wCo//8Ap///KbL//67g////////////////////////5fT//////////////////////////////////////0L///+l//////////////////////////////////////////+75P//E63//wCn//8Ap///AKf//wCn/v8AqP//AKf//wCo//8psv//UL///4LQ//+R1f//kNX//5DV//+Q1f//kNX//5HV//9hw///UL7//wCo//8Ap/7/AKj//wCn//8Ap///AKj//wCn//9Qvv//5vX/////////////Ub///5DV/////////////////////////////////5b////q////////////////////////////////8vr//3LK//8AqP//AKf//wCn//8AqP//AKj//1C///+R1f//y+r////////////////////////////////////////////////////////////////////////Y7///rd///3LJ//8Trf//AKf+/wCn//8AqP//E63//7zl////////n9r//wCo///l9P///////////////////////////9v////////////////////////////////Y7///Prj//wCn//8Ap///AKf+/1C+//+t3///8vr/////////////////////////////////////////////////////////////////////////////////////////////////////////////vOX//3LK//8Ap///AKf//wCo//+t3///2O///wCn//9zyv////////////////////////////n//////////////////////////9jw//8Trf//AKf//wCn//9yyf//5fT////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////y+v//kNX//xOt//9hw////////xOt//8Trf//////////////////////////////////////////////////u+T//xOt//8AqP//csn//+X0/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1G///8Ap///5vX////////////////////////////////////////Y7///AKj//1C+///l9f///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9jv//8Ap///Ub///2HD//+Q1f//csr//wCn//8Ap///y+r////////////////////////////////////////Y8P//ruD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////L6v//YsP//wCn//8Ap///AKj//wCo//8Ap///2PD///////////////////////////////////////////////////////////////////////////////////////////////////Pz8/+ioqL/VlZU/x0dG/8FBQT/BQUD/x0dHP9WVlX/hoaE/9jY2P////////////////////////////////++vr7/VlZV/6Kiov/////////////////////////////////K6f//yun//8rq///l9P//////////////////////////////////////////////////////////////////////////////////////////////////oqKi/x0dHP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/wUFBP9WVlT/5ubm/////////////////7Cwr/8FBQT/BQUE/wUFBP92dnb///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+GhoX/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wQEA/8FBQT/BQUD/wUFA/8FBQT/HR0c/7Cwr///////2dnZ/wUFBP8FBQT/BQUE/wUFBP8FBQT/Z2dm//Ly8v///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////729vf8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQP/BQUD/wUFBP8FBQT/BQUE/wUFBP+ioqL/MjIw/wUFBP8FBQT/BQUD/wUFA/8FBQT/BQUE/0REQ//y8vL//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////zExMP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8dHRv/////////////////////////////////////////////////////////////////////////////////////////////////////////////////2dnZ/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8dHRz/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQP/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8yMjD/////////////////////////////////////////////////////////////////////////////////////////////////////////////////lJST/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/HR0c/8zMzP///////////8zMzP8xMTD/BQUE/wUFBP8FBQT/BQUD/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP/MzMz/////////////////////////////////////////////////////////////////////////////////////////////////////////////////hoaF/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/zMzM///////////////////////y8vL/HR0c/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/4aGhP//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VlZV/wUFBP8EBAP/BQUD/wUFA/8FBQT/BQUE/wUFBP9FRUT/////////////////////////////////sLCv/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/+Xl5f//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////ZmZl/wUFA/8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP9VVVT//////////////////////////////////////zExMP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZV////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////lJST/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP9WVlX//////////////////////////////////////3Z2dv8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZV////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////sbGw/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8dHRz//////////////////////////////////////5SUk/8FBQP/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQT/VlZU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8vLy/wUFA/8FBQP/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQT/oqKi/////////////////////////////////5SUk/8FBQP/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQP/VlZV/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////3Z2dv8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/HR0c/729vf///////////////////////////83Nzf8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZV/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+bm5v8dHRz/BQUD/wUFA/8FBQT/BQUE/wUFBP8EBAP/BQUE/wUFBP9WVlX/vb29//Pz8////////////83Nzf8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/VlZV//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////++vr7/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZU/0REQ/8FBQT/BQUE/wUFBP8FBQP/BQUE/wUFBP8FBQT/VVVU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////zMzM/x0dG/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQP/VVVU//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Ly8v92dnb/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZV////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////5ubm/6Kiov9VVVT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/VlZV/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9nZ2f/MzMz/lJST/5SUk/9WVlT/VlZV/zExMP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VlZV/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8zMzP8FBQP/BQUE/wUFA/8FBQT/BAQD/wUFBP8FBQT/VlZV////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8/Pz/8zMzP/MzMz/lJST/5SUk//Z2dn//////////////////////////////////////76+vv8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/VlZV/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////5WVk/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP9nZ2b//////////////////////////////////////5SUk/8FBQT/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQT/dnZ2/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1ZWVP8FBQT/BQUE/wUFBP8FBQT/BQUD/wUFA/8dHRz/8/Pz/////////////////////////////////3Z2dv8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/lJST/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////6Ghof8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/dnZ2////////////////////////////2dnZ/x0dHP8FBQT/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/lJST/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+bm5v8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/BAQD/zExMP+xsbD/zMzM/8zMzP+UlJP/HR0c/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/zMzM//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////92dnb/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8dHRv///////////////////////////////////////////////////////////////////////////n////t///////////////////////////////////////////////////////////m5ub/Hh4c/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wQEA/8FBQP/BQUD/wUFBP+UlJP//////////////////////////////////////////////////////////////////////////97///+o////////////////////////////////////////////////////////////////2dnZ/x0dG/8FBQT/BQUE/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQP/BQUE/0VFRP/z8/P//////////////////////////////////////////////////////////////////////////5b///9U/////////////////////////////////////////////////////////////////////9nZ2f8xMTD/BQUE/wUFBP8FBQP/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/VVVU//Ly8v///////////////////////////////////////////////////////////////////////////////0L///8D////z///////////////////////////////////////////////////////////////////////////lZWU/zExMP8FBQT/BQUD/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/BQUD/zExMP+xsbD/////////////////////////////////////////////////////////////////////////////////////wwAAAAAAAAAA////MP////b////////////////////////////////////////////////////////////////////////////////Z2dn/lJST/1ZWVf9WVlX/BAQD/wUFBP8FBQT/RUVD/1ZWVf+UlJP/zMzM///////////////////////////////////////////////////////////////////////////////////////////w////JwAAAAAAAAAAAAAAAP///0v////z//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////D///8/AAAAAAAAAAAAAAAAAAAAAAAAAAD///8t////yf//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////w////yQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///0v///+f////z///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////zP///5n///9FAAAAAAAAAAAAAAAAAAAAAAAAAAD4AAAAAB8AAOAAAAAABwAAwAAAAAADAACAAAAAAAEAAIAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAgAAAAAABAADAAAAAAAMAAOAAAAAABwAA+AAAAAAfAAAoAAAAIAAAAEAAAAABACAAAAAAAIAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////Uf///5/////S///////////////////////////////////////////////////////////////////////////////////////////////////////////////P////nP///0gAAAAAAAAAAAAAAAAAAAAA////GP///7H//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////6X///8SAAAAAP///wb////P////////////////////////////////////////////////5fX//67g//+R1f//UL7//1C+//9Rv///YsT//5DU//+85f//8vr//////////////////////////////////////////////////////8P///8D////df//////////////////////////////////////////ruD//z24//8AqP//AKf//wCo//8Ap///AKj//wCo//8Ap/7/AKf//wCn//8AqP//csr//8vq/////////////////////////////////////////////////2b////S////////////////////////////////y+r//ymy//8Ap///AKj//wCo//8Ap///AKf//wCn//8Ap///AKj//wCn//8Ap///AKj//wCo//8AqP//AKj//1C////Y8P///////8rq///Y7///////////////////////w/////z/////////////////////8vr//3LJ//8AqP//AKf//wCn/v9ixP//kNT//8vq///y+v////////////////////////L6///L6v//n9r//2LE//8Trf//AKf//wCo//+u4P//vOX//z65///////////////////////w//////////////////////L6//8+uP//AKf//1C+//+t3///8/r///////////////////////////////////////////////////////////////////////+85f//UL7//wCo///Y7///AKf//8rp///////////////////////////////////Y7///E63//1C+///L6v////////////////////////////////////////////////////////////////////////////////////////P7///L6v//5fT///L6//8ps///kNT//////////////////////////////////5DU//+t3///////////////////////////////////////////////////////////////////////////////////////////////////5fX//1C+//8AqP//AKf//wCn//+Q1f//////////////////////////////////////////////////////////////////8vLy/5SUk/9FRUT/BQUE/wQEA/8yMjD/Z2dm/8zMzP////////////////+GhoX/Z2dm//Lz8////////////+X0///L6v//yun///L6//////////////////////////////////////////////////////////////Ly8v9FRUT/BQUE/wUFBP8FBQT/BQUE/wQEA/8FBQT/BQUD/3Z2dv/z8/P/dnZ2/wUFBP8FBQP/MTEw/9nZ2f//////////////////////////////////////////////////////////////////////////////////////VlZV/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/zIyMP8FBQT/BQUE/wUFBP8FBQT/HR0c/9nZ2f///////////////////////////////////////////////////////////////////////////+bm5v8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8xMTD/HR0c/wUFA/8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFA/8FBQT/lJST////////////////////////////////////////////////////////////////////////////vb29/wUFBP8EBAP/BQUE/wUFBP8FBQT/dnZ2////////////oqKi/wUFBP8EBAP/BQUE/wUFBP8FBQP/BQUE/zIyMf/y8vL///////////////////////////////////////////////////////////////////////////+UlJP/BQUE/wUFBP8FBQT/BQUE/wUFBP/y8vL/////////////////Z2dm/wUFBP8FBQT/BQUE/wUFBP8FBQT/sbGw/////////////////////////////////////////////////////////////////////////////////7GxsP8FBQT/BQUD/wUFBP8FBQT/BQUD//////////////////////+9vb3/BQUE/wUFBP8FBQT/BQUE/wUFBP/m5ub/////////////////////////////////////////////////////////////////////////////////2dnZ/wUFBP8FBQT/BQUE/wUFBP8FBQT/zMzM/////////////////+bm5v8FBQT/BQUE/wUFA/8FBQT/BQUD////////////////////////////////////////////////////////////////////////////////////////////MTEw/wUFBP8FBQT/BQUE/wUFBP9FRUT/5eXl/////////////////wUFBP8FBQT/BQUE/wUFBP8FBQT////////////////////////////////////////////////////////////////////////////////////////////MzMz/BQUE/wUFA/8FBQT/BQUD/wUFBP8FBQT/dnZ2/5SUk/+9vb3/BQUE/wUFBP8FBQT/BQUE/wUFA/////////////////////////////////////////////////////////////////////////////////////////////////+wsK//HR0c/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE///////////////////////////////////////////////////////////////////////////////////////////////////////m5ub/hoaF/zIyMP8FBQT/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQP//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+bm5v/MzMz/lJST/5SUk/9WVlX/BQUE/wQEA/8FBQT/BQUE/wUFA//////////////////////////////////////////////////////////////////////////////////////////////////y8vL/zMzM/8zMzP/Nzc3///////////////////////////8FBQT/BQUE/wUFBP8FBQT/BQUD////////////////////////////////////////////////////////////////////////////////////////////Z2dm/wUFBP8FBQT/BQUE/wUFBP/y8vL/////////////////2dnZ/wUFA/8FBQP/BQUD/wUFBP8FBQT///////////////////////////////////////////////////////////////////////////////////////////9mZmX/BQUE/wUFBP8FBQT/BQUE/3Z2dv////////////////92dnb/BQUE/wUFBP8FBQT/BQUE/wUFBP///////////////////////////////////////////////////////////////////////////////////////////7CwsP8FBQT/BQUE/wUFBP8FBQT/BQUE/zIyMP9WVlX/RUVE/wUFBP8FBQT/BQUE/wUFBP8FBQT/RUVD/////////////////////////////////////////////////////////////////////////////////////////////////1ZWVf8FBQT/BQUE/wUFBP8EBAP/BQUD/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP+wsK/////////////////////////////////////////////////2////2///////////////////////////////////////////8vLy/0VFRP8FBQP/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/dnZ2/////////////////////////////////////////////////////8z///9+/////////////////////////////////////////////////////7Cwr/9FRUT/BQUE/wUFBP8FBQT/BQUD/wUFBP8FBQT/RUVE/7Cwr///////////////////////////////////////////////////////////b////wz////b///////////////////////////////////////////////////////////y8vL/zMzM/8zMzP/MzMz/zc3N/+bm5v///////////////////////////////////////////////////////////////9L///8GAAAAAP///yf////b///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////S////HgAAAAAAAAAAAAAAAP///wz///94////2P/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////S////cv///wkAAAAAAAAAAOAAAAeAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAHAAAADKAAAABgAAAAwAAAAAQAgAAAAAABgCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8G////hP///9v/////////////////////////////////////////////////////////////////////////////////////////2////4T///8GAAAAAP///wz////P///////////////////////////y+v//vOX//5DV//+C0P//YsT//5DU//+u4P//5fT////////////////////////////////////////////G////Cf///4T/////////////////////8vr//3LK//8Trf//AKj//wCn//8Ap///AKf+/wCo//8AqP//AKf//1C+///K6v//////////////////////////////////////e////9v///////////////+u4P//E6z//wCn//8AqP//AKf//wCo//8Ap///AKf//wCo//8AqP//AKf//wCo//8Ap///kNX/////////////kdX//9jw////////////z/////D//////////4LP//8Ap///AKf//wCo//8qs///csr//5DV///K6f//y+r//8rq///L6v//n9n//3LK//8TrP//AKf//5/a////////kNX//1C+////////////7f////D/////kdX//wCo//8AqP//csn//9jw///////////////////////////////////////////////////y+v//n9r//4LQ////////yun//wCn///l9P//////8P////DK6v//AKf//1C+///l9P//////////////////////////////////////////////////////////////////////////////////yun//wCn//+85f//////8P////Aps///kNX///////////////////////////////////////////////////////////////////////+g2v//KrP//2LE//+Q1P//csr//wCn//+R1f//////8P////C75P////////////////////////////+xsbD/VlZV/1VVVP9WVlX/oaGh//Ly8v/y8vL/dnZ2/7Cwr///////vOT//2HD//8Ap///AKj//wCn/v+85f//////8P////D//////////////////////////4aGhf8EBAP/BQUD/wUFBP8EBAP/BQUD/0VFRP9nZ2b/BQUE/wUFBP92dnb/////////////////2O///+b1////////////8P////D/////////////////////8vLy/wUFBP8FBQT/BQUE/wUFA/9EREP/HR0b/wUFBP8FBQT/BQUD/wUFBP8FBQT/////////////////////////////////////8P////D/////////////////////zMzM/wUFBP8FBQT/BQUE/3Z2dv//////8vLy/x0dHP8FBQT/BQUE/wUFBP+UlJP/////////////////////////////////////8P////D/////////////////////zc3N/wUFBP8FBQT/BQUE/5SUk////////////4aGhf8FBQT/BQUE/wUFBP/MzMz/////////////////////////////////////8P////D//////////////////////////x0dG/8FBQT/BQUE/0VFQ//z8/P//////76+vv8FBQT/BQUE/wUFBP/Nzc3/////////////////////////////////////8P////D//////////////////////////7CwsP8FBQP/BQUE/wUFBP8dHRv/dnZ2/3Z2dv8FBQP/BQUE/wUFBP/MzMz/////////////////////////////////////8P////D///////////////////////////////++vr7/MTEw/wUFBP8FBQP/BQUD/wUFBP8FBQT/BQUE/wUFBP/MzMz/////////////////////////////////////8P////D//////////////////////////////////////////+Xl5f/MzMz/lJST/3Z2dv8FBQT/BQUE/wUFBP/MzMz/////////////////////////////////////8P////D//////////////////////////4aGhf9WVlX/HR0b/729vf///////////7Cwr/8FBQP/BQUE/wUFBP/MzMz/////////////////////////////////////8P////D//////////////////////////2ZmZf8FBQT/BQUE/x0dHP++vr7/zMzM/0VFRP8FBQT/BQUE/wUFBP/y8vL/////////////////////////////////////8P////D//////////////////////////8zMzP8FBQT/BQUE/wUFBP8FBQT/BQUE/wUFBP8FBQT/BQUD/1ZWVP/29vb/////////////////////////////////////7f///9X///////////////////////////////+wsK//HR0c/wUFBP8FBQT/BQUE/wUFBP8FBQT/MTEw/9vb2//6+vr/////////////////////////////////////z////3v/////////////////////////////////////8vLy/76+vv+UlJP/lJST/5SUk/++vr7/////////////////////////////////////////////////////df///wn////D//////////////////////////////////////////////////////////////////////////////////////////////////////////////+9////BgAAAAD///8D////df///9L/////////////////////////////////////////////////////////////////////////////////////////z////3X///8DAAAAAIAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAABACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAAAAD///8G////lv////b/////////////////////////////////////////////////////////9v///5b///8G////iv/////////////////////Y7///n9r//5DV//+Q1P//vOT/////////////////////////////////iv///+f//////////8vq//9Qvv//AKj//wCn//8Ap///AKf+/wCn//8ps///u+T////////y+v//8vr//////+f////w/////67g//8AqP//AKj//z24//+C0P//kNX//5DU//+R1f//UL7//wCn//+u4P//vOX//4LQ///////w////8Lzl//8AqP//csn//+bz///////////////////////////////////l9P//rd///9jv//8Trf//////8P////Aqs///2O//////////////////////////////////////////////Ur7//3LK//+C0P//AKf///////D////w5vX/////////////zMzM/x0dG/8FBQT/HR0b/5SUk/9WVlT/RUVD/+fu8/+i2P7/csr//3LK///////w////8P///////////////zExMP8FBQT/BQUE/0VFRP8FBQP/BQUE/wUFBP+UlJP/////////////////////8P////D///////////////8FBQT/BQUE/4aGhP//////ZmZl/wUFBP8FBQT/8vLy//////////////////////D////w////////////////VlZV/wUFBP8yMjD/5ubm/5SUk/8FBQT/BQUE///////////////////////////w////8P///////////////9nZ2f8yMjD/BQUE/wUFBP8FBQT/BQUE/wUFBP//////////////////////////8P////D////////////////m5ub/zMzM/729vf+wsK//VlZV/wUFBP8FBQT///////////////////////////D////w////////////////Z2dm/wUFBP9FRUT/2NjY/2dnZv8FBQT/HR0c///////////////////////////w////5////////////////8zMzP8FBQP/BQUE/wUFBP8FBQT/BQUE/3Z2dv//////////////////////////5////4f/////////////////////2dnZ/3Z2dv9VVVT/VlZV/6Kiov///////////////////////////////4r///8G////jf///+T/////////////////////////////////////////////////////////5P///43///8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==',
    comment: 'Standard-Favicon Amazon'
  }
]);

function getDefaultFaviconRules() {
  const baseTs = Date.now();
  return DEFAULT_FAVICON_RULES.map((rule, index) => Object.assign({}, rule, { createdAt: baseTs + index }));
}

    /**
     * HTMLBookmarkParser - Generic HTML structure parser for bookmark imports
     * Detects and extracts bookmarks from various HTML structures:
     * - Netscape bookmark format (DL/DT/DD)
     * - Nested lists (UL/OL with LI)
     * - Heading hierarchies (H1-H6 with following content)
     * - Definition lists
     * - Article/Section structures
     * - Table-based layouts
     */
    class HTMLBookmarkParser {
      constructor(options = {}) {
        this.options = {
          // Group detection settings
          minLinksForGroup: options.minLinksForGroup || 2,
          maxGroupDepth: options.maxGroupDepth || 5,
          inferGroupNames: options.inferGroupNames !== false,

          // Link extraction settings
          extractMetadata: options.extractMetadata !== false,
          extractKeywords: options.extractKeywords !== false,
          followRedirects: options.followRedirects || false,

          // Pattern priorities (higher = preferred)
          patternPriorities: {
            netscape: 100,    // Standard bookmark format
            headings: 90,     // H1-H6 hierarchies
            nestedLists: 80,  // UL/OL structures
            definitions: 70,  // DL/DT/DD (non-Netscape)
            sections: 60,     // article/section/nav
            tables: 50,       // Table-based layouts
            divGroups: 40,    // Grouped DIVs
            generic: 30       // Fallback patterns
          },
          ...options
        };
      }

      /**
       * Main parsing method - detects format and extracts bookmarks
       * @param {string} html - HTML content to parse
       * @returns {Array} Array of group objects with links
       */
      parse(html) {
        const doc = this.createDocument(html);
        if (!doc) return [];

        // Try patterns in priority order
        const patterns = this.getDetectionPatterns();

        for (const pattern of patterns) {
          const result = pattern.detector(doc);
          if (result && result.confidence > 0.5) {
            console.log(`[HTMLBookmarkParser] Using pattern: ${pattern.name} (confidence: ${result.confidence})`);
            return pattern.extractor(doc, result.context);
          }
        }

        // Fallback: extract all links as single group
        return this.extractGenericLinks(doc);
      }

      /**
       * Create DOM document from HTML string
       */
      createDocument(html) {
        try {
          const parser = new DOMParser();
          return parser.parseFromString(html, 'text/html');
        } catch (e) {
          console.error('[HTMLBookmarkParser] Failed to parse HTML:', e);
          return null;
        }
      }

      /**
       * Get detection patterns sorted by priority
       */
      getDetectionPatterns() {
        return [
          {
            name: 'Netscape Bookmarks',
            priority: this.options.patternPriorities.netscape,
            detector: (doc) => this.detectNetscapeFormat(doc),
            extractor: (doc) => this.extractNetscapeBookmarks(doc)
          },
          {
            name: 'Heading Hierarchy',
            priority: this.options.patternPriorities.headings,
            detector: (doc) => this.detectHeadingStructure(doc),
            extractor: (doc, ctx) => this.extractHeadingGroups(doc, ctx)
          },
          {
            name: 'Nested Lists',
            priority: this.options.patternPriorities.nestedLists,
            detector: (doc) => this.detectNestedLists(doc),
            extractor: (doc, ctx) => this.extractListGroups(doc, ctx)
          },
          {
            name: 'Definition Lists',
            priority: this.options.patternPriorities.definitions,
            detector: (doc) => this.detectDefinitionLists(doc),
            extractor: (doc, ctx) => this.extractDefinitionGroups(doc, ctx)
          },
          {
            name: 'Section Structure',
            priority: this.options.patternPriorities.sections,
            detector: (doc) => this.detectSectionStructure(doc),
            extractor: (doc, ctx) => this.extractSectionGroups(doc, ctx)
          },
          {
            name: 'Table Layout',
            priority: this.options.patternPriorities.tables,
            detector: (doc) => this.detectTableStructure(doc),
            extractor: (doc, ctx) => this.extractTableGroups(doc, ctx)
          }
        ].sort((a, b) => b.priority - a.priority);
      }

      /**
       * Detect Netscape bookmark format
       */
      detectNetscapeFormat(doc) {
        const hasDL = doc.querySelector('DL');
        const hasDT = doc.querySelector('DT');
        const hasH3inDT = doc.querySelector('DT > H3');
        const hasBookmarkMeta = doc.querySelector('META[HTTP-EQUIV*="Content-Type"]');

        const confidence =
          (hasDL ? 0.3 : 0) +
          (hasDT ? 0.3 : 0) +
          (hasH3inDT ? 0.3 : 0) +
          (hasBookmarkMeta ? 0.1 : 0);

        return { confidence, context: { hasDL, hasDT, hasH3inDT } };
      }

      /**
       * Extract Netscape bookmarks (existing implementation)
       */
      extractNetscapeBookmarks(doc) {
        const result = [];

        const walkDL = (dl, currentGroupName = null) => {
          const groupLinks = [];
          const groups = [];
          const nodes = Array.from(dl.children || []);

          for (let i = 0; i < nodes.length; i++) {
            const el = nodes[i];
            if (el.tagName === 'DT') {
              const a = el.querySelector('a');
              const h3 = el.querySelector('h3');

              if (a) {
                groupLinks.push(this.extractLinkData(a));
              } else if (h3) {
                const name = h3.textContent || 'Folder';
                let next = el.nextElementSibling;
                while (next && next.tagName !== 'DL') next = next.nextElementSibling;

                if (next && next.tagName === 'DL') {
                  const sub = walkDL(next, name);
                  groups.push(...sub);
                } else {
                  groups.push({ name, links: [] });
                }
              }
            }
          }

          if (currentGroupName) {
            groups.unshift({ name: currentGroupName, links: groupLinks });
          } else if (groupLinks.length) {
            groups.unshift({ name: 'Imported', links: groupLinks });
          }

          return groups;
        };

        const topDL = doc.querySelector('dl');
        return topDL ? walkDL(topDL) : [];
      }

      /**
       * Detect heading-based structure (H1-H6)
       */
      detectHeadingStructure(doc) {
        const headings = doc.querySelectorAll('h1, h2, h3, h4, h5, h6');
        const links = doc.querySelectorAll('a[href]');

        if (headings.length === 0 || links.length === 0) {
          return { confidence: 0 };
        }

        // Check if headings have links following them
        let headingsWithLinks = 0;
        headings.forEach(heading => {
          const nextElements = this.getNextSiblings(heading, 5);
          const hasLinks = nextElements.some(el =>
            el.querySelector && el.querySelector('a[href]')
          );
          if (hasLinks) headingsWithLinks++;
        });

        const confidence = headingsWithLinks / headings.length;
        return {
          confidence,
          context: { headings, headingsWithLinks }
        };
      }

      /**
       * Extract groups based on heading hierarchy
       */
      extractHeadingGroups(doc, context) {
        const groups = [];
        const headings = doc.querySelectorAll('h1, h2, h3, h4, h5, h6');

        headings.forEach(heading => {
          const level = parseInt(heading.tagName.charAt(1));
          const groupName = heading.textContent.trim();
          const links = [];

          // Collect links until next heading of same or higher level
          let current = heading.nextElementSibling;
          while (current) {
            // Stop at next heading of same or higher importance
            if (/^H[1-6]$/.test(current.tagName)) {
              const currentLevel = parseInt(current.tagName.charAt(1));
              if (currentLevel <= level) break;
            }

            // Extract links from current element
            const anchors = current.querySelectorAll('a[href]');
            anchors.forEach(a => links.push(this.extractLinkData(a)));

            current = current.nextElementSibling;
          }

          if (links.length >= this.options.minLinksForGroup) {
            groups.push({ name: groupName, links });
          }
        });

        return groups;
      }

      /**
       * Detect nested list structure
       */
      detectNestedLists(doc) {
        const lists = doc.querySelectorAll('ul, ol');
        const nestedLists = Array.from(lists).filter(list =>
          list.querySelector('ul, ol') || // Has nested lists
          list.parentElement.closest('ul, ol') // Is nested itself
        );

        const linksInLists = Array.from(lists).reduce((count, list) =>
          count + list.querySelectorAll('a[href]').length, 0
        );

        const totalLinks = doc.querySelectorAll('a[href]').length;

        if (lists.length === 0 || totalLinks === 0) {
          return { confidence: 0 };
        }

        const confidence = (linksInLists / totalLinks) *
                          (nestedLists.length > 0 ? 1.2 : 0.8);

        return {
          confidence: Math.min(confidence, 1),
          context: { lists, nestedLists }
        };
      }

      /**
       * Extract groups from list structures
       */
      extractListGroups(doc, context) {
        const groups = [];
        const processedLists = new Set();

        const extractList = (list, groupName = null) => {
          if (processedLists.has(list)) return null;
          processedLists.add(list);

          const group = {
            name: groupName || this.inferGroupName(list) || 'List Group',
            links: []
          };

          Array.from(list.children).forEach(li => {
            if (li.tagName !== 'LI') return;

            // Check for nested list (subgroup)
            const nestedList = li.querySelector('ul, ol');
            if (nestedList) {
              // Extract text before nested list as subgroup name
              const textNode = Array.from(li.childNodes).find(
                node => node.nodeType === Node.TEXT_NODE && node.textContent.trim()
              );
              const subgroupName = textNode ? textNode.textContent.trim() : null;

              const subgroup = extractList(nestedList, subgroupName);
              if (subgroup && subgroup.links.length >= this.options.minLinksForGroup) {
                groups.push(subgroup);
              }
            }

            // Extract links from this item
            const anchors = Array.from(li.querySelectorAll('a[href]')).filter(
              a => !nestedList || !nestedList.contains(a)
            );
            anchors.forEach(a => group.links.push(this.extractLinkData(a)));
          });

          return group;
        };

        // Process top-level lists
        const topLists = Array.from(doc.querySelectorAll('ul, ol')).filter(
          list => !list.parentElement.closest('ul, ol')
        );

        topLists.forEach(list => {
          const group = extractList(list);
          if (group && group.links.length >= this.options.minLinksForGroup) {
            groups.push(group);
          }
        });

        return groups;
      }

      /**
       * Detect section-based structure (article, section, nav)
       */
      detectSectionStructure(doc) {
        const sections = doc.querySelectorAll('article, section, nav, aside');
        const linksInSections = Array.from(sections).reduce((count, section) =>
          count + section.querySelectorAll('a[href]').length, 0
        );

        const totalLinks = doc.querySelectorAll('a[href]').length;

        if (sections.length === 0 || totalLinks === 0) {
          return { confidence: 0 };
        }

        const confidence = (linksInSections / totalLinks) * 0.9;
        return {
          confidence,
          context: { sections }
        };
      }

      /**
       * Extract groups from section elements
       */
      extractSectionGroups(doc, context) {
        const groups = [];
        const sections = doc.querySelectorAll('article, section, nav, aside');

        sections.forEach(section => {
          const groupName = this.inferGroupName(section) || 'Section';
          const links = Array.from(section.querySelectorAll('a[href]'))
            .map(a => this.extractLinkData(a));

          if (links.length >= this.options.minLinksForGroup) {
            groups.push({ name: groupName, links });
          }
        });

        return groups;
      }

      /**
       * Detect definition list structure
       */
      detectDefinitionLists(doc) {
        const dlElements = doc.querySelectorAll('dl');
        const hasNonNetscapeDL = Array.from(dlElements).some(dl =>
          !dl.querySelector('dt > h3') && dl.querySelector('dt') && dl.querySelector('dd')
        );

        if (!hasNonNetscapeDL) {
          return { confidence: 0 };
        }

        const confidence = 0.7;
        return { confidence, context: { dlElements } };
      }

      /**
       * Extract groups from definition lists
       */
      extractDefinitionGroups(doc, context) {
        const groups = [];
        const dlElements = doc.querySelectorAll('dl');

        dlElements.forEach(dl => {
          let currentGroup = null;

          Array.from(dl.children).forEach(el => {
            if (el.tagName === 'DT') {
              // DT might be a group header
              const links = el.querySelectorAll('a[href]');
              if (links.length === 0) {
                // No links, treat as group name
                if (currentGroup && currentGroup.links.length >= this.options.minLinksForGroup) {
                  groups.push(currentGroup);
                }
                currentGroup = {
                  name: el.textContent.trim(),
                  links: []
                };
              } else {
                // Has links, add to current group
                if (!currentGroup) {
                  currentGroup = { name: 'Definitions', links: [] };
                }
                links.forEach(a => currentGroup.links.push(this.extractLinkData(a)));
              }
            } else if (el.tagName === 'DD' && currentGroup) {
              // DD contains links for the current group
              const links = el.querySelectorAll('a[href]');
              links.forEach(a => currentGroup.links.push(this.extractLinkData(a)));
            }
          });

          if (currentGroup && currentGroup.links.length >= this.options.minLinksForGroup) {
            groups.push(currentGroup);
          }
        });

        return groups;
      }

      /**
       * Detect table-based structure
       */
      detectTableStructure(doc) {
        const tables = doc.querySelectorAll('table');
        const linksInTables = Array.from(tables).reduce((count, table) =>
          count + table.querySelectorAll('a[href]').length, 0
        );

        const totalLinks = doc.querySelectorAll('a[href]').length;

        if (tables.length === 0 || totalLinks === 0) {
          return { confidence: 0 };
        }

        const confidence = (linksInTables / totalLinks) * 0.7;
        return { confidence, context: { tables } };
      }

      /**
       * Extract groups from table structure
       */
      extractTableGroups(doc, context) {
        const groups = [];
        const tables = doc.querySelectorAll('table');

        tables.forEach(table => {
          // Try to detect if table has category rows/columns
          const rows = table.querySelectorAll('tr');
          let currentGroup = null;

          rows.forEach(row => {
            const cells = row.querySelectorAll('td, th');
            const links = row.querySelectorAll('a[href]');

            if (links.length === 0 && cells.length > 0) {
              // Possible category row
              if (currentGroup && currentGroup.links.length >= this.options.minLinksForGroup) {
                groups.push(currentGroup);
              }
              currentGroup = {
                name: row.textContent.trim(),
                links: []
              };
            } else if (links.length > 0) {
              // Row with links
              if (!currentGroup) {
                currentGroup = {
                  name: this.inferGroupName(table) || 'Table Links',
                  links: []
                };
              }
              links.forEach(a => currentGroup.links.push(this.extractLinkData(a)));
            }
          });

          if (currentGroup && currentGroup.links.length >= this.options.minLinksForGroup) {
            groups.push(currentGroup);
          }
        });

        return groups;
      }

      /**
       * Generic link extraction (fallback)
       */
      extractGenericLinks(doc) {
        const links = Array.from(doc.querySelectorAll('a[href]'))
          .map(a => this.extractLinkData(a));

        if (links.length === 0) return [];

        // Try to group by common parent containers
        const groups = this.groupByContainers(doc, links);

        if (groups.length > 1) {
          return groups;
        }

        // Single group with all links
        return [{
          name: this.inferGroupName(doc.body) || 'Imported Links',
          links: links
        }];
      }

      /**
       * Group links by their container elements
       */
      groupByContainers(doc, links) {
        const containerMap = new Map();

        doc.querySelectorAll('a[href]').forEach(anchor => {
          // Find meaningful container
          let container = anchor.parentElement;
          while (container && container !== doc.body) {
            if (this.isMeaningfulContainer(container)) {
              break;
            }
            container = container.parentElement;
          }

          if (!container || container === doc.body) {
            container = doc.body;
          }

          if (!containerMap.has(container)) {
            containerMap.set(container, {
              element: container,
              links: []
            });
          }

          containerMap.get(container).links.push(this.extractLinkData(anchor));
        });

        const groups = [];
        containerMap.forEach(({ element, links }) => {
          if (links.length >= this.options.minLinksForGroup) {
            groups.push({
              name: this.inferGroupName(element) || 'Group',
              links: links
            });
          }
        });

        return groups;
      }

      /**
       * Check if element is a meaningful container
       */
      isMeaningfulContainer(element) {
        const meaningfulTags = ['article', 'section', 'nav', 'aside', 'div', 'ul', 'ol', 'dl'];
        const meaningfulClasses = ['group', 'category', 'section', 'links', 'bookmarks', 'list'];

        if (meaningfulTags.includes(element.tagName.toLowerCase())) {
          // Check for meaningful class or id
          const classList = Array.from(element.classList);
          const hasClass = meaningfulClasses.some(cls =>
            classList.some(c => c.toLowerCase().includes(cls))
          );

          const hasId = element.id && meaningfulClasses.some(cls =>
            element.id.toLowerCase().includes(cls)
          );

          return hasClass || hasId || element.children.length > 2;
        }

        return false;
      }

      /**
       * Extract link data from anchor element
       */
      extractLinkData(anchor) {
        const link = {
          text: anchor.textContent.trim() || anchor.title || 'Link',
          url: anchor.href || anchor.getAttribute('href') || '',
          keywords: ''
        };

        if (this.options.extractMetadata) {
          // Extract title attribute
          if (anchor.title) {
            link.title = anchor.title;
          }

          // Extract favicon if present
          const img = anchor.querySelector('img');
          if (img && img.src) {
            link.favicon = img.src;
          }

          // Extract description from next sibling or parent
          const nextSibling = anchor.nextSibling;
          if (nextSibling && nextSibling.nodeType === Node.TEXT_NODE) {
            const desc = nextSibling.textContent.trim();
            if (desc && desc.length < 200) {
              link.description = desc;
            }
          }
        }

        if (this.options.extractKeywords) {
          // Extract keywords from class, data attributes, or context
          const keywords = [];

          if (anchor.className) {
            keywords.push(...anchor.className.split(/\s+/));
          }

          // Check data attributes
          Array.from(anchor.attributes).forEach(attr => {
            if (attr.name.startsWith('data-')) {
              keywords.push(attr.value);
            }
          });

          // Check parent context
          const parent = anchor.closest('[class*="tag"], [class*="category"], [data-category]');
          if (parent) {
            if (parent.dataset.category) {
              keywords.push(parent.dataset.category);
            }
            if (parent.className) {
              keywords.push(...parent.className.split(/\s+/));
            }
          }

          link.keywords = [...new Set(keywords)]
            .filter(k => k && k.length > 1 && k.length < 50)
            .join(', ');
        }

        return link;
      }

      /**
       * Infer group name from element context
       */
      inferGroupName(element) {
        if (!element || !this.options.inferGroupNames) return null;

        // Try various strategies to find a name

        // 1. Check for heading before or within element
        const heading = element.querySelector('h1, h2, h3, h4, h5, h6') ||
                       this.getPreviousHeading(element);
        if (heading) {
          return heading.textContent.trim();
        }

        // 2. Check for aria-label or title
        if (element.getAttribute('aria-label')) {
          return element.getAttribute('aria-label');
        }
        if (element.title) {
          return element.title;
        }

        // 3. Check for data attributes
        if (element.dataset.title || element.dataset.name) {
          return element.dataset.title || element.dataset.name;
        }

        // 4. Check for id or class that might indicate purpose
        if (element.id) {
          // Convert ID to readable name (bookmarks-list -> Bookmarks List)
          return element.id.replace(/[-_]/g, ' ')
            .replace(/([a-z])([A-Z])/g, '$1 $2')
            .replace(/\b\w/g, c => c.toUpperCase());
        }

        // 5. Check first text node
        const textNode = Array.from(element.childNodes).find(
          node => node.nodeType === Node.TEXT_NODE && node.textContent.trim()
        );
        if (textNode) {
          const text = textNode.textContent.trim();
          if (text.length < 50) {
            return text;
          }
        }

        return null;
      }

      /**
       * Get previous heading sibling
       */
      getPreviousHeading(element) {
        let sibling = element.previousElementSibling;
        while (sibling) {
          if (/^H[1-6]$/.test(sibling.tagName)) {
            return sibling;
          }
          sibling = sibling.previousElementSibling;
        }
        return null;
      }

      /**
       * Get next siblings up to count
       */
      getNextSiblings(element, count = 5) {
        const siblings = [];
        let current = element.nextElementSibling;

        while (current && siblings.length < count) {
          siblings.push(current);
          current = current.nextElementSibling;
        }

        return siblings;
      }
    }

    // Toast Notification System
    class ToastManager {
      constructor() {
        this.container = null;
        this.toasts = [];
        this.init();
      }

      init() {
        // Create container if it doesn't exist
        if (!document.getElementById('toast-container')) {
          this.container = document.createElement('div');
          this.container.id = 'toast-container';
          this.container.className = 'toast-container';
          document.body.appendChild(this.container);
        } else {
          this.container = document.getElementById('toast-container');
        }
      }

      show(title, body = '', type = 'info', duration = 5000) {
        const toast = document.createElement('div');
        toast.className = `toast-notification toast-${type} mb-toast mb-toast-${type}`;

        const toastId = 'toast-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        toast.id = toastId;

        // Toast content
        const content = document.createElement('div');
        content.className = 'toast-content mb-toast-content';

        // Title
        if (title) {
          const titleEl = document.createElement('div');
          titleEl.className = 'toast-title mb-toast-title';
          titleEl.textContent = title;
          content.appendChild(titleEl);
        }

        // Body (supports HTML)
        if (body) {
          const bodyEl = document.createElement('div');
          bodyEl.className = 'toast-body mb-toast-body';
          bodyEl.innerHTML = body;
          content.appendChild(bodyEl);
        }

        toast.appendChild(content);

        // Close button
        const closeBtn = document.createElement('button');
        closeBtn.className = 'toast-close mb-toast-close';
        closeBtn.innerHTML = '×';
        closeBtn.onclick = () => this.remove(toastId);
        toast.appendChild(closeBtn);

        // Progress bar
        const progressBar = document.createElement('div');
        progressBar.className = 'toast-progress mb-toast-progress';
        const progressFill = document.createElement('div');
        progressFill.className = 'toast-progress-fill mb-toast-progress-fill';
        progressBar.appendChild(progressFill);
        toast.appendChild(progressBar);

        // Add to container
        this.container.appendChild(toast);
        this.toasts.push({ id: toastId, element: toast });

        // Trigger animation
        setTimeout(() => {
          toast.classList.add('toast-show');
          progressFill.style.transition = `width ${duration}ms linear`;
          progressFill.style.width = '0%';
        }, 10);

        // Auto remove after duration
        if (duration > 0) {
          setTimeout(() => {
            this.remove(toastId);
          }, duration);
        }

        return toastId;
      }

      remove(toastId) {
        const index = this.toasts.findIndex(t => t.id === toastId);
        if (index > -1) {
          const toast = this.toasts[index];
          toast.element.classList.remove('toast-show');
          toast.element.classList.add('toast-hide');

          setTimeout(() => {
            if (toast.element.parentNode) {
              toast.element.parentNode.removeChild(toast.element);
            }
            this.toasts.splice(index, 1);
          }, 300);
        }
      }

      success(title, body = '', duration = 5000) {
        return this.show(title, body, 'success', duration);
      }

      error(title, body = '', duration = 5000) {
        return this.show(title, body, 'error', duration);
      }

      warning(title, body = '', duration = 5000) {
        return this.show(title, body, 'warning', duration);
      }

      info(title, body = '', duration = 5000) {
        return this.show(title, body, 'info', duration);
      }
    }

    // Create global instance
    const toastManager = new ToastManager();

    // Minimal in-file namespaces to group related helpers
    const MB = {
      Utils: {},
      DnD: {},
      Sync: {},
      EventLog: {},
      UI: {},
      Extension: {},
      CardDAV: {},
      SyncAdapters: {}
    };

    // Enums / Sentinel values for clarity
    const ENUMS = {
      EnvelopeType: {
        GROUP_UPDATE_REQUEST: 'group-update-request',
        GROUP_ROSTER: 'group-roster',
        SYNC_CHUNK: 'sync-chunk',
        SYNC_CHUNKS_DONE: 'sync-chunks-done',
        SYNC_EVENT: 'sync-event',
        EVENT_LOG_ACTIVATION: 'event-log-activation'
      },
      Role: { OWNER: 'owner', MEMBER: 'member' }
    };

    // Message/Envelope builder
    MB.Sync.buildEnvelope = function(app, type, payload = {}, overrides = {}) {
      const from = { uuid: app?.data?.identity?.uuid || '', name: app?.data?.identity?.name || '' };
      const base = { v: 1, type, ts: Date.now(), from, msgId: (Math.random().toString(36).slice(2) + Date.now()) };
      return Object.assign(base, payload || {}, overrides || {});
    };

    // URL helpers
    MB.Utils.isValidHttpUrl = function(str) {
      try { const u = new URL(str); return u.protocol === 'http:' || u.protocol === 'https:'; } catch { return false; }
    };
    MB.Utils.ensureProtocol = function(str) {
      const s = (str || '').trim();
      if (!s) return '';
      // Normalize accidental double http(s):// prefixes
      const m = s.match(/^(https?:\/\/)/i);
      if (m) {
        return s.replace(/^(https?:\/\/)+/i, m[1]);
      }
      if (/^[a-zA-Z]+:\/\//.test(s) || s.startsWith('/')) return s;
      try {
        const appRef = (typeof window !== 'undefined' && window.app) ? window.app : null;
        const hasCustomPrefix = (
          appRef &&
          appRef.data &&
          appRef.data.options &&
          appRef.data.options.links &&
          typeof appRef.data.options.links.defaultUrlPrefix === 'string'
        );
        let pref = hasCustomPrefix
          ? appRef.data.options.links.defaultUrlPrefix
          : CONSTS.DEFAULT_URL_PREFIX;
        pref = (typeof pref === 'string') ? pref.trim() : '';
        if (!pref) return s; // allow empty (no auto prefix)
        // Collapse repeated http(s):// again after concatenation
        const combined = pref + s;
        const mm = combined.match(/^(https?:\/\/)/i);
        if (mm) return combined.replace(/^(https?:\/\/)+/i, mm[1]);
        return combined;
      } catch {
        return CONSTS.DEFAULT_URL_PREFIX ? CONSTS.DEFAULT_URL_PREFIX + s : s;
      }
    };

    // Extension communication wrapper
    MB.Extension.isAvailable = function() {
      return window.MyBookmarksExtension && typeof window.MyBookmarksExtension.isAvailable === 'function';
    };

    MB.Extension.checkAvailability = async function() {
      if (!MB.Extension.isAvailable()) {
        debugLog('warn', 'Extension object not found');
        return false;
      }
      try {
        const available = await window.MyBookmarksExtension.isAvailable();
        debugLog('log', 'Extension availability check:', available);
        return available;
      } catch (e) {
        debugLog('error', 'Extension availability check failed:', e);
        return false;
      }
    };

    MB.Extension.fetchMetadata = async function(url, options = {}) {
      if (!MB.Extension.isAvailable()) {
        throw new Error('Extension not available');
      }

      const normalizedUrl = MB.Utils.ensureProtocol(url);
      if (!MB.Utils.isValidHttpUrl(normalizedUrl)) {
        throw new Error('Invalid URL: ' + url);
      }

      debugLog('log', 'Fetching metadata via extension for:', normalizedUrl, 'Options:', options);

      try {
        const metadata = await window.MyBookmarksExtension.fetchMetadata(normalizedUrl, options);

        if (!metadata || !metadata.success) {
          throw new Error(metadata?.error || 'Failed to fetch metadata');
        }

        // Normalize the response
        return {
          success: true,
          url: normalizedUrl,
          title: metadata.title || '',
          description: metadata.description || '',
          favicon: metadata.favicon || null,
          faviconUrl: metadata.faviconUrl || null,
          ogImage: metadata.ogImage || null,
          keywords: metadata.keywords || [],
          author: metadata.author || '',
          siteName: metadata.siteName || '',
          html: metadata.html || '', // Full HTML content if requested
          links: metadata.links || [] // Extracted links if requested
        };
      } catch (e) {
        debugLog('error', 'Extension fetchMetadata failed:', e);
        throw e;
      }
    };

    MB.Extension.fetchPageContent = async function(url) {
      // Special method for fetching and parsing page content (for import)
      if (!MB.Extension.isAvailable()) {
        throw new Error('Extension not available');
      }

      const normalizedUrl = MB.Utils.ensureProtocol(url);
      if (!MB.Utils.isValidHttpUrl(normalizedUrl)) {
        throw new Error('Invalid URL: ' + url);
      }

      debugLog('log', 'Fetching page content via extension for:', normalizedUrl);

      try {
        // Use the same fetchMetadata but we'll expand it to include HTML content
        const response = await window.MyBookmarksExtension.fetchMetadata(normalizedUrl);

        if (!response || !response.success) {
          throw new Error(response?.error || 'Failed to fetch page content');
        }

        // For now, return what we have - we'll need to enhance the extension
        // to also return the HTML content for parsing
        return {
          success: true,
          url: normalizedUrl,
          title: response.title || '',
          html: response.html || '', // Extension needs to be updated to return this
          links: response.links || [] // Extension needs to extract links
        };
      } catch (e) {
        debugLog('error', 'Extension fetchPageContent failed:', e);
        throw e;
      }
    };

    MB.Extension.getBookmarks = async function() {
      if (!MB.Extension.isAvailable()) {
        throw new Error('Extension not available');
      }

      debugLog('log', 'Fetching browser bookmarks via extension');

      try {
        const bookmarks = await window.MyBookmarksExtension.getBookmarks();

        if (!bookmarks) {
          throw new Error('Failed to fetch bookmarks');
        }

        return bookmarks;
      } catch (e) {
        debugLog('error', 'Extension getBookmarks failed:', e);
        throw e;
      }
    };

    // Set DAV auth for extension header injection
    MB.Extension.setDavAuth = async function(serverUrl, username, password) {
      if (!MB.Extension.isAvailable()) return false;
      try {
        await window.MyBookmarksExtension.setDavAuth({ serverUrl, username, password });
        return true;
      } catch { return false; }
    };

    MB.Extension.proxyFetch = async function(request = {}) {
      if (!MB.Extension.isAvailable()) {
        throw new Error('Extension not available');
      }
      const extension = window.MyBookmarksExtension;
      if (!extension || typeof extension.proxyFetch !== 'function') {
        throw new Error('Extension proxyFetch API missing');
      }
      try {
        const response = await extension.proxyFetch(request);
        if (!response) {
          throw new Error('Empty proxy response');
        }
        if (response.error) {
          throw new Error(response.error);
        }
        return response;
      } catch (error) {
        debugLog('error', '[PROXY] Extension proxyFetch failed', { request, error });
        throw error;
      }
    };

    // ===== CARDDAV HELPERS (transport strictly via extension) =====
    MB.CardDAV.buildBasicAuthHeader = function(username, password) {
      const up = `${username || ''}:${password || ''}`;
      try { return 'Basic ' + btoa(up); } catch { return 'Basic ' + btoa(unescape(encodeURIComponent(up))); }
    };

    MB.CardDAV.joinUrl = function(base, path) {
      if (!base) return path || '';
      if (!path) return base;
      if (/^https?:\/\//i.test(path)) return path;
      const b = base.endsWith('/') ? base.slice(0, -1) : base;
      const p = path.startsWith('/') ? path : ('/' + path);
      return b + p;
    };

    MB.CardDAV.request = async function(req) {
      // req: { method, url, headers, body }
      const { method, url, headers, body } = req || {};
      if (!MB.Extension.isAvailable() || !window.MyBookmarksExtension || typeof window.MyBookmarksExtension.davRequest !== 'function') {
        throw new Error('Extension DAV API not available');
      }
      // Extract creds from Authorization header if present
      let username = undefined, password = undefined;
      try {
        const authHeader = headers && (headers['Authorization'] || headers['authorization']);
        if (authHeader && /^Basic\s+/i.test(authHeader)) {
          const b64 = authHeader.split(/\s+/)[1] || '';
          const up = atob(b64);
          const idx = up.indexOf(':');
          if (idx >= 0) { username = up.slice(0, idx); password = up.slice(idx + 1); }
        }
      } catch {}
      // Send with auth on first try (Nextcloud-friendly)
      let res = await MB.Extension.davRequest({ method, url, headers: headers || {}, body, username, password });
      if (!res) throw new Error('No response from extension');
      return res;
    };

    // Try to resolve /.well-known/carddav to canonical DAV base via redirect
    MB.CardDAV.followWellKnown = async function(serverUrl) {
      const wellKnown = MB.CardDAV.joinUrl(serverUrl, '/.well-known/carddav');
      try {
        const res = await MB.CardDAV.request({ method: 'GET', url: wellKnown, headers: {} });
        // XHR follows redirects; derive final URL from Location header if provided
        const loc = res.headers && (res.headers['location'] || res.headers['content-location']);
        return loc ? MB.CardDAV.joinUrl(serverUrl, loc) : serverUrl;
      } catch { return serverUrl; }
    };

    MB.CardDAV.propfind = async function(url, depth, body, authHeader) {
      const headers = {
        'Depth': String(depth ?? 0),
        'Content-Type': 'application/xml; charset=utf-8',
        'Accept': 'application/xml,text/xml'
      };
      if (authHeader) headers['Authorization'] = authHeader;
      return await MB.CardDAV.request({ method: 'PROPFIND', url, headers, body });
    };

    MB.CardDAV.report = async function(url, body, authHeader, depth = 1) {
      const headers = {
        'Depth': String(depth),
        'Content-Type': 'application/xml; charset=utf-8',
        'Accept': 'application/xml,text/xml'
      };
      if (authHeader) headers['Authorization'] = authHeader;
      return await MB.CardDAV.request({ method: 'REPORT', url, headers, body });
    };

    MB.CardDAV.get = async function(url, authHeader) {
      const headers = {};
      if (authHeader) headers['Authorization'] = authHeader;
      return await MB.CardDAV.request({ method: 'GET', url, headers });
    };

    MB.CardDAV.put = async function(url, body, authHeader, ifMatch, ifNoneMatch) {
      const headers = { 'Content-Type': 'text/vcard; charset=utf-8' };
      if (authHeader) headers['Authorization'] = authHeader;
      if (ifMatch) headers['If-Match'] = ifMatch;
      if (ifNoneMatch) headers['If-None-Match'] = ifNoneMatch;
      return await MB.CardDAV.request({ method: 'PUT', url, headers, body });
    };

    MB.CardDAV.delete = async function(url, authHeader, ifMatch) {
      const headers = {};
      if (authHeader) headers['Authorization'] = authHeader;
      if (ifMatch) headers['If-Match'] = ifMatch;
      return await MB.CardDAV.request({ method: 'DELETE', url, headers });
    };

    MB.CardDAV.escapeText = function(s) {
      return String(s || '')
        .replace(/\\/g, '\\\\')
        .replace(/\n/g, '\\n')
        .replace(/;/g, '\\;')
        .replace(/,/g, '\\,');
    };

    MB.CardDAV.buildVCard = function(model) {
      // model: { uid, fn, url, categories[], note, keywords, meta }
      const lines = [];
      lines.push('BEGIN:VCARD');
      lines.push('VERSION:4.0');
      if (model.uid) lines.push('UID:' + MB.CardDAV.escapeText(model.uid));
      if (model.fn) lines.push('FN:' + MB.CardDAV.escapeText(model.fn));
      if (model.url) lines.push('URL;VALUE=uri:' + MB.CardDAV.escapeText(model.url));
      if (Array.isArray(model.categories) && model.categories.length) {
        const cat = model.categories.map(c => MB.CardDAV.escapeText(c)).join(',');
        lines.push('CATEGORIES:' + cat);
      }
      if (model.keywords) lines.push('X-MB-KEYWORDS:' + MB.CardDAV.escapeText(model.keywords));
      if (model.meta) lines.push('X-MB-META:' + MB.CardDAV.escapeText(JSON.stringify(model.meta)));
      if (model.note) lines.push('NOTE:' + MB.CardDAV.escapeText(model.note));
      lines.push('END:VCARD');
      return lines.join('\r\n');
    };

    // ===== GENERIC SYNC ADAPTER REGISTRY =====
    MB.SyncAdapters._adapters = {};
    MB.SyncAdapters.register = function(key, adapter) { MB.SyncAdapters._adapters[key] = adapter; };
    MB.SyncAdapters.get = function(key) { return MB.SyncAdapters._adapters[key]; };

    // CardDAV adapter (wrap existing CardDAV methods)
    MB.SyncAdapters.register('carddav', {
      name: 'CardDAV',
      async testConnection(app) {
        // Reuse existing test logic
        if (typeof app.testCardDavConnection === 'function') return app.testCardDavConnection();
        // Fallback: minimal PROPFIND 0
        const opts = app.data.options?.carddav||{};
        const serverUrl = (opts.serverUrl||'').trim(); const path=(opts.addressbookPath||'').trim();
        if (!serverUrl||!path) throw new Error('Missing serverUrl or addressbookPath');
        const auth = MB.CardDAV.buildBasicAuthHeader(opts.username||'', opts.password||'');
        const url = MB.CardDAV.joinUrl(serverUrl, path);
        const r = await MB.CardDAV.propfind(url, 0, `<?xml version="1.0"?><D:propfind xmlns:D="DAV:"><D:prop><D:resourcetype/></D:prop></D:propfind>`, auth);
        return { ok: r.ok, status: r.status };
      },
      async syncNow(app) {
        if (typeof app.syncCardDavNow === 'function') return app.syncCardDavNow();
        throw new Error('CardDAV sync not available');
      }
    });

    // Nextcloud Bookmarks adapter (REST) – initial test implementation
    MB.SyncAdapters.register('nc-bookmarks', {
      name: 'Nextcloud Bookmarks',
      async testConnection(app) {
        const bk = app.data.options?.bookmarks||{};
        const serverUrl = (bk.serverUrl||'').trim();
        if (!serverUrl) throw new Error('Missing bookmarks serverUrl');
        // Ensure extension has auth from bookmarks settings
        try { await MB.Extension.setDavAuth(serverUrl, bk.username||'', bk.password||''); } catch {}
        const url = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
        const headers = { 'Accept':'application/json', 'OCS-APIREQUEST':'true', 'X-Requested-With':'XMLHttpRequest' };
        const auth = MB.CardDAV.buildBasicAuthHeader(bk.username||'', bk.password||'');
        headers['Authorization']=auth;
        const res = await MB.Extension.davRequest({ method:'GET', url, headers, username: bk.username||'', password: bk.password||'' });
        return { ok: res.ok, status: res.status };
      },
      async syncNow(app) {
        debugLog('log', '[NC SYNC] syncNow start');
        try { app.syncInProgress = true; app.syncProgress = 5; app.syncProgressText = 'Synchronizing…'; } catch {}
        try { debugLog('log', '[NC-TRACE] Start', { traceId: (typeof TRACE_NC_ID!=='undefined'?TRACE_NC_ID:null), backend: 'nc-bookmarks' }); } catch {}
        const bk = app.data.options?.bookmarks||{};
        const serverUrl = (bk.serverUrl||'').trim();
        if (!serverUrl) throw new Error('Missing bookmarks serverUrl');
        const sessionId = Date.now();
        const forceFetchAll = (typeof window !== 'undefined' && (window.mbForceFetch === true)) || (localStorage.getItem('mbForceFetch') === '1');
        // Robust NC timestamp parser: supports seconds, millis, numeric strings, ISO strings
        const parseNcTs = (v) => {
          if (v === null || v === undefined) return 0;
          if (typeof v === 'number') return v < 1e12 ? Math.floor(v * 1000) : Math.floor(v);
          const s = String(v).trim();
          if (!s) return 0;
          const n = Number(s);
          if (!Number.isNaN(n)) return n < 1e12 ? Math.floor(n * 1000) : Math.floor(n);
          const d = Date.parse(s);
          return Number.isNaN(d) ? 0 : Math.floor(d);
        };
        try { await MB.Extension.setDavAuth(serverUrl, bk.username||'', bk.password||''); } catch {}
        const auth = MB.CardDAV.buildBasicAuthHeader(bk.username||'', bk.password||'');
        const hJson = { 'Accept':'application/json', 'OCS-APIREQUEST':'true', 'X-Requested-With':'XMLHttpRequest', 'Authorization':auth };
        // Process any pending remote deletions FIRST to avoid re-pulling locally deleted items
        try {
          const pending = Array.isArray(app.data.pendingNcDeletes) ? [...app.data.pendingNcDeletes] : [];
          for (const pd of pending) {
            if (!pd?.id) continue;
            const delUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(pd.id)}`);
            let delRes = null; try { delRes = await MB.Extension.davRequest({ method:'DELETE', url: delUrl, headers:hJson, username: bk.username||'', password: bk.password||'' }); } catch { delRes = { ok:false, status:0 }; }
            if (delRes?.ok || delRes?.status === 404) {
              try { app.data.pendingNcDeletes = (app.data.pendingNcDeletes||[]).filter(x => x !== pd); } catch {}
              debugLog('log', '[NC SYNC] Pre-pull delete OK', { id: pd.id, status: delRes?.status||200 });
            } else {
              debugLog('warn', '[NC SYNC] Pre-pull delete failed (will retry later)', { id: pd.id, status: delRes?.status });
            }
          }
          app.saveData();
        } catch {}
        // Helper: robust JSON parse for NC Bookmarks responses (handles OCS/data/items wrappers)
        const parseNcList = (bodyText, label) => {
          let parsed = null;
          try { parsed = JSON.parse(bodyText||'[]'); } catch {}
          if (Array.isArray(parsed)) return parsed;
          const d = parsed && parsed.data ? parsed.data : parsed;
          if (Array.isArray(d)) return d;
          if (d && Array.isArray(d.items)) return d.items;
          if (parsed && Array.isArray(parsed.items)) return parsed.items;
          debugLog('warn', '[NC SYNC] Could not parse list as array', { label, sample: (bodyText||'').slice(0, 200) });
          return [];
        };
        // Unwrap helper for single-object responses: {item:{...}}, {data:{...}}, {status, item}
        const unwrapNc = (obj) => {
          try {
            if (!obj) return obj;
            if (obj && obj.status && obj.item) return obj.item;
            if (obj && obj.data && obj.data.item) return obj.data.item;
            if (obj && obj.item) return obj.item;
            if (obj && obj.data && !obj.id) return obj.data;
            return obj;
          } catch { return obj; }
        };
        // Helper: fetch bookmarks for a folder with multiple fallbacks
        const fetchFolderItems = async (fid) => {
          // Attempt 0: some NC setups require page=0 + deleted=false + sortby
          try {
            const url0 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?limit=1000&page=0&sortby=lastmodified&folder=${encodeURIComponent(fid)}&deleted=false`);
            const res0 = await MB.Extension.davRequest({ method:'GET', url:url0, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res0?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt0 body head', { folderId: fid, head: (res0.bodyText||'').slice(0, 200) }); } catch {}
              const arr0 = parseNcList(res0.bodyText, 'attempt0-folder-page0');
              if (arr0.length) return arr0;
            } else { try { debugLog('warn', '[NC SYNC] items attempt0 status', { folderId: fid, status: res0?.status }); } catch {} }
          } catch {}
          // Attempt 0b: folders[] variant
          try {
            const url0b = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?limit=1000&page=0&sortby=lastmodified&folders[]=${encodeURIComponent(fid)}&deleted=false`);
            const res0b = await MB.Extension.davRequest({ method:'GET', url:url0b, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res0b?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt0b body head', { folderId: fid, head: (res0b.bodyText||'').slice(0, 200) }); } catch {}
              const arr0b = parseNcList(res0b.bodyText, 'attempt0b-folders[]-page0');
              if (arr0b.length) return arr0b;
            } else { try { debugLog('warn', '[NC SYNC] items attempt0b status', { folderId: fid, status: res0b?.status }); } catch {} }
          } catch {}
          // Attempt 1: folder=ID
          try {
            const url1 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?folder=${encodeURIComponent(fid)}&page=1&limit=1000`);
            const res1 = await MB.Extension.davRequest({ method:'GET', url:url1, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res1?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt1 body head', { folderId: fid, head: (res1.bodyText||'').slice(0, 200) }); } catch {}
              const arr1 = parseNcList(res1.bodyText, 'attempt1-folder');
              if (arr1.length) return arr1;
            }
          } catch {}
          // Attempt 2: folders[]=ID
          try {
            const url2 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?folders[]=${encodeURIComponent(fid)}&page=1&limit=1000`);
            const res2 = await MB.Extension.davRequest({ method:'GET', url:url2, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res2?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt2 body head', { folderId: fid, head: (res2.bodyText||'').slice(0, 200) }); } catch {}
              const arr2 = parseNcList(res2.bodyText, 'attempt2-folders[]');
              if (arr2.length) return arr2;
            }
          } catch {}
          // Attempt 3: all bookmarks then filter by folder membership if present
          try {
            const url3 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?page=1&limit=1000`);
            const res3 = await MB.Extension.davRequest({ method:'GET', url:url3, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res3?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt3 body head', { folderId: fid, head: (res3.bodyText||'').slice(0, 200) }); } catch {}
              const arr3 = parseNcList(res3.bodyText, 'attempt3-all');
              if (Array.isArray(arr3) && arr3.length) {
                const out = arr3.filter(it => {
                  const flds = Array.isArray(it.folders) ? it.folders : [];
                  const fSingle = (it.folder!==undefined && it.folder!==null) ? Number(it.folder) : null;
                  return (flds.includes(fid) || flds.includes(Number(fid)) || (fSingle!==null && fSingle === Number(fid)));
                });
                if (out.length) return out;
              }
            }
          } catch {}
          // Attempt 4: OCS fallback
          try {
            const url4 = MB.CardDAV.joinUrl(serverUrl, `/ocs/v2.php/apps/bookmarks/api/v1/bookmark?folder=${encodeURIComponent(fid)}&page=1&limit=1000&format=json`);
            const res4 = await MB.Extension.davRequest({ method:'GET', url:url4, headers:Object.assign({}, hJson, {'OCS-APIREQUEST':'true'}), username: bk.username||'', password: bk.password||'' });
            if (res4?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt4 OCS body head', { folderId: fid, head: (res4.bodyText||'').slice(0, 200) }); } catch {}
              let parsed=null; try { parsed = JSON.parse(res4.bodyText||'null'); } catch {}
              let items = [];
              const ocs = parsed && parsed.ocs ? parsed.ocs : parsed;
              const data = ocs && ocs.data ? ocs.data : (Array.isArray(parsed) ? parsed : (parsed && parsed.data ? parsed.data : []));
              if (Array.isArray(data)) items = data; else if (data && Array.isArray(data.items)) items = data.items;
              if (items && items.length) return items;
            } else { try { debugLog('warn', '[NC SYNC] items attempt4 OCS status', { folderId: fid, status: res4?.status, head: (res4.bodyText||'').slice(0,120) }); } catch {} }
          } catch {}
          // Attempt 5: REST nested per folder
          try {
            const url5 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(fid)}/bookmark?page=1&limit=1000`);
            const res5 = await MB.Extension.davRequest({ method:'GET', url:url5, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res5?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt5 nested body head', { folderId: fid, head: (res5.bodyText||'').slice(0, 200) }); } catch {}
              const arr5 = parseNcList(res5.bodyText, 'attempt5-folder-nested');
              if (arr5.length) return arr5;
            } else { try { debugLog('warn', '[NC SYNC] items attempt5 status', { folderId: fid, status: res5?.status }); } catch {} }
          } catch {}
          // Attempt 6: REST with folderId variant
          try {
            const url6 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?folderId=${encodeURIComponent(fid)}&page=1&limit=1000`);
            const res6 = await MB.Extension.davRequest({ method:'GET', url:url6, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (res6?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt6 folderId body head', { folderId: fid, head: (res6.bodyText||'').slice(0, 200) }); } catch {}
              const arr6 = parseNcList(res6.bodyText, 'attempt6-folderId');
              if (arr6.length) return arr6;
            } else { try { debugLog('warn', '[NC SYNC] items attempt6 status', { folderId: fid, status: res6?.status }); } catch {} }
          } catch {}
          // Attempt 7: OCS folder path
          try {
            const url7 = MB.CardDAV.joinUrl(serverUrl, `/ocs/v2.php/apps/bookmarks/api/v1/folder/${encodeURIComponent(fid)}/bookmarks?format=json&page=1&limit=1000`);
            const res7 = await MB.Extension.davRequest({ method:'GET', url:url7, headers:Object.assign({}, hJson, {'OCS-APIREQUEST':'true'}), username: bk.username||'', password: bk.password||'' });
            if (res7?.ok) {
              try { debugLog('log', '[NC SYNC] items attempt7 OCS folder body head', { folderId: fid, head: (res7.bodyText||'').slice(0, 200) }); } catch {}
              let parsed=null; try { parsed = JSON.parse(res7.bodyText||'null'); } catch {}
              let items = [];
              const ocs = parsed && parsed.ocs ? parsed.ocs : parsed;
              const data = ocs && ocs.data ? ocs.data : (Array.isArray(parsed) ? parsed : (parsed && parsed.data ? parsed.data : []));
              if (Array.isArray(data)) items = data; else if (data && Array.isArray(data.items)) items = data.items;
              if (items && items.length) return items;
            } else { try { debugLog('warn', '[NC SYNC] items attempt7 status', { folderId: fid, status: res7?.status, head: (res7.bodyText||'').slice(0,120) }); } catch {} }
          } catch {}
          return [];
        };
        // Helper to fetch single bookmark to resolve conflicts when folder-hash says no change
        // Trace helper: set a specific NC bookmark id to trace via localStorage.setItem('mbTraceNcId','2073')
        const TRACE_NC_ID = Number(localStorage.getItem('mbTraceNcId')||2073);
        const traceFlags = { fetch:false, folderItem:false, merge:false, reconcile:false, pushPre0:false, pushPre:false };
        const fetchBookmark = async (bid) => {
          try {
            const gUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(bid)}`);
            const gRes = await MB.Extension.davRequest({ method:'GET', url:gUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (!gRes.ok) return null;
            let obj=null; try { obj = JSON.parse(gRes.bodyText||'null'); } catch {}
            // Unwrap common NC REST wrappers: {data:{...}}, {item:{...}}, or direct object
            if (obj && obj.data && obj.data.item) obj = obj.data.item;
            else if (obj && obj.item) obj = obj.item;
            else if (obj && obj.data && !obj.id) obj = obj.data;
            // Some servers wrap in {status, item}
            if (obj && obj.status && obj.item) obj = obj.item;
            try {
              if (Number(bid) === TRACE_NC_ID) {
                traceFlags.fetch = true;
                debugLog('log', '[NC-TRACE 2073] fetchBookmark() response', {
                  url: gUrl,
                  ok: gRes.ok,
                  status: gRes.status,
                  bodyHead: (gRes.bodyText||'').slice(0, 500),
                  parsed: MB.Utils.safeClone(obj),
                  lastmodified: obj?.lastmodified || obj?.lastModified || obj?.updated,
                });
              }
            } catch {}
            return obj && (obj.id !== undefined) ? obj : null;
          } catch { return null; }
        };

        // 1) Folders
        const fUrl = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
        const fRes = await MB.Extension.davRequest({ method:'GET', url:fUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
        if (!fRes.ok) throw new Error('Folders fetch failed: '+fRes.status);
        const parseFolderList = (bodyText) => {
          let obj=null; try { obj = JSON.parse(bodyText||'[]'); } catch {}
          if (Array.isArray(obj)) return obj;
          const d = obj && obj.data ? obj.data : obj;
          if (Array.isArray(d)) return d;
          if (d && Array.isArray(d.items)) return d.items;
          if (obj && Array.isArray(obj.items)) return obj.items;
          // Some servers return {status:'success', item:{...}} for single; normalize to array
          if (d && d.item) return [d.item];
          if (obj && obj.item) return [obj.item];
          return [];
        };
        let folders = parseFolderList(fRes.bodyText);
        // Flatten embedded children recursively (server returns children inline)
        const seenFolderIds = new Set();
        const flat = [];
        const pushFolder = (f, parentHint = undefined) => {
          if (!f || f.id === undefined || f.id === null) return;
          if (parentHint !== undefined && (f.parent_folder === undefined || f.parent_folder === null)) f.parent_folder = parentHint;
          if (!seenFolderIds.has(f.id)) { seenFolderIds.add(f.id); flat.push(f); }
          const kids = Array.isArray(f.children) ? f.children : [];
          for (const k of kids) {
            if (k && typeof k === 'object') pushFolder(k, f.id); else if (typeof k === 'number') flat.push({ id: k, parent_folder: f.id });
          }
        };
        for (const f of (folders||[])) pushFolder(f, f.parent_folder);
        // Replace with flattened list and normalize id/parent_folder to numbers
        folders = flat.map(f => {
          const idNum = Number(f.id);
          const parentNum = (f.parent_folder === null || f.parent_folder === undefined) ? -1 : Number(f.parent_folder);
          const title = (f.title !== undefined) ? f.title : (f.name || '');
          return Object.assign({}, f, { id: idNum, parent_folder: parentNum, title });
        });
        try { debugLog('log', '[NC SYNC] fetched folders', { count: folders.length }); if (app && app.syncInProgress!==undefined) { app.syncProgress = 12; app.syncProgressText = `Preparing folders (${folders.length})…`; } } catch {}
        const byId = Object.fromEntries(folders.map(f=>[f.id, f]));
        const byTitle = Object.fromEntries(folders.map(f=>[(f.title||'').toLowerCase(), f]));

        // Limit to rootFolderId if configured (include subtree)
        const rootId = Number(bk.rootFolderId||0);
        // If we have a specific root but the server didn't return its subtree, first try to fetch child folders explicitly (BFS)
        if (rootId > 0) {
          const fetchChildrenOnce = async (pid) => {
            const results = [];
            const tryParse = (txt) => { try { const o = JSON.parse(txt||'[]'); const d=o&&o.data?o.data:o; return Array.isArray(d)?d:(d&&Array.isArray(d.items)?d.items:[]); } catch { return []; } };
            // Attempt 1: ?parent_folder=
            try {
              const u1 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder?parent_folder=${encodeURIComponent(pid)}`);
              const r1 = await MB.Extension.davRequest({ method:'GET', url:u1, headers:hJson, username: bk.username||'', password: bk.password||'' });
              if (r1?.ok) { const arr = tryParse(r1.bodyText); if (arr.length) return arr; }
            } catch {}
            // Attempt 2: ?parent=
            try {
              const u2 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder?parent=${encodeURIComponent(pid)}`);
              const r2 = await MB.Extension.davRequest({ method:'GET', url:u2, headers:hJson, username: bk.username||'', password: bk.password||'' });
              if (r2?.ok) { const arr = tryParse(r2.bodyText); if (arr.length) return arr; }
            } catch {}
            // Attempt 3: paged full list and filter by parent
            try {
              const u3 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder?page=1&limit=1000`);
              const r3 = await MB.Extension.davRequest({ method:'GET', url:u3, headers:hJson, username: bk.username||'', password: bk.password||'' });
              if (r3?.ok) { const arr = tryParse(r3.bodyText); return arr.filter(x => Number(x.parent_folder||-1) === Number(pid)); }
            } catch {}
            return results;
          };
          // BFS discover subtree
          const discovered = new Map();
          const queue = [];
          if (byId[rootId]) discovered.set(rootId, byId[rootId]); else queue.push(rootId);
          queue.push(rootId);
          const visited = new Set();
          while (queue.length) {
            const pid = queue.shift();
            if (visited.has(pid)) continue; visited.add(pid);
            let kids = [];
            try { kids = await fetchChildrenOnce(pid); } catch {}
            for (const k of (kids||[])) {
              const kid = Object.assign({}, k, { parent_folder: (k.parent_folder!==undefined?k.parent_folder:pid) });
              if (!byId[kid.id]) folders.push(kid);
              byId[kid.id] = kid; byTitle[(kid.title||'').toLowerCase()] = kid;
              if (!discovered.has(kid.id)) { discovered.set(kid.id, kid); queue.push(kid.id); }
            }
          }
          try { debugLog('log', '[NC SYNC] expanded folders via children BFS', { total: folders.length }); } catch {}
        }
        // If still only the root is known, try to expand by scanning bookmarks and fetching missing folder metas
        if (rootId > 0) {
          try {
            const allUrl = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/bookmark?page=1&limit=1000');
            const allRes = await MB.Extension.davRequest({ method:'GET', url:allUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (allRes?.ok) {
              const allItems = (function(bt){ let arr=[]; try{arr=JSON.parse(bt||'[]');}catch{}; const d=arr&&arr.data?arr.data:arr; return Array.isArray(d)?d:(d&&Array.isArray(d.items)?d.items:[]); })(allRes.bodyText);
              const needed = new Set();
              for (const it of (allItems||[])) {
                const fids = Array.isArray(it.folders) ? it.folders : [];
                for (const fid of fids) if (!byId[fid]) needed.add(fid);
              }
              for (const fid of needed) {
                try {
                  const getUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(fid)}`);
                  const r = await MB.Extension.davRequest({ method:'GET', url:getUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
                  if (r?.ok) {
                    let fo=null; try { fo = JSON.parse(r.bodyText||'null'); } catch {}
                    if (fo && fo.data && fo.data.item) fo=fo.data.item; else if (fo && fo.item) fo=fo.item; else if (fo && fo.data && !fo.id) fo=fo.data;
                    if (fo && (fo.id!==undefined)) { byId[fo.id]=fo; byTitle[(fo.title||'').toLowerCase()]=fo; folders.push(fo); }
                  }
                } catch {}
              }
              try { debugLog('log', '[NC SYNC] expanded folders via bookmark scan', { total: folders.length }); } catch {}
            }
          } catch {}
        }

        // Final fallback: try to fetch the root folder detail and inspect embedded children fields
        if (rootId > 0 && (!byId[rootId] || folders.length <= 1)) {
          try {
            const detailUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(rootId)}`);
            const det = await MB.Extension.davRequest({ method:'GET', url:detailUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (det?.ok) {
              let fo=null; try { fo = JSON.parse(det.bodyText||'null'); } catch {}
              if (fo && fo.data && fo.data.item) fo=fo.data.item; else if (fo && fo.item) fo=fo.item; else if (fo && fo.data && !fo.id) fo=fo.data;
              if (fo) {
                // Normalize a few potential child notations
                const childIds = [];
                if (Array.isArray(fo.children)) {
                  for (const c of fo.children) { if (typeof c === 'number') childIds.push(c); else if (c && c.id!==undefined) { childIds.push(c.id); if (!byId[c.id]) { byId[c.id]=c; folders.push(c); } } }
                }
                if (Array.isArray(fo.childIds)) childIds.push(...fo.childIds);
                if (fo.childCount > 0 && childIds.length === 0 && Array.isArray(fo.childs)) {
                  for (const c of fo.childs) { if (typeof c === 'number') childIds.push(c); else if (c && c.id!==undefined) { childIds.push(c.id); if (!byId[c.id]) { byId[c.id]=c; folders.push(c); } } }
                }
                // Fetch missing child meta
                for (const cid of childIds) {
                  if (byId[cid]) continue;
                  try {
                    const cu = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(cid)}`);
                    const cr = await MB.Extension.davRequest({ method:'GET', url:cu, headers:hJson, username: bk.username||'', password: bk.password||'' });
                    if (cr?.ok) { let co=null; try { co=JSON.parse(cr.bodyText||'null'); } catch {}; if (co && co.data && co.data.item) co=co.data.item; else if (co && co.item) co=co.item; else if (co && co.data && !co.id) co=co.data; if (co && co.id!==undefined) { byId[co.id]=co; folders.push(co); } }
                  } catch {}
                }
                try { debugLog('log', '[NC SYNC] expanded folders via root detail', { total: folders.length, childIds }); } catch {}
              }
            }
          } catch {}
        }
        const getChildren = (id) => {
          const f = byId[id];
          if (!f) return [];
          // children may be provided; otherwise derive from parent_folder
          let kids = [];
          if (Array.isArray(f.children)) {
            for (const ch of f.children) {
              if (typeof ch === 'number') kids.push(Number(ch));
              else if (ch && ch.id !== undefined) kids.push(Number(ch.id));
            }
          }
          if (!kids.length) {
            kids = folders.filter(x => Number(x.parent_folder||-1) === Number(id)).map(x => Number(x.id));
          }
          return kids;
        };
        const collectDescendants = (id, acc = new Set()) => {
          for (const cid of getChildren(id)) {
            if (!acc.has(cid)) { acc.add(cid); collectDescendants(cid, acc); }
          }
          return acc;
        };
        // Only sync descendants of selected root; not the root itself
        const targetIds = rootId>0 ? Array.from(collectDescendants(Number(rootId))) : folders.map(f=>Number(f.id));
        const targetFolders = folders.filter(x=> targetIds.includes(Number(x.id)));
        try { debugLog('log', '[NC SYNC] target folders', { ids: targetIds, count: targetFolders.length }); } catch {}

        let createdGroups=0, createdLinks=0, updatedLinks=0, createdFolders=0, renamedFolders=0, removedLinks=0;

        // Helper: ensure a local group exists and is linked to a given NC folder
        const ensureGroupForFolder = (folder) => {
          const title = folder.title || 'Bookmarks';
          // 1) Prefer existing mapping by folderId
          let g = (app.data.groups||[]).find(x => x.ncBookmarks && x.ncBookmarks.folderId === folder.id);
          if (g) {
            if ((g.name||'') !== title) { app.$set(g, 'name', title); }
            return g;
          }
          // 2) Fallback: find by current name and attach mapping
          g = (app.data.groups||[]).find(x => (x.name||'') === title);
          if (g) {
            app.$set(g, 'ncBookmarks', Object.assign({}, g.ncBookmarks||{}, { folderId: folder.id }));
            return g;
          }
          // 3) Create new group when not found
          g = app.getNewGroupTemplate(title);
          app.$set(g, 'ncBookmarks', Object.assign({}, g.ncBookmarks||{}, { folderId: folder.id }));
          app.data.groups.push(g);
          createdGroups++;
          return g;
        };

        // Map existing groups to folders (create folders if missing)
        for (const g of (app.data.groups||[])) {
          let fid = g.ncBookmarks?.folderId;
          if (fid && byId[fid]) { // ensure local name follows server if mapped folder exists
            const f = byId[fid];
            if (f && (g.name||'') !== (f.title||'')) app.$set(g, 'name', f.title||'Bookmarks');
            continue;
          }
          // If we have a stored mapping but it's not in the current list, trust mapping and try to fetch/insert into cache
          if (fid && !byId[fid]) {
            try {
              const getUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(fid)}`);
              const r = await MB.Extension.davRequest({ method:'GET', url:getUrl, headers:hJson, username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
              if (r?.ok) {
                let fo=null; try { fo=JSON.parse(r.bodyText||'null'); } catch {}
                // Unwrap
                if (fo && fo.data && fo.data.item) fo = fo.data.item; else if (fo && fo.item) fo = fo.item; else if (fo && fo.data && !fo.id) fo = fo.data;
                byId[fid] = fo; if (fo && (fo.title||fo.name)) byTitle[(fo.title||fo.name||'').toLowerCase()] = fo;
                debugLog('log', '[NC SYNC] Verified existing mapped folder via GET', { folderId: fid, title: fo?.title||fo?.name||'' });
                // Align group name if server has a title
                if (fo && (fo.title||fo.name) && (g.name||'') !== (fo.title||fo.name)) app.$set(g, 'name', (fo.title||fo.name));
                continue;
              } else {
                debugLog('warn', '[NC SYNC] Stored folderId not found on server, will try match/create', { folderId: fid, status: r?.status });
              }
            } catch {}
          }
          const match = byTitle[(g.name||'').toLowerCase()];
          if (match) { app.$set(g,'ncBookmarks',Object.assign({},g.ncBookmarks||{}, { folderId: match.id })); continue; }
          // create folder (only if enabled)
          if (bk.autoCreateFolders) {
            try {
              const cUrl = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
              const payload = { title: g.name||'Bookmarks' };
              if (rootId && rootId > 0) payload.parent_folder = rootId;
              try { debugLog('log', '[NC SYNC] Creating folder', { title: payload.title, parent_folder: payload.parent_folder||null }); } catch {}
              const cRes = await MB.Extension.davRequest({ method:'POST', url:cUrl, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(payload), username: bk.username||'', password: bk.password||'' });
              if (cRes.ok) { let cf=null; try{ cf=JSON.parse(cRes.bodyText||'null'); }catch{}; cf = unwrapNc(cf); const id=cf?.id; app.$set(g,'ncBookmarks',Object.assign({},g.ncBookmarks||{}, { folderId:id })); createdFolders++; if (id!==undefined) { byId[id]=cf; byTitle[(cf.title||'').toLowerCase()]=cf; } try { debugLog('log', '[NC SYNC] Created folder OK', { id, title: cf?.title, parent_folder: cf?.parent_folder }); } catch {} }
              else { try { debugLog('error', '[NC SYNC] Create folder FAILED', { status:cRes.status, bodyHead:(cRes.bodyText||'').slice(0,300) }); } catch {} }
            } catch {}
          }
        }

        // Rename handling: if names differ, either push rename (if enabled) or take server name into local
        for (const g of (app.data.groups||[])) {
          const fid = g.ncBookmarks?.folderId; if (!fid) continue;
          const f = byId[fid]; if (!f) continue;
          if ((f.title||'') !== (g.name||'')) {
            if (bk.autoRenameFolders) {
              try {
                const uUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(fid)}`);
                const uRes = await MB.Extension.davRequest({ method:'PATCH', url:uUrl, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify({ title: g.name||'' }), username: bk.username||'', password: bk.password||'' });
                if (uRes.ok) { let pf=null; try{ pf=JSON.parse(uRes.bodyText||'null'); } catch{}; pf = pf && pf.data && !pf.id ? pf.data : pf; if (pf && (pf.title || pf.id)) { f.title = pf.title || (g.name||''); } else { f.title = g.name||''; } renamedFolders++; byTitle[(f.title||'').toLowerCase()]=f; }
              } catch {}
            } else {
              // Server wins: rename local group to server title
              app.$set(g, 'name', f.title||'Bookmarks');
            }
          }
        }

        // 2) For each folder, fetch bookmarks
        const folderHashes = Object.assign({}, app.data.options?.bookmarks?.folderHashes||{});
        // Build an index of all local links by Nextcloud bookmark ID for robust matching/moves
        const localByNcId = new Map();
        for (const g of (app.data.groups||[])) {
          for (const l of (g.links||[])) {
            const nid = l?.ncBookmarks?.id;
            if (nid) localByNcId.set(nid, { group: g, link: l });
          }
        }
        let __pulledIdx = 0; const __pullTotal = targetFolders.length||1;
        for (const folder of targetFolders) {
          const hUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/folder/${encodeURIComponent(folder.id)}/hash?hashFn=xxh32`);
          let mustFetch = true;
          try {
            const hRes = await MB.Extension.davRequest({ method:'GET', url:hUrl, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (hRes.ok) {
              let newH = (hRes.bodyText||'').trim();
              try {
                const parsed = JSON.parse(hRes.bodyText||'null');
                if (parsed && typeof parsed === 'object') {
                  if (parsed.hash) newH = String(parsed.hash);
                  else if (typeof parsed.data === 'string') newH = parsed.data;
                  else if (parsed.data && typeof parsed.data === 'object' && parsed.data.hash) newH = String(parsed.data.hash);
                }
              } catch {}
              const oldH = folderHashes[folder.id] || null;
              if (newH && oldH===newH) mustFetch=false; else folderHashes[folder.id]=newH;
              debugLog('log', '[NC SYNC] folder hash decision', { folderId: folder.id, oldHash: oldH, newHash: newH, mustFetchDefault: mustFetch, forceFetchAll });
            }
          } catch {}
          if (!mustFetch && !forceFetchAll) {
            debugLog('log', '[NC SYNC] hash unchanged; still fetching to detect remote edits', { folderId: folder.id });
          }
          let items = await fetchFolderItems(folder.id);
            try {
              debugLog('log', '[NC SYNC] fetched items for folder', { folderId: folder.id, count: items.length });
              if (TRACE_NC_ID>0 && items.some(ii=> Number(ii.id)===TRACE_NC_ID)) traceFlags.folderItem = true;
              if (app && app.syncInProgress) { __pulledIdx++; app.syncProgressText = `Pulling folders (${__pulledIdx}/${__pullTotal})…`; app.syncProgress = 12 + Math.round((__pulledIdx/__pullTotal)*53); }
            } catch {}
          const group = ensureGroupForFolder(folder);
          if (!group.links) app.$set(group,'links',[]);
          app.$set(group, 'ncBookmarks', Object.assign({}, group.ncBookmarks||{}, { folderId: folder.id }));
          const remoteIds = new Set(items.map(i=>i.id));

          for (const it of items) {
            const url = it.url || '';
            const text = it.title || url;
            const tags = Array.isArray(it.tags)? it.tags : [];
            const desc = it.description || '';
            const ncId = it.id;
            const remoteUpdatedAt = parseNcTs(it.lastmodified || it.lastModified || it.updated || it.edited || it.lastUpdate || it.mtime || it.modTime);
            // Skip re-adding items that are pending deletion locally
            try {
              const pending = Array.isArray(app.data.pendingNcDeletes) ? app.data.pendingNcDeletes : [];
              if (pending.some(pd => (pd.id && Number(pd.id)===Number(ncId)) || (pd.url && pd.url===url))) {
                debugLog('log', '[NC SYNC] Skipping item (pending local deletion)', { id: ncId, url });
                continue;
              }
            } catch {}
            try { if (Number(ncId) === TRACE_NC_ID) debugLog('log', '[NC-TRACE 2073] Folder fetch item', { item: MB.Utils.safeClone(it), remoteUpdatedAt }); } catch {}
            // Prefer global match by Nextcloud ID across all groups
            let existingEntry = localByNcId.get(ncId) || null;
            let existing = existingEntry?.link || null;
            if (existing && existingEntry.group !== group) {
              // Move locally to the correct group to reflect server structure
              try {
                const src = existingEntry.group;
                const idx = (src.links||[]).indexOf(existing);
                if (idx >= 0) src.links.splice(idx, 1);
              } catch {}
              if (!group.links) app.$set(group,'links',[]);
              group.links.push(existing);
              // Update index to new group
              localByNcId.set(ncId, { group, link: existing });
            }
            if (!existing) {
              // Fallback: search in current group by id or url
              existing = group.links.find(l=> (l.ncBookmarks && l.ncBookmarks.id===ncId) || (l.url && l.url===url));
              if (existing) localByNcId.set(ncId, { group, link: existing });
            }
            const linkObj = {
              uuid: existing?.uuid || (app.generateUUID()),
              text, url,
              keywords: tags.join(', '),
              infoHtml: desc,
              deleted: false,
              ncBookmarks: { id:ncId, folderId:folder.id, lastSyncedAt:Date.now(), remoteUpdatedAt, localUpdatedAt: 0, justPulled: sessionId }
            };
            // Compute a local hash for change detection symmetry with push phase
            try {
              const payloadForHash = { text:linkObj.text||'', url:linkObj.url||'', keywords:linkObj.keywords||'', infoHtml:linkObj.infoHtml||'' };
              linkObj.ncBookmarks.lastHash = btoa(unescape(encodeURIComponent(JSON.stringify(payloadForHash))));
            } catch { linkObj.ncBookmarks.lastHash = ''; }
            // Also remember remote signature to detect remote changes without timestamp
            linkObj.ncBookmarks.remoteSig = linkObj.ncBookmarks.lastHash;
            if (existing) {
              try {
                if (Number(ncId) === TRACE_NC_ID) { traceFlags.merge = true; debugLog('log', '[NC-TRACE 2073] Before merge existing', {
                  group: group.name,
                  existing: MB.Utils.safeClone(existing),
                  incoming: MB.Utils.safeClone({ text, url, tags, desc, ncId, remoteUpdatedAt })
                }); }
              } catch {}
              // Decide direction per link based on timestamps and signatures
              const prevNB = existing.ncBookmarks || {};
              const prevLocalAt = parseNcTs(prevNB.localUpdatedAt || 0);
              const prevRemoteAt = parseNcTs(prevNB.remoteUpdatedAt || 0);
              // Compute local signature from current existing content BEFORE any overwrite
              let localSig = '';
              try { localSig = btoa(unescape(encodeURIComponent(JSON.stringify({ text: existing.text||'', url: existing.url||'', keywords: existing.keywords||'', infoHtml: existing.infoHtml||'' })))); } catch { localSig = JSON.stringify({ text: existing.text||'', url: existing.url||'', keywords: existing.keywords||'', infoHtml: existing.infoHtml||'' }); }
              const prevLastHash = prevNB.lastHash || '';
              const localChanged = (!prevLastHash || prevLastHash !== localSig) || !!prevLocalAt;
              const rSig = linkObj.ncBookmarks.lastHash || '';
              const storedRemoteSig = prevNB.remoteSig || '';
              const remoteChanged = (rSig !== storedRemoteSig) || (remoteUpdatedAt && remoteUpdatedAt > prevRemoteAt);
              // If remote is newer or no local change, adopt remote; otherwise keep local and only refresh remote meta
              const remoteWins = remoteChanged && (!localChanged || (remoteUpdatedAt && remoteUpdatedAt >= prevLocalAt));
              try {
                if (Number(ncId) === TRACE_NC_ID) { debugLog('log', '[NC-TRACE 2073] Merge decision', {
                  prevLocalAt, prevRemoteAt, remoteUpdatedAt, localSig, prevLastHash,
                  localChanged, remoteChanged, storedRemoteSig, rSig, remoteWins
                }); }
              } catch {}
              if (remoteWins) {
                existing.text = linkObj.text; existing.url = linkObj.url; existing.keywords = linkObj.keywords; existing.infoHtml = linkObj.infoHtml;
                existing.ncBookmarks = Object.assign({}, prevNB, linkObj.ncBookmarks, { remoteSig: rSig, lastHash: rSig, localUpdatedAt: 0 });
              } else {
                // Keep local content; refresh mapping/meta only
                existing.ncBookmarks = Object.assign({}, prevNB, {
                  id: linkObj.ncBookmarks.id,
                  folderId: linkObj.ncBookmarks.folderId,
                  lastSyncedAt: Date.now(),
                  remoteUpdatedAt: Math.max(prevRemoteAt, parseNcTs(linkObj.ncBookmarks.remoteUpdatedAt||0)),
                  remoteSig: rSig || storedRemoteSig,
                  // keep lastHash and localUpdatedAt as-is to push later
                });
              }
              try { if (Number(ncId) === TRACE_NC_ID) debugLog('log', '[NC-TRACE 2073] After merge', { existing: MB.Utils.safeClone(existing) }); } catch {}
              existing.deleted = false; updatedLinks++;
            } else { group.links.push(linkObj); createdLinks++; }
          }
          // Remove local links that are no longer on server (same folder & has nc id)
          const before = group.links.length;
          group.links = group.links.filter(l=> !(l.ncBookmarks && l.ncBookmarks.folderId===folder.id && l.ncBookmarks.id && !remoteIds.has(l.ncBookmarks.id)));
          removedLinks += (before - group.links.length);
          // Persist folder hash
          app.$set(app.data.options.bookmarks, 'folderHashes', Object.assign({}, folderHashes));
          app.saveData();
        }

        // 2.4) Try to resolve missing NC IDs by URL (to avoid creating/updating wrong records)
        const fetchByUrl = async (u) => {
          if (!u) return null;
          const tryParseList = (bodyText, label) => {
            let parsed=null; try { parsed = JSON.parse(bodyText||'[]'); } catch {}
            const d = parsed && parsed.data ? parsed.data : parsed;
            const items = Array.isArray(d) ? d : (d && Array.isArray(d.items) ? d.items : []);
            if (!Array.isArray(items)) return [];
            return items;
          };
          const norm = (s) => { try { return decodeURIComponent(String(s||'').trim()); } catch { return String(s||'').trim(); } };
          const cand = [];
          try {
            const url1 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?url=${encodeURIComponent(u)}&page=1&limit=5`);
            const r1 = await MB.Extension.davRequest({ method:'GET', url:url1, headers:hJson, username: bk.username||'', password: bk.password||'' });
            if (r1?.ok) { cand.push(...tryParseList(r1.bodyText, 'byUrl')); }
          } catch {}
          if (!cand.length) {
            try {
              const url2 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark?search=${encodeURIComponent(u)}&page=1&limit=20`);
              const r2 = await MB.Extension.davRequest({ method:'GET', url:url2, headers:hJson, username: bk.username||'', password: bk.password||'' });
              if (r2?.ok) { cand.push(...tryParseList(r2.bodyText, 'search')); }
            } catch {}
          }
          const target = cand.find(x => norm(x.url) === norm(u)) || null;
          return target;
        };

        try {
          for (const gg of (app.data.groups||[])) {
            for (const ll of (gg.links||[])) {
              if (ll?.ncBookmarks?.id) continue;
              if (!ll?.url) continue;
              try {
                const remote = await fetchByUrl(ll.url);
                if (remote && remote.id) {
                  const rUpdated = parseNcTs(remote.lastmodified || remote.lastModified || remote.updated || remote.edited || remote.lastUpdate || remote.mtime || remote.modTime);
                  const rTags = Array.isArray(remote.tags)? remote.tags : [];
                  const rPayload = { text: (remote.title||remote.url||''), url: (remote.url||''), keywords: rTags.join(', '), infoHtml: (remote.description||'') };
                  let rSig = '';
                  try { rSig = btoa(unescape(encodeURIComponent(JSON.stringify(rPayload)))); } catch { rSig = JSON.stringify(rPayload); }
                  const nb = Object.assign({}, ll.ncBookmarks||{}, { id: remote.id, folderId: (Array.isArray(remote.folders) && remote.folders[0]) ? remote.folders[0] : (gg.ncBookmarks?.folderId||0), remoteUpdatedAt: rUpdated||0, remoteSig: rSig });
                  // Keep local lastHash/localUpdatedAt as-is (we're only attaching ID here)
                  app.$set(ll, 'ncBookmarks', nb);
                  debugLog('log', '[NC SYNC] Resolved remote id by URL', { url: ll.url, id: remote.id, folderId: nb.folderId });
                }
              } catch {}
            }
          }
        } catch {}

        // 2.5) Remote-first reconcile per link (independent of folder hashes)
        try {
          const allLocal = [];
          for (const gg of (app.data.groups||[])) {
            for (const ll of (gg.links||[])) {
              if (ll?.ncBookmarks?.id) allLocal.push({ group: gg, link: ll });
            }
          }
          for (const entry of allLocal) {
            const ll = entry.link; const gg = entry.group;
            try {
              const remoteObj = await fetchBookmark(ll.ncBookmarks.id);
              if (!remoteObj) continue;
              const rUpdated = parseNcTs(remoteObj.lastmodified || remoteObj.lastModified || remoteObj.updated || remoteObj.edited || remoteObj.lastUpdate || remoteObj.mtime || remoteObj.modTime);
              const knownRemote = parseNcTs(ll.ncBookmarks?.remoteUpdatedAt||0);
              const localUpdatedAt = parseNcTs(ll.ncBookmarks?.localUpdatedAt || 0);
              const rTags = Array.isArray(remoteObj.tags)? remoteObj.tags : [];
              const rPayload = { text: (remoteObj.title||remoteObj.url||''), url: (remoteObj.url||''), keywords: rTags.join(', '), infoHtml: (remoteObj.description||'') };
              let rSig = '';
              try { rSig = btoa(unescape(encodeURIComponent(JSON.stringify(rPayload)))); } catch { rSig = JSON.stringify(rPayload); }
              const storedRemoteSig = ll.ncBookmarks?.remoteSig || '';
              const remoteChanged = (rSig !== storedRemoteSig) || (rUpdated && rUpdated > knownRemote);
              const lastHash = ll.ncBookmarks?.lastHash || '';
              const nextHash = (function(){ try { return btoa(unescape(encodeURIComponent(JSON.stringify({ text: ll.text||'', url: ll.url||'', keywords: ll.keywords||'', infoHtml: ll.infoHtml||'' })))); } catch { return JSON.stringify({ text: ll.text||'', url: ll.url||'', keywords: ll.keywords||'', infoHtml: ll.infoHtml||'' }); } })();
              const localChanged = (!lastHash || lastHash !== nextHash);
              try {
                if (Number(ll.ncBookmarks.id) === TRACE_NC_ID) { traceFlags.reconcile = true; debugLog('log', '[NC-TRACE 2073] Reconcile entry', {
                  group: gg.name,
                  remoteObj: MB.Utils.safeClone(remoteObj),
                  rUpdated, knownRemote, localUpdatedAt, storedRemoteSig, rSig,
                  lastHash, nextHash, localChanged, remoteChanged
                }); }
              } catch {}
              debugLog('log', '[NC SYNC] Reconcile preflight', { id: ll.ncBookmarks.id, rUpdated, knownRemote, localUpdatedAt, remoteChanged, localChanged });
              if (remoteChanged && (!localChanged || rUpdated === 0 || (rUpdated && rUpdated >= localUpdatedAt))) {
                // Apply remote to local
                ll.url = rPayload.url;
                ll.text = rPayload.text || rPayload.url;
                ll.keywords = rPayload.keywords;
                ll.infoHtml = rPayload.infoHtml;
                ll.deleted = false;
                ll.ncBookmarks.remoteUpdatedAt = rUpdated || Date.now();
                ll.ncBookmarks.lastHash = rSig;
                ll.ncBookmarks.remoteSig = rSig;
                ll.ncBookmarks.localUpdatedAt = 0;
                // Optional: respect remote folder move (first folder if provided)
                const rFolders = Array.isArray(remoteObj.folders) ? remoteObj.folders : [];
                if (rFolders.length) {
                  const targetFolderId = rFolders[0];
                  if (targetFolderId && targetFolderId !== ll.ncBookmarks.folderId) {
                    const targetGroup = (app.data.groups||[]).find(x=> x.ncBookmarks && x.ncBookmarks.folderId === targetFolderId);
                    if (targetGroup && targetGroup !== gg) {
                      try { const idx = (gg.links||[]).indexOf(ll); if (idx>=0) gg.links.splice(idx,1); } catch {}
                      if (!targetGroup.links) app.$set(targetGroup, 'links', []);
                      targetGroup.links.push(ll);
                      ll.ncBookmarks.folderId = targetFolderId;
                    }
                  }
                }
                debugLog('log', '[NC SYNC] Reconcile applied remote', { id: ll.ncBookmarks.id });
              }
            } catch {}
          }
        } catch {}

        // 3) Push local changes (best-effort)
        try {
          const totalLinks = (app.data.groups||[]).reduce((s,g)=> s + ((g.links||[]).length), 0);
          debugLog('log', '[NC SYNC] Begin push phase', { groups: (app.data.groups||[]).length, totalLinks });
          if (app && app.syncInProgress) { app.syncProgressText = totalLinks ? `Pushing updates (0/${totalLinks})…` : 'Finalizing…'; app.syncProgress = Math.max(app.syncProgress, 70); }
        } catch {}

        // 3.1) Process pending deletions (tombstones) queued from local deletes
        try {
          const pending = Array.isArray(app.data.pendingNcDeletes) ? [...app.data.pendingNcDeletes] : [];
          for (const pd of pending) {
            if (!pd?.id) continue;
            const delUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(pd.id)}`);
            let delRes = null; try { delRes = await MB.Extension.davRequest({ method:'DELETE', url: delUrl, headers:hJson, username: bk.username||'', password: bk.password||'' }); } catch { delRes = { ok:false, status:0 }; }
            // Accept 2xx and 404 as success (already gone)
            if (delRes?.ok || delRes?.status === 404) {
              try {
                app.data.pendingNcDeletes = (app.data.pendingNcDeletes||[]).filter(x => x !== pd);
                debugLog('log', '[NC SYNC] Remote delete OK', { id: pd.id, status: delRes?.status||200 });
              } catch {}
            } else {
              debugLog('warn', '[NC SYNC] Remote delete failed (will retry later)', { id: pd.id, status: delRes?.status });
            }
          }
          app.saveData();
        } catch {}
        // Hash only content fields (exclude folderId to detect moves separately)
        const computeHash = (l) => {
          const payload = { text:l.text||'', url:l.url||'', keywords:l.keywords||'', infoHtml:l.infoHtml||'' };
          try { return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))); } catch { return JSON.stringify(payload); }
        };
        let pushedNew=0, pushedUpd=0, pushedDel=0, skipped=0;
        let __pushed=0; const __pushTotal = (app.data.groups||[]).reduce((s,g)=> s + ((g.links||[]).length), 0) || 1;
        for (const g of (app.data.groups||[])) {
          // Ensure folder mapping for this group before pushing links
          let fId = g.ncBookmarks?.folderId;
          if (!fId) {
            try {
              const match = byTitle[(g.name||'').toLowerCase()];
              if (match && match.id) {
                app.$set(g, 'ncBookmarks', Object.assign({}, g.ncBookmarks||{}, { folderId: match.id }));
                fId = match.id;
                debugLog('log', '[NC SYNC] Mapped group to existing NC folder', { group: g.name, folderId: fId });
              } else if (bk.autoCreateFolders) {
                const cUrl = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
                const payload = { title: g.name||'Bookmarks' };
                if (rootId && rootId > 0) payload.parent_folder = rootId;
                debugLog('log', '[NC SYNC] Creating folder (push ensure)', { title: payload.title, parent_folder: payload.parent_folder||null });
                const cRes = await MB.Extension.davRequest({ method:'POST', url:cUrl, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(payload), username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
                if (cRes?.ok) {
                  let cf=null; try{ cf=JSON.parse(cRes.bodyText||'null'); }catch{}; cf = unwrapNc(cf); const id=cf?.id;
                  app.$set(g,'ncBookmarks',Object.assign({},g.ncBookmarks||{}, { folderId:id }));
                  if (id!==undefined) { byId[id]=cf; byTitle[(cf.title||'').toLowerCase()]=cf; fId = id; }
                  debugLog('log', '[NC SYNC] Created folder (push ensure) OK', { id: id, title: cf?.title, parent_folder: cf?.parent_folder, raw: (cRes.bodyText||'').slice(0,200) });
                } else {
                  debugLog('error', '[NC SYNC] Create folder (push ensure) FAILED', { status:cRes?.status, bodyHead:(cRes?.bodyText||'').slice(0,300) });
                }
              }
            } catch {}
          }
          for (const l of (g.links||[])) {
            try { debugLog('log', '[NC SYNC][LOCAL] Push candidate', { group: g.name, link: MB.Utils.safeClone(l) }); } catch {}
            try { if (app && app.syncInProgress) { __pushed++; app.syncProgressText = `Pushing updates (${__pushed}/${__pushTotal})…`; app.syncProgress = 70 + Math.round((__pushed/__pushTotal)*25); } } catch {}
            const pulledInSession = l.ncBookmarks?.justPulled === sessionId;
            // DELETE
            if (l.deleted && l.ncBookmarks?.id) {
              const dUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(l.ncBookmarks.id)}`);
              const dRes = await MB.Extension.davRequest({ method:'DELETE', url:dUrl, headers:hJson, username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
              if (dRes?.ok) { pushedDel++; l.ncBookmarks=null; } else skipped++;
              continue;
            }
            // CREATE
            if (!l.deleted && !l.ncBookmarks?.id && fId) {
              const tags = (Array.isArray(l.keywords)?l.keywords:(l.keywords||'')).toString().split(',').map(s=>s.trim()).filter(Boolean);
              const payload = { url:l.url||'', title:l.text||l.url||'', description:l.infoHtml||'', tags, folders: [fId] };
              const cUrl = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/bookmark');
              try { debugLog('log', '[NC SYNC] Creating bookmark', { group: g.name, folderId: fId, payload: MB.Utils.safeClone(payload) }); } catch {}
              // Skip create if URL is empty or clearly invalid for NC
              if (!payload.url || !/^https?:\/\//i.test(payload.url)) {
                try { debugLog('warn', '[NC SYNC] Skip create: invalid or empty URL', { group: g.name, url: payload.url, title: payload.title }); } catch {}
                skipped++;
                continue;
              }
              const cRes = await MB.Extension.davRequest({ method:'POST', url:cUrl, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(payload), username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
              if (cRes?.ok) {
                let created=null; try { created=JSON.parse(cRes.bodyText||'null'); } catch {}
                created = unwrapNc(created);
                const nid = created?.id; app.$set(l, 'ncBookmarks', { id:nid, folderId:fId, lastSyncedAt:Date.now(), lastHash:computeHash(l) }); pushedNew++;
                try { debugLog('log', '[NC SYNC] Created bookmark OK', { id: nid, folderId: fId }); } catch {}
              } else { skipped++; try { debugLog('error', '[NC SYNC] Create bookmark FAILED', { status:cRes?.status, bodyHead:(cRes?.bodyText||'').slice(0,300) }); } catch {} }
              continue;
            }
            // No ID and no folder mapping: cannot create
            if (!l.deleted && !l.ncBookmarks?.id && !fId) {
              try { debugLog('warn', '[NC SYNC] Skip create: no folder mapping for group', { group: g.name, linkUuid: l.uuid, linkText: l.text }); } catch {}
            }
            // UPDATE
            if (!l.deleted && l.ncBookmarks?.id) {
              const nextHash = computeHash(l), lastHash = l.ncBookmarks?.lastHash||'';
              const localUpdatedAtVal = parseNcTs(l.ncBookmarks?.localUpdatedAt || 0);
              const knownRemoteVal = parseNcTs(l.ncBookmarks?.remoteUpdatedAt || 0);
              const localChangedByHash = (!lastHash || lastHash !== nextHash);
              let localChanged = localChangedByHash || (localUpdatedAtVal && (!knownRemoteVal || localUpdatedAtVal > knownRemoteVal));
              if (localChangedByHash && !l.ncBookmarks.localUpdatedAt) { l.ncBookmarks.localUpdatedAt = Date.now(); }
              const moveNeeded = !!(fId && l.ncBookmarks?.folderId !== fId);
              if (!moveNeeded && lastHash && lastHash === nextHash) {
                // Even if no local change, preflight remote to detect newer server edits
                try {
                  const remoteObj0 = await fetchBookmark(l.ncBookmarks.id);
                  if (remoteObj0) {
                    const rUpdated0 = parseNcTs(remoteObj0.lastmodified || remoteObj0.lastModified || remoteObj0.updated || remoteObj0.edited || remoteObj0.lastUpdate || remoteObj0.mtime || remoteObj0.modTime);
                    const knownRemote0 = parseNcTs(l.ncBookmarks?.remoteUpdatedAt||0);
                    const rTags0 = Array.isArray(remoteObj0.tags)? remoteObj0.tags : [];
                    const rPayload0 = { text: (remoteObj0.title||remoteObj0.url||''), url: (remoteObj0.url||''), keywords: rTags0.join(', '), infoHtml: (remoteObj0.description||'') };
                    let rSig0 = '';
                    try { rSig0 = btoa(unescape(encodeURIComponent(JSON.stringify(rPayload0)))); } catch { rSig0 = JSON.stringify(rPayload0); }
                    const storedRemoteSig0 = l.ncBookmarks?.remoteSig || '';
                    const remoteChanged0 = (rSig0 !== storedRemoteSig0) || (rUpdated0 && rUpdated0 > knownRemote0);
                    const localUpdatedAt0 = parseNcTs(l.ncBookmarks?.localUpdatedAt || 0);
                    try { if (Number(l.ncBookmarks.id) === TRACE_NC_ID) { traceFlags.pushPre0 = true; debugLog('log', '[NC-TRACE 2073] Push preflight (no-local-change)', { rUpdated0, knownRemote0, localUpdatedAt0, remoteChanged0, storedRemoteSig0, rSig0, remoteObj0: MB.Utils.safeClone(remoteObj0) }); } } catch {}
                    debugLog('log', '[NC SYNC] Preflight (no-local-change) fetched remote', { id: l.ncBookmarks?.id, rUpdated: rUpdated0, knownRemote: knownRemote0, localUpdatedAt: localUpdatedAt0, remoteChanged: remoteChanged0, storedRemoteSig: storedRemoteSig0, rSig: rSig0 });
                    if (remoteChanged0 && (rUpdated0 === 0 || (rUpdated0 && rUpdated0 >= localUpdatedAt0))) {
                      // Remote newer: adopt remote locally, skip push
                      try {
                        l.url = rPayload0.url;
                        l.text = rPayload0.text || rPayload0.url;
                        l.keywords = rPayload0.keywords;
                        l.infoHtml = rPayload0.infoHtml;
                        l.deleted = false;
                        l.ncBookmarks.remoteUpdatedAt = rUpdated0 || Date.now();
                        l.ncBookmarks.lastHash = rSig0;
                        l.ncBookmarks.remoteSig = rSig0;
                        l.ncBookmarks.localUpdatedAt = 0;
                      } catch {}
                      debugLog('log', '[NC SYNC] Remote wins (no-local-change), skip push', { id: l.ncBookmarks?.id });
                      skipped++; continue;
                    }
                  } else {
                    // Remote record missing (likely deleted) -> CREATE fallback even without local content change
                    try { debugLog('warn', '[NC SYNC] Remote record missing for id, creating anew', { id: l.ncBookmarks?.id, group: g.name, folderId: fId }); } catch {}
                    const tags2 = (Array.isArray(l.keywords)?l.keywords:(l.keywords||'')).toString().split(',').map(s=>s.trim()).filter(Boolean);
                    const createPayload = { url:l.url||'', title:l.text||l.url||'', description:l.infoHtml||'', tags: tags2, folders: [fId] };
                    if (!createPayload.url || !/^https?:\/\//i.test(createPayload.url)) { skipped++; try { debugLog('warn', '[NC SYNC] Fallback CREATE (no-change) skipped: invalid URL', { url:createPayload.url }); } catch {} }
                    else {
                      const cUrl2 = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/bookmark');
                      const cRes2 = await MB.Extension.davRequest({ method:'POST', url:cUrl2, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(createPayload), username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
                      if (cRes2?.ok) {
                        let created2=null; try { created2=JSON.parse(cRes2.bodyText||'null'); } catch {}
                        created2 = unwrapNc(created2);
                        const nid2 = created2?.id; app.$set(l, 'ncBookmarks', { id:nid2, folderId:fId, lastSyncedAt:Date.now(), lastHash:computeHash(l) }); pushedNew++;
                        try { debugLog('log', '[NC SYNC] Fallback CREATE (no-change) OK', { id: nid2, folderId: fId }); } catch {}
                        continue;
                      } else {
                        skipped++;
                        try { debugLog('error', '[NC SYNC] Fallback CREATE (no-change) FAILED', { status:cRes2?.status, bodyHead:(cRes2?.bodyText||'').slice(0,300) }); } catch {}
                      }
                    }
                  }
                } catch {}
                debugLog('log', '[NC SYNC] Skip update (no local change, no move)', { id: l.ncBookmarks?.id, groupFolder: fId });
                skipped++; continue;
              }
              // If this item was just pulled in this session, avoid overwriting remote content; allow pure MOVE
              let allowContentUpdate = !pulledInSession && (!lastHash || lastHash !== nextHash);
              // Preflight: ALWAYS check remote to avoid overwriting newer server data
              {
                const remoteObj = await fetchBookmark(l.ncBookmarks.id);
                if (remoteObj) {
                  try { debugLog('log', '[NC SYNC][REMOTE] Preflight item', { id: l.ncBookmarks?.id, remote: MB.Utils.safeClone(remoteObj) }); } catch {}
                  const rUpdated = parseNcTs(remoteObj.lastmodified || remoteObj.lastModified || remoteObj.updated || remoteObj.edited || remoteObj.lastUpdate || remoteObj.mtime || remoteObj.modTime);
                  const knownRemote = parseNcTs(l.ncBookmarks?.remoteUpdatedAt||0);
                  // Compute remote content signature
                  const rTags = Array.isArray(remoteObj.tags)? remoteObj.tags : [];
                  const rPayload = { text: (remoteObj.title||remoteObj.url||''), url: (remoteObj.url||''), keywords: rTags.join(', '), infoHtml: (remoteObj.description||'') };
                  let rSig = '';
                  try { rSig = btoa(unescape(encodeURIComponent(JSON.stringify(rPayload)))); } catch { rSig = JSON.stringify(rPayload); }
                  const storedRemoteSig = l.ncBookmarks?.remoteSig || '';
                  const remoteChanged = (rSig !== storedRemoteSig) || (rUpdated && rUpdated > knownRemote);
                  const localUpdatedAt = parseNcTs(l.ncBookmarks?.localUpdatedAt || 0);
                  try { if (Number(l.ncBookmarks.id) === TRACE_NC_ID) { traceFlags.pushPre = true; debugLog('log', '[NC-TRACE 2073] Push preflight (with-local-change)', { rUpdated, knownRemote, localUpdatedAt, remoteChanged, storedRemoteSig, rSig, nextHash, lastHash, moveNeeded, allowContentUpdate, remoteObj: MB.Utils.safeClone(remoteObj) }); } } catch {}
                  debugLog('log', '[NC SYNC] Preflight fetched remote', { id: l.ncBookmarks?.id, rUpdated, knownRemote, localUpdatedAt, remoteChanged, localChanged, storedRemoteSig, rSig });
                  if (remoteChanged && (!localChanged || rUpdated === 0 || (rUpdated && rUpdated >= localUpdatedAt))) {
                    // Remote wins: adopt remote content locally, update hashes/sigs, and skip pushing content
                    try {
                      l.url = rPayload.url;
                      l.text = rPayload.text || rPayload.url;
                      l.keywords = rPayload.keywords;
                      l.infoHtml = rPayload.infoHtml;
                      l.deleted = false;
                      l.ncBookmarks.remoteUpdatedAt = rUpdated || Date.now();
                      l.ncBookmarks.lastHash = rSig; // sync local content hash to remote
                      l.ncBookmarks.remoteSig = rSig;
                      l.ncBookmarks.localUpdatedAt = 0;
                      // Remote folder move handling
                      const rFolders = Array.isArray(remoteObj.folders) ? remoteObj.folders : [];
                      if (rFolders.length) {
                        const targetFolderId = rFolders[0];
                        if (targetFolderId && targetFolderId !== l.ncBookmarks.folderId) {
                          const targetGroup = (app.data.groups||[]).find(x=> x.ncBookmarks && x.ncBookmarks.folderId === targetFolderId);
                          if (targetGroup && targetGroup !== g) {
                            try { const idx = (g.links||[]).indexOf(l); if (idx>=0) g.links.splice(idx,1); } catch {}
                            if (!targetGroup.links) app.$set(targetGroup, 'links', []);
                            targetGroup.links.push(l);
                            l.ncBookmarks.folderId = targetFolderId;
                          }
                        }
                      }
                    } catch {}
                    // Allow a pure MOVE even when remote changed (folders-only patch)
                    if (moveNeeded) {
                      const p = { folders: [fId] };
                      const uUrl2 = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(l.ncBookmarks.id)}`);
                      await MB.Extension.davRequest({ method:'PATCH', url:uUrl2, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(p) }).catch(()=>({ok:false}));
                      l.ncBookmarks.folderId = fId;
                    }
                    debugLog('log', '[NC SYNC] Remote wins, skip local content push', { id: l.ncBookmarks?.id });
                    skipped++;
                    continue;
                  }
                  // else: only local changed → continue to push content
                  // Extra safety: even if remoteChanged=false (e.g. equal signature), never push content if remote timestamp is newer
                  if (rUpdated && rUpdated > localUpdatedAt) {
                    debugLog('log', '[NC SYNC] Remote newer (timestamp), suppressing content push', { id: l.ncBookmarks?.id, rUpdated, localUpdatedAt });
                    allowContentUpdate = false;
                    if (!moveNeeded) { skipped++; continue; }
                    // fall through to allow a pure MOVE-only PATCH below
                  }
                }
              }
              const tags = (Array.isArray(l.keywords)?l.keywords:(l.keywords||'')).toString().split(',').map(s=>s.trim()).filter(Boolean);
              const payload = {};
              if (allowContentUpdate) {
                Object.assign(payload, { url:l.url||'', title:l.text||l.url||'', description:l.infoHtml||'', tags });
              }
              if (moveNeeded) { payload.folders = [fId]; }
              debugLog('log', '[NC SYNC] Pushing update', { id: l.ncBookmarks?.id, contentUpdate: !!allowContentUpdate, move: moveNeeded, payloadKeys: Object.keys(payload) });
              const uUrl = MB.CardDAV.joinUrl(serverUrl, `/index.php/apps/bookmarks/public/rest/v2/bookmark/${encodeURIComponent(l.ncBookmarks.id)}`);
              const uRes = await MB.Extension.davRequest({ method:'PATCH', url:uUrl, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(payload), username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
              if (uRes?.ok) {
                // Fetch latest remote to refresh timestamps/signature
                let after=null; try { after = await fetchBookmark(l.ncBookmarks.id); } catch {}
                let rUpdated2 = 0; let rSig2 = nextHash;
                if (after) {
                  rUpdated2 = parseNcTs(after.lastmodified || after.lastModified || after.updated || after.edited || after.lastUpdate || after.mtime || after.modTime);
                  const aTags = Array.isArray(after.tags)? after.tags : [];
                  const aPayload = { text: (after.title||after.url||''), url: (after.url||''), keywords: aTags.join(', '), infoHtml: (after.description||'') };
                  try { rSig2 = btoa(unescape(encodeURIComponent(JSON.stringify(aPayload)))); } catch { rSig2 = JSON.stringify(aPayload); }
                }
                l.ncBookmarks.lastHash = nextHash; l.ncBookmarks.lastSyncedAt = Date.now();
                l.ncBookmarks.remoteSig = rSig2; // remote now matches local
                l.ncBookmarks.remoteUpdatedAt = rUpdated2 || Date.now();
                l.ncBookmarks.localUpdatedAt = 0;
                if (moveNeeded) l.ncBookmarks.folderId = fId; pushedUpd++;
                debugLog('log', '[NC SYNC] Push OK', { id: l.ncBookmarks?.id, remoteUpdatedAt: l.ncBookmarks.remoteUpdatedAt, moveApplied: moveNeeded });
              } else {
                // If the record no longer exists remotely (e.g., 404), fall back to CREATE
                let status = uRes?.status||0; let bodyHead=(uRes?.bodyText||'').slice(0,300);
                try { debugLog('warn', '[NC SYNC] Update FAILED, will try CREATE fallback', { id: l.ncBookmarks?.id, status, bodyHead }); } catch {}
                const tags2 = (Array.isArray(l.keywords)?l.keywords:(l.keywords||'')).toString().split(',').map(s=>s.trim()).filter(Boolean);
                const createPayload = { url:l.url||'', title:l.text||l.url||'', description:l.infoHtml||'', tags: tags2, folders: [fId] };
                // Skip create if URL invalid
                if (!createPayload.url || !/^https?:\/\//i.test(createPayload.url)) { skipped++; try { debugLog('warn', '[NC SYNC] Fallback CREATE skipped: invalid URL', { url:createPayload.url }); } catch {} }
                else {
                  const cUrl2 = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/bookmark');
                  const cRes2 = await MB.Extension.davRequest({ method:'POST', url:cUrl2, headers:Object.assign({'Content-Type':'application/json'}, hJson), body: JSON.stringify(createPayload), username: bk.username||'', password: bk.password||'' }).catch(()=>({ok:false}));
                    if (cRes2?.ok) {
                    let created2=null; try { created2=JSON.parse(cRes2.bodyText||'null'); } catch {}
                    created2 = unwrapNc(created2);
                    const nid2 = created2?.id; app.$set(l, 'ncBookmarks', { id:nid2, folderId:fId, lastSyncedAt:Date.now(), lastHash:computeHash(l) }); pushedNew++;
                    try { debugLog('log', '[NC SYNC] Fallback CREATE OK', { id: nid2, folderId: fId }); } catch {}
                  } else {
                    skipped++;
                    try { debugLog('error', '[NC SYNC] Fallback CREATE FAILED', { status:cRes2?.status, bodyHead:(cRes2?.bodyText||'').slice(0,300) }); } catch {}
                  }
                }
              }
            }
          }
        }

        try {
          if (TRACE_NC_ID>0) {
            const haveLocal = (()=>{ try { for (const gg of (app.data.groups||[])) { for (const ll of (gg.links||[])) { if (Number(ll?.ncBookmarks?.id)===TRACE_NC_ID) return true; } } } catch {} return false; })();
            debugLog('log', '[NC-TRACE] Summary', { traceId: TRACE_NC_ID, flags: MB.Utils.safeClone(traceFlags), haveLocal });
          }
        } catch {}
        app.saveData();
        showAppToast(`NC: +${createdLinks} pull, ~${updatedLinks} pull, -${removedLinks} removed, groups +${createdGroups}, folders +${createdFolders}/renamed ${renamedFolders}; push +${pushedNew}, ~${pushedUpd}, -${pushedDel}`, 'success');
        try { app.syncProgress = 100; app.syncProgressText = 'Done'; setTimeout(()=>{ app.syncInProgress=false; }, 800); } catch {}
      }
    });

    // WebDAV/Cal/CardDAV discovery helpers
    MB.CardDAV.getCurrentUserPrincipal = async function(baseUrl, authHeader) {
      // Try PROPFIND Depth:0 for current-user-principal
      const body = `<?xml version="1.0" encoding="utf-8"?>
<D:propfind xmlns:D="DAV:">
  <D:prop>
    <D:current-user-principal/>
  </D:prop>
</D:propfind>`;
      const res = await MB.CardDAV.propfind(baseUrl, 0, body, authHeader);
      if (!res.ok) return null;
      const doc = MB.CardDAV.parseXml(res.bodyText);
      const cup = doc.getElementsByTagNameNS('DAV:','current-user-principal')[0];
      const href = cup?.getElementsByTagNameNS('DAV:','href')[0]?.textContent || '';
      return href || null;
    };

    MB.CardDAV.getAddressbookHome = async function(principalUrl, authHeader) {
      const body = `<?xml version="1.0" encoding="utf-8"?>
<D:propfind xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:carddav">
  <D:prop>
    <C:addressbook-home-set/>
  </D:prop>
</D:propfind>`;
      const res = await MB.CardDAV.propfind(principalUrl, 0, body, authHeader);
      if (!res.ok) return null;
      const doc = MB.CardDAV.parseXml(res.bodyText);
      const ahs = doc.getElementsByTagNameNS('urn:ietf:params:xml:ns:carddav','addressbook-home-set')[0];
      const href = ahs?.getElementsByTagNameNS('DAV:','href')[0]?.textContent || '';
      return href || null;
    };

    MB.CardDAV.listAddressbooks = async function(homeSetUrl, authHeader) {
      const body = `<?xml version="1.0" encoding="utf-8"?>
<D:propfind xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:carddav">
  <D:prop>
    <D:displayname/>
    <D:resourcetype/>
  </D:prop>
</D:propfind>`;
      const res = await MB.CardDAV.propfind(homeSetUrl, 1, body, authHeader);
      if (!res.ok) return [];
      const doc = MB.CardDAV.parseXml(res.bodyText);
      const responses = Array.from(doc.getElementsByTagNameNS('*','response'));
      const out = [];
      for (const r of responses) {
        const href = (r.getElementsByTagNameNS('DAV:','href')[0]?.textContent || '').trim();
        const displayname = (r.getElementsByTagNameNS('DAV:','displayname')[0]?.textContent || '').trim();
        const rt = r.getElementsByTagNameNS('DAV:','resourcetype')[0];
        const isAB = !!(rt && (rt.getElementsByTagNameNS('urn:ietf:params:xml:ns:carddav','addressbook')[0]));
        if (isAB) out.push({ href, displayname });
      }
      return out;
    };

    MB.CardDAV.mkcolAddressbook = async function(homeSetUrl, name, authHeader) {
      let url = MB.CardDAV.joinUrl(homeSetUrl, name.replace(/\s+/g,'-').toLowerCase());
      if (!url.endsWith('/')) url = url + '/';
      const body = `<?xml version="1.0" encoding="UTF-8"?>
<D:mkcol xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:carddav">
  <D:set>
    <D:prop>
      <D:resourcetype><D:collection/><C:addressbook/></D:resourcetype>
      <D:displayname>${name}</D:displayname>
    </D:prop>
  </D:set>
</D:mkcol>`;
      const headers = { 'Content-Type': 'application/xml; charset=utf-8' };
      if (authHeader) headers['Authorization'] = authHeader;
      const res = await MB.CardDAV.request({ method: 'MKCOL', url, headers, body });
      if (res.ok || res.status === 201 || res.status === 200) return { href: url };
      throw new Error(`MKCOL failed: ${res.status} ${res.statusText}`);
    };

    MB.CardDAV.syncCollection = async function(addressbookUrl, syncToken, authHeader) {
      const include = `<D:prop><D:getetag/><C:address-data/></D:prop>`;
      const tokenPart = syncToken ? `<D:sync-token>${syncToken}</D:sync-token>` : '';
      const body = `<?xml version="1.0" encoding="utf-8"?>
<D:sync-collection xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:carddav">
  <D:sync-level>1</D:sync-level>
  ${tokenPart}
  ${include}
</D:sync-collection>`;
      const res = await MB.CardDAV.report(addressbookUrl, body, authHeader, 1);
      if (!res.ok) throw new Error(`sync-collection failed: ${res.status} ${res.statusText}`);
      const doc = MB.CardDAV.parseXml(res.bodyText);
      const responses = Array.from(doc.getElementsByTagNameNS('DAV:','response'));
      const nextToken = doc.getElementsByTagNameNS('DAV:','sync-token')[0]?.textContent || '';
      const changes = [];
      const deletions = [];
      for (const r of responses) {
        const href = (r.getElementsByTagNameNS('DAV:','href')[0]?.textContent || '').trim();
        const status = (r.getElementsByTagNameNS('DAV:','status')[0]?.textContent || '').trim();
        const propstat = r.getElementsByTagNameNS('DAV:','propstat');
        let etag = '';
        let addressData = '';
        for (const ps of Array.from(propstat)) {
          const st = ps.getElementsByTagNameNS('DAV:','status')[0]?.textContent || '';
          const isOk = st.includes('200');
          if (isOk) {
            etag = ps.getElementsByTagNameNS('DAV:','getetag')[0]?.textContent || etag;
            const ad = ps.getElementsByTagNameNS('urn:ietf:params:xml:ns:carddav','address-data')[0]?.textContent || '';
            if (ad) addressData = ad;
          }
        }
        if (status.includes('404') || (!etag && !addressData)) {
          deletions.push({ href });
        } else {
          changes.push({ href, etag, vcard: addressData });
        }
      }
      return { changes, deletions, nextToken };
    };

    MB.CardDAV.parseXml = function(xmlText) {
      const parser = new DOMParser();
      return parser.parseFromString(xmlText || '', 'application/xml');
    };

    MB.CardDAV.addressbookQueryAll = async function(addressbookUrl, authHeader) {
      const body = `<?xml version="1.0" encoding="utf-8"?>
<C:addressbook-query xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:carddav">
  <D:prop>
    <D:getetag/>
    <C:address-data/>
  </D:prop>
</C:addressbook-query>`;
      const res = await MB.CardDAV.report(addressbookUrl, body, authHeader, 1);
      if (!res.ok) throw new Error(`addressbook-query failed: ${res.status} ${res.statusText}`);
      const doc = MB.CardDAV.parseXml(res.bodyText);
      const responses = Array.from(doc.getElementsByTagNameNS('*','response'));
      return responses.map(r => {
        const href = (r.getElementsByTagNameNS('*','href')[0]?.textContent || '').trim();
        const etag = (r.getElementsByTagNameNS('*','getetag')[0]?.textContent || '').trim();
        const ad = r.getElementsByTagNameNS('urn:ietf:params:xml:ns:carddav','address-data')[0]?.textContent || '';
        return { href, etag, vcard: ad };
      }).filter(x => x.vcard);
    };

    MB.CardDAV.unfoldVCard = function(text) {
      const lines = (text || '').replace(/\r\n/g, '\n').split('\n');
      const out = [];
      for (const line of lines) {
        if (line.startsWith(' ') || line.startsWith('\t')) {
          if (out.length) out[out.length - 1] += line.slice(1);
        } else {
          out.push(line);
        }
      }
      return out;
    };

    MB.CardDAV.parseVCard = function(vcardText) {
      const lines = MB.CardDAV.unfoldVCard(vcardText);
      const obj = { raw: vcardText };
      for (const raw of lines) {
        if (!raw || raw.startsWith('BEGIN') || raw.startsWith('END')) continue;
        const idx = raw.indexOf(':');
        if (idx < 0) continue;
        const namePart = raw.slice(0, idx);
        const value = raw.slice(idx + 1);
        const name = namePart.split(';')[0]; // ignore params
        const key = name.includes('.') ? name.split('.').pop() : name; // strip group prefix
        const up = key.toUpperCase();
        switch (up) {
          case 'UID': obj.uid = value.trim(); break;
          case 'FN': obj.fn = value.trim(); break;
          case 'URL': obj.url = value.trim(); break;
          case 'CATEGORIES': obj.categories = value.split(',').map(s => s.replace(/\\,/g, ',').trim()).filter(Boolean); break;
          case 'NOTE': obj.note = value; break;
          default:
            if (up === 'X-MB-KEYWORDS') obj.mbKeywords = value;
            else if (up === 'X-MB-META') { try { obj.mbMeta = JSON.parse(value); } catch { obj.mbMeta = null; }
            }
        }
      }
      return obj;
    };
    // Generic DAV request wrapper via browser extension (only when available)
    MB.Extension.davRequest = async function(request) {
      if (!MB.Extension.isAvailable() || !window.MyBookmarksExtension || typeof window.MyBookmarksExtension.davRequest !== 'function') {
        throw new Error('Extension DAV API not available');
      }
      try {
        const res = await window.MyBookmarksExtension.davRequest(request);
        return res;
      } catch (e) {
        debugLog('error', 'Extension davRequest failed:', e);
        throw e;
      }
    };

    class DropManager {
      constructor(appInstance) {
        this.app = appInstance; // Referenz zur Vue-Instanz
        this.draggedState = null;
        this.oldArr = null;
        this.oldItem = null;
        this.draggedElement = null; // Referenz auf das gezogene DOM-Element
        this.dragStartTime = null; // Track when drag started to prevent premature dragend
        this.dragTimeout = null; // Timeout to prevent stuck drag states
        this.delayedResetTimeout = null; // Timeout for delayed resets that can be cancelled
        this.activeDropZone = null; // Track active drop zone for highlighting
        this.dragImageEl = null; // Custom drag image element
        this.edgeDragAttempt = false; // Track Edge drag attempts
        this.edgeDragPending = false; // Track if Edge is waiting for real drag
        // No need for appElement anymore - using Vue reactive state
        debugLog('log', "DropManager initialized with Vue reactivity");
      }

      reset() {
        debugLog('log', "DropManager reset() called."); // DEBUG

        // Clear any existing timeout
        if (this.dragTimeout) {
          clearTimeout(this.dragTimeout);
          this.dragTimeout = null;
          debugLog('log', "Cleared drag timeout"); // DEBUG
        }

        // Clear any delayed reset timeout
        if (this.delayedResetTimeout) {
          clearTimeout(this.delayedResetTimeout);
          this.delayedResetTimeout = null;
          debugLog('log', "Cleared delayed reset timeout"); // DEBUG
        }

        // Reset reactive state for Vue
        this.app.dragState = null;
        debugLog('log', "Reset dragState to null"); // DEBUG
        if (this.app && this.app.clearExpandHoverTimers) {
          this.app.clearExpandHoverTimers();
        }
        // Reset all mouseover states
        if (this.app && this.app.resetAllMouseOverStates) {
          this.app.resetAllMouseOverStates();
        }

        // Stelle sicher, dass die 'grabbing'-Klasse vom Body entfernt wird
        document.body.classList.remove('grabbing');
        debugLog('log', "Removed grabbing class from body"); // DEBUG

        // Reset draggedElement reference without manipulating its classes
        if (this.draggedElement) {
          debugLog('log', "Reset dragged element reference:", this.draggedElement); // DEBUG
          this.draggedElement = null; // Referenz zurücksetzen
        }
        // Reset Edge-specific flags
        this.edgeDragAttempt = false;
        this.edgeDragPending = false;

        // Reset drop zone state
        if (this.activeDropZone) {
          this.activeDropZone.classList.remove('drag-over-active');
          this.activeDropZone = null;
        }

        // Remove custom drag image if any
        if (this.dragImageEl && this.dragImageEl.parentNode) {
          this.dragImageEl.parentNode.removeChild(this.dragImageEl);
        }
        this.dragImageEl = null;

        // Reset state variables
        this.draggedState = null;
        this.oldArr = null;
        this.oldItem = null;
        this.dragStartTime = null; // Reset drag start time

        debugLog('log', "DropManager state reset complete."); // DEBUG
      }

      isDragged(type) {
        return this.draggedState === type;
      }

      // --- Column Helpers ---
      isMostLeftColumn(columns, column) {
        if (!columns || columns.length === 0) return true;
        return column === Math.min(...columns);
      }

      getMostLeftColumn(columns) {
        if (!columns || columns.length === 0) return 0;
        return Math.min(...columns);
      }

      isMostRightColumn(columns, column) {
        if (!columns || columns.length === 0) return true;
        return column === Math.max(...columns);
      }

      getMostRightColumn(columns) {
        if (!columns || columns.length === 0) return 0;
        return Math.max(...columns);
      }

      // Get max index for a specific column within an array
      getMaxIndex(arr, column) {
        const itemsInColumn = arr.filter(item => item.column === column);
        return itemsInColumn.length > 0 ? Math.max(...itemsInColumn.map(item => item.index)) : -1;
      }

      // --- Drag Lifecycle ---
      startDrag(evt, sourceArray, item, type) {
        debugLog('log', "startDrag called - Type:", type, "Item:", item);
        
        // Edge browser detection
        const isEdge = /Edg/.test(navigator.userAgent);
        
        // Edge specific: Need special handling for immediate dragend
        if (isEdge) {
          debugLog('log', "Edge: Starting drag operation with special handling");
          // For Edge, we need to handle the immediate dragend differently
          // Mark this as an Edge drag attempt
          this.edgeDragAttempt = true;
        }
        
        // Stop propagation AFTER logging to ensure we see the call
        evt.stopPropagation();
        
        // For Edge, don't block second attempts based on time
        if (!isEdge && this.dragStartTime && (Date.now() - this.dragStartTime < 1000)) {
          debugLog('log', "Blocking new drag - previous drag still in progress");
          evt.preventDefault();
          return;
        }
        
        // For Edge with an active drag state from a cancelled attempt, allow the drag
        if (isEdge && this.draggedState && this.edgeDragAttempt) {
          debugLog('log', "Edge: Allowing second drag attempt with existing state");
        }

        // Record the time when drag starts
        this.dragStartTime = Date.now();

        // Clear any existing timeout
        if (this.dragTimeout) {
          clearTimeout(this.dragTimeout);
          this.dragTimeout = null;
        }

        // Clear any delayed reset timeout
        if (this.delayedResetTimeout) {
          clearTimeout(this.delayedResetTimeout);
          this.delayedResetTimeout = null;
        }

        // Clear any previous drag state to ensure clean start (only if it's old)
        if (this.draggedState) {
          debugLog('log', "Warning: Clearing previous drag state before starting new one");
          this.draggedState = null;
          this.oldArr = null;
          this.oldItem = null;
          this.app.dragState = null;
        }

        // Speichere das gezogene Element
        this.draggedElement = evt.target;
        debugLog('log', "startDrag - Type:", type, "Item UUID:", item.uuid, "Element:", this.draggedElement); // DEBUG

        this.draggedState = type;

        // Set reactive state for Vue
        this.app.dragState = type;
        debugLog('log', "Set dragState to:", type); // DEBUG

        // CRITICAL FOR EDGE: Set effectAllowed FIRST
        evt.dataTransfer.effectAllowed = 'move';
        
        // CRITICAL: ALWAYS set data, even dummy data - Edge/Chrome won't drag without it!
        // Use multiple formats for maximum compatibility
        const dragData = JSON.stringify({
          type: type,
          uuid: item.uuid || 'no-uuid',
          timestamp: Date.now()
        });
        
        try {
          // Set multiple data types for compatibility
          evt.dataTransfer.setData('text/plain', dragData);
          evt.dataTransfer.setData('text', dragData);
          evt.dataTransfer.setData('application/json', dragData);
        } catch (e) {
          debugLog('warn', "Failed to set some drag data formats:", e);
          // Ensure at least one format is set
          evt.dataTransfer.setData('text', 'dummy-drag-data');
        }
        
        evt.dataTransfer.dropEffect = 'move';

        // Provide a clearer drag image so the user sees the element being dragged
        try {
          const ghost = document.createElement('div');
          ghost.style.position = 'fixed';
          ghost.style.top = '-1000px';
          ghost.style.left = '-1000px';
          ghost.style.padding = '6px 10px';
          ghost.style.background = type === 'link' ? '#fff' : '#f7f7f7';
          ghost.style.border = '1px solid #ccc';
          ghost.style.borderRadius = '4px';
          ghost.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
          ghost.style.font = '14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif';
          ghost.style.pointerEvents = 'none';
          ghost.textContent = type === 'link' ? (item.text || 'Link') : (item.name || 'Group');
          document.body.appendChild(ghost);
          evt.dataTransfer.setDragImage(ghost, 10, 10);
          this.dragImageEl = ghost;
        } catch (e) {
          // setDragImage not supported: noop
        }

        this.oldArr = sourceArray;
        this.oldItem = item;

        // Only manipulate document.body for cursor styling
        document.body.classList.add('grabbing');

        // Do not auto-reset a running drag; rely on drop/dragend

        debugLog('log', "startDrag completed successfully");
      }

      handleDragEnterZone(evt) {
        // Remove highlight from previous active zone
        if (this.activeDropZone && this.activeDropZone !== evt.currentTarget) {
          this.activeDropZone.classList.remove('drag-over-active');
        }
        // Add highlight to current zone
        evt.currentTarget.classList.add('drag-over-active');
        this.activeDropZone = evt.currentTarget;
      }

      handleDragLeaveZone(evt) {
        // Remove highlight if leaving the current active zone
        if (this.activeDropZone === evt.currentTarget) {
          evt.currentTarget.classList.remove('drag-over-active');
          this.activeDropZone = null;
        }
      }

      handleDragEnterVerticalZone(evt) {
        // Prevent event bubbling that causes flickering
        evt.stopPropagation();

        // Remove highlight from any other active zone
        if (this.activeDropZone && this.activeDropZone !== evt.currentTarget) {
          this.activeDropZone.classList.remove('drag-over-active');
        }

        // Add highlight to vertical drop zone
        evt.currentTarget.classList.add('drag-over-active');
        this.activeDropZone = evt.currentTarget;
      }

      handleDragLeaveVerticalZone(evt) {
        // Check if we're actually leaving the dropzone (not just moving to a child element)
        const rect = evt.currentTarget.getBoundingClientRect();
        const x = evt.clientX;
        const y = evt.clientY;

        // Only remove highlight if we're truly leaving the expanded hit area
        if (x < rect.left - 15 || x > rect.right + 15 || y < rect.top || y > rect.bottom) {
          evt.currentTarget.classList.remove('drag-over-active');
          if (this.activeDropZone === evt.currentTarget) {
            this.activeDropZone = null;
          }
        }
      }

      onDropToNewColumn(evt, newColumnIndex) {
        debugLog('log', `onDropToNewColumn called for column ${newColumnIndex}`);
        debugLog('log', 'Current draggedState:', this.draggedState);
        debugLog('log', 'Current oldItem:', this.oldItem);

        // Prevent default to ensure drop is handled
        evt.preventDefault();
        evt.stopPropagation();

        // Check for correct drag type - draggedState is a string, not an object
        if (!this.draggedState || this.draggedState !== 'group') {
          debugLog('warn', 'No group being dragged or wrong type. draggedState:', this.draggedState);
          this.reset();
          return;
        }

        const movedItem = this.oldItem;
        if (!movedItem) {
          debugLog('warn', 'No item to move. oldItem:', this.oldItem);
          this.reset();
          return;
        }

        debugLog('log', `Moving group "${movedItem.name}" from column ${movedItem.column} to column ${newColumnIndex}`);

        // First, adjust indices in the old column
        const oldColumn = movedItem.column;
        const oldIndex = movedItem.index;

        // Shift groups up in the old column
        const groupsInOldColumn = this.app.data.groups.filter(g =>
          g.column === oldColumn && g.uuid !== movedItem.uuid && g.index > oldIndex
        );
        groupsInOldColumn.forEach(g => {
          g.index--;
        });

        // Now move to new column
        movedItem.column = newColumnIndex;

        // Find the correct index in the new column (add to the end)
        const groupsInNewColumn = this.app.data.groups.filter(g =>
          g.column === newColumnIndex && g.uuid !== movedItem.uuid
        );

        // Set index to be after all existing groups in the column
        const maxIndex = groupsInNewColumn.reduce((max, g) => Math.max(max, g.index || 0), -1);
        movedItem.index = maxIndex + 1;

        debugLog('log', `Group "${movedItem.name}" moved to column ${newColumnIndex} at index ${movedItem.index}`);

        // Clear any active drop zone styling
        if (this.activeDropZone) {
          this.activeDropZone.classList.remove('drag-over-active');
          this.activeDropZone = null;
        }

        // Handle shared group sync if needed
        if (movedItem.shared && movedItem.useEventLog) {
          try {
            // Log the position change for event-log based groups
            const event = {
              type: 'group-move',
              groupId: movedItem.uuid,
              oldColumn,
              oldIndex,
              newColumn: newColumnIndex,
              newIndex: movedItem.index,
              timestamp: Date.now()
            };
            debugLog('log', '[DRAG] Group position change event:', event);
          } catch (error) {
            debugLog('error', '[DRAG] Error logging group move:', error);
          }
        }

        // Save and reset
        this.app.saveData();
        this.reset();
      }

      isDragOverActive(element) {
        return this.activeDropZone === element;
      }


      async onDrop(evt, targetArray, targetItem, targetIndex, targetColumn, type) {
        if (type !== this.draggedState || !this.oldItem) {
          debugLog('warn', "Drop cancelled or invalid state. Resetting early.");
          this.reset();
          return;
        }
        evt.preventDefault();

        // Remove drag-over-active class on drop
        if (this.activeDropZone) {
          this.activeDropZone.classList.remove('drag-over-active');
          this.activeDropZone = null;
        }

        debugLog('log', `onDrop - Type: ${type}, TargetItem: ${targetItem?.uuid}, TargetIndex: ${targetIndex}, TargetColumn: ${targetColumn}`);

        const oldItemUuid = this.oldItem.uuid;
        const oldColumn = this.oldItem.column;

        // Check if this is a cross-group move for links and verify permissions FIRST
        if (type === 'link') {
          const oldGroup = (this.app.data.groups || []).find(g =>
            g.links === this.oldArr
          );
          const newGroup = (this.app.data.groups || []).find(g =>
            g.links === targetArray
          );

          if (oldGroup && newGroup && oldGroup !== newGroup) {
            // Check permissions BEFORE making any changes
            if (!this.app.canDelete(oldGroup)) {
              alert(this.app.getTranslation('error.perm.delete') || 'You do not have permission to remove links from this group');
              this.reset();
              return;
            }

            if (!this.app.canAdd(newGroup)) {
              alert(this.app.getTranslation('error.perm.add') || 'You do not have permission to add links to this group');
              this.reset();
              return;
            }
          }
        }

        // 1) Remove item from its original array (only after permission check)
        const oldItemIndex = this.oldArr.findIndex(item =>
          this.oldItem.uuid && item.uuid === this.oldItem.uuid
        );
        let movedItem;
        if (oldItemIndex > -1) {
          movedItem = this.oldArr.splice(oldItemIndex, 1)[0];
          debugLog('log', `Removed item ${movedItem.uuid} from old index ${oldItemIndex}`);
        } else {
          debugLog('error', "Could not find dragged item in source array.");
          return;
        }

        // 2) Assign new column and ensure the moved item exists in the target array
        movedItem.column = targetColumn;
        if (!targetArray.includes(movedItem)) {
          targetArray.push(movedItem);
          debugLog('log', `Pushed item ${movedItem.uuid} into target array (column ${targetColumn}).`);
        }

        // 3) Reorder within the target column with fractional indexing (cheap reindex)
        const assignFractionalIndex = (items, column, desiredIndex) => {
          const EPS = 1e-6;
          const inCol = items.filter(it => it.column === column && it !== movedItem)
                              .sort((a, b) => a.index - b.index);
          const clamped = Math.max(0, Math.min(desiredIndex, inCol.length));
          const prev = clamped > 0 ? inCol[clamped - 1] : null;
          const next = clamped < inCol.length ? inCol[clamped] : null;
          let newIdx;
          if (prev && next) {
            const gap = next.index - prev.index;
            if (gap > EPS) {
              newIdx = prev.index + gap / 2;
            } else {
              // Gap too small; fallback to full reindex once, then place at middle
              this.app.reindexArr(inCol);
              newIdx = (inCol[clamped - 1]?.index || 0) + 0.5;
            }
          } else if (prev && !next) {
            newIdx = prev.index + 1;
          } else if (!prev && next) {
            newIdx = next.index - 1;
          } else {
            newIdx = 0;
          }
          movedItem.index = newIdx;
          debugLog('log', `Assigned fractional index ${newIdx} for ${type} in column ${column}`);
        };

        if (type === 'group') {
          assignFractionalIndex(this.app.data.groups, targetColumn, targetIndex);
          debugLog('log', "Normalizing group columns after drop...");
          this.app.normalizeColumnNumbers();
        } else if (type === 'link') {
          const parentGroup = this.app.data.groups.find(g => g.links === targetArray);
          if (parentGroup) {
            assignFractionalIndex(parentGroup.links, targetColumn, targetIndex);
          } else {
            debugLog('error', "Could not find parent group for link drop target array.");
          }
        }

        // 4) Reindex old column (from which the item was removed)
        if (type === 'group') {
          const leftBehind = this.app.data.groups.filter(g => g.column === oldColumn);
          if (leftBehind.length) this.app.reindexArr(leftBehind);
        } else if (type === 'link') {
          const srcGroup = this.app.data.groups.find(g => g.links === this.oldArr);
          if (srcGroup) {
            const leftBehind = srcGroup.links.filter(l => l.column === oldColumn);
            if (leftBehind.length) this.app.reindexArr(leftBehind);
          }
        }

        debugLog('log', "Saving data after drop and re-index...");
        this.app.saveData();
        
        // Send share-links update for shared groups
        if (type === 'link' && movedItem) {
          try {
            // Find the OLD group (where the link was dragged FROM)
            const oldGroup = (this.app.data.groups || []).find(g => 
              g.links === this.oldArr
            );
            
            // Find the NEW group (where the link was dragged TO)
            // Important: targetArray is the links array of the target group
            const newGroup = (this.app.data.groups || []).find(g =>
              g.links === targetArray
            );
            
            // If the link was moved between different groups
            if (oldGroup && newGroup && oldGroup !== newGroup) {
              // Permissions were already checked before making any changes

              // Handle sync for cross-group moves
              // Send DELETE event/message to old group if it's shared
              if (oldGroup.shared) {
                if (oldGroup.useEventLog && this.app.eventLogManager) {
                  // Create link-delete event for old group
                  this.app.createAndApplyEvent(oldGroup, {
                    type: 'link-delete',
                    linkId: movedItem.uuid,
                    data: {
                      deletedLink: {
                        uuid: movedItem.uuid,
                        text: movedItem.text,
                        url: movedItem.url,
                        column: oldColumn,
                        index: movedItem.index
                      }
                    }
                  });
                  debugLog('log', '[DND EVENT-LOG] Created link-delete event for old group:', oldGroup.name);
                } else if (oldGroup.groupTopic && oldGroup.groupKey) {
                  // Legacy sync for old group
                  try {
                    const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name || '' };
                    const deleteEnv = {
                      v: 1,
                      type: 'link-delete',
                      ts: Date.now(),
                      from,
                      groupId: oldGroup.groupId,
                      link: { uuid: movedItem.uuid, url: movedItem.url || null },
                      version: oldGroup.version || CONSTS.VERSION_FALLBACK,
                      msgId: (Math.random().toString(36).slice(2) + Date.now())
                    };
                    debugLog('log', '[DRAG] Sending link-delete to old shared group:', oldGroup.name, movedItem.uuid);
                    if (typeof sharing !== 'undefined' && sharing) {
                      await sharing.sendToGroup(oldGroup, deleteEnv);
                    }
                  } catch (error) {
                    debugLog('error', '[DRAG] Error sending link-delete:', error);
                  }
                }
              }

              // Send ADD event/message to new group if it's shared
              if (newGroup.shared) {
                if (newGroup.useEventLog && this.app.eventLogManager) {
                  // Create link-add event for new group
                  this.app.createAndApplyEvent(newGroup, {
                    type: 'link-add',
                    linkId: movedItem.uuid,
                    data: {
                      uuid: movedItem.uuid,
                      text: movedItem.text || '',
                      url: movedItem.url || '',
                      rawUrlInput: movedItem.rawUrlInput || '',
                      keywords: movedItem.keywords || '',
                      column: movedItem.column || 0,
                      index: movedItem.index || 0,
                      createdAt: movedItem.createdAt || Date.now(),
                      lastModified: movedItem.lastModified || Date.now()
                    }
                  });
                  debugLog('log', '[DND EVENT-LOG] Created link-add event for new group:', newGroup.name);
                } else if (newGroup.groupTopic && newGroup.groupKey) {
                  // Legacy sync for new group
                  try {
                    const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name || '' };
                    const linkData = {
                      uuid: movedItem.uuid,
                      text: movedItem.text || movedItem.url,
                      url: movedItem.url,
                      rawUrlInput: movedItem.rawUrlInput || '',
                      keywords: movedItem.keywords || '',
                      column: movedItem.column || 0,
                      index: movedItem.index || 0,
                      createdAt: movedItem.createdAt || Date.now(),
                      lastModified: movedItem.lastModified || Date.now()
                    };
                    const addEnv = {
                      v: 1,
                      type: 'share-links',
                      ts: Date.now(),
                      from,
                      groupId: newGroup.groupId,
                      selection: { groups: [], links: [linkData] },
                      mode: 'merge',
                      msgId: (Math.random().toString(36).slice(2) + Date.now())
                    };
                    debugLog('log', '[DRAG] Sending share-links to new shared group:', newGroup.name, linkData);
                    if (typeof sharing !== 'undefined' && sharing) {
                      await sharing.sendToGroup(newGroup, addEnv);
                    }
                  } catch (error) {
                    debugLog('error', '[DRAG] Error sending share-links:', error);
                  }
                }
              }
            }
            // If the link was moved within the same group (just repositioned)
            else if (newGroup && newGroup.shared) {
              // For event-log groups, create a link-update event
              if (newGroup.useEventLog && this.app.eventLogManager) {
                this.app.createAndApplyEvent(newGroup, {
                  type: 'link-update',
                  linkId: movedItem.uuid,
                  data: {
                    uuid: movedItem.uuid,
                    text: movedItem.text || '',
                    url: movedItem.url || '',
                    keywords: movedItem.keywords || '',
                    column: movedItem.column || 0,
                    index: movedItem.index || 0,
                    lastModified: movedItem.lastModified || Date.now()
                  }
                });
                debugLog('log', '[DND EVENT-LOG] Created link-update event for position change:', newGroup.name);
              }
              // Legacy sync needs explicit position updates
              else if (newGroup.groupTopic && newGroup.groupKey && !newGroup.useEventLog) {
                try {
                  const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name || '' };
                  const linkData = {
                    uuid: movedItem.uuid,
                    text: movedItem.text || movedItem.url,
                    url: movedItem.url,
                    rawUrlInput: movedItem.rawUrlInput || '',
                    keywords: movedItem.keywords || '',
                    column: movedItem.column || 0,
                    index: movedItem.index || 0,
                    lastModified: movedItem.lastModified || Date.now()
                  };
                  const env = {
                    v: 1,
                    type: 'share-links',
                    ts: Date.now(),
                    from,
                    groupId: newGroup.groupId,
                    selection: { groups: [], links: [linkData] },
                    mode: 'merge',
                    msgId: (Math.random().toString(36).slice(2) + Date.now())
                  };
                  debugLog('log', '[DRAG] Sending share-links update within same group:', linkData);
                  if (typeof sharing !== 'undefined' && sharing) {
                    await sharing.sendToGroup(newGroup, env);
                  }
                } catch (error) {
                  debugLog('error', '[DRAG] Error sending share-links update:', error);
                }
              }
            }
          } catch (e) {
            debugLog('error', '[DRAG] Failed to send share-links:', e);
          }
        }
        
        debugLog('log', `onDrop finished processing for item ${movedItem.id}`);

        // Ensure reset in case dragend isn't reliable
        debugLog('log', "Resetting drag state after successful drop");
        this.reset();
      }
    } // Ende DropManager Klasse

    // --- Helpers for base64url ---
    const B64 = {
      enc(bytes) {
        const bin = Array.from(bytes).map(b => String.fromCharCode(b)).join('');
        return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      },
      dec(str) {
        str = str.replace(/-/g, '+').replace(/_/g, '/');
        const pad = str.length % 4 ? '='.repeat(4 - (str.length % 4)) : '';
        const bin = atob(str + pad);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
        return arr;
      }
    };

    // --- WebCrypto utilities: ECDH/HKDF/AES-GCM ---
    class CryptoUtil {
      static async generateIdentity() {
        const kp = await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']);
        const pubRaw = new Uint8Array(await crypto.subtle.exportKey('raw', kp.publicKey));
        const privPkcs8 = new Uint8Array(await crypto.subtle.exportKey('pkcs8', kp.privateKey));
        return { pubKeyB64: B64.enc(pubRaw), privKeyB64: B64.enc(privPkcs8) };
      }
      static async importPub(rawB64) {
        return await crypto.subtle.importKey('raw', B64.dec(rawB64), { name: 'ECDH', namedCurve: 'P-256' }, true, []);
      }
      static async importPriv(pkcs8B64) {
        return await crypto.subtle.importKey('pkcs8', B64.dec(pkcs8B64), { name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']);
      }
      static async deriveBits(privKey, pubKey) {
        return new Uint8Array(await crypto.subtle.deriveBits({ name: 'ECDH', public: pubKey }, privKey, 256));
      }
      static async hkdf(inputBytes, infoStr, len = 32, salt = new Uint8Array(32)) {
        const baseKey = await crypto.subtle.importKey('raw', inputBytes, 'HKDF', false, ['deriveBits']);
        const info = new TextEncoder().encode(infoStr);
        const bits = await crypto.subtle.deriveBits({ name: 'HKDF', hash: 'SHA-256', salt, info }, baseKey, len * 8);
        return new Uint8Array(bits);
      }
      static async deriveChannel(sharedSecret) {
        const k = await this.hkdf(sharedSecret, 'mybookmarks:channel-key', 32);
        const topicBytes = await this.hkdf(sharedSecret, 'mybookmarks:channel-topic', 32);
        const topic = B64.enc(topicBytes).slice(0, 22);
        return { k, topic };
      }
      static async aesEncrypt(keyBytes, plaintextObj) {
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-GCM', length: 256 }, false, ['encrypt']);
        const pt = new TextEncoder().encode(JSON.stringify(plaintextObj));
        const ct = new Uint8Array(await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, pt));
        const out = new Uint8Array(iv.length + ct.length);
        out.set(iv, 0); out.set(ct, iv.length);
        return B64.enc(out);
      }
      static async aesDecrypt(keyBytes, payloadB64) {
        const all = B64.dec(payloadB64);
        const iv = all.slice(0, 12);
        const ct = all.slice(12);
        const key = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-GCM', length: 256 }, false, ['decrypt']);
        const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
        return JSON.parse(new TextDecoder().decode(pt));
      }
    }

    // Expose classes in in-file namespaces for clarity
    MB.DnD.DropManager = DropManager;
    MB.Utils.CryptoUtil = CryptoUtil;

    // --- ntfy client ---
    class NtfyClient {
      constructor(serverUrl, token) { this.serverUrl = serverUrl?.replace(/\/$/, ''); this.token = token || ''; this.subs = new Map(); this.valid = /^https?:\/\//i.test(this.serverUrl||''); this.memberWindows = new Map(); }
      setConfig(serverUrl, token) { this.serverUrl = serverUrl?.replace(/\/$/, ''); this.token = token || ''; this.valid = /^https?:\/\//i.test(this.serverUrl||''); }
      buildTopicPath(topic) {
        // Sanitize to a single path component: ntfy topics should not contain '/'
        let t = String(topic || '');
        t = t.replace(/[\/\\]/g, '-');            // replace any slashes with '-'
        t = t.replace(/[^A-Za-z0-9._-]/g, '_');     // keep only safe chars
        return `${this.serverUrl}/${t}`;
      }
      headers(extra) {
        const h = {};
        // Only attach Authorization on http(s) origins to avoid CORS preflight from file://
        if (/^https?:/i.test(location.protocol) && this.token) h['Authorization'] = `Bearer ${this.token}`;
        if (extra) Object.assign(h, extra);
        return h;
      }
      async publish(topic, bodyB64, ttlSec) {
        if (!this.valid) { debugLog('warn', 'ntfy serverUrl not configured or invalid'); return; }
        // Lightweight per-destination rate limit (windowed)
        try {
          // Token-bucket rate limit per topic for steady control
          const isQc = String(topic||'').startsWith('mb-qc-');
          const limit = Number((window.app?.data?.options?.sync?.memberRateLimit)||0);
          if (!isQc && limit > 0) {
            const key = topic;
            if (!this.memberBuckets) this.memberBuckets = new Map();
            let b = this.memberBuckets.get(key);
            if (!b) { b = { tokens: Math.min(limit, Math.max(1, Math.floor(limit/2))), last: Date.now(), capacity: limit, rate: limit / 60 }; this.memberBuckets.set(key, b); }
            const now = Date.now();
            const delta = (now - b.last) / 1000;
            b.tokens = Math.min(b.capacity, b.tokens + delta * b.rate);
            b.last = now;
            if (b.tokens < 1) { debugLog('warn', '[RATE] token bucket drop', { topic, tokens: b.tokens.toFixed(2) }); return; }
            b.tokens -= 1;
          }
        } catch (e) { debugLog('warn','[RATE] token bucket error', e); }
        // Prefer token as query to keep request "simple" (no preflight) for file:// origins
        let url = this.buildTopicPath(topic);
        if (this.token && !/^https?:/i.test(location.protocol)) {
          url += (url.includes('?') ? '&' : '?') + 'token=' + encodeURIComponent(this.token);
        }
        const headers = this.headers({ 'Content-Type': 'text/plain' });
        // Only set X-Ttl on http(s) origins to avoid non-simple headers on file://
        if (ttlSec && /^https?:/i.test(location.protocol)) headers['X-Ttl'] = String(ttlSec);
        const opts = { method: 'POST', headers, body: bodyB64 };
        if (!/^https?:/i.test(location.protocol)) Object.assign(opts, { mode: 'no-cors', keepalive: true });
        const res = await fetch(url, opts);
        if (/^https?:/i.test(location.protocol)) {
          if (!res.ok) throw new Error(`ntfy publish failed: ${res.status}`);
        } else {
          // On file:// with no-cors we cannot read status; assume best-effort
          return;
        }
      }
      async subscribeLongPoll(topic, onMsg) {
        // Avoid cross-origin issues when running from file:// — require http(s) origin
        if (!/^https?:/i.test(location.protocol)) { debugLog('warn', 'Skipping long-poll on non-http origin'); return { abort(){} }; }
        if (!this.valid) { debugLog('warn', 'ntfy serverUrl not configured or invalid'); return { abort(){} }; }
        const controller = new AbortController();
        const headers = this.headers();
        const url = this.buildTopicPath(topic) + '/json';
        let backoffMs = 1000;
        const run = async () => {
          try {
            const res = await fetch(url, { method: 'GET', headers, signal: controller.signal });
            if (!res.ok) throw new Error('ntfy poll failed ' + res.status);
            backoffMs = 1000;
            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            let buf = '';
            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              buf += decoder.decode(value, { stream: true });
              let idx;
              while ((idx = buf.indexOf('\n')) >= 0) {
                const line = buf.slice(0, idx).trim();
                buf = buf.slice(idx + 1);
                if (!line) continue;
                try {
                  const evt = JSON.parse(line);
                  const payload = (evt && typeof evt.message === 'string') ? evt.message : line;
                  onMsg({ text: payload, id: evt.id, time: evt.time, event: evt.event });
                } catch (_) { /* ignore */ }
              }
            }
          } catch (e) {
            if (controller.signal.aborted) return;
            debugLog('warn', 'ntfy long-poll error', e);
          }
          if (!controller.signal.aborted) {
            const factor = 1.5 + Math.random() * 0.5; // jitter 1.5x..2.0x
            backoffMs = Math.min(backoffMs * factor, CONSTS.BACKOFF_MAX_MS);
            setTimeout(run, backoffMs);
          }
        };
        run();
        this.subs.set(topic, controller);
        return controller;
      }
      subscribe(topic, onMsg) {
        if (!this.valid) { debugLog('warn', 'ntfy serverUrl not configured or invalid'); return { close(){}, abort(){} }; }
        // Start both SSE (no headers) and long-poll (with headers) to maximize compatibility
        const handles = { es: null, lp: null, closed: false, lpPaused: false, lpPauseTimer: null };
        try {
          let url = this.buildTopicPath(topic) + '/sse';
          // If token is configured, prefer passing it as query for SSE to avoid CORS headers
          if (this.token) url += (url.includes('?') ? '&' : '?') + 'token=' + encodeURIComponent(this.token);
          const es = new EventSource(url, { withCredentials: false });
          es.onmessage = (ev) => {
            try {
              const evt = JSON.parse(ev.data);
              const payload = (evt && typeof evt.message === 'string') ? evt.message : ev.data;
              onMsg({ text: payload, id: evt.id, time: evt.time, event: evt.event });
            } catch (e) {
              try { onMsg({ text: ev.data }); } catch (_) {}
            }
          };
          es.onerror = (e) => {
            debugLog('warn', '[NTFY] EventSource error for topic', topic, e);
            // Resume long-poll if it was paused
            if (handles.lpPaused && !handles.closed) {
              this.subscribeLongPoll(topic, onMsg).then(ctrl => { handles.lp = ctrl; handles.lpPaused = false; }).catch((err)=>debugLog('warn','[NTFY] resume LP failed', err));
            }
            // Don't close ES on error - let it auto-reconnect
          };
          es.onopen = () => {
            debugLog('log', '[NTFY] EventSource connected for topic', topic);
            // If ES remains open for a short delay, pause long-poll to save resources
            try {
              if (handles.lpPauseTimer) clearTimeout(handles.lpPauseTimer);
              handles.lpPauseTimer = setTimeout(() => {
                try { if (!handles.closed && handles.lp && handles.lp.abort) { handles.lp.abort(); handles.lp = null; handles.lpPaused = true; } } catch (e) { debugLog('warn','[NTFY] pause LP failed', e); }
              }, 2000);
            } catch (e) { debugLog('warn','[NTFY] schedule LP pause failed', e); }
          };
          handles.es = es;
        } catch (error) {
          debugLog('error', '[Sharing] Failed to initialize EventSource:', error);
        }
        // Also start long-polling loop (works with Authorization header if set) when origin is http(s)
        this.subscribeLongPoll(topic, onMsg).then(ctrl => { handles.lp = ctrl; }).catch((e) => { debugLog('warn', '[NTFY] subscribeLongPoll init failed', e); });
        // Unified abort/close handle
        handles.abort = () => {
          if (handles.closed) return;
          try { handles.es && handles.es.close && handles.es.close(); } catch (e) { debugLog('warn', '[NTFY] ES close failed', e); }
          try { handles.lp && handles.lp.abort && handles.lp.abort(); } catch (e) { debugLog('warn', '[NTFY] LP abort failed', e); }
          try { handles.lpPauseTimer && clearTimeout(handles.lpPauseTimer); } catch (e) { }
          handles.closed = true;
        };
        handles.close = handles.abort;
        this.subs.set(topic, handles);
        return handles;
      }
      unsubscribe(topic) {
        const h = this.subs.get(topic);
        if (h) {
          try { h.es && h.es.close && h.es.close(); } catch (e) { debugLog('warn', '[Sharing] Error closing EventSource:', e); }
          try { h.lp && h.lp.abort && h.lp.abort(); } catch (e) { debugLog('warn', '[Sharing] Error aborting long-poll:', e); }
          try { h.close && h.close(); } catch (e) { debugLog('warn', '[Sharing] Error closing connection:', e); }
          try { h.abort && h.abort(); } catch (e) { debugLog('warn', '[Sharing] Error aborting connection:', e); }
          this.subs.delete(topic);
        }
      }
      
    }

    // --- Event-Log System for Advanced Sync (Future Migration) ---
    class VectorClock {
      constructor(memberId) {
        this.clock = {};
        this.memberId = memberId;
      }
      
      increment() {
        this.clock[this.memberId] = (this.clock[this.memberId] || 0) + 1;
        return this.clone();
      }
      
      merge(otherClock) {
        if (!otherClock) return;
        Object.keys(otherClock).forEach(id => {
          this.clock[id] = Math.max(
            this.clock[id] || 0,
            otherClock[id] || 0
          );
        });
      }
      
      clone() {
        const cloned = new VectorClock(this.memberId);
        cloned.clock = { ...this.clock };
        return cloned;
      }
      
      happensBefore(other) {
        if (!other || !other.clock) return false;
        let hasLess = false;
        for (let id in this.clock) {
          if (this.clock[id] > (other.clock[id] || 0)) return false;
          if (this.clock[id] < (other.clock[id] || 0)) hasLess = true;
        }
        return hasLess;
      }
      
      isConcurrent(other) {
        return !this.happensBefore(other) && !other.happensBefore(this);
      }
      
      toJSON() {
        return this.clock;
      }
    }

    MB.EventLog.VectorClock = VectorClock;
    
    class EventLogManager {
      constructor(maxEvents = CONSTS.EVENT_LOG_MAX_EVENTS, snapshotInterval = CONSTS.EVENT_LOG_SNAPSHOT_INTERVAL * 2) {
        this.maxEvents = maxEvents;
        this.snapshotInterval = snapshotInterval;
      }

      // Compare two vector clocks. Returns 'lt' | 'gt' | 'eq' | 'concurrent'
      static compareVectorClocks(a = {}, b = {}) {
        const keys = new Set([...Object.keys(a||{}), ...Object.keys(b||{})]);
        let aLTEb = true;
        let bLTEa = true;
        let aLTb = false;
        let bLTa = false;
        for (const k of keys) {
          const av = a[k] || 0;
          const bv = b[k] || 0;
          if (av > bv) { aLTEb = false; aLTb = false; bLTa = true; }
          if (bv > av) { bLTEa = false; bLTa = false; aLTb = true; }
        }
        if (aLTEb && bLTEa) return 'eq';
        if (aLTEb && aLTb) return 'lt';
        if (bLTEa && bLTa) return 'gt';
        return 'concurrent';
      }
      
      shouldCreateSnapshot(group) {
        const eventCount = group.eventLog?.length || 0;
        const lastSnapTime = group.snapshot?.timestamp || 0;
        const hoursSinceSnap = (Date.now() - lastSnapTime) / (1000 * 60 * 60);
        
        return eventCount >= this.snapshotInterval || hoursSinceSnap > 24;
      }
      
      createSnapshot(group) {
        // Create a point-in-time snapshot of the group state
          const snapshot = {
            timestamp: Date.now(),
            eventId: group.headEventId || null,
            vectorClock: group.vectorClock ? { ...group.vectorClock } : {},
            data: {
              links: JSON.parse(JSON.stringify(group.links || [])),
              members: JSON.parse(JSON.stringify(group.members || [])),
              version: group.version || 0,
              name: group.name,
              emoji: group.emoji || '',
              color: group.color,
            }
          };
        
        // Garbage collect old events
        if (group.eventLog && snapshot.eventId) {
          const snapEventIndex = group.eventLog.findIndex(
            e => e.eventId === snapshot.eventId
          );
          
          if (snapEventIndex >= 0) {
            // Keep only events after snapshot
            group.eventLog = group.eventLog.slice(snapEventIndex + 1);
          }
        }
        
        group.snapshot = snapshot;
        debugLog('log', '[EVENT-LOG] Created snapshot', { 
          groupId: group.groupId, 
          eventCount: group.eventLog?.length || 0 
        });
        return snapshot;
      }
      
      addEvent(event, group) {
        debugLog('log', '[EventLogManager.addEvent] Called with:', {
          groupName: group.name,
          groupId: group.groupId,
          eventType: event.operation?.type || event.type,
          eventId: event.eventId,
          hasEventLog: !!group.eventLog,
          eventLogLength: group.eventLog?.length || 0
        });
        
        // Initialize event log if needed
        if (!group.eventLog) {
          debugLog('log', '[EventLogManager.addEvent] Initializing event log for group');
          group.eventLog = [];
        }
        
        // Generate event ID if not present
        if (!event.eventId) {
          event.eventId = `${event.authorId || event.author}-${Date.now()}-${Math.random().toString(36).slice(2)}`;
          debugLog('log', '[EventLogManager.addEvent] Generated event ID:', event.eventId);
        }
        
        // Check for duplicates
        if (group.eventLog.some(e => e.eventId === event.eventId)) {
          debugLog('log', '[EVENT-LOG] Skipping duplicate event', event.eventId);
          return false;
        }
        
        // Add event to log
        group.eventLog.push(event);
        group.headEventId = event.eventId;
        debugLog('log', '[EventLogManager.addEvent] Event added to log:', {
          eventId: event.eventId,
          newLength: group.eventLog.length
        });
        
        // Update vector clock
        if (!group.vectorClock) {
          group.vectorClock = {};
        }
        const authorKey = event.author || event.authorId;
        if (authorKey) {
          group.vectorClock[authorKey] = (group.vectorClock[authorKey] || 0) + 1;
          event.vectorClock = { ...group.vectorClock };
          debugLog('log', '[EventLogManager.addEvent] Updated vector clock:', group.vectorClock);
        }
        
        // Check if snapshot is needed
        if (this.shouldCreateSnapshot(group)) {
          this.createSnapshot(group);
        }
        
        debugLog('log', '[EVENT-LOG] Added event', {
          type: event.type,
          eventId: event.eventId,
          eventCount: group.eventLog.length
        });
        
        return true;
      }
      
      applyEvent(group, event) {
        // Initialize event log if needed
        if (!group.eventLog) group.eventLog = [];
        
        // Check for duplicates
        if (group.eventLog.some(e => e.eventId === event.eventId)) {
          debugLog('log', '[EVENT-LOG] Skipping duplicate event', event.eventId);
          return false;
        }
        
        // Add to log
        group.eventLog.push(event);
        group.headEventId = event.eventId;
        
        // Apply the operation - MUST use Vue reactivity for UI updates
        switch(event.operation?.type) {
          case 'link-add':
            if (!group.links) {
              // Use Vue's reactivity if app is available
              if (window.app && window.app.$set) {
                window.app.$set(group, 'links', []);
              } else {
                group.links = [];
              }
            }
            const newLink = {
              uuid: event.operation.data.uuid || event.operation.linkId,  // Support both formats
              ...event.operation.data,
              // Ensure reactive UI properties
              editing: false,
              isMouseOver: false
            };
            // Use Vue's reactivity to add the link
            if (window.app && window.app.$set) {
              window.app.$set(group.links, group.links.length, newLink);
            } else {
              group.links.push(newLink);
            }
            group.version = (group.version || 0) + 1;
            debugLog('log', '[EVENT-LOG] Applied link-add', newLink.uuid);
            break;
            
          case 'link-edit':
            // Support both linkId formats
            const editLinkId = event.operation.linkId || event.operation.data?.linkId || event.operation.data?.uuid;
            const linkToEdit = group.links?.find(l => l.uuid === editLinkId);
            if (linkToEdit) {
              // Use Vue's reactivity for updates
              if (window.app && window.app.$set) {
                Object.keys(event.operation.data).forEach(key => {
                  // Skip linkId/uuid in data to avoid overwriting
                  if (key !== 'linkId' && key !== 'uuid') {
                    window.app.$set(linkToEdit, key, event.operation.data[key]);
                  }
                });
              } else {
                Object.assign(linkToEdit, event.operation.data);
              }
              group.version = (group.version || 0) + 1;
              debugLog('log', '[EVENT-LOG] Applied link-edit', editLinkId);
            }
            break;
            
          case 'link-delete':
            // Support both linkId formats
            const deleteLinkId = event.operation.linkId || event.operation.data?.linkId || event.operation.data?.uuid;
            const idx = group.links?.findIndex(l => l.uuid === deleteLinkId);
            if (idx >= 0) {
              group.links.splice(idx, 1);
              group.version = (group.version || 0) + 1;
              debugLog('log', '[EVENT-LOG] Applied link-delete', deleteLinkId);
              // Trigger Vue update
              if (window.app && window.app.$forceUpdate) {
                try { window.app.$forceUpdate(); } catch {}
              }
            }
            break;
            
          case 'snapshot':
            // Full snapshot replacement
            if (event.operation.data) {
              group.links = event.operation.data.links || [];
              group.version = event.operation.data.version || 0;
              debugLog('log', '[EVENT-LOG] Applied snapshot');
            }
            break;
        }
        
        // Update vector clock
        if (event.vectorClock) {
          if (!group.vectorClock) group.vectorClock = {};
          Object.assign(group.vectorClock, event.vectorClock);
        }
        
        // Check if we need a snapshot
        if (this.shouldCreateSnapshot(group)) {
          this.createSnapshot(group);
        }
        
        return true;
      }
      
      findMissingEvents(group, remoteVectorClock) {
        if (!group.eventLog || !remoteVectorClock) return [];
        
        const missing = [];
        for (const event of group.eventLog) {
          if (event.author && 
              (!remoteVectorClock[event.author] || 
               remoteVectorClock[event.author] < (event.vectorClock?.[event.author] || 0))) {
            missing.push(event);
          }
        }
        
        return missing;
      }
      
      // Conflict Resolution Methods
      detectConflict(localEvent, remoteEvent) {
        // Check if two events conflict
        if (!localEvent || !remoteEvent) return false;
        
        // Different operation types on same entity
        if (localEvent.operation?.linkId === remoteEvent.operation?.linkId) {
          // Check if events are concurrent using vector clocks
          const localVC = new VectorClock();
          localVC.clock = localEvent.vectorClock || {};
          const remoteVC = new VectorClock();
          remoteVC.clock = remoteEvent.vectorClock || {};
          
          return localVC.isConcurrent(remoteVC);
        }
        
        return false;
      }
      
      resolveConflict(localEvent, remoteEvent, strategy = 'last-write-wins') {
        debugLog('log', '[CONFLICT] Resolving conflict', {
          local: localEvent.eventId,
          remote: remoteEvent.eventId,
          strategy
        });
        
        switch (strategy) {
          case 'last-write-wins':
            // Use timestamp to determine winner
            const localTime = localEvent.timestamp || 0;
            const remoteTime = remoteEvent.timestamp || 0;
            
            if (remoteTime > localTime) {
              return remoteEvent;
            } else if (localTime > remoteTime) {
              return localEvent;
            } else {
              // Same timestamp - use author UUID as tiebreaker for consistency
              return (remoteEvent.author || '') > (localEvent.author || '') ? remoteEvent : localEvent;
            }
            
          case 'owner-wins':
            // Owner changes always win
            if (remoteEvent.authorRole === 'owner') return remoteEvent;
            if (localEvent.authorRole === 'owner') return localEvent;
            // Fall back to last-write-wins
            return this.resolveConflict(localEvent, remoteEvent, 'last-write-wins');
            
          case 'merge':
            // For edit operations, try to merge changes
            if (localEvent.operation?.type === 'link-edit' && 
                remoteEvent.operation?.type === 'link-edit' &&
                localEvent.operation?.linkId === remoteEvent.operation?.linkId) {
              
              // Merge the changes
              const mergedData = { ...localEvent.operation.data };
              
              // For each field, use the most recent change
              Object.keys(remoteEvent.operation.data || {}).forEach(field => {
                // Compare field-level timestamps if available
                const localFieldTime = localEvent.fieldTimestamps?.[field] || localEvent.timestamp;
                const remoteFieldTime = remoteEvent.fieldTimestamps?.[field] || remoteEvent.timestamp;
                
                if (remoteFieldTime >= localFieldTime) {
                  mergedData[field] = remoteEvent.operation.data[field];
                }
              });
              
              // Create merged event
              return {
                ...remoteEvent,
                operation: {
                  ...remoteEvent.operation,
                  data: mergedData
                },
                merged: true,
                mergedFrom: [localEvent.eventId, remoteEvent.eventId]
              };
            }
            
            // For non-mergeable operations, use last-write-wins
            return this.resolveConflict(localEvent, remoteEvent, 'last-write-wins');
            
          default:
            return this.resolveConflict(localEvent, remoteEvent, 'last-write-wins');
        }
      }
      
      // Check if an operation is still valid given current state
      validateOperation(group, event) {
        if (!event?.operation) return false;
        
        const op = event.operation;
        
        switch (op.type) {
          case 'link-edit':
          case 'link-delete':
            // Check if link still exists - support both linkId formats
            const linkId = op.linkId || op.data?.linkId || op.data?.uuid;
            const link = group.links?.find(l => l.uuid === linkId);
            if (!link) {
              debugLog('warn', '[CONFLICT] Operation invalid - link not found', linkId);
              return false;
            }
            // For edits, check if link hasn't been deleted
            if (link.deleted && op.type === 'link-edit') {
              debugLog('warn', '[CONFLICT] Cannot edit deleted link', linkId);
              return false;
            }
            break;
            
          case 'link-add':
            // Check for duplicate UUIDs - support both linkId formats
            const addLinkId = op.linkId || op.data?.linkId || op.data?.uuid;
            if (group.links?.some(l => l.uuid === addLinkId)) {
              debugLog('warn', '[CONFLICT] Link with UUID already exists', addLinkId);
              return false;
            }
            break;
        }
        
        return true;
      }
      
      // Apply remote event with conflict detection
      applyRemoteEvent(group, remoteEvent, conflictStrategy = 'last-write-wins') {
        // Check for conflicts with recent local events
        const recentLocalEvents = (group.eventLog || [])
          .filter(e => e.timestamp > Date.now() - CONSTS.MINUTE_MS); // Last minute
        
        let hasConflict = false;
        let winningEvent = remoteEvent;
        
        for (const localEvent of recentLocalEvents) {
          if (this.detectConflict(localEvent, remoteEvent)) {
            hasConflict = true;
            winningEvent = this.resolveConflict(localEvent, remoteEvent, conflictStrategy);
            
            if (winningEvent !== remoteEvent) {
              debugLog('log', '[CONFLICT] Local event wins', {
                local: localEvent.eventId,
                remote: remoteEvent.eventId
              });
              return false; // Don't apply remote event
            }
          }
        }
        
        // Validate operation is still applicable
        if (!this.validateOperation(group, winningEvent)) {
          debugLog('warn', '[CONFLICT] Operation no longer valid', winningEvent.eventId);
          return false;
        }
        
        // Apply the winning event
        if (hasConflict) {
          debugLog('log', '[CONFLICT] Applying winning remote event after conflict', winningEvent.eventId);
          // Notify user of conflict resolution
          this.notifyConflictResolution(group, winningEvent, 'remote');
        }
        
        return this.applyEvent(group, winningEvent);
      }
      
      // Notify user about conflict resolution
      notifyConflictResolution(group, winningEvent, winner) {
        // Store conflict info for UI notification
        if (!group.conflictNotifications) {
          group.conflictNotifications = [];
        }
        
        group.conflictNotifications.push({
          timestamp: Date.now(),
          eventId: winningEvent.eventId,
          winner: winner,
          operation: winningEvent.operation?.type,
          resolved: true
        });
        
        // Keep only recent notifications
        group.conflictNotifications = group.conflictNotifications
          .filter(n => n.timestamp > Date.now() - 300000); // 5 minutes
        
        // Trigger UI notification check if app is available
        if (window.app && typeof window.app.checkAndShowConflictNotifications === 'function') {
          setTimeout(() => window.app.checkAndShowConflictNotifications(), 100);
        }
      }
      
      isOlderThanSnapshot(memberClock, snapshotClock) {
        if (!memberClock || !snapshotClock) return false;
        
        for (let memberId in snapshotClock) {
          if ((memberClock[memberId] || 0) < snapshotClock[memberId]) {
            return true;
          }
        }
        return false;
      }
    }

    // --- Sharing service (identity, contacts, quick-connect, inbox) ---
    class SharingService {
      constructor(app) {
        this.app = app;
        this.ntfy = new NtfyClient('', '');
        this.pairSubs = new Map();
        this.qcSub = null;
        this.qcSecrets = new Map();
        this.onQcStatus = null;
        this.qcTopic = '';
        this.qcCode = '';
        this.syncResponded = new Set();
        // Chunked transfer reassembly buffers
        this.groupTransfers = new Map(); // transferId -> { groupId, contentType, total, parts: Map, timer, from }
        // Per-topic msgId dedupe
        this.msgIds = new Map(); // topic -> Set(msgId)
      }
      setStatusHandler(fn) { this.onQcStatus = typeof fn === 'function' ? fn : null; }
      get cfg() { return this.app.data.options?.sharing || {}; }
      applyConfig() {
        // Provide sensible default for demos if not configured
        const server = this.cfg.ntfyServerUrl && this.cfg.ntfyServerUrl.trim() ? this.cfg.ntfyServerUrl.trim() : 'https://ntfy.c5p.de';
        this.ntfy.setConfig(server, this.cfg.ntfyAuthToken || '');
      }
      async ensureIdentity() {
        if (!this.app.data.identity?.uuid || !this.app.data.identity?.privKey || !this.app.data.identity?.pubKey) {
          const { pubKeyB64, privKeyB64 } = await CryptoUtil.generateIdentity();
          this.app.$set(this.app.data, 'identity', { uuid: this.uuidv4(), name: this.app.data.identity?.name || '', pubKey: pubKeyB64, privKey: privKeyB64 });
          this.app.saveData();
        }
      }
      uuidv4() { 
        try { 
          // Prefer native crypto.randomUUID
          if (crypto && crypto.randomUUID) {
            return crypto.randomUUID();
          }
          // Fallback to crypto.getRandomValues with proper UUID v4 format
          if (crypto && crypto.getRandomValues) {
            const bytes = new Uint8Array(16);
            crypto.getRandomValues(bytes);
            // Set version (4) and variant bits according to UUID v4 spec
            bytes[6] = (bytes[6] & 0x0f) | 0x40; // Version 4
            bytes[8] = (bytes[8] & 0x3f) | 0x80; // Variant 10
            // Format as UUID string
            const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
            return `${hex.substr(0,8)}-${hex.substr(8,4)}-${hex.substr(12,4)}-${hex.substr(16,4)}-${hex.substr(20,12)}`;
          }
          // Fallback to URL.createObjectURL (still better than timestamp)
          return URL.createObjectURL(new Blob()).split('/').pop();
        } catch (error) { 
          debugLog('error', '[UUID] Failed to generate secure UUID:', error);
          // Last resort with better entropy
          const timestamp = Date.now().toString(36);
          const random1 = Math.random().toString(36).substr(2, 9);
          const random2 = Math.random().toString(36).substr(2, 9);
          const random3 = performance.now().toString(36).substr(2, 5);
          return `${timestamp}-${random1}-${random2}-${random3}`;
        } 
      }
      getContactCard() {
        const id = this.app.data.identity || {};
        return { v: 1, uuid: id.uuid, name: id.name || '', pubKey: id.pubKey };
      }
      async addContactFromCard(card) {
        if (!card || !card.uuid || !card.pubKey) throw new Error('invalid card');
        const exists = (this.app.data.contacts || []).some(c => c.uuid === card.uuid);
        if (!exists) {
          if (!Array.isArray(this.app.data.contacts)) this.app.$set(this.app.data, 'contacts', []);
          this.app.data.contacts.push({ uuid: card.uuid, name: card.name || '', pubKey: card.pubKey, topic: '', kChannelB64: '' });
        }
        
        // Remove from blocked list if previously blocked
        if (this.app.data.blockedContacts?.includes(card.uuid)) {
          const idx = this.app.data.blockedContacts.indexOf(card.uuid);
          if (idx >= 0) {
            this.app.data.blockedContacts.splice(idx, 1);
            debugLog('log', '[CONTACT] Removed from blocked list:', card.uuid);
          }
        }
        
        await this.derivePairwiseFor(card.uuid);
        this.app.saveData();
      }
      async derivePairwiseFor(contactUuid) {
        const me = this.app.data.identity;
        const c = (this.app.data.contacts || []).find(x => x.uuid === contactUuid);
        if (!me || !c) return;
        const pubOther = await CryptoUtil.importPub(c.pubKey);
        const privSelf = await CryptoUtil.importPriv(me.privKey);
        const shared = await CryptoUtil.deriveBits(privSelf, pubOther);
        const { k, topic } = await CryptoUtil.deriveChannel(shared);
        c.topic = topic; c.kChannelB64 = B64.enc(k);
        this.subscribePairwise(c);
      }
      subscribePairwise(contact) {
        if (!contact.topic || !contact.kChannelB64) return;
        if (this.pairSubs.has(contact.topic)) return;
        this.applyConfig();
        const seen = new Set();
        const handles = this.ntfy.subscribe(contact.topic, async (evt) => {
          try {
            const id = evt && evt.id;
            if (id) { if (seen.has(id)) return; seen.add(id); }
            if (evt && evt.event && evt.event !== 'message') return; // ignore non-message events
            const payload = (evt && typeof evt.text === 'string') ? evt.text : (typeof evt === 'string' ? evt : '');
            if (!payload || !/^[A-Za-z0-9_\-]+$/.test(payload)) return; // only accept base64url bodies
            const env = await CryptoUtil.aesDecrypt(B64.dec(contact.kChannelB64), payload);
            this.onEnvelope(env, { scope: 'pair', contact, id });
          } catch (e) { debugLog('warn', 'pair decrypt failed', e); }
        });
        this.pairSubs.set(contact.topic, { handles, seen });
      }
      // --- Chunked send helper ---
      async sendChunkedGroup(group, contentType, envelopeObj) {
        try {
          const json = JSON.stringify(envelopeObj);
          // compute sha256 over UTF-8 bytes to validate on receiver
          let sha256 = '';
          try {
            const bytes = new TextEncoder().encode(json);
            const digest = await crypto.subtle.digest('SHA-256', bytes);
            sha256 = B64.enc(new Uint8Array(digest));
          } catch (e) { debugLog('warn', '[SYNC] sha256 failed', e); }
          // encode to base64url chunks without padding (supports Unicode)
          const b64 = B64.enc(new TextEncoder().encode(json));
          const chunkSize = CONSTS.NTFY_CHUNK_SIZE; // ~80KB per chunk
          const total = Math.ceil(b64.length / chunkSize);
          const transferId = (Math.random().toString(36).slice(2)+Date.now());
          const from = { uuid: this.app.data.identity?.uuid, name:this.app.data.identity?.name||'' };
          for (let i=0;i<total;i++) {
            const part = b64.slice(i*chunkSize, (i+1)*chunkSize);
            const chunkEnv = { v:1, type:'sync-chunk', ts:Date.now(), from, groupId: group.groupId, transferId, seq:i, total, contentType, payloadB64: part, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
            await this.sendToGroup(group, chunkEnv);
          }
          const doneEnv = { v:1, type:'sync-chunks-done', ts:Date.now(), from, groupId: group.groupId, transferId, total, contentType, sha256, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
          await this.sendToGroup(group, doneEnv);
        } catch(e) {
          try { debugLog('warn','[SYNC] sendChunkedGroup failed', e); } catch {}
        }
      }

      // --- Chunked send helper over pairwise channel ---
      async sendChunkedToContact(contactUuid, contentType, envelopeObj) {
        try {
          const json = JSON.stringify(envelopeObj);
          // compute sha256 over UTF-8 bytes to validate on receiver
          let sha256 = '';
          try {
            const bytes = new TextEncoder().encode(json);
            const digest = await crypto.subtle.digest('SHA-256', bytes);
            sha256 = B64.enc(new Uint8Array(digest));
          } catch (e) { debugLog('warn', '[SYNC] sha256 failed', e); }
          // encode to base64url chunks without padding (supports Unicode)
          const b64 = B64.enc(new TextEncoder().encode(json));
          const chunkSize = CONSTS.NTFY_CHUNK_SIZE; // ~80KB per chunk
          const total = Math.ceil(b64.length / chunkSize);
          const transferId = (Math.random().toString(36).slice(0,8) + Date.now());
          const from = { uuid: this.app.data.identity?.uuid, name:this.app.data.identity?.name||'' };
          for (let i=0;i<total;i++) {
            const part = b64.slice(i*chunkSize, (i+1)*chunkSize);
            const chunkEnv = { v:1, type:'sync-chunk', ts:Date.now(), from, transferId, seq:i, total, contentType, payloadB64: part, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
            await this.sendToContact(contactUuid, chunkEnv);
          }
          const doneEnv = { v:1, type:'sync-chunks-done', ts:Date.now(), from, transferId, total, contentType, sha256, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
          await this.sendToContact(contactUuid, doneEnv);
        } catch (e) {
          try { debugLog('warn','[SYNC] sendChunkedToContact failed', e); } catch {}
        }
      }
      unsubscribePairwise(contact) {
        if (!contact.topic) return;
        const sub = this.pairSubs.get(contact.topic);
        if (sub) {
          try {
            // Close the subscription
            if (sub.handles) {
              this.ntfy.unsubscribe(contact.topic);
            }
            // Remove from map
            this.pairSubs.delete(contact.topic);
            debugLog('log', '[PAIR] Unsubscribed from contact topic:', contact.topic);
          } catch (e) {
            debugLog('error', '[PAIR] Failed to unsubscribe:', e);
          }
        }
      }
      async sendToContact(contactUuid, envelope) {
        const c = (this.app.data.contacts || []).find(x => x.uuid === contactUuid);
        if (!c || !c.kChannelB64 || !c.topic) throw new Error('no channel');
        // Ensure minimal envelope fields
        const env = (envelope && envelope.v && envelope.ts && envelope.msgId) ? envelope : MB.Sync.buildEnvelope(this.app, envelope?.type || 'message', envelope);
        const b64 = await CryptoUtil.aesEncrypt(B64.dec(c.kChannelB64), env);
        await this.ntfy.publish(c.topic, b64, this.cfg.defaultTtl || undefined);
      }
      // --- Group sharing ---
      genGroupId() { return this.uuidv4(); }
      genGroupKeyB64() { const k=new Uint8Array(32); crypto.getRandomValues(k); return B64.enc(k); }
      genGroupTopic() { const seed=new Uint8Array(16); crypto.getRandomValues(seed); return (this.app.data.options?.groupSharing?.topicPrefix || 'mb-g-') + B64.enc(seed).slice(0,12); }
      async sendToGroup(group, envelope) {
        if (!group?.groupTopic || !group?.groupKey) throw new Error('group not shared');
        // Ensure minimal envelope fields and groupId
        const env = (envelope && envelope.v && envelope.ts && envelope.msgId) ? Object.assign({ groupId: group.groupId }, envelope) : MB.Sync.buildEnvelope(this.app, envelope?.type || 'message', Object.assign({ groupId: group.groupId }, envelope || {}));
        // Debug logging - errors can be ignored
        try { debugLog('log', '[SYNC] sendToGroup', { topic: group.groupTopic, groupId: group.groupId, type: env?.type, from: this.app.data.identity?.uuid }); } catch (e) { /* Console error */ }
        const b64 = await CryptoUtil.aesEncrypt(B64.dec(group.groupKey), env);
        try {
          await this.ntfy.publish(group.groupTopic, b64, this.cfg.defaultTtl || undefined);
          try { debugLog('log', '[SYNC] publish ok', { type: env?.type, topic: group.groupTopic }); } catch {}
        } catch (e) {
          debugLog('warn', '[SYNC] publish failed', e);
          throw e;
        }
      }
      subscribeGroup(group, skipUpdateRequest = false) {
        if (!group?.groupTopic || !group?.groupKey) return;
        if (!this.groupSubs) this.groupSubs = new Map();
        if (this.groupSubs.has(group.groupTopic)) {
          debugLog('log', '[SYNC] Already subscribed to group', group.groupTopic);
          return;
        }
        this.applyConfig();
        
        // Check if NTFY is properly configured
        if (!this.ntfy.valid) {
          debugLog('warn', '[SYNC] NTFY not configured, cannot subscribe to group', group.groupTopic);
          return;
        }
        
        try { debugLog('log', '[SYNC] subscribeGroup start', { 
          topic: group.groupTopic, 
          groupId: group.groupId,
          ntfyServer: this.ntfy.serverUrl,
          hasToken: !!this.ntfy.token
        }); } catch (error) {
          debugLog('error', '[Sharing] Failed to subscribe to group:', error);
        }
        
        const seen = new Set();
        const handles = this.ntfy.subscribe(group.groupTopic, async (evt) => {
          try {
            const id = evt && evt.id; 
            if (id) { 
              if (seen.has(id)) { 
                try { debugLog('log', '[SYNC] drop duplicate ntfy id', id); } catch {} 
                return; 
              } 
              seen.add(id); 
            }
            if (evt && evt.event && evt.event !== 'message') { 
              try { debugLog('log', '[SYNC] skip non-message event', evt.event); } catch {} 
              return; 
            }
            const payload = (evt && typeof evt.text === 'string') ? evt.text : (typeof evt === 'string' ? evt : '');
            
            // Check if this is an attachment notification (not our encrypted message)
            if (payload && payload.includes('attachment.txt')) {
              try { 
                debugLog('log', '[SYNC] Skipping NTFY attachment notification:', payload); 
              } catch {} 
              return;
            }
            
            if (!payload || !/^[A-Za-z0-9_\-]+$/.test(payload)) { 
              try { 
                debugLog('log', '[SYNC] skip non-b64url payload', {
                  hasPayload: !!payload,
                  payloadType: typeof payload,
                  payloadLength: payload ? payload.length : 0,
                  payloadSample: payload ? payload.substring(0, 50) : 'none',
                  eventType: evt?.event,
                  hasMessage: !!evt?.message
                }); 
              } catch {} 
              return; 
            }
            const env = await CryptoUtil.aesDecrypt(B64.dec(group.groupKey), payload);
            try { debugLog('log', '[SYNC] recv envelope', { type: env?.type, from: env?.from?.uuid, groupId: env?.groupId }); } catch {}
            // Envelope-level dedup by msgId per topic
            if (env && env.msgId) {
              const topic = group.groupTopic;
              let set = this.msgIds.get(topic);
              if (!set) { set = new Set(); this.msgIds.set(topic, set); }
              if (set.has(env.msgId)) { debugLog('log', '[SYNC] drop duplicate msgId', env.msgId); return; }
              set.add(env.msgId);
            }
            
            // Use the current group from data.groups, not the old reference
            // Always pass the original group to handleGroupEnvelope
            // The handleGroupEnvelope will find the current group internally
            this.handleGroupEnvelope(group, env);
          } catch(e){ 
            debugLog('warn', 'group decrypt failed', e); 
          }
        });
        
        this.groupSubs.set(group.groupTopic, { handles, seen });
        debugLog('log', '[SYNC] Subscription created for group', group.groupTopic);
        
        // Request a full update after subscribing (covers offline gaps) - but skip if caller will do it
        if (!skipUpdateRequest) {
          // Add a small delay to ensure subscription is fully established
          setTimeout(() => {
            try {
              const from = { uuid: this.app.data.identity?.uuid, name:this.app.data.identity?.name||'' };
              try { debugLog('log', '[SYNC] send group-update-request after subscribe', { topic: group.groupTopic, groupId: group.groupId }); } catch {}
              this.sendToGroup(group, { v:1, type:'group-update-request', ts:Date.now(), from, groupId: group.groupId, msgId:(Math.random().toString(36).slice(2)+Date.now()) });
            } catch(e) {
              debugLog('warn', '[SYNC] Failed to send update request after subscribe', e);
            }
          }, 500);
        }
      }
      async handleGroupEnvelope(group, env) {
        if (!env || !env.type) { try { debugLog('log', '[SYNC] ignore envelope without type'); } catch {} return; }
        if (env.msgId && this.app.processedMsgIds && this.app.processedMsgIds.has(env.msgId)) { try { debugLog('log', '[SYNC] drop duplicate msgId', env.msgId); } catch {} return; }
        if (env.msgId && this.app.processedMsgIds) this.app.processedMsgIds.add(env.msgId);
        // Ignore our own outbound messages to prevent echo/duplication
        try { if (env.from && env.from.uuid && this.app.data.identity && env.from.uuid === this.app.data.identity.uuid) { try { debugLog('log', '[SYNC] drop self-echo'); } catch {} return; } } catch {}

        // Chunked sync reassembly
        if (env.type === 'sync-chunk' || env.type === 'sync-chunks-done') {
          try {
            const tId = env.transferId;
            if (!tId) return;
            let buf = this.groupTransfers.get(tId);
            if (!buf) {
              // Enforce max concurrent transfers
              if (this.groupTransfers.size >= CONSTS.MAX_CONCURRENT_TRANSFERS) {
                debugLog('warn', '[SYNC] dropping chunk: too many concurrent transfers');
                return;
              }
              buf = { groupId: env.groupId, contentType: env.contentType || 'snapshot', total: env.total || 0, parts: new Map(), timer: null, from: env.from?.uuid, bytes: 0 };
              this.groupTransfers.set(tId, buf);
              // Timeout cleanup
              buf.timer = setTimeout(() => { this.groupTransfers.delete(tId); }, CONSTS.MINUTE_MS);
            }
            if (env.type === 'sync-chunk') {
              if (typeof env.seq === 'number' && typeof env.payloadB64 === 'string') {
                buf.parts.set(env.seq, env.payloadB64);
                buf.bytes += env.payloadB64.length;
                // Size cap safety
                if (buf.bytes > CONSTS.MAX_TRANSFER_SIZE) {
                  debugLog('warn', '[SYNC] dropping transfer: size exceeds cap');
                  clearTimeout(buf.timer);
                  this.groupTransfers.delete(tId);
                  return;
                }
                if (env.total && !buf.total) buf.total = env.total;
                // Early assemble if all parts are present (in case DONE is lost)
                if (buf.total && buf.parts.size === buf.total) {
                  const ordered = Array.from({ length: buf.total }, (_, i) => buf.parts.get(i) || '');
                  try {
                    const bytes = B64.dec(ordered.join(''));
                    const json = new TextDecoder().decode(bytes);
                    const fullEnv = JSON.parse(json);
                    const g = (this.app.data.groups || []).find(x => x.groupId === (fullEnv.groupId || buf.groupId));
                    if (g) this.handleGroupEnvelope(g, fullEnv);
                  } catch (e) { debugLog('warn','[SYNC] early chunk reassembly failed', e); }
                  if (buf.timer) clearTimeout(buf.timer);
                  this.groupTransfers.delete(tId);
                }
              }
              return; // wait for DONE (or already assembled)
            }
            if (env.type === 'sync-chunks-done') {
              // assemble if complete
              const total = buf.total || env.total || 0;
              const have = buf.parts.size;
              if (total > 0 && have === total) {
              const ordered = Array.from({ length: total }, (_, i) => buf.parts.get(i) || '');
              let joined = ordered.join('');
              try {
                  // Decode base64url to bytes, then UTF-8 to string
                  const bytes = B64.dec(joined);
                  const json = new TextDecoder().decode(bytes);
                  // optional integrity check if sha256 present
                  if (typeof env.sha256 === 'string' && env.sha256) {
                    try {
                      const encBytes = new TextEncoder().encode(json);
                      const digest = await crypto.subtle.digest('SHA-256', encBytes);
                      const hashB64 = B64.enc(new Uint8Array(digest));
                      if (hashB64 !== env.sha256) {
                        debugLog('warn','[SYNC] chunk hash mismatch – dropping transfer');
                        if (buf.timer) clearTimeout(buf.timer);
                        this.groupTransfers.delete(tId);
                        return;
                      }
                    } catch (e) { debugLog('warn','[SYNC] sha256 verify failed', e); }
                  }
                  const fullEnv = JSON.parse(json);
                  // Dispatch reconstructed envelope
                  const g = (this.app.data.groups || []).find(x => x.groupId === (fullEnv.groupId || buf.groupId));
                  if (g) this.handleGroupEnvelope(g, fullEnv);
                } catch (e) { debugLog('warn','[SYNC] chunk reassembly failed', e); }
              } else {
                debugLog('warn', '[SYNC] chunks-done but parts missing', { have, total });
              }
              // cleanup
              if (buf.timer) clearTimeout(buf.timer);
              this.groupTransfers.delete(tId);
              return;
            }
          } catch (e) { debugLog('warn', '[SYNC] envelope handling error', e); }
        }
        
        // Handle Event-Log activation message
        if (env.type === 'event-log-activation') {
          debugLog('log', '[EVENT-LOG] Received activation message from owner', { 
            groupId: env.groupId, 
            from: env.from?.uuid 
          });
          
          const g = (this.app.data.groups || []).find(x => x.groupId === env.groupId);
          if (g && !g.useEventLog) {
            // Owner has activated event-log, members should adopt it
            debugLog('log', '[EVENT-LOG] Adopting event-log for group', g.name);
            
            // Use complete event-log data if provided, otherwise use migration snapshot
            if (env.eventLog && env.eventLog.length > 0) {
              debugLog('log', '[EVENT-LOG] Applying complete event-log from owner', {
                eventCount: env.eventLog.length,
                hasSnapshot: !!env.snapshot
              });
              this.app.$set(g, 'eventLog', env.eventLog);
              this.app.$set(g, 'snapshot', env.snapshot || null);
              this.app.$set(g, 'headEventId', env.headEventId || env.eventLog[env.eventLog.length - 1].eventId);
              this.app.$set(g, 'vectorClock', env.vectorClock || {});
              this.app.$set(g, 'useEventLog', true);
            } else if (env.migrationSnapshot) {
              // Fallback to migration snapshot if no complete event-log
              const migrationEvent = {
                eventId: env.migrationSnapshot.eventId,
                parentId: null,
                timestamp: env.migrationSnapshot.timestamp,
                author: 'owner-migration',
                vectorClock: { 'system': 1 },
                operation: {
                  type: 'snapshot',
                  data: env.migrationSnapshot.data
                }
              };
              
              this.app.$set(g, 'eventLog', [migrationEvent]);
              this.app.$set(g, 'headEventId', migrationEvent.eventId);
              this.app.$set(g, 'vectorClock', { 'system': 1 });
              this.app.$set(g, 'useEventLog', true);
              
              debugLog('log', '[EVENT-LOG] Member adopted event-log for group', g.groupId);
              this.app.saveData();
              
              // Force UI update
              try { this.app.$forceUpdate(); } catch {}
            }
          }
          return;
        }
        
        // Handle Event-Log sync events
        else if (env.type === 'sync-event') {
          debugLog('log', '[EVENT-LOG] Received sync-event', {
            groupId: env.groupId,
            eventType: env.event?.operation?.type,
            from: env.from?.uuid
          });

          const g = (this.app.data.groups || []).find(x => x.groupId === env.groupId);
          
          // If group doesn't have event-log enabled yet but receives events, enable it
          if (g && !g.useEventLog && env.event) {
            debugLog('log', '[EVENT-LOG] Enabling event-log for group due to received event', g.name);
            this.app.$set(g, 'useEventLog', true);
            if (!g.eventLog) {
              this.app.$set(g, 'eventLog', []);
            }
            if (!g.vectorClock) {
              this.app.$set(g, 'vectorClock', {});
            }
          }
          
          if (g && g.useEventLog && env.event) {
            // Fork detection via vector clock comparison
            try {
              const localVC = g.vectorClock || {};
              const remoteVC = env.event.vectorClock || {};
              const rel = EventLogManager.compareVectorClocks(localVC, remoteVC);
              if (rel === 'concurrent') {
                // Mark local flag and alert owner to send a snapshot
                this.app.$set(g, 'forkDetected', true);
                const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name||'' };
                const alert = { v:1, type:'sync-fork-alert', ts:Date.now(), from, groupId: g.groupId, headVC: localVC, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
                this.sendToGroup(g, alert).catch(()=>{});
              }
            } catch {}
            // Determine conflict resolution strategy based on group settings and user options
            let strategy = 'last-write-wins'; // Default
            
            // Check if user is owner and has configured a strategy
            if (this.app.isOwnerOfGroup(g)) {
              strategy = this.app.data.options?.sync?.conflictResolution || 'last-write-wins';
            } else {
              // Members always use last-write-wins unless group has specific setting
              strategy = g.conflictResolution || 'last-write-wins';
            }
            
            // Apply the event using EventLogManager with conflict detection
            const applied = this.app.eventLogManager.applyRemoteEvent(g, env.event, strategy);
            
            if (applied) {
              debugLog('log', '[EVENT-LOG] Applied event to group', g.name);
              this.app.saveData();
              
              // Check for conflict notifications to show to user
              if (g.conflictNotifications?.length > 0) {
                const recentConflicts = g.conflictNotifications.filter(
                  n => n.timestamp > Date.now() - 5000 // Last 5 seconds
                );
                if (recentConflicts.length > 0) {
                  debugLog('info', '[CONFLICT] Conflicts resolved automatically', {
                    count: recentConflicts.length,
                    strategy: strategy
                  });
                }
              }
              
              try { this.app.$forceUpdate(); } catch {}
            } else {
              debugLog('warn', '[EVENT-LOG] Event not applied (conflict or invalid)', {
                eventId: env.event.eventId,
                from: env.from?.uuid
              });
            }
          }
          return;
        }

        // Fork alert: owner prepares a consistent snapshot and rebases members
        else if (env.type === 'sync-fork-alert') {
          try { debugLog('log', '[SMART-SYNC] Fork alert received', { from: env.from?.uuid, groupId: env.groupId }); } catch {}
          const g = (this.app.data.groups || []).find(x => x.groupId === env.groupId);
          if (!g) return;
          if (!this.app.isOwnerOfGroup(g)) return; // Only owner responds
          try {
            // Generate/ensure snapshot
            const snap = this.app.eventLogManager.createSnapshot(g);
            const eventsSince = Array.isArray(g.eventLog) ? g.eventLog.slice() : [];
            const from = { uuid: this.app.data.identity?.uuid, name:this.app.data.identity?.name||'' };
            const envSnap = { v:1, type:'sync-snapshot', ts:Date.now(), from, groupId: g.groupId, baseVC: snap.vectorClock||{}, snapshot: snap, eventsSince, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
            // Choose chunked path for large payloads
            const raw = JSON.stringify(envSnap);
            if (raw.length > 100000) {
              await this.sendChunkedGroup(g, 'snapshot', envSnap);
            } else {
              await this.sendToGroup(g, envSnap);
            }
          } catch(e) { debugLog('warn','[SMART-SYNC] Failed to send sync-snapshot', e); }
          return;
        }

        // Apply snapshot and optional delta events
        else if (env.type === 'sync-snapshot') {
          try { debugLog('log', '[SMART-SYNC] Applying snapshot', { groupId: env.groupId }); } catch {}
          const g = (this.app.data.groups || []).find(x => x.groupId === env.groupId);
          if (!g) return;
          try {
            // Replace state from snapshot
            const snap = env.snapshot || {};
            const d = snap.data || {};
            if (Array.isArray(d.links)) this.app.$set(g, 'links', JSON.parse(JSON.stringify(d.links)));
            if (Array.isArray(d.members)) this.app.$set(g, 'members', JSON.parse(JSON.stringify(d.members)));
            if (d.name !== undefined) this.app.$set(g, 'name', d.name);
            if (d.color !== undefined) this.app.$set(g, 'color', d.color);
            this.app.$set(g, 'version', d.version || 0);
            this.app.$set(g, 'vectorClock', snap.vectorClock || {});
            this.app.$set(g, 'headEventId', snap.eventId || null);
            // Reset event log to eventsSince
            const eventsSince = Array.isArray(env.eventsSince) ? env.eventsSince : [];
            this.app.$set(g, 'eventLog', []);
            for (const ev of eventsSince) {
              try { this.app.eventLogManager.applyEvent(g, ev); } catch {}
            }
            this.app.$set(g, 'forkDetected', false);
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch {}
          } catch(e) { debugLog('warn', '[SMART-SYNC] Snapshot apply failed', e); }
          return;
        }

        // Ownership transfer
        else if (env.type === 'owner-transfer') {
          const g = (this.app.data.groups || []).find(x => x.groupId === env.groupId);
          if (!g) return;
          // Validate that the sender is current owner
          if (env.from?.uuid && g.ownerUuid && env.from.uuid !== g.ownerUuid) return;
          // Ask the designated new owner to accept; others do nothing and wait for roster
          const my = this.app.data.identity?.uuid;
          if (my && my === env.newOwnerUuid) {
            const ok = confirm(this.app.getTranslation('dialog.transfer.acceptPrompt') || 'Owner transfer requested. Accept?');
            if (!ok) {
              // Optionally notify rejection
              try { const rej = { v:1, type:'owner-transfer-reject', ts:Date.now(), from:{uuid:my,name:this.app.data.identity?.name||''}, groupId: env.groupId, msgId:(Math.random().toString(36).slice(2)+Date.now()) }; this.sendToGroup(g, rej); } catch {}
              return;
            }
            // Apply locally and broadcast roster as the new owner
            this.app.$set(g, 'ownerUuid', env.newOwnerUuid);
            if (Array.isArray(g.members)) {
              g.members = g.members.map(m => {
                if (m.uuid === env.newOwnerUuid) return Object.assign({}, m, { role: 'owner' });
                if (m.role === 'owner') return Object.assign({}, m, { role: 'member' });
                return m;
              });
              const from = { uuid: my, name: this.app.data.identity?.name||'' };
              const roster = { v:1, type:'group-roster', ts:Date.now(), from, groupId: g.groupId, members: g.members, groupOwnerUuid: env.newOwnerUuid };
              await this.sendToGroup(g, roster);
            }
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch {}
          }
          return;
        }

        // Identity migration
        else if (env.type === 'identity-migrate') {
          const oldId = env.from?.oldUuid;
          const newId = env.from?.newUuid;
          if (!oldId || !newId) return;
          // Update contacts
          try {
            const c = (this.app.data.contacts||[]).find(x => x.uuid === oldId);
            if (c) c.uuid = newId;
          } catch {}
          // Update group rosters (owner action authoritative)
          (this.app.data.groups||[]).forEach(g => {
            const m = Array.isArray(g.members) ? g.members.find(x => x.uuid === oldId) : null;
            if (m) m.uuid = newId;
          });
          this.app.saveData();
          return;
        }
      
        // Handle Smart Sync protocol messages
        else if (env.type === 'sync-version-check') {
          debugLog('log', '[SMART-SYNC] Received version check request', { from: env.from?.uuid, groupId: env.groupId });
          await this.app.handleSyncVersionCheck(env, env.from?.uuid);
          return;
        } else if (env.type === 'sync-version-response') {
          debugLog('log', '[SMART-SYNC] Received version response', { from: env.from?.uuid, version: env.myVersion });
          this.app.handleSyncVersionResponse(env);
          return;
        } else if (env.type === 'sync-request-full') {
          debugLog('log', '[SMART-SYNC] Received full update request', { from: env.from?.uuid, toMember: env.toMember });
          if (env.toMember === this.app.data.identity?.uuid) {
            await this.app.handleSyncFullRequest(env);
          }
          return;
        } else if (env.type === 'sync-full-update') {
          debugLog('log', '[SMART-SYNC] Received full update', { from: env.from?.uuid, version: env.version });
          await this.app.handleSyncFullUpdate(env);
          return;
        } else if (env.type === 'sync-request-any') {
          debugLog('log', '[SMART-SYNC] Received broadcast update request', { from: env.from?.uuid });
          await this.app.handleSyncBroadcastRequest(env);
          return;
        }
        
        if (env.type === 'group-meta') {
          // Find group by groupId (for shared groups only - no fallback)
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          if (g) {
            if (env.name) g.name = env.name;
            if (env.emoji !== undefined) g.emoji = env.emoji || '';
            if (env.color!==undefined) g.color=env.color;
            if (env.favicon !== undefined) {
              this.app.$set(g, 'favicon', env.favicon || '');
              this.app.$set(g, 'faviconError', false);
              this.app.$set(g, 'faviconLoading', false);
            }
            if (env.faviconSource !== undefined) this.app.$set(g, 'faviconSource', env.faviconSource || null);
            if (env.faviconRuleId !== undefined) this.app.$set(g, 'faviconRuleId', env.faviconRuleId || null);
            if (typeof env.opacity==='number') g.opacity = Math.max(0, Math.min(100, env.opacity));
            if (env.infoHtml !== undefined) g.infoHtml = this.app.sanitizeHtml(String(env.infoHtml || ''));
          }
          this.app.saveData();
          try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
        } else if (env.type === 'group-roster') {
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          if (g) {
            let list = Array.isArray(env.members)?env.members:[];
            // Fill missing names from identity/contacts and preserve all permission fields
            try {
              const myUuid = this.app.data.identity?.uuid;
              const myName = this.app.data.identity?.name || '';
              const contacts = Array.isArray(this.app.data.contacts) ? this.app.data.contacts : [];
              list = list.map(m => {
                // Copy all properties from the incoming member object, including permissions
                const mm = Object.assign({}, m);
                if (!mm.name || mm.name === mm.uuid) {
                  if (mm.uuid === myUuid && myName) mm.name = myName;
                  else {
                    const c = contacts.find(x => x.uuid === mm.uuid);
                    if (c && c.name) mm.name = c.name;
                    // Fallback: if this member is the sender (owner usually sends roster), use from.name
                    if ((!mm.name || mm.name === mm.uuid) && env.from?.uuid === mm.uuid && env.from?.name) mm.name = env.from.name;
                  }
                }
                // Ensure permission fields are preserved exactly as sent by owner
                // Keep the permissions as they are in the incoming roster
                mm.canAdd = m.canAdd;
                mm.canEdit = m.canEdit;
                mm.canDelete = m.canDelete;
                return mm;
              });
            } catch {}
            this.app.$set(g, 'members', list);
            // Update ownerUuid from roster if provided, and normalize roles
            if (typeof env.groupOwnerUuid === 'string' && env.groupOwnerUuid) this.app.$set(g, 'ownerUuid', env.groupOwnerUuid);
            if (g.ownerUuid) {
              // Ensure exactly one owner role matches ownerUuid
              g.members = g.members.map(m => {
                if (m.uuid === g.ownerUuid) return Object.assign({}, m, { role: 'owner' });
                if (m.role === 'owner') return Object.assign({}, m, { role: 'member' });
                return m;
              });
            } else {
              // Infer ownerUuid if missing
              const owner = list.find(m=>m.role==='owner');
              if (owner && owner.uuid) this.app.$set(g, 'ownerUuid', owner.uuid);
            }
            // Ensure inbound prefs exist and default allow for known members (do not override existing choices)
            try {
              if (!g.prefs) this.app.$set(g, 'prefs', { inbound: { perMember: {} } });
              if (!g.prefs.inbound) this.app.$set(g.prefs, 'inbound', { perMember: {} });
              if (!g.prefs.inbound.perMember) this.app.$set(g.prefs.inbound, 'perMember', {});
              const per = g.prefs.inbound.perMember;
              (list||[]).forEach(m => { if (!per[m.uuid]) per[m.uuid] = 'allow'; });
            } catch {}
          }
          this.app.saveData();
          try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
        } else if (env.type === 'group-update') {
          // Replace local state with provided snapshot (but preserve roster/permissions)
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          if (g) {
            // CRITICAL FIX: Version checking to prevent old updates overwriting new ones
            if (env.version && g.version && env.version < g.version) {
              debugLog('warn', '[SYNC] Ignoring older group-update', {
                incoming: env.version,
                current: g.version,
                from: env.from?.uuid
              });
              
              // Send back our newer version to help the sender sync up
              const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name || '' };
              const snapshot = {
                v: 1,
                type: 'group-update',
                ts: Date.now(),
                from,
                version: g.version,
                ...this.app.serializeGroupForSync(g),
                msgId: (Math.random().toString(36).slice(2) + Date.now())
              };
              
              try {
                debugLog('log', '[SYNC] Sending newer version back to', env.from?.uuid);
                this.sendToGroup(g, snapshot);
              } catch (e) {
                debugLog('error', '[SYNC] Failed to send newer version back', e);
              }
              return; // Don't apply the older update
            }
            
            // Update version if provided
            if (env.version) {
              g.version = env.version;
            }
            if (env.name) g.name = env.name;
            if (env.emoji !== undefined) g.emoji = env.emoji || '';
            if (env.color!==undefined) g.color = env.color;
            if (env.favicon !== undefined) {
              this.app.$set(g, 'favicon', env.favicon || '');
              this.app.$set(g, 'faviconError', false);
              this.app.$set(g, 'faviconLoading', false);
            }
            if (env.faviconSource !== undefined) this.app.$set(g, 'faviconSource', env.faviconSource || null);
            if (env.faviconRuleId !== undefined) this.app.$set(g, 'faviconRuleId', env.faviconRuleId || null);
            if (typeof env.opacity==='number') g.opacity = Math.max(0, Math.min(100, env.opacity));
            if (env.infoHtml !== undefined) g.infoHtml = this.app.sanitizeHtml(String(env.infoHtml || ''));
            // Note: We don't update members/roster here - that's handled by group-roster messages
            const isOwner = (g?.members||[]).some(m=>m.role==='owner' && m.uuid===this.app.data.identity?.uuid) || (g.ownerUuid===this.app.data.identity?.uuid);
            try { 
              debugLog('log', '[SYNC] handle group-update', { 
                isOwner, 
                links: Array.isArray(env.links)?env.links.length:0,
                sampleLink: env.links?.[0] ? { text: env.links[0].text, url: env.links[0].url, hasUrl: !!env.links[0].url } : null
              }); 
            } catch {}
            // Hydrate links for members on initial bootstrap even if event-log is present
            if (!isOwner) {
              const incomingLinks = Array.isArray(env.links)
                ? env.links
                : (env.snapshot && env.snapshot.data && Array.isArray(env.snapshot.data.links) ? env.snapshot.data.links : null);
              if (incomingLinks && (!Array.isArray(g.links) || g.links.length === 0)) {
                if (!Array.isArray(g.links)) this.app.$set(g, 'links', []);
                g.links = [];
                incomingLinks.forEach((l, i) => {
                  const col = (typeof l.column==='number') ? l.column : 0;
                  const idx = (typeof l.index==='number') ? l.index : i;
                  const nl = {
                    uuid: l.uuid || this.app.generateUUID(),
                    text: l.text || l.url || '',
                    url: l.url || '',
                    keywords: l.keywords || '',
                    emoji: l.emoji || '',
                    infoHtml: this.app.sanitizeHtml(String(l.infoHtml || '')),
                    column: col,
                    index: idx,
                    editing: false,
                    isMouseOver: false
                  };
                  this.app.$set(g.links, g.links.length, nl);
                });
              }
            }

            if (Array.isArray(env.links)) {
              if (isOwner) {
                // Owner is canonical; ignore incoming link snapshots to avoid overriding positions/order
                try { debugLog('log', '[SYNC] owner ignoring incoming link snapshot'); } catch {}
              } else {
                // Member: merge by remoteId (or URL) and preserve local order
                // Ensure g.links is an array
                if (!Array.isArray(g.links)) {
                  this.app.$set(g, 'links', []);
                }
                const ensure = (l)=>{
                  debugLog('log', '[SYNC] Processing link in group-update:', {
                    uuid: l.uuid,
                    text: l.text,
                    url: l.url,
                    hasUrl: !!l.url && l.url !== '',
                    urlType: typeof l.url,
                    urlLength: l.url ? l.url.length : 0
                  });
                  
                  // Find existing link by UUID (preferred)
                  let ex = null;
                  
                  // First try to find by UUID if available
                  if (l.uuid) {
                    ex = g.links.find(x => x.uuid === l.uuid);
                    if (ex) {
                      debugLog('log', '[SYNC] Found existing link by UUID in group-update');
                    }
                  }
                  
                  // Only use URL matching as fallback if both links have URLs
                  // Don't skip links without URLs
                  if (!ex && l.url && l.url.trim()) {
                    ex = g.links.find(x => x.url && this.app.urlsEqual(x.url, l.url));
                    if (ex) {
                      debugLog('log', '[SYNC] Found existing link by URL in group-update');
                    }
                  }
                  
                  if (ex) {
                    // Update existing link with reactive properties
                    debugLog('log', '[SYNC] Updating link - before:', { text: ex.text, url: ex.url });
                    this.app.$set(ex, 'text', l.text || '');
                    this.app.$set(ex, 'url', l.url || '');
                    this.app.$set(ex, 'keywords', l.keywords || '');
                    this.app.$set(ex, 'emoji', l.emoji || '');
                    this.app.$set(ex, 'infoHtml', this.app.sanitizeHtml(String(l.infoHtml || '')));
                    // Always preserve UUID consistency
                    if (l.uuid && !ex.uuid) this.app.$set(ex, 'uuid', l.uuid);
                    // Ensure reactive UI properties exist
                    if (ex.editing === undefined) this.app.$set(ex, 'editing', false);
                    if (ex.isMouseOver === undefined) this.app.$set(ex, 'isMouseOver', false);
                    debugLog('log', '[SYNC] Updated link - after:', { uuid: ex.uuid, text: ex.text, url: ex.url, hasUrl: !!ex.url && ex.url !== '' });
                  } else {
                    // Add new link with reactive properties - including those without URL
                    const col = (typeof l.column==='number') ? l.column : 0;
                    // compute next index in that column if none provided
                    const nextIdx = (() => { const arr=g.links.filter(x=>x.column===col); return arr.length? Math.max(...arr.map(x=>x.index||0))+1 : 0; })();
                    const idx = (typeof l.index==='number') ? l.index : nextIdx;
                    const nl = this.app.$set(g.links, g.links.length, { 
                      uuid: l.uuid || this.app.generateUUID(), // Use UUID from update or generate new one
                      text: l.text || '', // Links can have text without URL
                      url: l.url || '', // URL can be empty
                      keywords: l.keywords || '', 
                      emoji: l.emoji || '',
                      column: col, 
                      index: idx, 
                      editing: false, 
                      isMouseOver: false 
                    });
                    try { debugLog('log', '[SYNC] added link from snapshot', { uuid: nl.uuid, column: nl.column, index: nl.index, text: nl.text, hasUrl: !!nl.url }); } catch {}
                  }
                };
                debugLog('log', '[SYNC] processing', env.links.length, 'links from update');
                env.links.forEach(ensure);
                // Final dedupe pass to avoid multiple occurrences
                this.dedupeGroupLinks(g);
                // tidy indices column-wise
                const cols = [...new Set((g.links||[]).map(x=>x.column))];
                cols.forEach(c => {
                  const arr = g.links.filter(x=>x.column===c).sort((a,b)=> (a.index||0)-(b.index||0));
                  arr.forEach((l,i)=> l.index = i);
                });
              }
            }
            
            // Apply event-log data if provided in the update - BUT DON'T OVERWRITE OWNER'S DATA
            if (env.useEventLog && env.eventLog) {
              const isOwner = (g?.members||[]).some(m=>m.role==='owner' && m.uuid===this.app.data.identity?.uuid) || (g.ownerUuid===this.app.data.identity?.uuid);
              
              if (isOwner) {
                // OWNER: Never overwrite own event-log, only merge new events
                debugLog('log', '[SYNC] Owner merging event-log from member update', {
                  currentEventCount: g.eventLog?.length || 0,
                  incomingEventCount: env.eventLog?.length || 0
                });
                
                // Only process if we already have event-log enabled
                if (g.useEventLog && g.eventLog) {
                  // Find new events that we don't have yet
                  const existingEventIds = new Set((g.eventLog || []).map(e => e.eventId));
                  const newEvents = (env.eventLog || []).filter(e => !existingEventIds.has(e.eventId));
                  
                  if (newEvents.length > 0) {
                    debugLog('log', '[SYNC] Owner found new events to merge', { count: newEvents.length });
                    // Merge new events using EventLogManager
                    if (this.app.eventLogManager) {
                      newEvents.forEach(event => {
                        this.app.eventLogManager.applyRemoteEvent(g, event, 'owner-leads');
                      });
                    }
                  }
                  
                  // Update vector clock by merging
                  if (env.vectorClock) {
                    const mergedVC = { ...(g.vectorClock || {}) };
                    Object.keys(env.vectorClock).forEach(key => {
                      mergedVC[key] = Math.max(mergedVC[key] || 0, env.vectorClock[key] || 0);
                    });
                    this.app.$set(g, 'vectorClock', mergedVC);
                  }
                } else if (!g.useEventLog) {
                  // Owner doesn't have event-log yet, but member does - enable it
                  debugLog('log', '[SYNC] Owner enabling event-log based on member data');
                  this.app.$set(g, 'useEventLog', true);
                  this.app.$set(g, 'eventLog', env.eventLog || []);
                  this.app.$set(g, 'snapshot', env.snapshot || null);
                  this.app.$set(g, 'headEventId', env.headEventId || null);
                  this.app.$set(g, 'vectorClock', env.vectorClock || {});
                }
              } else {
                // MEMBER: Accept event-log from owner or other members
                debugLog('log', '[SYNC] Member applying event-log data from group-update', {
                  eventLogCount: env.eventLog?.length || 0,
                  hasSnapshot: !!env.snapshot,
                  vectorClock: env.vectorClock
                });
                
                this.app.$set(g, 'useEventLog', true);
                this.app.$set(g, 'eventLog', env.eventLog || []);
                this.app.$set(g, 'snapshot', env.snapshot || null);
                this.app.$set(g, 'headEventId', env.headEventId || null);
                this.app.$set(g, 'vectorClock', env.vectorClock || {});
              }
            }
            
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
          }
        } else if (env.type === 'group-update-request') {
          // Respond with snapshot: ONLY the owner should respond
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          const isOwner = (g?.members||[]).some(m=>m.role==='owner' && m.uuid===this.app.data.identity?.uuid);
          if (!g) return;
          if (!isOwner) return; // Members do not respond to group-update-request
          try { debugLog('log', '[SYNC] respond group-update', { isOwner, to: env.from?.uuid, groupId: g.groupId }); } catch {}
          const snapshot = { 
            v:1, 
            type:'group-update', 
            ts:Date.now(), 
            from:{ uuid:this.app.data.identity.uuid, name:this.app.data.identity.name||'' }, 
            ...this.app.serializeGroupForSync(g), 
            msgId:(Math.random().toString(36).slice(2)+Date.now()) 
          };
          try { await this.sendChunkedGroup(g, 'group-update', snapshot); } catch {}
          // Also send the current roster if owner, so members get the latest permissions
          if (isOwner && g.members) {
            try {
              const rosterMsg = { v:1, type:'group-roster', ts:Date.now(), from:{ uuid:this.app.data.identity.uuid, name:this.app.data.identity.name||'' }, groupId: g.groupId, members: g.members||[] };
              await this.sendToGroup(g, rosterMsg);
              debugLog('log', '[SYNC] sent roster after update-request', { members: g.members.length });
            } catch {}
          }
        } else if (env.type === 'share-links') {
          // import into this group
          const sel = env.selection || {};
          // Resolve current up-to-date group reference by groupId only
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          
          // IMPORTANT: Ignore share-links if event-log is active
          if (g && g.useEventLog) {
            debugLog('log', '[SYNC] Ignoring share-links because event-log is active for group', g.name);
            return;
          }
          
          // inbound filter by prefs
          const fromUuid = env.from?.uuid;
          const prefs = g?.prefs?.inbound;
          if (prefs) {
            const per = prefs.perMember || {};
            const st = per[fromUuid] || 'unset';
            // For owner: always allow updates from all members
            // For members: allow by default unless explicitly denied  
            const isOwner = this.app.isOwnerOfGroup(g);
            const allow = isOwner || st==='allow' || st==='unset';
            try { debugLog('log', '[SYNC] inbound share-links filter', { from: fromUuid, state: st, isOwner, allow }); } catch {}
            if (!allow) { try { debugLog('warn', '[SYNC] share-links blocked by inbound prefs'); } catch {} return; }
          }
          if (Array.isArray(sel.links)) {
            debugLog('log', '[SYNC] Processing share-links', { 
              count: sel.links.length, 
              sample: sel.links[0] ? { 
                uuid: sel.links[0].uuid, 
                text: sel.links[0].text, 
                url: sel.links[0].url, 
                hasUrl: !!sel.links[0].url 
              } : null 
            });
            
            sel.links.forEach((l,i)=>{
              debugLog('log', '[SYNC] Processing incoming link:', {
                uuid: l.uuid,
                text: l.text,
                url: l.url,
                hasUrl: !!l.url && l.url !== '',
                urlLength: l.url ? l.url.length : 0
              });
              
              // IMPORTANT: With UUIDs, we must check for UUID match first
              let ex = null;
              
              // First priority: Match by UUID (this is the primary identifier now)
              if (l.uuid) {
                ex = (g.links||[]).find(x => x.uuid === l.uuid);
                if (ex) {
                  debugLog('log', '[SYNC] Found existing link by UUID:', l.uuid, 'existing url:', ex.url, 'new url:', l.url);
                }
              }
              
              // Fallback: URL match (only if no UUID match and URL exists)
              if (!ex && l.url && l.url.trim()) {
                ex = (g.links||[]).find(x => x.url && this.app.urlsEqual(x.url, l.url));
                if (ex) {
                  debugLog('log', '[SYNC] Found existing link by URL match');
                }
              }
              
              if (ex) {
                // Update existing link with reactive properties
                debugLog('log', '[SYNC] Updating existing link - before:', { text: ex.text, url: ex.url });
                this.app.$set(ex, 'text', l.text || '');
                this.app.$set(ex, 'url', l.url || '');
                this.app.$set(ex, 'keywords', l.keywords || '');
                this.app.$set(ex, 'emoji', l.emoji || '');
                this.app.$set(ex, 'infoHtml', this.app.sanitizeHtml(String(l.infoHtml || '')));
                // Ensure UUID is set if provided
                if (l.uuid && !ex.uuid) this.app.$set(ex, 'uuid', l.uuid);
                // Ensure reactive UI properties exist
                if (ex.editing === undefined) this.app.$set(ex, 'editing', false);
                if (ex.isMouseOver === undefined) this.app.$set(ex, 'isMouseOver', false);
                debugLog('log', '[SYNC] Updated existing link - after:', { uuid: ex.uuid, text: ex.text, url: ex.url });
              } else {
                // Create new link with UUID and reactive properties - including links without URL
                const col = (typeof l.column==='number') ? l.column : 0;
                const nextIdx = (() => { const arr=(g.links||[]).filter(x=>x.column===col); return arr.length? Math.max(...arr.map(x=>x.index||0))+1 : 0; })();
                const idx = (typeof l.index==='number') ? l.index : nextIdx;
                const newLink = this.app.$set(g.links, g.links.length, { 
                  uuid: l.uuid || this.app.generateUUID(), // Ensure UUID exists 
                  text: l.text || '', // Links can have only text
                  url: l.url || '', // URL can be empty
                  keywords: l.keywords || '',
                  emoji: l.emoji || '',
                  infoHtml: this.app.sanitizeHtml(String(l.infoHtml || '')),
                  column: col, 
                  index: idx, 
                  editing: false, 
                  isMouseOver: false 
                });
                debugLog('log', '[SYNC] Added new link from share-links:', { 
                  uuid: newLink.uuid, 
                  text: newLink.text, 
                  url: newLink.url,
                  hasUrl: !!newLink.url && newLink.url !== '',
                  column: newLink.column, 
                  index: newLink.index 
                });
              }
            });
            // Final dedupe pass to avoid multiple occurrences
            this.dedupeGroupLinks(g);
            // normalize per-column indices
            const cols = [...new Set((g.links||[]).map(x=>x.column))];
            cols.forEach(c => {
              const arr = g.links.filter(x=>x.column===c).sort((a,b)=> (a.index||0)-(b.index||0));
              arr.forEach((l,i)=> l.index=i);
            });
            this.app.saveData();
            // Force Vue to recalc classes that depend on reactive props
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
          }
        } else if (env.type === 'link-delete' && env.link) {
          if (!group.groupId) return; // Only process for shared groups with groupId
          const g = (this.app.data.groups||[]).find(x => 
            x.groupId === group.groupId
          );
          if (!g) return;
          
          // CRITICAL FIX: Version checking for delete operations
          if (env.version && g.version && env.version < g.version) {
            debugLog('warn', '[SYNC] Ignoring link-delete from older version', {
              incoming: env.version,
              current: g.version,
              link: env.link?.uuid || env.link?.url,
              from: env.from?.uuid
            });
            // Don't send back update here - the sender will sync via other means
            return;
          }
          const luuid = env.link.uuid;
          const lid = env.link.id; // Legacy - not used anymore
          const lurl = env.link.url;
          let idx = -1;
          let col = 0;
          if (Array.isArray(g.links)) {
            // First try to find by UUID (preferred)
            if (luuid) {
              idx = g.links.findIndex(x => x.uuid === luuid);
            }
            // Fallback to URL matching if no UUID
            if (idx < 0 && lurl) {
              idx = g.links.findIndex(x => this.app.urlsEqual(x.url, lurl));
            }
            if (idx >= 0) col = g.links[idx].column||0;
          }
          if (idx >= 0) {
            g.links.splice(idx,1);
            const colLinks = (g.links||[]).filter(l=>l.column===col).sort((a,b)=>a.index-b.index);
            colLinks.forEach((l,i)=>{ l.index=i; });
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
            try { debugLog('log', '[SYNC] link-delete applied', { lid, lurl, col }); } catch {}
          } else {
            try { debugLog('warn', '[SYNC] link-delete could not find local link', { lid, lurl }); } catch {}
          }
        }
      }
      async sendOwnerSync(group) {
        // Owner initiates snapshot + request once on open
        // Get fresh group data to ensure we have the latest UUIDs after any migrations
        const freshGroup = this.app.data.groups?.find(g => g.uuid === group.uuid) || group;
        const isOwner = (freshGroup?.members||[]).some(m=>m.role==='owner' && m.uuid===this.app.data.identity?.uuid);
        if (!freshGroup || !freshGroup.shared || !isOwner) return;
        const from = { uuid:this.app.data.identity.uuid, name:this.app.data.identity.name||'' };
        // Ensure every link has a UUID before sending
        const linksWithUUIDs = (freshGroup.links||[]).map(l => {
          if (!l.uuid) {
            debugLog('warn', '[SYNC] Link missing UUID during owner sync:', l.text || l.url);
            // Generate UUID only if missing (should not happen after migration)
            l.uuid = this.app.generateUUID ? this.app.generateUUID() : this.generateUUID();
          }
          return this.app.serializeLinkForSync(l);
        });
        const snapshot = { 
          v:1, 
          type:'group-update', 
          ts:Date.now(), 
          from, 
          ...this.app.serializeGroupForSync(freshGroup),
          msgId:(Math.random().toString(36).slice(2)+Date.now()) 
        };
        try { debugLog('log', '[SYNC] owner snapshot+request', { topic: freshGroup.groupTopic, links: linksWithUUIDs.length, uuids: linksWithUUIDs.map(l => l.uuid) }); } catch {}
        try { await this.sendToGroup(freshGroup, snapshot); } catch {}
        const reqId = (Math.random().toString(36).slice(2)+Date.now());
        try { await this.sendToGroup(freshGroup, { v:1, type:'group-update-request', ts:Date.now(), from, groupId: freshGroup.groupId, msgId:reqId }); } catch {}
      }
      async inviteContactToGroup(group, contactUuid) {
        await this.ensureIdentity();
        // Ensure pairwise channel is derived and subscribed before sending invite
        try { await this.derivePairwiseFor(contactUuid); } catch {}
        
        // Get fresh group data to ensure we have the latest UUIDs after any migrations
        const freshGroup = this.app.data.groups?.find(g => g.uuid === group.uuid) || group;
        
        if (!freshGroup.shared || !freshGroup.groupId) {
          // Group is not shared yet OR was previously shared but is now unshared
          this.app.$set(freshGroup, 'shared', true);
          
          // Only generate new sharing properties if they don't exist
          // This preserves groupId for previously shared groups
          if (!freshGroup.groupId) {
            this.app.$set(freshGroup, 'groupId', this.genGroupId());
          }
          if (!freshGroup.groupKey) {
            this.app.$set(freshGroup, 'groupKey', this.genGroupKeyB64());
          }
          if (!freshGroup.groupTopic) {
            this.app.$set(freshGroup, 'groupTopic', this.genGroupTopic());
          }
          
          this.app.$set(freshGroup, 'ownerUuid', this.app.data.identity?.uuid || '');
          // persist newly shared state on owner side
          this.app.saveData();
          this.subscribeGroup(freshGroup);
          // send initial meta
          await this.sendToGroup(freshGroup, { 
            v:1, 
            type:'group-meta', 
            ts:Date.now(), 
            from:{uuid:this.app.data.identity.uuid,name:this.app.data.identity.name||''}, 
            groupId: freshGroup.groupId, 
            ...this.app.serializeGroupMetaForSync(freshGroup) 
          });
        }
        // Update and send roster
        if (!Array.isArray(freshGroup.members)) this.app.$set(freshGroup,'members',[]);
        const owner = { uuid: this.app.data.identity.uuid, name: this.app.data.identity.name||'' , role:'owner' };
        const contact = (this.app.data.contacts||[]).find(c=>c.uuid===contactUuid);
        // New member starts with basic permissions (owner can adjust later)
        // Start with add/edit permissions enabled for better collaboration experience
        const invited = { uuid: contactUuid, name: contact?.name||contactUuid, role:'member', canAdd:true, canEdit:true, canDelete:false };
        const uniqBy = (arr,key) => Object.values(arr.reduce((m,x)=>{m[x[key]]=x;return m;},{}));
        freshGroup.members = uniqBy([owner, ...(freshGroup.members||[]), invited],'uuid');
        // persist updated roster on owner side
        this.app.saveData();
        await this.sendToGroup(freshGroup, { v:1, type:'group-roster', ts:Date.now(), from:{uuid:this.app.data.identity.uuid,name:this.app.data.identity.name||''}, groupId: freshGroup.groupId, members: freshGroup.members });
        
        // Ensure all links have UUIDs before sending in invite
        const linksWithUUIDs = (freshGroup.links||[]).map(l => {
          if (!l.uuid) {
            debugLog('warn', '[INVITE] Link missing UUID:', l.text || l.url);
            // This should not happen after migration, but ensure UUID exists
            l.uuid = this.app.generateUUID ? this.app.generateUUID() : this.generateUUID();
            this.app.saveData(); // Save if we had to generate any UUIDs
          }
          return this.app.serializeLinkForSync(l);
        });
        
        debugLog('log', '[INVITE] Sending links with UUIDs:', linksWithUUIDs.map(l => ({ uuid: l.uuid, text: l.text })));
        debugLog('log', '[INVITE] Group event-log status:', {
          useEventLog: freshGroup.useEventLog,
          eventLogCount: freshGroup.eventLog?.length || 0,
          hasSnapshot: !!freshGroup.snapshot,
          headEventId: freshGroup.headEventId,
          vectorClock: freshGroup.vectorClock
        });
        
        // Keep invite lightweight to avoid ntfy attachments on pairwise channel
        // Full snapshot is delivered via group topic after subscribe
        const inviteSelection = { groups: [], links: [] };
        const invite = { 
          v:1, 
          type:'invite', 
          ts:Date.now(), 
          from:{uuid:this.app.data.identity.uuid,name:this.app.data.identity.name||''}, 
          groupId: freshGroup.groupId, 
          groupName: freshGroup.name, 
          groupColor: freshGroup.color||'', 
          groupOpacity: (typeof freshGroup.opacity==='number'?freshGroup.opacity:100), 
          groupOwnerUuid: (freshGroup.ownerUuid||this.app.data.identity?.uuid||''), 
          groupTopic: freshGroup.groupTopic, 
          groupKey: freshGroup.groupKey, 
          roles:['member'], 
          members: freshGroup.members||[], 
          selection: inviteSelection,
          // Only signal if event-log is used; no heavy payload here
          useEventLog: !!freshGroup.useEventLog
        };
        // Final safety: ensure contact has channel
        const c = (this.app.data.contacts||[]).find(x=>x.uuid===contactUuid);
        if (!c || !c.topic || !c.kChannelB64) {
          debugLog('warn', '[INVITE] Cannot send invite: contact channel missing', { contactUuid });
          return;
        }
        await this.sendToContact(contactUuid, invite);
        // Also bootstrap member with a pairwise full snapshot (chunked)
        try {
          const snapshot = { 
            v:1, 
            type:'group-update', 
            ts:Date.now(), 
            from:{ uuid:this.app.data.identity.uuid, name:this.app.data.identity.name||'' }, 
            ...this.app.serializeGroupForSync(freshGroup), 
            msgId:(Math.random().toString(36).slice(2)+Date.now()) 
          };
          await this.sendChunkedToContact(contactUuid, 'group-update', snapshot);
          debugLog('log','[INVITE] Pairwise chunked group-update sent to invited contact');
        } catch (e) { debugLog('warn','[INVITE] Pairwise snapshot failed', e); }
        // Proactively send full snapshot over group topic shortly after invite
        try {
          setTimeout(async () => {
            try {
              const from = { uuid: this.app.data.identity?.uuid, name: this.app.data.identity?.name || '' };
              const snapshot = {
                v: 1,
                type: 'group-update',
                ts: Date.now(),
                from,
                ...this.app.serializeGroupForSync(freshGroup),
                msgId: (Math.random().toString(36).slice(2) + Date.now())
              };
              // Use chunked transfer to avoid ntfy attachments for large payloads
              await this.sendChunkedGroup(freshGroup, 'group-update', snapshot);
              debugLog('log', '[INVITE] Proactive chunked group-update snapshot sent');
            } catch (e) { debugLog('warn', '[INVITE] Proactive snapshot failed', e); }
          }, 800);
        } catch {}
      }
      // Quick-Connect: rendezvous (offer/answer) and secure card exchange using ephemeral ECDH
      async quickCodeReceiveStart(code) {
        this.applyConfig();
        const topic = `mb-qc-${code}`; // avoid '/' in topic for broad server compatibility
        this.qcTopic = topic; this.qcCode = code;
        this.qcSeen = new Set(); this.qcAnswered = false;
        if (this.qcSub) { 
          try {
            if (this.qcSub.es && this.qcSub.es.close) this.qcSub.es.close();
            if (this.qcSub.lp && this.qcSub.lp.abort) this.qcSub.lp.abort();
          } catch {}
          this.qcSub = null; 
        }
        this.onQcStatus && this.onQcStatus({ phase: 'waiting', side: 'receiver', code, topic });
        this.qcSub = this.ntfy.subscribe(topic, async (evt) => {
          try {
            if (evt && evt.id && this.qcSeen && this.qcSeen.has(evt.id)) return; if (evt && evt.id && this.qcSeen) this.qcSeen.add(evt.id);
            const msg = JSON.parse(evt.text);
            if (msg?.type === 'qc-offer' && msg.epub) {
              this.onQcStatus && this.onQcStatus({ phase: 'offer_received' });
              if (!this.qcAnswered) { this.qcAnswered = true; await this.handleQcOffer(topic, msg); }
            } else if (msg?.type === 'qc-final' && msg.payload) {
              const kTemp = this.qcSecrets.get(topic);
              if (!kTemp) return;
              const plain = await CryptoUtil.aesDecrypt(kTemp, msg.payload);
              if (plain?.card) {
                await this.addContactFromCard(plain.card);
                await this.derivePairwiseFor(plain.card.uuid);
              }
              this.onQcStatus && this.onQcStatus({ phase: 'final_received', done: true });
              try { this.qcSub && this.qcSub.close(); } catch {}
              try { this.ntfy.unsubscribe(this.qcTopic); } catch {}
            }
          } catch { /* ignore */ }
        });
      }
      async handleQcOffer(topic, offer) {
        const eph = await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']);
        const otherEpub = await CryptoUtil.importPub(offer.epub);
        const shared = await CryptoUtil.deriveBits(eph.privateKey, otherEpub);
        const kTemp = await CryptoUtil.hkdf(shared, 'mybookmarks:qc-temp', 32);
        await this.ensureIdentity();
        const plaintext = { v: 1, type: 'qc-answer', ts: Date.now(), from: { uuid: this.app.data.identity.uuid, name: this.app.data.identity.name || '' }, card: this.getContactCard() };
        const payload = await CryptoUtil.aesEncrypt(kTemp, plaintext);
        const myEpubB64 = B64.enc(new Uint8Array(await crypto.subtle.exportKey('raw', eph.publicKey)));
        this.qcSecrets.set(topic, kTemp);
        try {
          await this.ntfy.publish(topic, JSON.stringify({ type: 'qc-answer', epub: myEpubB64, payload }), this.cfg.quickCodeTtlSec || CONSTS.QUICK_CODE_TTL_SEC);
        } catch(e) { try { debugLog('error','[QC] publish qc-answer failed', e); } catch {} }
        this.onQcStatus && this.onQcStatus({ phase: 'answer_sent' });
      }
      async quickCodeSendOffer(code) {
        this.applyConfig();
        const topic = `mb-qc-${code}`; // avoid '/' in topic for broad server compatibility
        this.qcTopic = topic; this.qcCode = code; this.qcSeen = new Set();
        // Close any existing subscription first
        if (this.qcSub) { try { this.qcSub.close(); } catch {} this.qcSub = null; }
        // ephemeral key
        const eph = await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']);
        const epubB64 = B64.enc(new Uint8Array(await crypto.subtle.exportKey('raw', eph.publicKey)));
        this.qcSub = this.ntfy.subscribe(topic, async (evt) => {
          try {
            if (evt && evt.id && this.qcSeen && this.qcSeen.has(evt.id)) return; if (evt && evt.id && this.qcSeen) this.qcSeen.add(evt.id);
            const msg = JSON.parse(evt.text);
            if (msg?.type === 'qc-answer' && msg.payload && msg.epub) {
              this.onQcStatus && this.onQcStatus({ phase: 'answer_received' });
              const otherEpub = await CryptoUtil.importPub(msg.epub);
              const shared = await CryptoUtil.deriveBits(eph.privateKey, otherEpub);
              const kTemp = await CryptoUtil.hkdf(shared, 'mybookmarks:qc-temp', 32);
              const plain = await CryptoUtil.aesDecrypt(kTemp, msg.payload);
              if (plain?.card) {
                await this.addContactFromCard(plain.card);
                // auto-derive pairwise
                await this.derivePairwiseFor(plain.card.uuid);
              }
              // Send back our card encrypted with the same temporary key (finalize pairing for receiver)
              const myCard = this.getContactCard();
              const finalPayload = await CryptoUtil.aesEncrypt(kTemp, { v: 1, type: 'qc-final', ts: Date.now(), from: { uuid: this.app.data.identity.uuid, name: this.app.data.identity.name || '' }, card: myCard });
              await this.ntfy.publish(topic, JSON.stringify({ type: 'qc-final', payload: finalPayload }), this.cfg.quickCodeTtlSec || CONSTS.QUICK_CODE_TTL_SEC);
              this.onQcStatus && this.onQcStatus({ phase: 'final_sent', done: true });
              try { 
                if (this.qcSub) {
                  if (this.qcSub.es && this.qcSub.es.close) this.qcSub.es.close();
                  if (this.qcSub.lp && this.qcSub.lp.abort) this.qcSub.lp.abort();
                }
              } catch { }
              try { this.ntfy.unsubscribe(this.qcTopic); } catch {}
            }
          } catch (e) { /* ignore */ }
        });
        try {
          await this.ntfy.publish(topic, JSON.stringify({ v: 1, type: 'qc-offer', ts: Date.now(), from: { name: this.app.data.identity?.name || '' }, epub: epubB64 }), this.cfg.quickCodeTtlSec || CONSTS.QUICK_CODE_TTL_SEC);
        } catch(e) { try { debugLog('error','[QC] publish qc-offer failed', e); } catch {} }
        this.onQcStatus && this.onQcStatus({ phase: 'offer_sent', side: 'sender', code, topic });
        // Return a promise that resolves when answer handled
        return new Promise((resolve) => {
          const handler = async (data) => {
            try {
              const msg = JSON.parse(data);
              if (msg?.type === 'qc-answer' && msg.payload && msg.epub) { resolve(true); }
            } catch { }
          };
          if (this.qcSub) this.qcSub.onmessage = (ev) => handler(ev.data);
          // timeout safety
          setTimeout(() => { 
            try { 
              if (this.qcSub) {
                if (this.qcSub.es && this.qcSub.es.close) this.qcSub.es.close();
                if (this.qcSub.lp && this.qcSub.lp.abort) this.qcSub.lp.abort();
              }
            } catch { } 
            this.qcSub = null; 
            resolve(null); 
          }, (this.cfg.quickCodeTtlSec || CONSTS.QUICK_CODE_TTL_SEC) * 1000);
        });
      }
      quickCodeStop() { 
        try { 
          if (this.qcSub) {
            // qcSub is a handles object with { es, lp, closed } structure
            if (this.qcSub.es && this.qcSub.es.close) this.qcSub.es.close();
            if (this.qcSub.lp && this.qcSub.lp.abort) this.qcSub.lp.abort();
            // Also unsubscribe from ntfy topic
            if (this.qcTopic) this.ntfy.unsubscribe(this.qcTopic);
          }
        } catch (e) { 
          debugLog('warn', '[QC] Error closing subscription:', e); 
        } 
        this.qcSub = null; 
        this.qcSecrets.clear(); 
        this.onQcStatus && this.onQcStatus({ phase: 'stopped' }); 
      }
      async onEnvelope(env, meta) {
        // Ignore self-echo on pairwise channels to avoid acting on our own messages
        try {
          if (meta?.scope === 'pair' && env?.from?.uuid && this.app.data.identity?.uuid && env.from.uuid === this.app.data.identity.uuid) {
            return;
          }
        } catch {}
        
        // Check if sender is blocked (removed contact)
        if (env?.from?.uuid && this.app.data.blockedContacts?.includes(env.from.uuid)) {
          debugLog('log', '[SECURITY] Dropping message from blocked contact:', env.from.uuid);
          return;
        }
        
        // Dedup by msgId if present
        if (env && env.msgId && this.app.processedMsgIds && this.app.processedMsgIds.has(env.msgId)) return;

        // Pairwise chunked sync (initial snapshot bootstrap)
        if (meta?.scope==='pair' && (env?.type==='sync-chunk' || env?.type==='sync-chunks-done')) {
          try {
            const tId = env.transferId;
            if (!tId) return;
            let buf = this.groupTransfers.get(tId);
            if (!buf) {
              if (this.groupTransfers.size >= CONSTS.MAX_CONCURRENT_TRANSFERS) return;
              buf = { groupId: env.groupId || null, contentType: env.contentType||'snapshot', total: env.total||0, parts: new Map(), timer: null, from: env.from?.uuid, bytes: 0 };
              this.groupTransfers.set(tId, buf);
              buf.timer = setTimeout(()=>{ this.groupTransfers.delete(tId); }, CONSTS.MINUTE_MS);
            }
            if (env.type==='sync-chunk') {
              if (typeof env.seq==='number' && typeof env.payloadB64==='string') {
                buf.parts.set(env.seq, env.payloadB64);
                buf.bytes += env.payloadB64.length;
                if (env.total && !buf.total) buf.total = env.total;
                if (buf.total && buf.parts.size===buf.total) {
                  try {
                    const ordered = Array.from({ length: buf.total }, (_, i)=> buf.parts.get(i)||'');
                    const bytes = B64.dec(ordered.join(''));
                    const json = new TextDecoder().decode(bytes);
                    const fullEnv = JSON.parse(json);
                    const g = (this.app.data.groups||[]).find(x=> x.groupId === fullEnv.groupId);
                    if (g) this.handleGroupEnvelope(g, fullEnv);
                  } catch(e) { debugLog('warn','[PAIR] early chunk reassembly failed', e); }
                  if (buf.timer) clearTimeout(buf.timer);
                  this.groupTransfers.delete(tId);
                }
              }
              return;
            }
            if (env.type==='sync-chunks-done') {
              const total = buf.total || env.total || 0;
              if (total>0 && buf.parts.size===total) {
                const ordered = Array.from({ length: total }, (_, i)=> buf.parts.get(i)||'');
                const bytes = B64.dec(ordered.join(''));
                const json = new TextDecoder().decode(bytes);
                const fullEnv = JSON.parse(json);
                // Dispatch to group handler
                const g = (this.app.data.groups||[]).find(x => x.groupId === fullEnv.groupId);
                if (g) this.handleGroupEnvelope(g, fullEnv);
              }
              if (buf.timer) clearTimeout(buf.timer);
              this.groupTransfers.delete(tId);
              return;
            }
          } catch (e) { debugLog('warn','[PAIR] chunk reassembly failed', e); }
        }
        
        // Show invitation dialog for group invites (don't mark as processed yet)
        if (meta?.scope==='pair' && env?.type==='invite' && env.groupTopic && env.groupKey) {
          this.app.showInvitationDialog('group', env);
          return;
        }
        
        // Show invitation dialog for shared links or groups (don't mark as processed yet)
        if (meta?.scope==='pair' && env?.type==='share' && env?.selection && (env.selection.links || env.selection.groups)) {
          this.app.showInvitationDialog('link', env);
          return;
        }
        
        // Mark as processed for other message types
        if (env && env.msgId && this.app.processedMsgIds) this.app.processedMsgIds.add(env.msgId);
        // Handle membership updates over pairwise
        if (meta?.scope==='pair' && env?.type==='group-member-removed' && env.groupId) {
          debugLog('log', '[GROUP_REMOVED] Received removal notification for group:', env.groupId);
          // Unsubscribe and remove local group
          const gs = (this.app.data.groups||[]);
          const idx = gs.findIndex(x=>x.groupId===env.groupId);
          if (idx>=0) {
            const groupName = gs[idx].name;
            debugLog('log', '[GROUP_REMOVED] Removing group:', groupName, 'with id:', env.groupId);
            try { 
              if (gs[idx].groupTopic) {
                // Unsubscribe from NTFY
                this.ntfy.unsubscribe(gs[idx].groupTopic);
                // Also remove from groupSubs map to allow re-subscription later
                if (this.groupSubs && this.groupSubs.has(gs[idx].groupTopic)) {
                  this.groupSubs.delete(gs[idx].groupTopic);
                  debugLog('log', '[GROUP_REMOVED] Removed from groupSubs:', gs[idx].groupTopic);
                }
              }
            } catch (e) {
              debugLog('error', '[GROUP_REMOVED] Failed to unsubscribe:', e);
            }
            gs.splice(idx,1);
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
            debugLog('log', '[GROUP_REMOVED] Successfully removed group:', groupName);
          } else {
            debugLog('warn', '[GROUP_REMOVED] Group not found with id:', env.groupId);
          }
          return;
        }
        if (meta?.scope==='pair' && env?.type==='group-member-left' && env.groupId && env.memberUuid) {
          // Owner's side: remove member and broadcast roster
          const g = (this.app.data.groups||[]).find(x=>x.groupId===env.groupId);
          if (g) {
            g.members = (g.members||[]).filter(x=>x.uuid!==env.memberUuid);
            // Auto-unshare when only owner remains or no regular members
            try {
              const noMembers = !g.members || g.members.length === 0;
              const onlyOwnerRemains = g.members && g.members.length === 1 && g.members[0].role === 'owner';
              const noRegularMembers = g.members && g.members.length > 0 && !g.members.some(x => x.role === 'member');
              if (g.shared && (noMembers || onlyOwnerRemains || noRegularMembers)) {
                debugLog('log', '[SHARE] Auto-unshare after member left:', g.name,
                  noMembers ? '(no members)' : onlyOwnerRemains ? '(only owner remains)' : '(no regular members)');
                g.shared = false;
                try { if (g.groupTopic) this.ntfy.unsubscribe(g.groupTopic); } catch (e) { debugLog('warn','[SHARE] Unsubscribe failed', e); }
              }
            } catch {}

            this.app.saveData();
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
            
            // Only broadcast roster if group is still shared
            if (g.shared) {
              try { await this.sendToGroup(g, { v:1, type:'group-roster', ts:Date.now(), from:{ uuid:this.app.data.identity?.uuid, name:this.app.data.identity?.name||'' }, groupId: g.groupId, members: g.members||[] }); } catch {}
            }
          }
          return;
        }
        // Contact update: refresh contact name and affected group rosters
        if (meta?.scope==='pair' && env?.type==='contact-update' && env.from?.uuid) {
          try {
            const uuid = env.from.uuid;
            const name = env.from.name || '';
            const contacts = (this.app.data.contacts||[]);
            const c = contacts.find(x=>x.uuid===uuid);
            if (c && name && c.name!==name) { c.name = name; }
            // Update rosters where this member exists
            for (const g of (this.app.data.groups||[])) {
              if (Array.isArray(g.members)) {
                let changed = false;
                g.members = g.members.map(m=>{
                  if (m.uuid===uuid && name && m.name!==name) { changed=true; return Object.assign({}, m, { name }); }
                  return m;
                });
                if (changed) { /* local change suffices; owner will broadcast */ }
              }
            }
            this.app.saveData();
            try { this.app.$forceUpdate(); } catch (error) {
            debugLog('warn', '[Vue] $forceUpdate failed:', error);
          }
          } catch {}
          return;
        }
        // Handle ping/pong for online status checking
        if (env?.type === 'ping' && env?.pingId) {
          // Extract sender UUID - it might be directly in 'from' field or in 'from.uuid'
          const senderUuid = typeof env.from === 'string' ? env.from : env.from?.uuid;
          debugLog('log', '[PING/PONG] Received ping from:', senderUuid, 'with ID:', env?.pingId);
          
          // Don't respond to our own pings
          if (senderUuid === this.app.data.identity?.uuid) {
            debugLog('log', '[PING/PONG] Ignoring self-ping');
            return;
          }
          
          // Automatically respond with pong
          try {
            const contact = (this.app.data.contacts || []).find(c => c.uuid === senderUuid);
            if (contact) {
              const pongMessage = {
                type: 'pong',
                pingId: env.pingId, // Echo back the same ID
                from: this.app.data.identity?.uuid,
                timestamp: Date.now()
              };
              await this.sendToContact(contact.uuid, pongMessage);
              debugLog('log', '[PING/PONG] Sent pong response to:', contact.uuid);
            } else {
              debugLog('warn', '[PING/PONG] No contact found for UUID:', senderUuid);
            }
          } catch (e) {
            debugLog('error', '[PING/PONG] Failed to send pong:', e);
          }
          return;
        }
        
        // Handle pong responses
        if (env?.type === 'pong' && env?.pingId) {
          // Extract sender UUID - it might be directly in 'from' field or in 'from.uuid'
          const senderUuid = typeof env.from === 'string' ? env.from : env.from?.uuid;
          debugLog('log', '[PING/PONG] Received pong from:', senderUuid, 'with ID:', env?.pingId);
          
          // Trigger any waiting promise for this pingId
          if (this.app.pendingPings && this.app.pendingPings[env.pingId]) {
            this.app.pendingPings[env.pingId].resolve(true);
            delete this.app.pendingPings[env.pingId];
          }
          return;
        }
        
        // For any other message types, we can optionally log them but don't store in inbox
        debugLog('log', '[MESSAGE] Received message type:', env?.type, 'from:', env?.from?.name || env?.from?.uuid);
      }
      
      dedupeGroupLinks(group) {
        if (!group || !Array.isArray(group.links)) return;
        const seen = new Map();
        const deduped = [];
        
        for (const link of group.links) {
          // Use UUID for deduplication if available, otherwise fall back to URL
          const key = link.uuid 
            ? `uuid:${link.uuid}` 
            : `url:${this.app.normalizeUrl ? this.app.normalizeUrl(link.url) : link.url}`;
          
          if (!seen.has(key)) {
            seen.set(key, true);
            deduped.push(link);
          } else {
            // If we find a duplicate, keep the one with more information
            const existing = deduped.find(l => {
              const existingKey = l.uuid 
                ? `uuid:${l.uuid}` 
                : `url:${this.app.normalizeUrl ? this.app.normalizeUrl(l.url) : l.url}`;
              return existingKey === key;
            });
            // Update existing link with any missing information
            if (existing) {
              if (!existing.uuid && link.uuid) existing.uuid = link.uuid;
              if (!existing.text && link.text) existing.text = link.text;
              if (!existing.keywords && link.keywords) existing.keywords = link.keywords;
            }
          }
        }
        
        group.links = deduped;
      }
    }

    MB.Sync.SharingService = SharingService;

    const LINK_SHORTENER_SERVICES = [
      {
        id: 'bitly',
        name: 'Bitly',
        demoDomain: 'https://bit.ly',
        summaryKey: 'shorteners.services.bitly.summary',
        audienceKey: 'shorteners.services.bitly.audience',
        integrations: [
          { name: 'Elementor', score: 3 },
          { name: 'Branch', score: 3 },
          { name: 'geotargetly.com', score: 3 }
        ],
        accountRequired: true
      },
      {
        id: 'rebrandly',
        name: 'Rebrandly',
        demoDomain: 'https://rebrand.ly',
        summaryKey: 'shorteners.services.rebrandly.summary',
        audienceKey: 'shorteners.services.rebrandly.audience',
        integrations: [
          { name: 'Emelia', score: 3 },
          { name: 'Zapier', score: 3 },
          { name: 'Branch', score: 3 }
        ],
        accountRequired: true
      },
      {
        id: 'tinyurl',
        name: 'TinyURL',
        demoDomain: 'https://tinyurl.com',
        summaryKey: 'shorteners.services.tinyurl.summary',
        audienceKey: 'shorteners.services.tinyurl.audience',
        integrations: [
          { name: 'Zapier', score: 2 },
          { name: 'onstipe.com', score: 2 }
        ],
        accountRequired: false
      },
      {
        id: 'blink',
        name: 'BL.INK',
        demoDomain: 'https://bl.ink',
        summaryKey: 'shorteners.services.blink.summary',
        audienceKey: 'shorteners.services.blink.audience',
        integrations: [
          { name: 'Zapier', score: 1 }
        ],
        accountRequired: true
      },
      {
        id: 'shortio',
        name: 'Short.io',
        demoDomain: 'https://short.io',
        summaryKey: 'shorteners.services.shortio.summary',
        audienceKey: 'shorteners.services.shortio.audience',
        integrations: [
          { name: 'Zapier', score: 2 },
          { name: 'Buffer', score: 2 }
        ],
        accountRequired: true
      },
      {
        id: 'dub',
        name: 'Dub',
        demoDomain: 'https://dub.sh',
        summaryKey: 'shorteners.services.dub.summary',
        audienceKey: 'shorteners.services.dub.audience',
        integrations: [
          { name: 'Zapier', score: 1 }
        ],
        accountRequired: true
      },
      {
        id: 'owly',
        name: 'Ow.ly (Hootsuite)',
        demoDomain: 'https://ow.ly',
        summaryKey: 'shorteners.services.owly.summary',
        audienceKey: 'shorteners.services.owly.audience',
        integrations: [
          { name: 'Social Media Dashboard', score: 1 }
        ],
        accountRequired: true
      },
      {
        id: 'replug',
        name: 'Replug',
        demoDomain: 'https://replug.link',
        summaryKey: 'shorteners.services.replug.summary',
        audienceKey: 'shorteners.services.replug.audience',
        integrations: [
          { name: 'Buffer', score: 2 },
          { name: 'Blogging Wizard', score: 2 }
        ],
        accountRequired: true
      },
      {
        id: 't2m',
        name: 'T2M',
        demoDomain: 'https://t2m.one',
        summaryKey: 'shorteners.services.t2m.summary',
        audienceKey: 'shorteners.services.t2m.audience',
        integrations: [
          { name: 'companionlink.com', score: null }
        ],
        accountRequired: true
      }
    ];

    const DEFAULT_PROXY_TIMEOUT_MS = 20000;

    const LINK_SHORTENER_ADAPTERS = {
      tinyurl: async ({ url, account = {}, options = {} }) => {
        const apiKey = (account.apiKey || '').trim();
        const slug = options.suggestedSlug || '';
        const timeoutMs = options.timeoutMs || DEFAULT_PROXY_TIMEOUT_MS;

        if (apiKey) {
          const body = { url };
          try {
            const baseHost = options.baseUrl ? new URL(options.baseUrl).hostname : '';
            if (baseHost && baseHost !== 'tinyurl.com') {
              body.domain = baseHost;
            }
          } catch {}
          if (slug) body.alias = slug;

          return {
            request: {
              url: 'https://api.tinyurl.com/create',
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
              },
              body: JSON.stringify(body),
              timeoutMs
            },
            parse: (response) => {
              if (!response) throw new Error('Empty response from TinyURL');
              if (response.error) throw new Error(response.error);
              let data = null;
              try {
                data = response.bodyText ? JSON.parse(response.bodyText) : null;
              } catch (e) {
                throw new Error('TinyURL returned invalid JSON');
              }
              if (!response.ok) {
                const message = data?.errors?.[0]?.message || data?.message || `HTTP ${response.status}`;
                throw new Error(message);
              }
              const shortUrl = data?.data?.tiny_url || data?.data?.tinyUrl || data?.tiny_url;
              if (!shortUrl) {
                throw new Error('TinyURL response missing tiny_url');
              }
              return {
                shortUrl,
                meta: {
                  provider: 'tinyurl',
                  id: data?.data?.id || null
                }
              };
            }
          };
        }

        const endpoint = new URL('https://tinyurl.com/api-create.php');
        endpoint.searchParams.set('url', url);

        return {
          request: {
            url: endpoint.toString(),
            method: 'GET',
            timeoutMs
          },
          parse: (response) => {
            if (!response) throw new Error('Empty response from TinyURL');
            if (response.error) throw new Error(response.error);
            const text = (response.bodyText || '').trim();
            if (!text) {
              throw new Error('TinyURL returned an empty response');
            }
            if (!response.ok && response.status) {
              throw new Error(text || `HTTP ${response.status}`);
            }
            if (/^error/i.test(text)) {
              throw new Error(text);
            }
            return {
              shortUrl: text,
              meta: { provider: 'tinyurl' }
            };
          }
        };
      },
      bitly: async ({ url, account = {}, options = {} }) => {
        const token = (account.apiKey || '').trim();
        if (!token) {
          throw new Error('Bitly requires an API token.');
        }
        const domain = resolveDomain(account.label, options.baseUrl, 'bit.ly');
        const body = { long_url: url };
        if (domain) body.domain = domain;
        if (options.suggestedSlug && domain) {
          body.custom_bitlink = `${domain}/${options.suggestedSlug}`;
        }
        return {
          request: {
            url: 'https://api-ssl.bitly.com/v4/shorten',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body,
            timeoutMs: options.timeoutMs || DEFAULT_PROXY_TIMEOUT_MS
          },
          parse: (response) => {
            const data = parseJsonResponse(response, 'Bitly');
            const shortUrl = data.link || data.id || '';
            if (!shortUrl) throw new Error('Bitly response missing link');
            return {
              shortUrl,
              meta: {
                provider: 'bitly',
                id: data.id || null
              }
            };
          }
        };
      },
      rebrandly: async ({ url, account = {}, options = {} }) => {
        const apiKey = (account.apiKey || '').trim();
        if (!apiKey) {
          throw new Error('Rebrandly requires an API key.');
        }
        const body = {
          destination: url
        };
        const domain = resolveDomain(account.label, options.baseUrl, 'rebrand.ly');
        if (domain) {
          body.domain = { fullName: domain };
        }
        if (options.suggestedSlug) {
          body.slashtag = options.suggestedSlug;
        }
        return {
          request: {
            url: 'https://api.rebrandly.com/v1/links',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'apikey': apiKey
            },
            body,
            timeoutMs: options.timeoutMs || DEFAULT_PROXY_TIMEOUT_MS
          },
          parse: (response) => {
            const data = parseJsonResponse(response, 'Rebrandly');
            const shortUrl = data.shortUrl || data.shortURL || data.link || '';
            if (!shortUrl) throw new Error('Rebrandly response missing shortUrl');
            return {
              shortUrl: shortUrl.startsWith('http') ? shortUrl : `https://${shortUrl}`,
              meta: {
                provider: 'rebrandly',
                id: data.id || null
              }
            };
          }
        };
      },
      blink: async ({ url, account = {}, options = {} }) => {
        const apiKey = (account.apiKey || '').trim();
        if (!apiKey) {
          throw new Error('BL.INK requires an API token.');
        }
        const body = {
          long_url: url
        };
        const domain = resolveDomain(account.label, options.baseUrl, 'bl.ink');
        if (domain) body.domain = domain;
        if (options.suggestedSlug) body.slashtag = options.suggestedSlug;
        return {
          request: {
            url: 'https://blinkapi.com/api/v4/links',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            },
            body,
            timeoutMs: options.timeoutMs || DEFAULT_PROXY_TIMEOUT_MS
          },
          parse: (response) => {
            const data = parseJsonResponse(response, 'BL.INK');
            const shortUrl = data.short_url || data.link || data.shortUrl || '';
            if (!shortUrl) throw new Error('BL.INK response missing short_url');
            return {
              shortUrl,
              meta: {
                provider: 'blink',
                id: data.id || data.uuid || null
              }
            };
          }
        };
      },
      'shortio': async ({ url, account = {}, options = {} }) => {
        const apiKey = (account.apiKey || '').trim();
        if (!apiKey) {
          throw new Error('Short.io requires an API key.');
        }
        const domain = resolveDomain(account.label, options.baseUrl, 'short.io');
        const body = {
          originalURL: url
        };
        if (domain) body.domain = domain;
        if (options.suggestedSlug) body.path = options.suggestedSlug;
        return {
          request: {
            url: 'https://api.short.io/links',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'authorization': apiKey
            },
            body,
            timeoutMs: options.timeoutMs || DEFAULT_PROXY_TIMEOUT_MS
          },
          parse: (response) => {
            const data = parseJsonResponse(response, 'Short.io');
            const shortUrl = data.shortURL || data.short_url || data.link || '';
            if (!shortUrl) throw new Error('Short.io response missing shortURL');
            return {
              shortUrl,
              meta: {
                provider: 'shortio',
                id: data.idString || data.id || null
              }
            };
          }
        };
      },
      dub: async ({ url, account = {}, options = {} }) => {
        const apiKey = (account.apiKey || '').trim();
        if (!apiKey) {
          throw new Error('Dub requires an API token.');
        }
        const domain = resolveDomain(account.label, options.baseUrl, 'dub.sh');
        const body = {
          url
        };
        if (domain) body.domain = domain;
        if (options.suggestedSlug) body.slug = options.suggestedSlug;
        return {
          request: {
            url: 'https://api.dub.co/links',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            },
            body,
            timeoutMs: options.timeoutMs || DEFAULT_PROXY_TIMEOUT_MS
          },
          parse: (response) => {
            const data = parseJsonResponse(response, 'Dub');
            const shortUrl = data.shortLink || data.shortUrl || data.link?.shortLink || data.link?.short_url || '';
            if (!shortUrl) throw new Error('Dub response missing shortLink');
            return {
              shortUrl,
              meta: {
                provider: 'dub',
                id: data.id || data.link?.id || null
              }
            };
          }
        };
      },
      owly: async ({ url, account = {}, options = {} }) => {
        const apiKey = (account.apiKey || '').trim();
        if (!apiKey) {
          throw new Error('Ow.ly requires an OAuth token.');
        }
        const body = {
          longUrl: url
        };
        if (options.suggestedSlug) body.alias = options.suggestedSlug;
        return {
          request: {
            url: 'https://api.hootsuite.com/v1/links/shorten',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            },
            body,
            timeoutMs: options.timeoutMs || DEFAULT_PROXY_TIMEOUT_MS
          },
          parse: (response) => {
            const data = parseJsonResponse(response, 'Ow.ly');
            const shortUrl = data.shortUrl || data.short_url || data.data?.owlyUrl || '';
            if (!shortUrl) throw new Error('Ow.ly response missing shortUrl');
            return {
              shortUrl,
              meta: {
                provider: 'owly',
                id: data.id || null
              }
            };
          }
        };
      },
      replug: async ({ url, account = {}, options = {} }) => {
        const apiKey = (account.apiKey || '').trim();
        if (!apiKey) {
          throw new Error('Replug requires an API token.');
        }
        const domain = resolveDomain(account.label, options.baseUrl, 'replug.link');
        const body = {
          url
        };
        if (domain) body.domain = domain;
        if (options.suggestedSlug) body.slug = options.suggestedSlug;
        return {
          request: {
            url: 'https://app.replug.io/api/v1/links',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            },
            body,
            timeoutMs: options.timeoutMs || DEFAULT_PROXY_TIMEOUT_MS
          },
          parse: (response) => {
            const data = parseJsonResponse(response, 'Replug');
            const shortUrl = data.short_url || data.shortUrl || data.data?.short_url || '';
            if (!shortUrl) throw new Error('Replug response missing short_url');
            return {
              shortUrl,
              meta: {
                provider: 'replug',
                id: data.id || data.data?.id || null
              }
            };
          }
        };
      },
      t2m: async ({ url, account = {}, options = {} }) => {
        const apiKey = (account.apiKey || '').trim();
        if (!apiKey) {
          throw new Error('T2M requires an API key.');
        }
        const domain = resolveDomain(account.label, options.baseUrl, 't2m.io');
        const body = {
          long_url: url
        };
        if (domain) body.domain = domain;
        if (options.suggestedSlug) body.custom_backhalf = options.suggestedSlug;
        return {
          request: {
            url: 'https://t2mio.com/api/v1/shorten',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-API-KEY': apiKey
            },
            body,
            timeoutMs: options.timeoutMs || DEFAULT_PROXY_TIMEOUT_MS
          },
          parse: (response) => {
            const data = parseJsonResponse(response, 'T2M');
            const shortUrl = data.short_url || data.shortUrl || data.data?.short_url || data.url || '';
            if (!shortUrl) throw new Error('T2M response missing short_url');
            return {
              shortUrl,
              meta: {
                provider: 't2m',
                id: data.id || data.data?.id || null
              }
            };
          }
        };
      }
    };

    const LINK_SHORTENER_DOMAINS = new Set(LINK_SHORTENER_SERVICES.map(service => {
      try {
        return new URL(service.demoDomain).hostname.toLowerCase();
      } catch (e) {
        return (service.demoDomain || '').replace(/^https?:\/\//, '').replace(/\/$/, '').toLowerCase();
      }
    }).filter(Boolean));

    const LINK_SUSPICIOUS_QUERY_KEYS = ['token', 'access_token', 'session', 'sessionid', 'password', 'pass', 'auth', 'apikey', 'api_key', 'jwt'];
    const LINK_DANGEROUS_PROTOCOLS = ['javascript:', 'data:', 'vbscript:'];
    const LINK_SUSPICIOUS_PATTERNS = ['<script', '%3cscript', 'onerror=', 'onclick=', 'document.cookie', 'window.location'];

    window.MB = window.MB || {};

    const MB_I18N_TRANSLATIONS = { // Übersetzungen jetzt hier
          'en': {
            // Favicon rules
            'options.links.faviconRules': 'Favicon rules',
            'options.links.faviconRules.manage': 'Manage favicon rules',
            'favicon.rules.title': 'Favicon Rules',
            'favicon.rules.add': 'Add rule',
            'favicon.rules.apply': 'Apply to existing links',
            'favicon.rules.override': 'Override existing favicons',
            'favicon.rules.type': 'Type',
            'favicon.rules.pattern': 'Pattern',
            'favicon.rules.icon': 'Icon',
            'favicon.rules.comment': 'Comment',
            'favicon.rules.commentPlaceholder': 'Optional comment',
            'favicon.rules.enabled': 'Enabled',
            'favicon.rules.domain': 'Domain',
            'favicon.rules.prefix': 'URL prefix',
            'favicon.rules.regex': 'Regex',
            'favicon.rules.autofetch': 'Auto-fetch',
            'favicon.rules.upload': 'Upload',
            'favicon.rules.delete': 'Delete',
            'favicon.rules.test': 'Test URL',
            'favicon.rules.matchPreview': 'Matched rule preview',
            'favicon.rules.restoreDefaults': 'Restore defaults',
            'favicon.rules.export': 'Export rules',
            'favicon.rules.import': 'Import rules',
            'favicon.rules.none': 'No favicon rules yet.',
            'favicon.rules.defaultsRestored': 'Default favicon rules restored',
            'favicon.rules.defaultsAlreadyPresent': 'All default favicon rules are already present',
            'favicon.rules.exportError': 'Failed to export favicon rules',
            'favicon.rules.importSuccess': 'Imported {count} favicon rules',
            'favicon.rules.importNothing': 'No new favicon rules to import',
            'favicon.rules.importError': 'Failed to import favicon rules',
            'favicon.rules.needsExtension': 'Extension required to auto-fetch icons',
            'favicon.rules.saved': 'Favicon rules saved',
            'favicon.rules.applied': 'Favicon rules applied',
            // CardDAV
            'carddav.title': 'CardDAV Sync',
            'carddav.serverUrl': 'Server URL',
            'carddav.serverUrl.help': 'Base URL of your CardDAV server (e.g., https://cloud.example.com)',
            'carddav.username': 'Username',
            'carddav.username.help': 'Your CardDAV username',
            'carddav.password': 'App password',
            'carddav.password.help': 'Use an app-specific password if available',
            'carddav.addressbookPath': 'Addressbook path (optional)',
            'carddav.addressbookPath.help': 'Leave empty for auto-discovery, or set a full DAV path',
            'carddav.createAddressbookIfMissing': 'Create addressbook if missing',
            'carddav.createAddressbookIfMissing.help': 'Automatically create an addressbook named "MyBookmarks" if allowed',
            'carddav.syncInterval': 'Auto-sync interval',
            'carddav.syncInterval.help': 'How often to sync automatically (0 = manual only)',
            'carddav.syncInterval.manual': 'Manual only',
            'carddav.syncInterval.5min': 'Every 5 minutes',
            'carddav.syncInterval.10min': 'Every 10 minutes',
            'carddav.syncInterval.30min': 'Every 30 minutes',
            'carddav.syncInterval.1hour': 'Every hour',
            'carddav.syncNow': 'Sync now (Nextcloud Bookmarks)',
            'carddav.extensionRequired': 'Browser extension with CardDAV support required',
            'carddav.notEnabled': 'CardDAV is disabled in Options',
            'carddav.syncStarted': 'CardDAV sync started',
            'carddav.syncFailed': 'CardDAV sync failed: {message}',
            'carddav.addressbookPathMissing': 'Please configure Server URL and Addressbook Path in Options',
            'carddav.testConnection': 'Test connection',
            'options.sync.engine': 'Sync Backend',
            'options.sync.backend': 'Backend',
            'options.sync.backend.help': 'Select sync provider',
            'options.sync.backend.carddav': 'CardDAV (DAV, experimental)',
            'options.sync.backend.nc': 'Nextcloud Bookmarks (REST, alpha)',
            'bookmarks.title': 'Nextcloud Bookmarks',
            'bookmarks.serverUrl': 'Server URL',
            'bookmarks.serverUrl.help': 'Base URL of your Nextcloud (e.g., https://cloud.example.com)',
            'bookmarks.username': 'Username',
            'bookmarks.username.help': 'Your Nextcloud username',
            'bookmarks.password': 'App password',
            'bookmarks.password.help': 'Use an app-specific password',
            'bookmarks.rootFolderId': 'Root Folder ID',
            'bookmarks.rootFolderId.help': '0 = all folders; set a specific folder ID to limit sync',
            'bookmarks.autoCreate': 'Auto-create folders from groups',
            'bookmarks.autoCreate.help': 'Create missing Nextcloud folders for local groups',
            'bookmarks.autoRename': 'Auto-rename folders on group rename',
            'bookmarks.autoRename.help': 'Rename Nextcloud folders when group names change',
            'bookmarks.chooseFolder': 'Choose Folder',
            'bookmarks.pickFolder': 'Select a Nextcloud folder',
            'bookmarks.refresh': 'Refresh',
            'bookmarks.select': 'Select',
            'sync.resetBindings': 'Reset Sync Bindings',
            'sync.resetBindings.help': 'Remove all stored Nextcloud folder/bookmark IDs from your groups and links. Useful to resync fresh.',
            'sync.resetBindings.confirm': 'This will remove all Nextcloud sync bindings (folder and bookmark IDs) from all groups and links. Your bookmarks stay, but re-sync will recreate mappings. Continue?',
            'sync.resetBindings.done': 'Sync bindings cleared',
            'sync.resetBindings.failed': 'Failed to clear sync bindings',
            'eraseDatabase': 'Erase database',
            'eraseDatabase.warning': 'Warning! This will permanently delete ALL your bookmarks, groups, and settings. This action cannot be undone!',
            'eraseDatabase.confirm': 'Are you absolutely sure you want to delete everything?',
            'addGroup': 'Add group',
            'search': 'Search',
            'importFromFile': 'Import from file',
            'exportToFile': 'Export to file',
            'import': 'Import',
            'options': 'Options',
            'css.advancedEditor': 'Advanced Editor',
            'options.common': 'Common',
            'options.common.language': 'Language',
            'options.common.language.english': 'English',
            'options.common.language.german': 'German',
            'options.common.language.help': 'Select the language',
            'options.common.pageTitle': 'Page title',
            'options.common.pageTitle.help': 'Set the page title',
            'options.common.identityName': 'Your display name',
            'options.common.identityName.help': 'This name is shown to other members and contacts',
            'options.groups': 'Groups',
            'options.groups.collapseGroupsOnStart': 'Collapse groups on start',
            'options.groups.collapseGroupsOnStart.help': 'Collapse all groups on start',
            'options.groups.hoverExpandEnabled': 'Enable auto-expand on link hover',
            'options.groups.hoverExpandEnabled.help': 'When dragging a link, hovering a collapsed group expands it after the delay',
            'options.groups.hoverExpandDelay': 'Auto-expand delay on link hover',
            'options.groups.hoverExpandDelay.help': 'Time to hover a collapsed group with a dragged link before it expands (milliseconds)',
            'options.common.searchAsYouType': 'Search as you type',
            'options.common.searchAsYouType.help': 'You can start typing a search term without clicking in the search text field, unless you have focused on another input field',
            'options.common.confirmDeleteGroup': 'Confirm before deleting groups',
            'options.common.confirmDeleteGroup.help': 'Ask for confirmation when deleting a group',
            'options.common.confirmDeleteLink': 'Confirm before deleting links',
            'options.common.confirmDeleteLink.help': 'Ask for confirmation when deleting a link',
            'confirm.deleteGroup': 'Delete group "%s" and all its links?',
            'confirm.deleteLink': 'Delete this link?',
            'options.groups.defaultGroupFormatting': 'Default group formatting',
            'options.groups.defaultGroupFormatting.help': 'Background formatting applied to newly created groups',
            'options.groups.defaultGroupTitleFormatting': 'Default group title formatting',
            'options.groups.defaultGroupTitleFormatting.help': 'Title formatting applied to newly created groups',
            'options.groups.defaultGroupLinkFormatting': 'Default group link formatting',
            'options.groups.defaultGroupLinkFormatting.help': 'Link formatting applied to all links in newly created groups',
            'options.groups.defaultGroupBadgeFormatting': 'Default badge formatting',
            'options.groups.defaultGroupBadgeFormatting.help': 'Badge formatting for link count and keywords in newly created groups',
            'options.groups.defaultLinkCountFormatting': 'Default link count formatting',
            'options.groups.defaultLinkCountFormatting.help': 'Formatting for link count display in newly created groups',
            'options.links.defaultLinkFormatting': 'Default link formatting',
            'options.links.defaultLinkFormatting.help': 'Default formatting for individual links',
            'options.links.defaultUrlPrefix': 'Default URL prefix',
            'options.links.defaultUrlPrefix.help': 'Prefix to add when a URL has no scheme (e.g., https://). Leave empty to add nothing.',
            'options.groups.clearClosesAllGroups': 'Clear search collapses all groups',
            'options.groups.clearClosesAllGroups.help': 'On Clear, collapse all groups for privacy',
            'options.groups.keywordClickExpandsAll': 'Keyword click expands all groups',
            'options.groups.keywordClickExpandsAll.help': 'When clicking a keyword chip, expand all groups',
            'options.groups.searchAutoExpandFound': 'Auto-expand matched groups while searching',
            'options.groups.searchAutoExpandFound.help': 'Expand groups that match the current search text',
            'options.colors.generalSection': 'General Website Colors',
            'options.colors.globalFormatting': 'Global Formatting',
            'options.colors.globalFormatting.help': 'Sets the overall appearance and background of the entire application',
            'options.colors.background': 'Website Background',
            'options.colors.background.help': 'Sets the main background color of the entire website',
            'options.colors.toolbarBackground': 'Toolbar Background',
            'options.colors.toolbarBackground.help': 'Background color of the toolbar containing search and action buttons',
            'options.colors.titleBarBackground': 'Title Bar Background',
            'options.colors.titleBarBackground.help': 'Background color of the title bar at the top of the page',
            'options.colors.titleTextColor': 'Title Text Color',
            'options.colors.titleTextColor.help': 'Color of the title text in the header',
            'options.colors.keywordBackground': 'Default keyword formatting',
            'options.colors.keywordBackground.help': 'Default background/formatting for the keyword area and badges',
            'options.colors.resetAll': 'Reset All Colors',
            'options.colors.reset': 'Reset',
            'css.custom.open': 'Custom CSS',
            'css.custom.title': 'Custom CSS',
            'css.custom.help': 'Styles are applied live. Example selectors: .groupTitle .text-truncate, .linkText a',
            'css.custom.placeholder': 'Example: .linkText a { color: #0d6efd; }',
            'css.reset': 'Reset',
            'css.custom.hooks': 'Hook classes',
            'css.custom.clickToInsert': 'Click to insert',
            'css.custom.selectClass': '-- Select CSS Selector --',
            'css.custom.layoutStructure': 'Layout & Structure',
            'css.custom.groups': 'Groups',
            'css.custom.groupInfo': 'Group Info Section',
            'css.custom.currentGroups': 'Current Groups',
            'css.custom.links': 'Links',
            'css.custom.currentLinks': 'Current Links',
            'css.custom.badges': 'Badges & Keywords',
            'css.custom.currentKeywords': 'Current Keywords',
            'css.custom.keywordsInGroups': 'Keywords in Groups',
            'css.custom.keywordsInLinks': 'Keywords in Links',
            'css.custom.specificGroupKeywords': 'Specific Keywords (Group → Keyword)',
            'css.custom.specificKeywords': 'Specific Keywords (Group → Link → Keyword)',
            'css.custom.multiline': 'With Comments',
            'css.custom.multilineTooltip': 'Add explanatory comments above complex selectors for better readability',
            'css.selectorExists': 'CSS selector already exists! Jumped to line.',
            'css.custom.buttons': 'Buttons & Forms',
            'css.custom.modals': 'Dialogs & Modals',
            'css.custom.sidebar': 'Sidebar & CSS Editor',
            'css.custom.keywordBar': 'Keyword Bar',
            'link.favicon.upload': 'Upload favicon',
            'link.favicon.remove': 'Remove',
            'link.favicon.invalidFile': 'Please select an image file',
            'link.favicon.tooLarge': 'Image is too large (max 256KB)',
            'link.favicon.uploaded': 'Favicon uploaded',
            'link.favicon.readError': 'Could not read image file',
            'group.favicon.upload': 'Upload group icon',
            'group.favicon.remove': 'Remove icon',
            'group.favicon.invalidFile': 'Please select an image file',
            'group.favicon.tooLarge': 'Image is too large (max 256KB)',
            'group.favicon.uploaded': 'Group icon updated',
            'group.favicon.readError': 'Could not read image file',
            'css.custom.slugHelpTitle': 'Keyword slugs',
            'css.custom.slugHelpText': 'Keywords are transformed to slugs: lowercased, spaces → dash, other non [a-z0-9_-] → dash.\nExamples: "UI/UX" → ui-ux, "C++" → c--, "Foo Bar" → foo-bar.\n\nKeyword CSS levels:\n1) Global keyword chips:\n   .mb-keyword { ... }\n   .mb-keyword-kw-<slug> { ... }\n\n2) Per group keyword chips:\n   .group-uuid-<uuid> .mb-group__keyword-badge { ... }\n   .group-uuid-<uuid> .mb-keyword-kw-<slug> { ... }\n\n3) Per link keyword chips:\n   .link-uuid-<uuid> .mb-link__keyword-badge { ... }\n   .link-uuid-<uuid> .mb-keyword-kw-<slug> { ... }\n\n4) Combined / specific anchor styles:\n   .group-uuid-<uuid> .mb-link__anchor { ... }\n   .link-uuid-<uuid> .mb-link__anchor { ... }\n\nTip: Copy UUID via context menu → "Copy CSS class".',
            'css.custom.helpTitle': '🎨 CSS CUSTOMIZATION GUIDE',
            'css.templates.select': '-- Select Template --',
            'css.templates.save': 'Save as Template',
            'css.templates.delete': 'Delete Template',
            'css.templates.namePlaceholder': 'Enter template name...',
            'css.templates.overwriteConfirm': 'Template "{0}" already exists. Overwrite?',
            'css.templates.saved': 'Template "{0}" saved',
            'css.templates.loaded': 'Template "{0}" loaded',
            'css.templates.deleted': 'Template "{0}" deleted',
            'css.templates.deleteConfirm': 'Really delete template "{0}"?',
            'css.templates.darkMode': 'Dark Mode',
            'css.templates.minimal': 'Minimal',
            'css.templates.colorful': 'Colorful',
            'css.visual.title': 'Visual CSS Editor',
            'css.visual.templates': 'CSS Templates',
            'css.visual.rules': 'CSS Rules',
            'css.visual.generated': 'Generated CSS',
            'css.visual.importantHint': 'Override other styles with !important',
            'css.visual.designTokens': 'Design Tokens',
            'css.visual.addToken': 'Add Token',
            'css.visual.noTokens': 'No tokens yet. Add some (e.g., brand-primary (without --), #3b82f6)',
            'css.visual.tokensHint': 'Use tokens via the dropdown next to properties (var(--token)).',
            'css.visual.tokensSelect': '-- Select Token --',
            'css.visual.valuePlaceholder': 'Enter value (e.g., #ff0000, rgb(), var(--...))',
            'css.visual.tokenName': 'Token name',
            'css.visual.tokenValue': 'Token value',
            'css.visual.invalidCssValue': 'Invalid CSS value',
            'css.visual.missingTokens': 'Missing tokens',
            'css.visual.invalidTokenValue': 'Invalid token value (e.g., #rrggbb, rgb(), linear-gradient(), var(--name))',
            'extension.clearCache': 'Clear extension cache',
            'extension.cacheCleared': 'Extension cache cleared',
            'extension.cacheClearFailed': 'Failed to clear extension cache',
            'extension.notAvailable': 'Extension not available',
            'extension.refetchFavicons': 'Re-fetching favicons…',
            
            'css.visual.pickElement': 'Pick element',
            'css.visual.pickerActive': 'Element picker active: Click an element in content',
            'css.visual.picked': 'Picked',
            'css.visual.applyPreset': 'Apply preset…',
            'css.visual.presetApplied': 'Preset applied',
            'css.visual.rule': 'Rule',
            'css.visual.doubleClickToEdit': 'Double-click to edit',
            'css.visual.copy': 'Copy',
            'css.visual.toggleCollapse': 'Toggle collapse',
            'css.visual.expandAll': 'Expand all',
            'css.visual.collapseAll': 'Collapse all',
            'css.visual.activate': 'Activate',
            'css.visual.deactivate': 'Deactivate',
            'css.visual.searchRules': 'Search rules…',
            'css.visual.activateProperty': 'Activate property',
            'css.visual.deactivateProperty': 'Deactivate property',
            'css.visual.selectElementShort': 'Select element',
            'css.visual.customCss': 'Custom CSS',
            'css.visual.moveUp': 'Move up',
            'css.visual.moveDown': 'Move down',
            'css.visual.duplicate': 'Duplicate',
            'css.visual.delete': 'Delete',
            'css.visual.selectTemplate': '-- Select Template --',
            'css.visual.defaultTemplates': 'Default Templates',
            'css.visual.appLevel': 'App Level',
            'css.visual.groupLevel': 'Group Level',
            'css.visual.linkLevel': 'Link Level',
            'css.visual.allGroups': 'All Groups',
            'css.visual.groupHeader': 'Group Header',
            'css.visual.groupTitle': 'Group Title',
            'css.visual.groupContent': 'Group Content',
            'css.visual.allLinks': 'All Links',
            'css.visual.linkHover': 'Link (Hover)',
            'css.visual.linkAnchor': 'Link Anchor',
            'css.visual.linkUrl': 'Link URL',
            'css.visual.linkIcon': 'Link Icon',
            'css.visual.keywords': 'Keywords',
            'css.visual.allKeywords': 'All Keywords (Keyword Bar)',
            'css.visual.keywordsHierarchical': 'Keywords (Hierarchical)',
            'css.visual.keywordByName': 'Keyword by Name',
            'css.visual.copy': 'Copy',
            'css.visual.apply': 'Apply',
            'css.visual.save': 'Save',
            'css.visual.migrationNotice': 'Note: Your existing Custom CSS has been imported. You can edit or delete it above as a "Legacy CSS" rule.',
            'css.visual.selectGroup': '-- All Groups --',
            'css.visual.selectLink': '-- All Links --',
            'css.visual.selectKeyword': '-- All Keywords --',
            'css.visual.keyword': 'Keyword',
            'css.visual.customProperties': 'Custom CSS Properties',
            'css.visual.customPropertiesHint': 'e.g. display: flex;\njustify-content: center;',
            'css.visual.customPropertiesHelp': 'Enter any CSS properties (one per line)',
            'css.visual.generatedSelector': 'Generated Selector',
            'css.visual.ruleSets': 'Rule Sets',
            'css.visual.loadRuleSet': 'Load Rule Set',
            'css.visual.saveCurrentRules': 'Save Current Rules',
            'css.visual.savedRuleSets': 'Saved Sets',
            'css.visual.rulesCount': 'rules',
            'css.visual.deleteRuleSet': 'Delete',
            'css.visual.ruleSetName': 'Rule Set Name:',
            'css.visual.ruleSetSaved': 'Rule set saved!',
            'css.visual.loadRuleSetConfirm': 'Load this rule set? Your current rules will be replaced.',
            'css.visual.deleteRuleSetConfirm': 'Delete this rule set?',
            'css.visual.selectRuleSet': '-- Select --',
            'css.visual.ruleSetLoaded': 'Rule set loaded',
            'css.visual.ruleSetDeleted': 'Rule set deleted',
            'css.visual.clearAll': 'Clear All',
            'css.visual.clearAllTooltip': 'Delete all CSS settings',
            'css.visual.clearAllConfirm': 'Do you really want to delete ALL CSS settings?\n\nThis will remove:\n• All CSS rules\n• The selected template\n• All saved rule sets\n\nThis action cannot be undone!',
            'css.visual.clearedAll': 'All CSS settings have been deleted',
            'css.visual.clearProperties': 'Clear Properties',
            'css.visual.clearPropertiesTitle': 'Delete all properties of this rule',
            'css.visual.propertiesCleared': 'Properties cleared',
            'css.visual.propertyAlreadyExists': 'This property already exists in this rule',
            'css.templates.defaultTemplates': 'Default Templates',
            'css.templates.customTemplates': 'Custom Templates',
            'css.templates.cannotDeleteDefault': 'Default templates cannot be deleted',
            'options.colors.add': 'Add Color',
            'options.links': 'Links',
            'options.sharing': 'Sharing',
            'options.sync': 'Synchronization',
            // Role badges
            'sync.role.all': 'All',
            'sync.role.owner': 'Owner',
            'sync.role.member': 'Member',
            // Conflict notification settings
            'options.sync.conflictNotificationLevel': 'Conflict Notifications',
            'options.sync.conflictNotificationLevel.help': 'How to display sync conflict resolutions (applies to everyone):\n• Silent - No notifications, conflicts resolved automatically\n• Important only - Show only critical conflicts that may affect your data\n• All conflicts - Show every conflict resolution for full transparency',
            'options.sync.conflictNotificationLevel.silent': 'Silent',
            'options.sync.conflictNotificationLevel.minimal': 'Important only',
            'options.sync.conflictNotificationLevel.verbose': 'All conflicts',
            // Auto sync interval
            'options.sync.autoSyncInterval': 'Auto-Sync Interval',
            'options.sync.autoSyncInterval.help': 'How often to check for updates (applies to everyone):\n• 5 minutes - For active collaboration, moderate battery usage\n• 10 minutes - Good balance between updates and resource usage\n• 30 minutes - Battery-friendly, suitable for less active groups\n• 1 hour - Minimal resource usage, for rarely changing content\n• Manual only - You control when to sync, no automatic updates',
            'options.sync.autoSyncInterval.5min': '5 minutes',
            'options.sync.autoSyncInterval.10min': '10 minutes',
            'options.sync.autoSyncInterval.30min': '30 minutes',
            'options.sync.autoSyncInterval.1hour': '1 hour',
            'options.sync.autoSyncInterval.manual': 'Manual only',
            // Offline mode
            'options.sync.offlineMode': 'Offline Mode',
            'options.sync.offlineMode.help': 'How to handle changes when offline (applies to everyone):\n• Show immediately - Changes appear instantly, may need correction later if conflicts occur\n• Wait for confirmation - Changes only appear after successful sync, more reliable but slower',
            'options.sync.offlineMode.optimistic': 'Show immediately',
            'options.sync.offlineMode.conservative': 'Wait for confirmation',
            // Owner-only settings
            'options.sync.conflictResolution': 'Conflict Resolution Strategy',
            'options.sync.conflictResolution.help': 'How to resolve editing conflicts (owner groups only):\n• Owner wins - Your changes as owner always take priority\n• Latest wins - Most recent change wins regardless of who made it\n• Ask me - Prompt for each conflict (may interrupt workflow)',
            'options.sync.conflictResolution.ownerWins': 'Owner wins',
            'options.sync.conflictResolution.lastWriteWins': 'Latest wins',
            'options.sync.conflictResolution.manual': 'Ask me',
            'options.sync.memberRateLimit': 'Member Rate Limit',
            'options.sync.memberRateLimit.help': 'Max changes per minute per member (0 = unlimited, owner groups only)',
            'options.sync.memberRateLimit.suffix': 'per min',
            'options.sync.validationLevel': 'Validation Level',
            'options.sync.validationLevel.help': 'How strictly to validate incoming changes (owner groups only):\n• Strict - Reject any suspicious or malformed data\n• Moderate - Allow minor issues but block major problems\n• Permissive - Accept most changes, only block critical errors',
            'options.sync.validationLevel.strict': 'Strict',
            'options.sync.validationLevel.moderate': 'Moderate',
            'options.sync.validationLevel.permissive': 'Permissive',
            // Member-only settings
            'options.sync.localCacheStrategy': 'Local Cache',
            'options.sync.localCacheStrategy.help': 'How much data to keep locally (member groups only):\n• Everything - Keep full history and all versions locally (uses more storage)\n• Current only - Keep only latest version (saves storage space)',
            'options.sync.localCacheStrategy.full': 'Everything',
            'options.sync.localCacheStrategy.minimal': 'Current only',
            'options.sync.errorHandling': 'Error Handling',
            'options.sync.errorHandling.help': 'How to handle sync errors (member groups only):\n• Auto-retry - Automatically retry failed operations (recommended)\n• Queue for later - Save failed changes to retry manually\n• Discard on error - Give up on failed changes (data may be lost)',
            'options.sync.errorHandling.retry': 'Auto-retry',
            'options.sync.errorHandling.queue': 'Queue for later',
            'options.sync.errorHandling.discard': 'Discard on error',
            'options.sharing.ntfyServerUrl': 'ntfy Server URL',
            'options.sharing.ntfyServerUrl.help': 'URL of the ntfy push notification server, Default: https://ntfy.c5p.de (high limits)',
            'options.sharing.ntfyAuthToken': 'Auth Token',
            'options.sharing.ntfyAuthToken.help': 'Optional Bearer token for authentication',
            'options.sharing.defaultTtl': 'Default TTL',
            'options.sharing.defaultTtl.help': 'Time to live in seconds (0 = server default)',
            'options.sharing.quickCodeTtl': 'Quick Code TTL',
            'options.sharing.quickCodeTtl.help': 'Validity of quick share codes in seconds',
            'options.sharing.contactOnlineTimeout': 'Contact Online Timeout',
            'options.sharing.contactOnlineTimeout.help': 'How long a contact is shown as online without response (in seconds)',
            'options.links.openInNewTab': 'Open links in new tab',
            'options.links.openInNewTab.help': 'If enabled, clicking a link opens it in a new browser tab',
            'options.links.progressiveLoadingThreshold': 'Progressive loading threshold',
            'options.links.progressiveLoadingThreshold.help': 'Number of links to show initially per group (show more button appears above this limit)',
            'options.links.addViaDialog': 'Add links via dialog (top-right button)',
            'options.links.addViaDialog.help': 'Show an add button in the group header and hide inline inputs',
            'options.links.autoFetchTitle': 'Auto-fetch page title on add',
            'options.links.autoFetchTitle.help': 'Try to fetch the web page title and prefill link title (best-effort)',
            'options.links.autoFetchFavicon': 'Show site favicon (via URL)',
            'options.links.autoFetchFavicon.help': 'Use a favicon service URL to render the icon before the link',
            'options.links.showLinkBadges': 'Show link keyword badges',
            'options.links.showLinkBadges.help': 'Display keyword badges next to links',
            'options.links.showLinkPopover': 'Show link detail popover',
            'options.links.showLinkPopover.help': 'Display a multi-line popover with metadata when hovering or focusing a link',
            'css.visual.popoverLevel': 'Link Popover',
            'css.visual.linkPopover': 'Popover container',
            'css.visual.linkPopoverTitle': 'Popover title row',
            'css.visual.linkPopoverUrl': 'Popover URL line',
            'css.visual.linkPopoverMeta': 'Popover metadata block',
            'css.visual.linkPopoverRow': 'Popover metadata row',
            'css.visual.linkPopoverLabel': 'Popover label',
            'css.visual.linkPopoverValue': 'Popover value',
            'css.visual.linkPopoverValueMuted': 'Popover relative value',
            'css.visual.linkPopoverKeywords': 'Popover keywords container',
            'css.visual.linkPopoverBadge': 'Popover keyword badge',
            'css.visual.linkPopoverFavicon': 'Popover favicon',
            'options.links.copyUrlFormat': 'Copy URL format',
            'options.links.copyUrlFormat.help': 'Format for copying links. Available placeholders: {title}, {url}, {keywords}, {date}, {time}',
            'options.linkShorteners.title': 'Link shortener services',
            'options.linkShorteners.services': 'Service catalogue',
            'options.linkShorteners.services.help': 'Select the providers that should appear in the link menu and add optional account details.',
            'options.linkShorteners.accountLabel': 'Account label',
            'options.linkShorteners.accountLabel.help': 'Optional description (e.g. custom domain or workspace identifier).',
            'options.linkShorteners.apiKey': 'API token',
            'options.linkShorteners.apiKey.help': 'Optional API token or key used when calling the provider.',
            'options.linkShorteners.requiresAccount': 'Account required',
            'options.linkShorteners.optionalAccount': 'Account optional',
            'options.linkShorteners.notEnabled': 'Not enabled in settings',
            'options.linkShorteners.menuHint': 'Activate a provider in the settings to use it from the link menu.',
            'options.linkShorteners.integrations': 'Integrations',
            'options.linkShorteners.audience': 'Best suited for',
            'options.linkShorteners.summary': 'Highlights',
            'options.proxy.title': 'Proxy',
            'options.proxy.enabled': 'Use proxy for outgoing requests',
            'options.proxy.enabled.help': 'When enabled, MyBookmarks sends all network calls (shorteners, metadata, link checks) via the configured proxy instead of the browser extension.',
            'options.proxy.baseUrl': 'Proxy endpoint',
            'options.proxy.baseUrl.placeholder': 'https://proxy.example.com',
            'options.proxy.baseUrl.help': 'Base URL of your proxy service (e.g., https://proxy.example.com). MyBookmarks will call POST /fetch on this server.',
            'options.proxy.apiKey': 'Proxy API token',
            'options.proxy.apiKey.placeholder': 'Optional API token',
            'options.proxy.apiKey.help': 'Optional Bearer token sent as Authorization header.',
            'options.proxy.extraHeaders': 'Additional headers',
            'options.proxy.extraHeaders.placeholder': 'Header-Name: Value',
            'options.proxy.extraHeaders.help': 'Optional custom headers to send with every proxy request (one per line as "Header-Name: Value").',
            'proxy.error.missingBaseUrl': 'Proxy is enabled but no base URL is configured.',
            'proxy.error.fetchFailed': 'Proxy request failed: {message}',
            'proxy.error.noTransport': 'No network transport available. Configure a proxy or install the browser extension.',
            'proxy.info.usingProxy': 'Using configured proxy for network requests.',
            'proxy.info.usingExtension': 'Using browser extension for network requests.',
            'options.buttons': 'Quick Action Buttons',
            'options.buttons.showAddLink': 'Show "Add Link" button',
            'options.buttons.showAddLink.help': 'Display the add link button in group headers',
            'options.buttons.showDeleteGroup': 'Show "Delete Group" button',
            'options.buttons.showDeleteGroup.help': 'Display the delete button in group headers',
            'options.buttons.showCopyUrl': 'Show "Copy URL" button',
            'options.buttons.showCopyUrl.help': 'Display the copy URL button for links',
            'options.buttons.showQrCode': 'Show "QR Code" button',
            'options.buttons.showQrCode.help': 'Display the QR code button for links',
            'options.buttons.showDeleteLink': 'Show "Delete Link" button',
            'options.buttons.showDeleteLink.help': 'Display the delete button for links',
            'groups.openAll': 'Open all',
            'groups.closeAll': 'Close all',
            'group.toggleGroupCollapse': 'Toggle group collapse',
            'group.moveGroupLeft': 'Move group left',
            'group.moveGroupRight': 'Move group right',
            'group.deleteGroup': 'Delete group',
            'group.link.moveLinkLeft': 'Move link left',
            'group.link.moveLinkRight': 'Move link right',
            'group.link.deleteLink': 'Delete link',
            'group.link.linkText': 'Link text',
            'group.link.linkUrl': 'Link URL',
            'group.link.add': 'Add',
            'group.link.dropAfter': 'Drop here',
            // Sync and Conflict Resolution
            'sync.conflictResolved': 'Sync Conflict Resolved',
            'sync.conflict.linkEdit': 'Link edit conflict resolved automatically',
            'sync.conflict.linkAdd': 'Duplicate link prevented',
            'sync.conflict.linkDelete': 'Link deletion conflict resolved',
            'sync.conflict.generic': 'Sync conflict automatically resolved',
            'group.dropAfter': 'Drop here',
            'menu.group.editGroup': 'Edit group',
            'group.showMore': 'Show more',
            'group.showLess': 'Show less',
            'menu.group.inviteMembers': 'Invite members…',
            'menu.group.transferOwnership': 'Transfer ownership…',
            'menu.group.duplicate': 'Duplicate',
            'dialog.contacts.title': 'Contacts',
            'dialog.contacts.empty': 'No contacts yet',
            'dialog.contacts.name': 'Name',
            'dialog.contacts.uuid': 'UUID',
            'dialog.contacts.status': 'Status',
            'dialog.contacts.actions': 'Actions',
            'dialog.contacts.sendTest': 'Send test',
            'dialog.contacts.remove': 'Remove',
            'dialog.contacts.online': 'online',
            'dialog.contacts.offline': 'offline', 
            'dialog.contacts.checking': 'checking...',
            'dialog.contacts.reachable': 'reachable',
            'dialog.contacts.unreachable': 'unreachable',
            'dialog.contacts.offlineTooltip': 'Contact is offline',
            'dialog.contacts.cannotSendOffline': 'Cannot send to offline contact',
            'dialog.contacts.removeWarningOwner': 'This contact owns',
            'dialog.contacts.removeWarningGroups': 'shared group(s) that will be deleted',
            'dialog.contacts.removeWarningMember': 'This contact is member of',
            'dialog.contacts.removeWarningYourGroups': 'of your shared group(s)',
            'dialog.contacts.removeConfirm': 'Remove contact',
            'dialog.contacts.removeNote': 'This contact will no longer be able to send you messages.',
            'dialog.share.title': 'Share',
            'dialog.send.linkTitle': 'Send Link',
            'dialog.send.groupTitle': 'Send Group',
            'dialog.send.selectContacts': 'Select contacts to send to:',
            'dialog.send.noContacts': 'No contacts available. Add contacts first.',
            'dialog.send.send': 'Send',
            'dialog.send.cancel': 'Cancel',
            'dialog.transfer.title': 'Transfer Ownership',
            'dialog.transfer.select': 'Select new owner:',
            'dialog.transfer.noCandidates': 'No eligible members found.',
            'dialog.transfer.transfer': 'Transfer',
            'dialog.transfer.acceptPrompt': 'The current owner requests to transfer group ownership to you. Do you accept?',
            'dialog.invite.title': 'Invite Members',
            'qc.receive': 'RECEIVE',
            'qc.receive.desc': 'Show code',
            'qc.receive.instruction': 'Share this code:',
            'qc.send': 'SEND',
            'qc.send.desc': 'Enter code',
            'qc.send.instruction': 'Enter the code:',
            'qc.generate': 'Generate Code',
            'qc.connect': 'Connect',
            'qc.stop': 'Stop',
            'qc.cancel': 'Cancel',
            'dialog.contacts.tabTitle': 'Contacts',
            'dialog.quickconnect.tabTitle': 'Quick-Connect',
            'dialog.close': 'Close',
            'members.title': 'Members',
            'members.filter.allow': 'allowed',
            'members.filter.deny': 'blocked',
            'members.filter.unset': 'local default',
            'members.remove': 'Remove',
            'members.noRoster': 'No member list received yet',
            'removedFromGroup.title': 'Group Membership Removed',
            'removedFromGroup.message': 'You have been removed from the following group while you were offline:',
            'removedFromGroup.owner': 'Group Owner:',
            'removedFromGroup.removedAt': 'Removed:',
            'removedFromGroup.explanation': 'The group will be removed from your list. If you need access again, please contact the group owner.',
            'removedFromGroup.acknowledge': 'I Understand',
            'members.perm.add': 'Add',
            'members.perm.edit': 'Edit',
            'members.perm.delete': 'Delete',
            'error.perm.add': 'You do not have permission to add links in this group.',
            'error.perm.edit': 'You do not have permission to edit links in this group.',
            'error.perm.delete': 'You do not have permission to delete links in this group.',
            'permission.denied': 'No permission',
            'error.onlyOwner': 'Only the owner can invite members.',
            'group.shared': 'Shared group',
            'group.keywords': 'Keywords',
            'group.basic': 'Basic Settings',
            'group.styling': 'Styling',
            'group.advanced': 'Advanced',
            'group.name': 'Group Name',
            'group.name.help': 'HTML is allowed. Safe tags only (b, i, strong, em, br, span, small, code, pre, a with http/https/mailto).',
            'group.name.required': 'Please enter a group name',
            'group.keywords.help': 'Keywords for searching and filtering (separate with comma or semicolon)',
            'group.infoHtml.placeholder': 'Enter HTML content to display in info tooltip...',
            'group.infoHtml.help': 'This HTML will be displayed when hovering over the info icon.',
            'group.color': 'Color',
            'group.backgroundFormatting': 'Background Formatting',
            'group.titleFormatting': 'Title Formatting',
            'group.linkFormatting': 'Link Formatting',
            'group.badgeFormatting': 'Keyword Badge Formatting',
            'group.pillFormatting': 'Link Count Formatting',
            'group.infoHtml': 'Info HTML',
            'group.infoHtml.placeholder': 'Enter HTML content to display in info section...',
            'group.infoHtml.help': 'This HTML will be displayed in a collapsible section below the group title.',
            'group.emoji': 'Icon',
            'group.emoji.placeholder': 'Click to select emoji',
            'group.emoji.help': 'Select an emoji icon for this group',
            'group.info.toggle': 'Information',
            'link.info': 'Information',
            'link.infoHtml': 'Info HTML',
            'link.infoHtml.placeholder': 'Enter HTML content to display in tooltip...',
            'link.infoHtml.help': 'This HTML will be displayed when hovering over the info icon.',
            'link.popover.url': 'URL',
            'link.popover.noUrl': 'No URL available',
            'link.popover.created': 'Created',
            'link.popover.updated': 'Updated',
            'link.popover.originalUrl': 'Original Input',
            'link.popover.untitled': 'Untitled link',
            'link.popover.notAvailable': 'Not recorded',
            'link.url.info': 'Leave URL empty to create a heading/category',
            'link.basic': 'Basic Settings',
            'link.advanced': 'Advanced',
            'link.text': 'Text',
            'link.text.help': 'HTML is allowed in the visible link text. Safe tags only. Note: anchors are stripped inside the link label.',
            'link.text.required': 'Please enter link text',
            'link.url': 'URL',
            'link.keywords': 'Keywords',
            'link.keywords.help': 'Keywords for searching and filtering (separate with comma or semicolon)',
            'link.emoji': 'Icon',
            'link.emoji.placeholder': 'Click to select emoji',
            'link.emoji.help': 'Select an emoji icon for this link',
            // Emoji picker
            'emoji.recent': 'Recent',
            'emoji.smileys': 'Smileys',
            'emoji.people': 'People',
            'emoji.animals': 'Animals',
            'emoji.food': 'Food',
            'emoji.travel': 'Travel',
            'emoji.activities': 'Activities',
            'emoji.objects': 'Objects',
            'emoji.symbols': 'Symbols',
            'emoji.flags': 'Flags',
            'link.color': 'Link Color',
            'color.reset': 'Reset',
            'color.remove': 'Remove',
            'color.add': 'Add Color',
            'menu.link.editLink': 'Edit link',
            'menu.link.deleteLink': 'Delete link',
            'link.copyUrl': 'Copy URL to clipboard',
            'link.urlCopied': 'URL copied',
            'link.copyFailed': 'Failed to copy URL',
            'toast.success': 'Success',
            'toast.error': 'Error',
            'toast.warning': 'Warning',
            'toast.info': 'Information',
            'shorteners.toast.missingAccount': 'Please add account details for {service} first.',
            'shorteners.toast.disabled': '{service} is not enabled. Toggle it in the settings.',
            'shorteners.toast.extensionMissing': 'Browser extension required to shorten links. Please install and enable it.',
            'shorteners.toast.extensionUnsupported': 'Installed extension version does not support link shortening yet.',
            'shorteners.toast.success': 'Short link copied to clipboard: {shortUrl}',
            'shorteners.toast.error': 'Could not create a short link.{message}',
            'shorteners.toast.notSupported': '{service} is not yet supported.',
            'shorteners.toast.noTransport': 'No network transport configured. Enable the browser extension or configure a proxy.',
            'shorteners.services.bitly.summary': 'Widely adopted with strong analytics, branding options, and deep API integrations.',
            'shorteners.services.bitly.audience': 'Best for teams managing large link volumes with a focus on branded experiences.',
            'shorteners.services.rebrandly.summary': 'Supports custom domains and fine-grained control for brand-conscious link management.',
            'shorteners.services.rebrandly.audience': 'Ideal for marketers who want branded short URLs instead of shared public domains.',
            'shorteners.services.tinyurl.summary': 'A classic shortener: simple, reliable, and free to start.',
            'shorteners.services.tinyurl.audience': 'Great for casual or personal use when you need quick shortening without extra setup.',
            'shorteners.services.blink.summary': 'Analytics-rich platform with team workflows for mid-sized and enterprise projects.',
            'shorteners.services.blink.audience': 'Suited for organizations or agencies collaborating on multi-user campaigns.',
            'shorteners.services.shortio.summary': 'Balances ease of use with branded domains, API access, and team collaboration.',
            'shorteners.services.shortio.audience': 'Perfect for teams wanting more control without moving to heavy enterprise suites.',
            'shorteners.services.dub.summary': 'Modern, developer-friendly shortening with automation and fresh UX.',
            'shorteners.services.dub.audience': 'Great for innovators who prefer contemporary tooling and rapid iteration.',
            'shorteners.services.owly.summary': 'Bundle link shortening with Hootsuite’s scheduling and analytics stack.',
            'shorteners.services.owly.audience': 'Tailored for social media teams already living inside Hootsuite dashboards.',
            'shorteners.services.replug.summary': 'Link rotation, retargeting, bio links, and deep analytics geared toward marketing campaigns.',
            'shorteners.services.replug.audience': 'Designed for marketers optimizing campaign links with advanced targeting.',
            'shorteners.services.t2m.summary': 'Feature-rich link platform delivering analytics and customization at a moderate price.',
            'shorteners.services.t2m.audience': 'Good for users seeking many features without enterprise-level costs.',
            'link.security.safe': 'No obvious issues detected.',
            'link.security.info.shortener': 'Shortener domain detected ({host}) – final destination unknown.',
            'link.security.info.ip': 'Hostname is an IP address ({host}).',
            'link.security.warning.punycode': 'Hostname uses punycode ({host}); double-check for impersonation.',
            'link.security.warning.query': 'Sensitive query parameter detected ({key}).',
            'link.security.warning.protocol': 'Uncommon protocol detected ({protocol}).',
            'link.security.warning.generic': 'Potential issue detected.',
            'link.security.danger.protocol': 'Blocked protocol detected ({protocol}).',
            'link.security.danger.malformed': 'URL appears malformed or incomplete.',
            'link.security.danger.suspicious': 'Suspicious pattern detected in URL.',
            'link.security.scoreLabel': 'Security score: {score}/100',
            'menu.link.sendLink': 'Send link…',
            'menu.link.createQrCode': 'Create QR code',
            'menu.link.copyForCss': 'Copy for CSS',
            'menu.link.copyCssClass': 'Copy CSS class',
            'menu.link.copyUuid': 'Copy UUID',
            'menu.link.copyCssSelector': 'Copy CSS selector [data-link-uuid]',
            'menu.link.shorten': 'Shorten URL via…',
            'menu.link.shorten.disabled': 'Configure providers in the settings to enable shortening',
            'menu.link.shorten.noUrl': 'Link has no URL',
            'menu.group.sendGroup': 'Send group…',
            'menu.group.members': 'Members…',
            'menu.group.inspectJSON': 'Inspect JSON',
            'menu.group.enableEventLog': 'Enable Event-Log (Beta)',
            'menu.group.copyForCss': 'Copy for CSS',
            'menu.group.copyCssClass': 'Copy CSS class',
            'menu.group.copyUuid': 'Copy UUID',
            'menu.group.copyCssSelector': 'Copy CSS selector [data-group-uuid]',
            'menu.group.leaveGroup': 'Leave group…',
            'menu.group.sort': 'Sort links',
            'menu.group.sort.withinColumns': 'Within columns (A→Z)',
            'menu.group.sort.preserveCounts': 'Global A→Z, preserve column sizes',
            'menu.group.sort.rebalance': 'Global A→Z, rebalance columns',
            'menu.group.sort.withinColumnsDesc': 'Within columns (Z→A)',
            'menu.group.sort.preserveCountsDesc': 'Global Z→A, preserve column sizes',
            'menu.group.sort.rebalanceDesc': 'Global Z→A, rebalance columns',
            'json.inspector.title': 'Group JSON Inspector',
            'json.inspector.info': 'Complete JSON representation of the group object',
            'json.inspector.copy': 'Copy JSON',
            'json.inspector.stats': 'Statistics',
            'error.eventlog.ownerOnly': 'Only the owner can enable event-log for this group',
            'Are you sure?': 'Are you sure?',
            'tools': 'Tools',
            'snapshots.title': 'Snapshots',
            'snapshots.save': 'Save snapshot',
            'snapshots.none': 'No snapshots yet',
            'snapshots.promptName': 'Snapshot name:',
            'snapshots.restore.confirm': 'Restore this snapshot? Current state will be added to Undo.',
            'snapshots.delete.confirm': 'Delete this snapshot?',
            'clear': 'Clear',
            'undo': 'Undo',
            'redo': 'Redo',
            'savedSearches.placeholder': 'Saved searches…',
            'savedSearches.save': 'Save search',
            'savedSearches.delete': 'Delete saved search',
            'savedSearches.delete.confirm': 'Delete the selected saved search?',
            'savedSearches.promptName': 'Name for this search:',
            'savedSearches.empty': 'Enter a search query first.',
            'duplicates.find': 'Find duplicates',
            'duplicates.title': 'Duplicate Links Found',
            'duplicates.description': 'The following links appear in multiple groups:',
            'duplicates.none': 'No duplicates found.',
            'duplicates.copies': 'copies',
            'duplicates.keep': 'Keep',
            'duplicates.remove': 'Remove',
            'duplicates.info': 'The first occurrence of each link will be kept. Unchecked items will not be deleted.',
            'duplicates.removeSelected': 'Remove Selected Duplicates',
            'duplicates.confirmDelete': 'Delete %s duplicate(s) and keep the first?',
            'duplicates.deleted': 'Deleted %s duplicate(s).',
            'bookmarklet.addCurrentTab': 'Bookmarklet: Add current tab',
            'bookmarklet.instructions': 'Drag this link to your bookmarks bar to add the current tab here. Clicking it on any page opens this app with the URL prefilled.'
            , 'bookmarklet.helpTitle': 'Add Current Tab (Clipboard Bookmarklet)'
            , 'bookmarklet.dragThis': 'Drag this to your bookmarks bar'
            , 'bookmarklet.step.drag': 'Drag the button below to your bookmarks bar.'
            , 'bookmarklet.step.clickAnyPage': 'On any page, click the bookmarklet to copy URL and title to your clipboard.'
            , 'bookmarklet.step.switchBack': 'Switch back to this app and click “Paste from clipboard” to add it.'
            , 'clipboard.paste': 'Paste from clipboard'
            , 'clipboard.pastePrompt': 'Paste clipboard content here (JSON or URL):'
            , 'clipboard.empty': 'Clipboard is empty.'
            , 'clipboard.invalid': 'Clipboard content is not a valid URL or JSON.'
            , 'clipboard.noPermission': 'Could not read clipboard. Paste manually when prompted.'
            , 'clipboard.modalTitle': 'Import Links'
            , 'clipboard.instructions': 'Paste JSON, CSV, or HTML bookmarks:'
            , 'clipboard.read': 'Read from Clipboard'
            , 'clipboard.add': 'Add'
            , 'clipboard.placeholder': 'Paste your data here...'
            , 'clipboard.detectedFormat': 'Detected format:'
            , 'clipboard.preview': 'Preview'
            , 'clipboard.selectAll': 'Select All'
            , 'clipboard.deselectAll': 'Deselect All'
            , 'clipboard.import': 'Import Selected'
            , 'clipboard.cancel': 'Cancel'
            , 'clipboard.noLinksFound': 'No valid links found'
            , 'clipboard.noSelection': 'Please select at least one link'
            , 'clipboard.importSuccess': 'Successfully imported links'
            , 'clipboard.readOk': 'Content read from clipboard'
            , 'import.fromFile': 'Import from file:'
            , 'import.fromUrl': 'Import from URL:'
            , 'import.urlPlaceholder': 'https://example.com/bookmarks.json'
            , 'import.fetch': 'Fetch'
            , 'import.fetching': 'Fetching...'
            , 'import.corsError': 'Cannot fetch due to CORS policy. Try downloading the file and importing it locally, or use a CORS proxy.'
            , 'import.fetchError': 'Failed to fetch'
            , 'import.fromClipboard': 'Paste from clipboard:'
            , 'import.or': '— OR —'
            , 'import.newGroupTitle': 'New group title:'
            , 'import.groupTitlePlaceholder': 'Enter group title (optional)'
            , 'import.fullExportWarning.title': 'Warning!'
            , 'import.fullExportWarning.message': 'This is a full database export. It should only be imported into an EMPTY database to avoid conflicts. All existing data will be replaced.'
            , 'import.fullExportConfirm': 'This will REPLACE your entire database (groups, settings, contacts, etc.).\n\nThis is a restore operation - all UUIDs will be preserved.\n\nContinue?'
            , 'import.fullExportSuccess': 'Database restored successfully!'
            , 'import.groupsFound': 'Found links from the following groups:'
            , 'import.groupsWillBeCreated': 'These groups will be created automatically if they don\'t exist.'
            , 'import.defaultGroupTitle': 'Import'
            , 'import.fromBrowser': 'Import from browser:'
            , 'import.fetchingBookmarks': 'Loading bookmarks...'
            , 'import.browserBookmarks': 'Import Browser Bookmarks'
            , 'import.fullExportError': 'Database restore failed. Check console for details.'
            , 'export.title': 'Export Bookmarks'
            , 'export.selectItems': 'Select groups and links to export:'
            , 'export.groups': 'Groups'
            , 'export.selectAll': 'Select All'
            , 'export.deselectAll': 'Deselect All'
            , 'export.format': 'Export Format:'
            , 'export.selected': 'links selected'
            , 'export.export': 'Export'
            , 'export.cancel': 'Cancel'
            // Invitation dialog translations
            , 'invitation.groupTitle': 'Shared Group Invitation'
            , 'invitation.linkTitle': 'Shared Links Received'
            , 'share.groupTitle': 'Group Received'
            , 'share.linkTitle': 'Links Received'
            , 'invitation.from': 'From'
            , 'invitation.groupName': 'Group name'
            , 'invitation.linkCount': 'Number of links'
            , 'invitation.linksToAdd': 'Links to be added'
            , 'invitation.groupDescription': 'Would you like to add this shared group? You will be able to share links with other members of the group.'
            , 'invitation.linkDescription': 'Would you like to add these links to your selected group?'
            , 'invitation.sharedGroupDescription': 'Would you like to add this shared group with all its links?'
            , 'share.groupDescription': 'Would you like to add this group with all its links?'
            , 'share.linkDescription': 'Would you like to add these links?'
            , 'share.add': 'Add'
            , 'share.cancel': 'Cancel'
            , 'invitation.reject': 'Reject'
            , 'invitation.accept': 'Accept'
            // Browser Extension translations
            , 'extension.importBookmarks': 'Import Browser Bookmarks'
            , 'extension.enrichMetadata': 'Enrich Links with Metadata'
            , 'extension.notInstalled': 'Browser Extension not installed'
            , 'extension.installHint': 'Please install the MyBookmarks extension from local2/extensions/'
            , 'extension.imported': 'Imported {count} bookmarks in {groups} groups!'
            , 'extension.enriched': 'Enriched {count} links with metadata!'
            , 'extension.allHaveMetadata': 'All links already have metadata!'
            , 'extension.fetchMetadataConfirm': 'Fetch metadata for {count} links?'
            , 'extension.error': 'Error: {message}'

            // Event-Log Tab translations
            , 'eventlog.time': 'Time'
            , 'eventlog.type': 'Type'
            , 'eventlog.author': 'Author'
            , 'eventlog.details': 'Details'
            , 'eventlog.changes': 'changes'
            
            // Snapshot Tab translations
            , 'snapshot.info': 'Snapshot Information'
            , 'snapshot.created': 'Created'
            , 'snapshot.eventId': 'Event ID'
            , 'snapshot.links': 'Links in snapshot'
            , 'snapshot.members': 'Members in snapshot'
            , 'snapshot.version': 'Version'
            , 'snapshot.vectorClock': 'Vector Clock'
            , 'snapshot.member': 'Member'
            , 'snapshot.eventCount': 'Event Count'
            , 'snapshot.noVectorClock': 'No vector clock data'
            , 'snapshot.showData': 'Show snapshot data'
            
            // Event-Log & Sync Settings
            , 'options.eventlog.title': 'Event-Log & Sync'
            , 'options.eventlog.snapshotInterval': 'Snapshot after events'
            , 'options.eventlog.snapshotInterval.help': 'Create snapshot after this many events (reduces memory usage)'
            , 'options.eventlog.maxEvents': 'Max events to keep'
            , 'options.eventlog.maxEvents.help': 'Maximum events before forced cleanup (hard limit)'
            , 'options.eventlog.syncStrategy': 'Sync strategy'
            , 'options.eventlog.syncStrategy.help': 'How to handle conflicts when syncing'
            , 'options.eventlog.syncStrategy.ownerLeads': 'Owner leads (recommended)'
            , 'options.eventlog.syncStrategy.allEqual': 'All members equal'
            , 'options.eventlog.syncStrategy.smartMerge': 'Smart merge (experimental)'
            , 'Events': 'Events'
            , 'options.eventlog.note': 'Note:'
            , 'options.eventlog.note.text': 'Event-log settings apply when you are the group owner. Members use the owner\'s settings.'
            
            // CSS Dialog translations
            , 'css.format': 'CSS Format'
            , 'css.noStyle': 'No custom style'
            , 'css.clear': 'Clear'
            , 'css.preview.text': 'Preview Text'
            , 'css.opacity.warning': 'Note:'
            , 'css.opacity.websiteBackgroundInfo': 'For Website Background, opacity is applied to the background color only (using rgba). This prevents dialogs from becoming transparent.'
            , 'css.background': 'Background (shorthand)'
            , 'css.backgroundColor': 'Background Color'
            , 'css.backgroundOpacity': 'Opacity'
            , 'css.text': 'Text'
            , 'css.textColor': 'Text Color'
            , 'css.fontFamily': 'Font Family'
            , 'css.default': 'Default'
            , 'css.fontSize': 'Font Size'
            , 'css.fontWeight': 'Font Weight'
            , 'css.normal': 'Normal'
            , 'css.bold': 'Bold'
            , 'css.lighter': 'Lighter'
            , 'css.fontStyle': 'Font Style'
            , 'css.italic': 'Italic'
            , 'css.oblique': 'Oblique'
            , 'css.textDecoration': 'Text Decoration'
            , 'css.underline': 'Underline'
            , 'css.overline': 'Overline'
            , 'css.lineThrough': 'Line Through'
            , 'css.underlineOverline': 'Underline + Overline'
            , 'css.border': 'Border'
            , 'css.borderStyle': 'Border Style'
            , 'css.none': 'None'
            , 'css.solid': 'Solid'
            , 'css.dashed': 'Dashed'
            , 'css.dotted': 'Dotted'
            , 'css.double': 'Double'
            , 'css.groove': 'Groove'
            , 'css.ridge': 'Ridge'
            , 'css.inset': 'Inset'
            , 'css.outset': 'Outset'
            , 'css.borderWidth': 'Border Width'
            , 'css.borderColor': 'Border Color'
            , 'css.borderRadius': 'Border Radius'
            , 'css.shadow': 'Shadow'
            , 'css.boxShadow': 'Box Shadow'
            , 'css.shadowPresets': 'Presets'
            , 'css.shadowSubtle': 'Subtle'
            , 'css.shadowMedium': 'Medium'
            , 'css.shadowStrong': 'Strong'
            , 'css.shadowInset': 'Inset'
            , 'css.generatedCode': 'Generated CSS:'
            , 'css.apply': 'Apply'
            , 'css.cancel': 'Cancel'
            , 'css.shorthand': 'Shorthand'
            , 'css.spacing': 'Spacing'
            , 'css.padding': 'Padding'
            , 'css.margin': 'Margin'
            , 'css.top': 'Top'
            , 'css.right': 'Right'
            , 'css.bottom': 'Bottom'
            , 'css.left': 'Left'
            , 'css.resetAll': 'Reset All'
            
            // Visual CSS Editor translations
            , 'css.visual.title': 'Visual CSS Editor'
            , 'css.visual.templates': 'CSS Templates'
            , 'css.visual.rules': 'CSS Rules'
            , 'css.visual.generated': 'Generated CSS'
            , 'css.visual.addRule': 'Add New CSS Rule'
            , 'css.visual.deleteRule': 'Delete Rule'
            , 'css.visual.element': 'Element'
            , 'css.visual.selectElement': '-- Select Element --'
            , 'css.visual.group': 'Group'
            , 'css.visual.selectGroup': '-- Select Group --'
            , 'css.visual.link': 'Link'
            , 'css.visual.selectLink': '-- Select Link --'
            , 'css.visual.properties': 'CSS Properties'
            , 'css.visual.addProperty': '+ Add Property...'
            , 'css.visual.colors': 'Colors'
            , 'css.visual.typography': 'Typography'
            , 'css.visual.borders': 'Borders'
            , 'css.visual.sizes': 'Sizes'
            , 'css.visual.complete': 'complete'
            , 'css.outline': 'Outline'
            , 'css.outlineWidth': 'Outline Width'
            , 'css.outlineStyle': 'Outline Style'
            , 'css.outlineColor': 'Outline Color'
            , 'css.outlineOffset': 'Outline Offset'
            , 'css.width': 'Width'
            , 'css.height': 'Height'
            , 'css.opacity': 'Opacity'
            , 'css.textAlign': 'Text Align'
            , 'css.topLeft': 'top left'
            , 'css.topRight': 'top right'
            , 'css.bottomLeft': 'bottom left'
            , 'css.bottomRight': 'bottom right'
            , 'css.visual.layout': 'Layout'
            , 'css.visual.effects': 'Effects'
            , 'css.visual.importantHint': 'Force this style to override others (!important)'

            // Generic button translations
            , 'apply': 'Apply'
            , 'cancel': 'Cancel'
            , 'save': 'Save'
            , 'members.select': 'Select member by number:'
            , 'close': 'Close'
            , 'ok': 'OK'
          },
          'de': {
            // Favicon rules
            'options.links.faviconRules': 'Favicon-Regeln',
            'options.links.faviconRules.manage': 'Favicon-Regeln verwalten',
            'favicon.rules.title': 'Favicon-Regeln',
            'favicon.rules.add': 'Regel hinzufügen',
            'favicon.rules.apply': 'Auf bestehende Links anwenden',
            'favicon.rules.override': 'Vorhandene Favicons überschreiben',
            'favicon.rules.type': 'Typ',
            'favicon.rules.pattern': 'Muster',
            'favicon.rules.icon': 'Icon',
            'favicon.rules.comment': 'Kommentar',
            'favicon.rules.commentPlaceholder': 'Optionaler Kommentar',
            'favicon.rules.enabled': 'Aktiv',
            'favicon.rules.domain': 'Domain',
            'favicon.rules.prefix': 'URL-Präfix',
            'favicon.rules.regex': 'Regex',
            'favicon.rules.autofetch': 'Auto laden',
            'favicon.rules.upload': 'Hochladen',
            'favicon.rules.delete': 'Löschen',
            'favicon.rules.test': 'Test-URL',
            'favicon.rules.matchPreview': 'Treffervorschau',
            'favicon.rules.restoreDefaults': 'Standardregeln wiederherstellen',
            'favicon.rules.export': 'Regeln exportieren',
            'favicon.rules.import': 'Regeln importieren',
            'favicon.rules.none': 'Keine Favicon-Regeln vorhanden.',
            'favicon.rules.defaultsRestored': 'Standard-Favicon-Regeln wiederhergestellt',
            'favicon.rules.defaultsAlreadyPresent': 'Alle Standard-Favicon-Regeln sind bereits vorhanden',
            'favicon.rules.exportError': 'Export der Favicon-Regeln fehlgeschlagen',
            'favicon.rules.importSuccess': '{count} Favicon-Regeln importiert',
            'favicon.rules.importNothing': 'Keine neuen Favicon-Regeln importiert',
            'favicon.rules.importError': 'Import der Favicon-Regeln fehlgeschlagen',
            'favicon.rules.needsExtension': 'Extension erforderlich zum automatischen Laden von Icons',
            'favicon.rules.saved': 'Favicon-Regeln gespeichert',
            'favicon.rules.applied': 'Favicon-Regeln angewendet',
            // CardDAV
            'carddav.title': 'CardDAV-Sync',
            'carddav.serverUrl': 'Server-URL',
            'carddav.serverUrl.help': 'Basis-URL deines CardDAV-Servers (z. B. https://cloud.example.com)',
            'carddav.username': 'Benutzername',
            'carddav.username.help': 'Dein CardDAV-Benutzername',
            'carddav.password': 'App-Passwort',
            'carddav.password.help': 'Falls möglich App-Passwort verwenden',
            'carddav.addressbookPath': 'Adressbuch-Pfad (optional)',
            'carddav.addressbookPath.help': 'Leer lassen für Auto-Discovery oder vollständigen DAV-Pfad angeben',
            'carddav.createAddressbookIfMissing': 'Adressbuch anlegen, falls nicht vorhanden',
            'carddav.createAddressbookIfMissing.help': 'Adressbuch "MyBookmarks" automatisch anlegen, sofern erlaubt',
            'carddav.syncInterval': 'Auto-Sync-Intervall',
            'carddav.syncInterval.help': 'Wie oft automatisch synchronisiert wird (0 = nur manuell)',
            'carddav.syncInterval.manual': 'Nur manuell',
            'carddav.syncInterval.5min': 'Alle 5 Minuten',
            'carddav.syncInterval.10min': 'Alle 10 Minuten',
            'carddav.syncInterval.30min': 'Alle 30 Minuten',
            'carddav.syncInterval.1hour': 'Stündlich',
            'carddav.syncNow': 'Jetzt synchronisieren (Nextcloud Bookmarks)',
            'carddav.extensionRequired': 'Browser-Erweiterung mit CardDAV-Unterstützung erforderlich',
            'carddav.notEnabled': 'CardDAV ist in den Optionen deaktiviert',
            'carddav.syncStarted': 'CardDAV-Synchronisierung gestartet',
            'carddav.syncFailed': 'CardDAV-Synchronisierung fehlgeschlagen: {message}',
            'carddav.addressbookPathMissing': 'Bitte Server-URL und Adressbuch-Pfad in den Optionen konfigurieren',
            'carddav.testConnection': 'Verbindung testen',
            'options.sync.engine': 'Sync-Backend',
            'options.sync.backend': 'Backend',
            'options.sync.backend.help': 'Sync-Anbieter wählen',
            'options.sync.backend.carddav': 'CardDAV (experimentell)',
            'options.sync.backend.nc': 'Nextcloud Bookmarks (REST)',
            'bookmarks.title': 'Nextcloud Bookmarks',
            'bookmarks.serverUrl': 'Server-URL',
            'bookmarks.serverUrl.help': 'Basis-URL deiner Nextcloud (z. B. https://cloud.example.com)',
            'bookmarks.username': 'Benutzername',
            'bookmarks.username.help': 'Dein Nextcloud-Benutzername',
            'bookmarks.password': 'App-Passwort',
            'bookmarks.password.help': 'App-spezifisches Passwort verwenden',
            'bookmarks.rootFolderId': 'Root-Ordner-ID',
            'bookmarks.rootFolderId.help': '0 = alle Ordner; eine Ordner-ID setzen, um zu begrenzen',
            'bookmarks.autoCreate': 'Ordner aus Gruppen automatisch anlegen',
            'bookmarks.autoCreate.help': 'Nicht vorhandene Nextcloud-Ordner für lokale Gruppen anlegen',
            'bookmarks.autoRename': 'Ordner bei Gruppen-Umbenennung anpassen',
            'bookmarks.autoRename.help': 'Nextcloud-Ordnernamen aktualisieren, wenn Gruppen umbenannt werden',
            'bookmarks.chooseFolder': 'Ordner wählen',
            'bookmarks.pickFolder': 'Nextcloud-Ordner auswählen',
            'bookmarks.refresh': 'Aktualisieren',
            'bookmarks.select': 'Auswählen',
            'sync.resetBindings': 'Sync-Verknüpfungen zurücksetzen',
            'sync.resetBindings.help': 'Entfernt alle gespeicherten Nextcloud Ordner-/Bookmark-IDs aus Gruppen und Links. Nützlich für einen frischen Neuabgleich.',
            'sync.resetBindings.confirm': 'Dies entfernt ALLE Nextcloud-Sync-Verknüpfungen (Ordner- und Bookmark-IDs) aus allen Gruppen und Links. Deine Bookmarks bleiben erhalten, aber beim nächsten Sync werden die Verknüpfungen neu erstellt. Fortfahren?',
            'sync.resetBindings.done': 'Sync-Verknüpfungen wurden entfernt',
            'sync.resetBindings.failed': 'Zurücksetzen der Sync-Verknüpfungen fehlgeschlagen',
            'eraseDatabase': 'Lösche Datenbank',
            'eraseDatabase.warning': 'Warnung! Dies wird ALLE Ihre Lesezeichen, Gruppen und Einstellungen dauerhaft löschen. Diese Aktion kann nicht rückgängig gemacht werden!',
            'eraseDatabase.confirm': 'Sind Sie absolut sicher, dass Sie alles löschen möchten?',
            'addGroup': 'Gruppe hinzufügen',
            'search': 'Suche',
            'importFromFile': 'Importiere aus Datei',
            'exportToFile': 'Exportiere in Datei',
            'import': 'Importieren',
            'options': 'Optionen',
            'css.advancedEditor': 'Erweiterter Editor',
            'options.common': 'Allgemein',
            'options.common.language': 'Sprache',
            'options.common.language.english': 'Englisch',
            'options.common.language.german': 'Deutsch',
            'options.common.language.help': 'Wähle die Sprache',
            'options.common.pageTitle': 'Seitentitel',
            'options.common.pageTitle.help': 'Setze den Seitentitel',
            'options.common.identityName': 'Ihr Anzeigename',
            'options.common.identityName.help': 'Dieser Name wird anderen Mitgliedern und Kontakten angezeigt',
            'options.groups': 'Gruppen',
            'options.groups.collapseGroupsOnStart': 'Gruppen beim Start einklappen',
            'options.groups.collapseGroupsOnStart.help': 'Klappe alle Gruppen beim Start ein',
            'options.groups.hoverExpandEnabled': 'Auto-Öffnen beim Link-Hover aktivieren',
            'options.groups.hoverExpandEnabled.help': 'Beim Ziehen eines Links öffnet sich eine eingeklappte Gruppe nach der Wartezeit',
            'options.groups.hoverExpandDelay': 'Auto-Öffnen Verzögerung (Link-Hover)',
            'options.groups.hoverExpandDelay.help': 'Zeit in Millisekunden, die ein gezogener Link über einer eingeklappten Gruppe schweben muss, um sie zu öffnen',
            'options.common.searchAsYouType': 'Suche während des Tippens',
            'options.common.searchAsYouType.help': 'Du kannst anfangen, einen Suchbegriff einzugeben, ohne in das Suchfeld zu klicken, es sei denn, du hast ein anderes Eingabefeld fokussiert',
            'options.common.confirmDeleteGroup': 'Vor dem Löschen von Gruppen nachfragen',
            'options.common.confirmDeleteGroup.help': 'Beim Löschen einer Gruppe eine Bestätigung anzeigen',
            'options.common.confirmDeleteLink': 'Vor dem Löschen von Links nachfragen',
            'options.common.confirmDeleteLink.help': 'Beim Löschen eines Links eine Bestätigung anzeigen',
            'confirm.deleteGroup': 'Gruppe "%s" und alle enthaltenen Links löschen?',
            'confirm.deleteLink': 'Diesen Link löschen?',
            'options.groups.defaultGroupFormatting': 'Standard-Gruppenformatierung',
            'options.groups.defaultGroupFormatting.help': 'Hintergrundformatierung für neu erstellte Gruppen',
            'options.groups.defaultGroupTitleFormatting': 'Standard-Titelformatierung',
            'options.groups.defaultGroupTitleFormatting.help': 'Titelformatierung für neu erstellte Gruppen',
            'options.groups.defaultGroupLinkFormatting': 'Standard-Gruppenlink-Formatierung',
            'options.groups.defaultGroupLinkFormatting.help': 'Linkformatierung für alle Links in neu erstellten Gruppen',
            'options.groups.defaultGroupBadgeFormatting': 'Standard-Badge-Formatierung',
            'options.groups.defaultGroupBadgeFormatting.help': 'Badge-Formatierung für Link-Anzahl und Keywords in neu erstellten Gruppen',
            'options.groups.defaultLinkCountFormatting': 'Standard-Linkanzahl-Formatierung',
            'options.groups.defaultLinkCountFormatting.help': 'Formatierung für Link-Anzahl-Anzeige in neu erstellten Gruppen',
            'options.links.defaultLinkFormatting': 'Standard-Link-Formatierung',
            'options.links.defaultLinkFormatting.help': 'Standardformatierung für einzelne Links',
            'options.groups.clearClosesAllGroups': 'Clear klappt alle Gruppen ein',
            'options.groups.clearClosesAllGroups.help': 'Beim Clear alle Gruppen einklappen (Datensicherheit)',
            'options.groups.keywordClickExpandsAll': 'Keyword-Klick klappt alle Gruppen aus',
            'options.groups.keywordClickExpandsAll.help': 'Beim Klick auf ein Keyword alle Gruppen ausklappen',
            'options.groups.searchAutoExpandFound': 'Gefundene Gruppen während Suche ausklappen',
            'options.groups.searchAutoExpandFound.help': 'Passende Gruppen bei aktiver Suche automatisch ausklappen',
            'options.colors': 'Darstellung & Farben',
            'options.colors.generalSection': 'Allgemeine Website-Farben',
            'options.colors.globalFormatting': 'Globale Formatierung',
            'options.colors.globalFormatting.help': 'Legt das allgemeine Erscheinungsbild und den Hintergrund der gesamten Anwendung fest',
            'options.colors.background': 'Website-Hintergrund',
            'options.colors.background.help': 'Legt die Haupthintergrundfarbe der gesamten Website fest',
            'options.colors.toolbarBackground': 'Werkzeugleiste-Hintergrund',
            'options.colors.toolbarBackground.help': 'Hintergrundfarbe der Werkzeugleiste mit Such- und Aktionsschaltflächen',
            'options.colors.titleBarBackground': 'Titelleiste-Hintergrund',
            'options.colors.titleBarBackground.help': 'Hintergrundfarbe der Titelleiste am oberen Rand der Seite',
            'options.colors.titleTextColor': 'Titeltext-Farbe',
            'options.colors.titleTextColor.help': 'Farbe des Titeltextes in der Kopfzeile',
            'options.colors.keywordBackground': 'Standard-Schlagwort-Formatierung',
            'options.colors.keywordBackground.help': 'Standard-Hintergrund/Formatierung für den Schlagwortbereich und Badges',
            'options.colors.resetAll': 'Alle Farben zurücksetzen',
            'options.colors.reset': 'Zurücksetzen',
            'css.custom.open': 'Benutzerdefiniertes CSS',
            'css.custom.title': 'Benutzerdefiniertes CSS',
            'css.custom.help': 'Styles werden live angewendet. Beispiel-Selektoren: .groupTitle .text-truncate, .linkText a',
            'css.custom.placeholder': 'Beispiel: .linkText a { color: #0d6efd; }',
            'css.reset': 'Zurücksetzen',
            'css.custom.hooks': 'Hook‑Klassen',
            'css.custom.clickToInsert': 'Zum Einfügen klicken',
            'css.custom.selectClass': '-- CSS-Selektor wählen --',
            'css.custom.layoutStructure': 'Layout & Struktur',
            'css.custom.groups': 'Gruppen',
            'css.custom.groupInfo': 'Gruppen Info-Bereich',
            'css.custom.currentGroups': 'Aktuelle Gruppen',
            'css.custom.links': 'Links',
            'css.custom.currentLinks': 'Aktuelle Links',
            'css.custom.badges': 'Badges & Keywords',
            'css.custom.currentKeywords': 'Aktuelle Keywords',
            'css.custom.keywordsInGroups': 'Keywords in Gruppen',
            'css.custom.keywordsInLinks': 'Keywords in Links',
            'css.custom.specificGroupKeywords': 'Spezifische Keywords (Gruppe → Keyword)',
            'css.custom.specificKeywords': 'Spezifische Keywords (Gruppe → Link → Keyword)',
            'css.custom.multiline': 'Mit Kommentaren',
            'css.custom.multilineTooltip': 'Erklärende Kommentare über komplexen Selektoren für bessere Lesbarkeit hinzufügen',
            'css.selectorExists': 'CSS-Selektor existiert bereits! Zur Zeile gesprungen.',
            'css.custom.buttons': 'Buttons & Formulare',
            'css.custom.modals': 'Dialoge & Modals',
            'css.custom.sidebar': 'Sidebar & CSS Editor',
            'css.custom.keywordBar': 'Keyword-Leiste',
            'link.favicon.upload': 'Favicon hochladen',
            'link.favicon.remove': 'Entfernen',
            'link.favicon.invalidFile': 'Bitte eine Bilddatei auswählen',
            'link.favicon.tooLarge': 'Bild ist zu groß (max. 256KB)',
            'link.favicon.uploaded': 'Favicon hochgeladen',
            'link.favicon.readError': 'Bilddatei konnte nicht gelesen werden',
            'group.favicon.upload': 'Gruppen-Icon hochladen',
            'group.favicon.remove': 'Icon entfernen',
            'group.favicon.invalidFile': 'Bitte eine Bilddatei auswählen',
            'group.favicon.tooLarge': 'Bild ist zu groß (max. 256KB)',
            'group.favicon.uploaded': 'Gruppen-Icon aktualisiert',
            'group.favicon.readError': 'Bilddatei konnte nicht gelesen werden',
            'css.custom.slugHelpTitle': 'Keyword‑Slugs',
            'css.custom.slugHelpText': 'Keywords werden zu Slugs umgewandelt: Kleinbuchstaben, Leerzeichen → Bindestrich, andere Nicht‑[a-z0-9_-] → Bindestrich.\nBeispiele: "UI/UX" → ui-ux, "C++" → c--, "Foo Bar" → foo-bar.\n\nKeyword‑CSS Ebenen:\n1) Globale Keywordchips:\n   .mb-keyword { ... }\n   .mb-keyword-kw-<slug> { ... }\n\n2) Pro Gruppe (Keywordchips):\n   .group-uuid-<uuid> .mb-group__keyword-badge { ... }\n   .group-uuid-<uuid> .mb-keyword-kw-<slug> { ... }\n\n3) Pro Link (Keywordchips):\n   .link-uuid-<uuid> .mb-link__keyword-badge { ... }\n   .link-uuid-<uuid> .mb-keyword-kw-<slug> { ... }\n\n4) Kombiniert / spezifische Link‑Stile:\n   .group-uuid-<uuid> .mb-link__anchor { ... }\n   .link-uuid-<uuid> .mb-link__anchor { ... }\n\nTipp: UUID über Kontextmenü → "CSS‑Klasse kopieren".',
            'css.custom.helpTitle': '🎨 CSS ANPASSUNGS-LEITFADEN',
            'css.templates.select': '-- Vorlage wählen --',
            'css.templates.save': 'Als Vorlage speichern',
            'css.templates.delete': 'Vorlage löschen',
            'css.templates.namePlaceholder': 'Vorlagen-Name eingeben...',
            'css.templates.overwriteConfirm': 'Vorlage "{0}" existiert bereits. Überschreiben?',
            'css.templates.saved': 'Vorlage "{0}" gespeichert',
            'css.templates.loaded': 'Vorlage "{0}" geladen',
            'css.templates.deleted': 'Vorlage "{0}" gelöscht',
            'css.templates.deleteConfirm': 'Vorlage "{0}" wirklich löschen?',
            'css.templates.darkMode': 'Dunkler Modus',
            'css.templates.minimal': 'Minimal',
            'css.templates.colorful': 'Farbenfroh',
            'css.visual.title': 'Visueller CSS Editor',
            'css.visual.templates': 'CSS Vorlagen',
            'css.visual.rules': 'CSS Regeln',
            'css.visual.generated': 'Generiertes CSS',
            'css.visual.importantHint': 'Andere Styles mit !important überschreiben',
            'css.templates.defaultTemplates': 'Standard-Vorlagen',
            'css.templates.customTemplates': 'Eigene Vorlagen',
            'css.templates.cannotDeleteDefault': 'Standard-Vorlagen können nicht gelöscht werden',
            'options.colors.add': 'Farbe hinzufügen',
            'options.links': 'Links',
            'options.sharing': 'Teilen',
            'options.sharing.ntfyServerUrl': 'ntfy Server URL',
            'options.sharing.ntfyServerUrl.help': 'URL des ntfy Push-Benachrichtigungsservers',
            'options.sharing.ntfyAuthToken': 'Authentifizierungs-Token',
            'options.sharing.ntfyAuthToken.help': 'Optionales Bearer-Token für die Authentifizierung',
            'options.sharing.defaultTtl': 'Standard-TTL',
            'options.sharing.defaultTtl.help': 'Gültigkeitsdauer in Sekunden (0 = Server-Standard)',
            'options.sharing.quickCodeTtl': 'Quick-Code TTL',
            'options.sharing.quickCodeTtl.help': 'Gültigkeit von Quick-Share-Codes in Sekunden',
            'options.sharing.contactOnlineTimeout': 'Kontakt Online-Timeout',
            'options.sharing.contactOnlineTimeout.help': 'Wie lange ein Kontakt als online angezeigt wird, ohne zu antworten (in Sekunden)',
            'options.links.openInNewTab': 'Links in neuem Tab öffnen',
            'options.links.openInNewTab.help': 'Wenn aktiviert, öffnet ein Klick auf einen Link einen neuen Browser-Tab',
            'options.links.progressiveLoadingThreshold': 'Schwellenwert für schrittweises Laden',
            'options.links.progressiveLoadingThreshold.help': 'Anzahl der Links, die anfangs pro Gruppe angezeigt werden ("Weitere anzeigen"-Button erscheint oberhalb dieses Limits)',
            'options.links.addViaDialog': 'Links per Dialog hinzufügen (oben rechts)',
            'options.links.addViaDialog.help': 'Zeige oben rechts einen Hinzufügen-Button und blende die Inline-Eingaben aus',
            'options.links.autoFetchTitle': 'Titel der Webseite automatisch holen',
            'options.links.autoFetchTitle.help': 'Versuche, den Seitentitel zu laden und das Titelfeld vorzufüllen (Best-Effort)',
            'options.links.autoFetchFavicon': 'Favicon über URL anzeigen',
            'options.links.autoFetchFavicon.help': 'Verwende eine Favicon-Service-URL, um das Icon vor dem Link anzuzeigen',
            'options.links.showLinkBadges': 'Link-Keyword-Badges anzeigen',
            'options.links.showLinkBadges.help': 'Zeige Keyword-Badges neben Links an',
            'options.links.showLinkPopover': 'Link-Detail-Popover anzeigen',
            'options.links.showLinkPopover.help': 'Zeigt beim Überfahren oder Fokussieren eines Links ein Popover mit wichtigsten Metadaten an',
            'css.visual.popoverLevel': 'Link-Popover',
            'css.visual.linkPopover': 'Popover-Container',
            'css.visual.linkPopoverTitle': 'Popover-Titelzeile',
            'css.visual.linkPopoverUrl': 'Popover-URL-Zeile',
            'css.visual.linkPopoverMeta': 'Popover-Metadatenblock',
            'css.visual.linkPopoverRow': 'Popover-Zeile',
            'css.visual.linkPopoverLabel': 'Popover-Label',
            'css.visual.linkPopoverValue': 'Popover-Wert',
            'css.visual.linkPopoverValueMuted': 'Popover-Wert (relativ)',
            'css.visual.linkPopoverKeywords': 'Popover-Keywords',
            'css.visual.linkPopoverBadge': 'Popover-Keyword-Badge',
            'css.visual.linkPopoverFavicon': 'Popover-Favicon',
            'options.links.copyUrlFormat': 'URL-Kopierformat',
            'options.links.copyUrlFormat.help': 'Format zum Kopieren von Links. Verfügbare Platzhalter: {title}, {url}, {keywords}, {date}, {time}',
            'options.linkShorteners.title': 'Link-Shortener-Dienste',
            'options.linkShorteners.services': 'Dienstekatalog',
            'options.linkShorteners.services.help': 'Wähle aus, welche Anbieter im Link-Menü erscheinen und hinterlege optional Zugangsdaten.',
            'options.linkShorteners.accountLabel': 'Account-Bezeichnung',
            'options.linkShorteners.accountLabel.help': 'Optionaler Freitext (z. B. eigene Domain oder Workspace-Kennung).',
            'options.linkShorteners.apiKey': 'API-Token',
            'options.linkShorteners.apiKey.help': 'Optionaler API-Schlüssel oder Token für diesen Anbieter.',
            'options.linkShorteners.requiresAccount': 'Account erforderlich',
            'options.linkShorteners.optionalAccount': 'Account optional',
            'options.linkShorteners.notEnabled': 'In den Einstellungen (noch) nicht aktiviert',
            'options.linkShorteners.menuHint': 'Aktiviere einen Dienst in den Einstellungen, um ihn im Link-Menü zu nutzen.',
            'options.linkShorteners.integrations': 'Integrationen',
            'options.linkShorteners.audience': 'Geeignet für',
            'options.linkShorteners.summary': 'Highlights',
            'options.proxy.title': 'Proxy',
            'options.proxy.enabled': 'Proxy für ausgehende Anfragen verwenden',
            'options.proxy.enabled.help': 'Wenn aktiviert, laufen alle Netzwerkaufrufe (Shortener, Metadaten, Link-Prüfungen) über den konfigurierten Proxy statt über die Browser-Erweiterung.',
            'options.proxy.baseUrl': 'Proxy-Endpunkt',
            'options.proxy.baseUrl.placeholder': 'https://proxy.meinedomain.de',
            'options.proxy.baseUrl.help': 'Basis-URL deines Proxy-Services (z. B. https://proxy.meinedomain.de). MyBookmarks ruft darüber POST /fetch auf.',
            'options.proxy.apiKey': 'Proxy-API-Token',
            'options.proxy.apiKey.placeholder': 'Optionales API-Token',
            'options.proxy.apiKey.help': 'Optionales Bearer-Token, das als Authorization-Header gesendet wird.',
            'options.proxy.extraHeaders': 'Zusätzliche Header',
            'options.proxy.extraHeaders.placeholder': 'Header-Name: Wert',
            'options.proxy.extraHeaders.help': 'Optionale eigene Header (eine Zeile pro Eintrag im Format „Header-Name: Wert“).',
            'proxy.error.missingBaseUrl': 'Proxy ist aktiviert, aber es wurde keine Basis-URL hinterlegt.',
            'proxy.error.fetchFailed': 'Proxy-Anfrage fehlgeschlagen: {message}',
            'proxy.error.noTransport': 'Kein Netzwerk-Transport verfügbar. Bitte Proxy konfigurieren oder die Browser-Erweiterung installieren.',
            'proxy.info.usingProxy': 'Netzwerkaufrufe laufen über den konfigurierten Proxy.',
            'proxy.info.usingExtension': 'Netzwerkaufrufe laufen über die Browser-Erweiterung.',
            'options.links.defaultUrlPrefix': 'Standard-URL-Präfix',
            'options.links.defaultUrlPrefix.help': 'Präfix, das ergänzt wird, wenn eine URL kein Schema hat (z. B. https://). Leer lassen, um nichts zu ergänzen.',
            'options.buttons': 'Schnellaktions-Schaltflächen',
            'options.buttons.showAddLink': '"Link hinzufügen" anzeigen',
            'options.buttons.showAddLink.help': 'Zeigt die Schaltfläche zum Hinzufügen von Links in Gruppenkopfzeilen',
            'options.buttons.showDeleteGroup': '"Gruppe löschen" anzeigen',
            'options.buttons.showDeleteGroup.help': 'Zeigt die Löschen-Schaltfläche in Gruppenkopfzeilen',
            'options.buttons.showCopyUrl': '"URL kopieren" anzeigen',
            'options.buttons.showCopyUrl.help': 'Zeigt die URL-Kopieren-Schaltfläche für Links',
            'options.buttons.showQrCode': '"QR-Code" anzeigen',
            'options.buttons.showQrCode.help': 'Zeigt die QR-Code-Schaltfläche für Links',
            'options.buttons.showDeleteLink': '"Link löschen" anzeigen',
            'options.buttons.showDeleteLink.help': 'Zeigt die Löschen-Schaltfläche für Links',
            'groups.openAll': 'Alle öffnen',
            'groups.closeAll': 'Alle schließen',
            'group.toggleGroupCollapse': 'Gruppe ein-/ausklappen',
            'group.moveGroupLeft': 'Gruppe nach links verschieben',
            'group.moveGroupRight': 'Gruppe nach rechts verschieben',
            'group.deleteGroup': 'Gruppe löschen',
            'group.link.moveLinkLeft': 'Link nach links verschieben',
            'group.link.moveLinkRight': 'Link nach rechts verschieben',
            'group.link.deleteLink': 'Link löschen',
            'group.link.linkText': 'Link Text',
            'group.link.linkUrl': 'Link URL',
            'group.link.add': 'Hinz.',
            'group.link.dropAfter': 'Hier einfügen',
            'group.dropAfter': 'Hier einfügen',
            'menu.group.editGroup': 'Gruppe bearbeiten',
            'group.showMore': 'Weitere anzeigen',
            'group.showLess': 'Weniger anzeigen',
            'menu.group.inviteMembers': 'Mitglieder einladen…',
            'menu.group.transferOwnership': 'Eigentümer übertragen…',
            'menu.group.duplicate': 'Duplizieren',
            'dialog.contacts.title': 'Kontakte',
            'dialog.contacts.empty': 'Keine Kontakte',
            'dialog.contacts.name': 'Name',
            'dialog.contacts.uuid': 'UUID',
            'dialog.contacts.status': 'Status',
            'dialog.contacts.actions': 'Aktionen',
            'dialog.contacts.sendTest': 'Test senden',
            'dialog.contacts.remove': 'Entfernen',
            'dialog.contacts.online': 'online',
            'dialog.contacts.offline': 'offline',
            'dialog.contacts.checking': 'prüfe...',
            'dialog.contacts.reachable': 'erreichbar',
            'dialog.contacts.unreachable': 'nicht erreichbar',
            'dialog.contacts.offlineTooltip': 'Kontakt ist offline',
            'dialog.contacts.cannotSendOffline': 'Kann nicht an offline Kontakt senden',
            'dialog.contacts.removeWarningOwner': 'Dieser Kontakt besitzt',
            'dialog.contacts.removeWarningGroups': 'geteilte Gruppe(n), die gelöscht werden',
            'dialog.contacts.removeWarningMember': 'Dieser Kontakt ist Mitglied von',
            'dialog.contacts.removeWarningYourGroups': 'Ihrer geteilten Gruppe(n)',
            'dialog.contacts.removeConfirm': 'Kontakt entfernen',
            'dialog.contacts.removeNote': 'Dieser Kontakt kann Ihnen keine Nachrichten mehr senden.',
            'dialog.share.title': 'Teilen',
            'dialog.send.linkTitle': 'Link senden',
            'dialog.send.groupTitle': 'Gruppe senden',
            'dialog.send.selectContacts': 'Kontakte zum Senden auswählen:',
            'dialog.send.noContacts': 'Keine Kontakte vorhanden. Fügen Sie zuerst Kontakte hinzu.',
            'dialog.send.send': 'Senden',
            'dialog.send.cancel': 'Abbrechen',
            'dialog.transfer.title': 'Eigentümer übertragen',
            'dialog.transfer.select': 'Neuen Eigentümer auswählen:',
            'dialog.transfer.noCandidates': 'Keine geeigneten Mitglieder gefunden.',
            'dialog.transfer.transfer': 'Übertragen',
            'dialog.transfer.acceptPrompt': 'Der aktuelle Eigentümer möchte die Gruppen-Inhaberschaft an Sie übertragen. Akzeptieren?',
            'dialog.invite.title': 'Mitglieder einladen',
            'qc.receive': 'EMPFANGEN',
            'qc.receive.desc': 'Code anzeigen',
            'qc.receive.instruction': 'Teilen Sie diesen Code:',
            'qc.send': 'SENDEN',
            'qc.send.desc': 'Code eingeben',
            'qc.send.instruction': 'Code eingeben:',
            'qc.generate': 'Code generieren',
            'qc.connect': 'Verbinden',
            'qc.stop': 'Stopp',
            'qc.cancel': 'Abbrechen',
            'dialog.contacts.tabTitle': 'Kontakte',
            'dialog.quickconnect.tabTitle': 'Quick-Connect',
            'dialog.close': 'Schließen',
            'clipboard.paste': 'Aus Zwischenablage einfügen',
            'clipboard.modalTitle': 'Links importieren',
            'clipboard.instructions': 'JSON, CSV oder HTML-Lesezeichen einfügen:',
            'clipboard.read': 'Aus Zwischenablage lesen',
            'clipboard.placeholder': 'Daten hier einfügen...',
            'clipboard.detectedFormat': 'Erkanntes Format:',
            'clipboard.preview': 'Vorschau',
            'clipboard.selectAll': 'Alle auswählen',
            'clipboard.deselectAll': 'Alle abwählen',
            'clipboard.import': 'Ausgewählte importieren',
            'clipboard.cancel': 'Abbrechen',
            'clipboard.noLinksFound': 'Keine gültigen Links gefunden',
            'clipboard.noSelection': 'Bitte mindestens einen Link auswählen',
            // Sync und Konfliktauflösung
            'sync.conflictResolved': 'Sync-Konflikt gelöst',
            'sync.conflict.linkEdit': 'Link-Bearbeitungskonflikt automatisch gelöst',
            'sync.conflict.linkAdd': 'Doppelter Link verhindert',
            'sync.conflict.linkDelete': 'Link-Löschkonflikt gelöst',
            'sync.conflict.generic': 'Sync-Konflikt automatisch gelöst',
            // Sync-Einstellungen
            'options.sync': 'Synchronisation',
            // Rollen-Badges
            'sync.role.all': 'Alle',
            'sync.role.owner': 'Besitzer',
            'sync.role.member': 'Mitglied',
            // Konflikt-Benachrichtigungen
            'options.sync.conflictNotificationLevel': 'Konflikt-Benachrichtigungen',
            'options.sync.conflictNotificationLevel.help': 'Wie Sync-Konflikte angezeigt werden (gilt für alle):\n• Stumm - Keine Benachrichtigungen, Konflikte werden automatisch gelöst\n• Nur wichtige - Zeigt nur kritische Konflikte die Ihre Daten betreffen könnten\n• Alle Konflikte - Zeigt jede Konfliktlösung für volle Transparenz',
            'options.sync.conflictNotificationLevel.silent': 'Stumm',
            'options.sync.conflictNotificationLevel.minimal': 'Nur wichtige',
            'options.sync.conflictNotificationLevel.verbose': 'Alle Konflikte',
            // Auto-Sync Intervall
            'options.sync.autoSyncInterval': 'Auto-Sync Intervall',
            'options.sync.autoSyncInterval.help': 'Wie oft nach Updates gesucht wird (gilt für alle):\n• 5 Minuten - Für aktive Zusammenarbeit, moderater Akkuverbrauch\n• 10 Minuten - Gute Balance zwischen Updates und Ressourcenverbrauch\n• 30 Minuten - Akkuschonend, geeignet für weniger aktive Gruppen\n• 1 Stunde - Minimaler Ressourcenverbrauch, für selten ändernde Inhalte\n• Nur manuell - Sie kontrollieren wann synchronisiert wird',
            'options.sync.autoSyncInterval.5min': '5 Minuten',
            'options.sync.autoSyncInterval.10min': '10 Minuten',
            'options.sync.autoSyncInterval.30min': '30 Minuten',
            'options.sync.autoSyncInterval.1hour': '1 Stunde',
            'options.sync.autoSyncInterval.manual': 'Nur manuell',
            // Offline-Modus
            'options.sync.offlineMode': 'Offline-Modus',
            'options.sync.offlineMode.help': 'Wie Änderungen offline behandelt werden (gilt für alle):\n• Sofort anzeigen - Änderungen erscheinen sofort, müssen evtl. später korrigiert werden\n• Auf Bestätigung warten - Änderungen erst nach erfolgreicher Sync, zuverlässiger aber langsamer',
            'options.sync.offlineMode.optimistic': 'Sofort anzeigen',
            'options.sync.offlineMode.conservative': 'Auf Bestätigung warten',
            // Nur für Besitzer
            'options.sync.conflictResolution': 'Konfliktauflösung',
            'options.sync.conflictResolution.help': 'Wie Bearbeitungskonflikte gelöst werden (nur Besitzer-Gruppen):\n• Besitzer gewinnt - Ihre Änderungen als Besitzer haben immer Vorrang\n• Neueste gewinnt - Die aktuellste Änderung gewinnt, egal von wem\n• Nachfragen - Bei jedem Konflikt nachfragen (kann Workflow unterbrechen)',
            'options.sync.conflictResolution.ownerWins': 'Besitzer gewinnt',
            'options.sync.conflictResolution.lastWriteWins': 'Neueste gewinnt',
            'options.sync.conflictResolution.manual': 'Nachfragen',
            'options.sync.memberRateLimit': 'Mitglieder-Ratelimit',
            'options.sync.memberRateLimit.help': 'Max. Änderungen pro Minute pro Mitglied (0 = unbegrenzt, nur Besitzer-Gruppen)',
            'options.sync.memberRateLimit.suffix': 'pro Min',
            'options.sync.validationLevel': 'Validierungsstufe',
            'options.sync.validationLevel.help': 'Wie strikt eingehende Änderungen validiert werden (nur Besitzer-Gruppen):\n• Strikt - Verdächtige oder fehlerhafte Daten ablehnen\n• Moderat - Kleine Probleme erlauben, große blockieren\n• Nachsichtig - Die meisten Änderungen akzeptieren, nur kritische Fehler blockieren',
            'options.sync.validationLevel.strict': 'Strikt',
            'options.sync.validationLevel.moderate': 'Moderat',
            'options.sync.validationLevel.permissive': 'Nachsichtig',
            // Nur für Mitglieder
            'options.sync.localCacheStrategy': 'Lokaler Cache',
            'options.sync.localCacheStrategy.help': 'Wie viele Daten lokal gespeichert werden (nur Mitglieder-Gruppen):\n• Alles - Vollständige Historie und alle Versionen lokal (mehr Speicher)\n• Nur aktuell - Nur neueste Version behalten (spart Speicherplatz)',
            'options.sync.localCacheStrategy.full': 'Alles',
            'options.sync.localCacheStrategy.minimal': 'Nur aktuell',
            'options.sync.errorHandling': 'Fehlerbehandlung',
            'options.sync.errorHandling.help': 'Wie Sync-Fehler behandelt werden (nur Mitglieder-Gruppen):\n• Auto-Wiederholen - Fehlgeschlagene Operationen automatisch wiederholen (empfohlen)\n• Für später aufheben - Fehlgeschlagene Änderungen für manuellen Retry speichern\n• Bei Fehler verwerfen - Fehlgeschlagene Änderungen aufgeben (Datenverlust möglich)',
            'options.sync.errorHandling.retry': 'Auto-Wiederholen',
            'options.sync.errorHandling.queue': 'Für später aufheben',
            'options.sync.errorHandling.discard': 'Bei Fehler verwerfen',
            'clipboard.importSuccess': 'Links erfolgreich importiert',
            'clipboard.readOk': 'Inhalt aus Zwischenablage gelesen',
            'clipboard.empty': 'Zwischenablage ist leer.',
            'clipboard.noPermission': 'Konnte Zwischenablage nicht lesen. Bitte manuell einfügen.',
            'import.fromFile': 'Aus Datei importieren:',
            'import.fromUrl': 'Von URL importieren:',
            'import.urlPlaceholder': 'https://beispiel.de/bookmarks.json',
            'import.fetch': 'Abrufen',
            'import.fetching': 'Wird abgerufen...',
            'import.corsError': 'Abruf aufgrund von CORS-Richtlinien nicht möglich. Laden Sie die Datei herunter und importieren Sie sie lokal, oder verwenden Sie einen CORS-Proxy.',
            'import.fetchError': 'Abruf fehlgeschlagen',
            'import.fromClipboard': 'Aus Zwischenablage einfügen:',
            'import.or': '— ODER —',
            'import.newGroupTitle': 'Neuer Gruppentitel:',
            'import.groupTitlePlaceholder': 'Gruppentitel eingeben (optional)',
            'import.fullExportWarning.title': 'Warnung!',
            'import.fullExportWarning.message': 'Dies ist ein vollständiger Datenbank-Export. Er sollte nur in eine LEERE Datenbank importiert werden, um Konflikte zu vermeiden. Alle vorhandenen Daten werden ersetzt.',
            'import.fullExportConfirm': 'Dies wird Ihre GESAMTE Datenbank ERSETZEN (Gruppen, Einstellungen, Kontakte, etc.).\n\nDies ist eine Wiederherstellungsoperation - alle UUIDs bleiben erhalten.\n\nFortfahren?',
            'import.fullExportSuccess': 'Datenbank erfolgreich wiederhergestellt!',
            'import.groupsFound': 'Links aus folgenden Gruppen gefunden:',
            'import.groupsWillBeCreated': 'Diese Gruppen werden automatisch erstellt, falls sie noch nicht existieren.',
            'import.defaultGroupTitle': 'Import',
            'import.fromBrowser': 'Aus Browser importieren:',
            'import.fetchingBookmarks': 'Lade Lesezeichen...',
            'import.browserBookmarks': 'Browser-Lesezeichen importieren',
            'import.fullExportError': 'Datenbankwiederherstellung fehlgeschlagen. Details in der Konsole.',
            'export.title': 'Lesezeichen exportieren',
            'export.selectItems': 'Gruppen und Links zum Export auswählen:',
            'export.groups': 'Gruppen',
            'export.selectAll': 'Alle auswählen',
            'export.deselectAll': 'Alle abwählen',
            'export.format': 'Export-Format:',
            'export.selected': 'Links ausgewählt',
            'export.export': 'Exportieren',
            'export.cancel': 'Abbrechen',
            'members.title': 'Mitglieder',
            'members.filter.allow': 'erlaubt',
            'members.filter.deny': 'blockiert',
            'members.filter.unset': 'lokal standard',
            'members.remove': 'Entfernen',
            'members.noRoster': 'Noch keine Mitgliederliste empfangen',
            'removedFromGroup.title': 'Gruppenmitgliedschaft entfernt',
            'removedFromGroup.message': 'Sie wurden aus der folgenden Gruppe entfernt, während Sie offline waren:',
            'removedFromGroup.owner': 'Gruppenbesitzer:',
            'removedFromGroup.removedAt': 'Entfernt:',
            'removedFromGroup.explanation': 'Die Gruppe wird aus Ihrer Liste entfernt. Falls Sie wieder Zugriff benötigen, kontaktieren Sie bitte den Gruppenbesitzer.',
            'removedFromGroup.acknowledge': 'Verstanden',
            'members.perm.add': 'Hinzufügen',
            'members.perm.edit': 'Bearbeiten',
            'members.perm.delete': 'Löschen',
            'error.perm.add': 'Du hast keine Berechtigung, in dieser Gruppe Links hinzuzufügen.',
            'error.perm.edit': 'Du hast keine Berechtigung, in dieser Gruppe Links zu bearbeiten.',
            'error.perm.delete': 'Du hast keine Berechtigung, in dieser Gruppe Links zu löschen.',
            'permission.denied': 'Keine Berechtigung',
            'error.onlyOwner': 'Nur der Owner kann Mitglieder einladen.',
            'group.shared': 'Geteilte Gruppe',
            'group.keywords': 'Schlagwörter',
            'group.basic': 'Grundeinstellungen',
            'group.styling': 'Darstellung',
            'group.advanced': 'Erweitert',
            'group.name': 'Gruppenname',
            'group.name.help': 'HTML ist erlaubt. Sichere Tags (b, i, strong, em, br, span, small, code, pre, a mit http/https/mailto).',
            'group.name.required': 'Bitte einen Gruppennamen eingeben',
            'group.keywords.help': 'Schlagwörter für Suche und Filterung (mit Komma oder Semikolon trennen)',
            'group.infoHtml.placeholder': 'HTML-Inhalt für Info-Tooltip eingeben...',
            'group.infoHtml.help': 'Dieser HTML-Inhalt wird beim Überfahren des Info-Symbols angezeigt.',
            'group.color': 'Farbe',
            'group.backgroundFormatting': 'Hintergrundformatierung',
            'group.titleFormatting': 'Titelformatierung',
            'group.linkFormatting': 'Link-Formatierung',
            'group.badgeFormatting': 'Schlagwort-Badge-Formatierung',
            'group.pillFormatting': 'Linkanzahl-Formatierung',
            'group.infoHtml': 'Info HTML',
            'group.infoHtml.placeholder': 'HTML-Inhalt eingeben, der im Info-Bereich angezeigt wird...',
            'group.infoHtml.help': 'Dieser HTML-Inhalt wird in einem aufklappbaren Bereich unter dem Gruppentitel angezeigt.',
            'group.emoji': 'Symbol',
            'group.emoji.placeholder': 'Klicke, um ein Emoji zu wählen',
            'group.emoji.help': 'Wähle ein Emoji-Symbol für diese Gruppe',
            'group.info.toggle': 'Information',
            'link.info': 'Information',
            'link.infoHtml': 'Info HTML',
            'link.infoHtml.placeholder': 'HTML-Inhalt eingeben, der im Tooltip angezeigt wird...',
            'link.infoHtml.help': 'Dieser HTML-Inhalt wird beim Überfahren des Info-Symbols angezeigt.',
            'link.popover.url': 'URL',
            'link.popover.noUrl': 'Keine URL vorhanden',
            'link.popover.created': 'Erstellt',
            'link.popover.updated': 'Aktualisiert',
            'link.popover.originalUrl': 'Originaleingabe',
            'link.popover.untitled': 'Unbenannter Link',
            'link.popover.notAvailable': 'Nicht erfasst',
            'link.url.info': 'URL leer lassen, um eine Überschrift/Kategorie zu erstellen',
            'link.basic': 'Grundeinstellungen',
            'link.appearance': 'Darstellung',
            'link.advanced': 'Erweitert',
            'link.text': 'Text',
            'link.text.help': 'HTML ist im sichtbaren Linktext erlaubt. Nur sichere Tags. Hinweis: Anker werden im Linklabel entfernt.',
            'link.text.required': 'Bitte einen Link-Text eingeben',
            'link.url': 'URL',
            'link.keywords': 'Schlagwörter',
            'link.keywords.help': 'Schlagwörter für Suche und Filterung (mit Komma oder Semikolon trennen)',
            'link.emoji': 'Symbol',
            'link.emoji.placeholder': 'Klicke, um ein Emoji zu wählen',
            'link.emoji.help': 'Wähle ein Emoji-Symbol für diesen Link',
            // Emoji-Auswahl
            'emoji.recent': 'Zuletzt',
            'emoji.smileys': 'Smileys',
            'emoji.people': 'Personen',
            'emoji.animals': 'Tiere',
            'emoji.food': 'Essen',
            'emoji.travel': 'Reisen',
            'emoji.activities': 'Aktivitäten',
            'emoji.objects': 'Objekte',
            'emoji.symbols': 'Symbole',
            'emoji.flags': 'Flaggen',
            'link.color': 'Linkfarbe',
            'color.reset': 'Zurücksetzen',
            'color.remove': 'Entfernen',
            'color.add': 'Farbe hinzufügen',
            'menu.link.editLink': 'Link bearbeiten',
            'menu.link.deleteLink': 'Link löschen',
            'link.copyUrl': 'URL in Zwischenablage kopieren',
            'link.urlCopied': 'URL kopiert',
            'link.copyFailed': 'URL konnte nicht kopiert werden',
            'toast.success': 'Erfolg',
            'toast.error': 'Fehler',
            'toast.warning': 'Warnung',
            'toast.info': 'Information',
            'shorteners.toast.missingAccount': 'Bitte hinterlege zuerst Account-Daten für {service}.',
            'shorteners.toast.disabled': '{service} ist noch nicht aktiviert. Schalte den Dienst in den Einstellungen frei.',
            'shorteners.toast.extensionMissing': 'Zum Kürzen wird die Browser-Erweiterung benötigt. Bitte installiere sie und erlaube den Zugriff.',
            'shorteners.toast.extensionUnsupported': 'Die installierte Erweiterung unterstützt das Kürzen aktuell noch nicht.',
            'shorteners.toast.success': 'Kurzlink in die Zwischenablage kopiert: {shortUrl}',
            'shorteners.toast.error': 'Kurzlink konnte nicht erstellt werden.{message}',
            'shorteners.toast.notSupported': '{service} wird derzeit noch nicht unterstützt.',
            'shorteners.toast.noTransport': 'Kein Netzwerk-Transport konfiguriert. Aktiviere die Browser-Erweiterung oder richte einen Proxy ein.',
            'shorteners.services.bitly.summary': 'Sehr verbreitet mit umfangreicher Analytics, Branding-Optionen und tiefer API-Integration.',
            'shorteners.services.bitly.audience': 'Ideal für Teams, die große Link-Mengen verwalten und Wert auf Markenauftritt legen.',
            'shorteners.services.rebrandly.summary': 'Unterstützt eigene Domains und feingranulare Steuerung für markenkonforme Kurz-Links.',
            'shorteners.services.rebrandly.audience': 'Perfekt für Marketer, die gebrandete Short-URLs statt generischer Domains wünschen.',
            'shorteners.services.tinyurl.summary': 'Der Klassiker: schnell, zuverlässig und kostenfrei im Einstieg.',
            'shorteners.services.tinyurl.audience': 'Geeignet für private oder gelegentliche Nutzung ohne viel Aufwand.',
            'shorteners.services.blink.summary': 'Analytics-starkes Tool mit Team-Workflows für mittelgroße bis große Projekte.',
            'shorteners.services.blink.audience': 'Richtet sich an Organisationen oder Agenturen mit mehreren Beteiligten.',
            'shorteners.services.shortio.summary': 'Ausgewogener Mix aus einfacher Bedienung, gebrandeten Domains und Team-Funktionen.',
            'shorteners.services.shortio.audience': 'Für Teams, die mehr Kontrolle wünschen, ohne gleich zu Enterprise-Lösungen zu greifen.',
            'shorteners.services.dub.summary': 'Moderner, entwicklerfreundlicher Shortener mit Automatisierungen und frischer UX.',
            'shorteners.services.dub.audience': 'Optimal für Nutzer, die neue Tools testen und auf moderne Funktionen setzen.',
            'shorteners.services.owly.summary': 'Verknüpft Link-Verkürzung mit Hootsuite-Planung und Analyse.',
            'shorteners.services.owly.audience': 'Gedacht für Social-Media-Teams, die ohnehin mit dem Hootsuite-Dashboard arbeiten.',
            'shorteners.services.replug.summary': 'Link-Rotation, Retargeting, Bio-Links und tiefe Analytics speziell für Marketing-Kampagnen.',
            'shorteners.services.replug.audience': 'Für Marketer, die Kampagnen-Links gezielt steuern und optimieren möchten.',
            'shorteners.services.t2m.summary': 'Funktionsreicher Link-Dienst mit starker Analyse zu moderaten Kosten.',
            'shorteners.services.t2m.audience': 'Für Anwender, die viele Features wünschen, ohne Enterprise-Preise zu zahlen.',
            'link.security.safe': 'Keine Auffälligkeiten erkannt.',
            'link.security.info.shortener': 'Shortener-Domain erkannt ({host}) – Zieladresse unbekannt.',
            'link.security.info.ip': 'Hostname ist eine IP-Adresse ({host}).',
            'link.security.warning.punycode': 'Hostname verwendet Punycode ({host}); auf mögliche Nachahmung prüfen.',
            'link.security.warning.query': 'Sensitiver Parameter gefunden ({key}).',
            'link.security.warning.protocol': 'Ungewöhnliches Protokoll erkannt ({protocol}).',
            'link.security.warning.generic': 'Mögliche Auffälligkeit erkannt.',
            'link.security.danger.protocol': 'Blockiertes Protokoll erkannt ({protocol}).',
            'link.security.danger.malformed': 'URL scheint fehlerhaft oder unvollständig zu sein.',
            'link.security.danger.suspicious': 'Verdächtiges Muster in der URL entdeckt.',
            'link.security.scoreLabel': 'Sicherheits-Score: {score}/100',
            'menu.link.sendLink': 'Link senden…',
            'menu.link.createQrCode': 'QR‑Code erstellen',
            'menu.link.copyForCss': 'Für CSS kopieren',
            'menu.link.copyCssClass': 'CSS‑Klasse kopieren',
            'menu.link.copyUuid': 'UUID kopieren',
            'menu.link.copyCssSelector': 'CSS-Selektor kopieren [data-link-uuid]',
            'menu.link.shorten': 'URL kürzen mit…',
            'menu.link.shorten.disabled': 'Konfiguriere Dienste in den Einstellungen, um Kurzlinks zu erstellen',
            'menu.link.shorten.noUrl': 'Kein URL-Wert vorhanden',
            'menu.group.sendGroup': 'Gruppe senden…',
            'menu.group.members': 'Mitglieder…',
            'menu.group.inspectJSON': 'JSON inspizieren',
            'menu.group.enableEventLog': 'Event-Log aktivieren (Beta)',
            'menu.group.copyForCss': 'Für CSS kopieren',
            'menu.group.copyCssClass': 'CSS‑Klasse kopieren',
            'menu.group.copyUuid': 'UUID kopieren',
            'menu.group.copyCssSelector': 'CSS-Selektor kopieren [data-group-uuid]',
            'menu.group.leaveGroup': 'Gruppe verlassen…',
            'menu.group.sort': 'Links sortieren',
            'menu.group.sort.withinColumns': 'Spaltenweise (A→Z)',
            'menu.group.sort.preserveCounts': 'Global A→Z, Spaltengröße beibehalten',
            'menu.group.sort.rebalance': 'Global A→Z, Spalten ausbalancieren',
            'menu.group.sort.withinColumnsDesc': 'Spaltenweise (Z→A)',
            'menu.group.sort.preserveCountsDesc': 'Global Z→A, Spaltengröße beibehalten',
            'menu.group.sort.rebalanceDesc': 'Global Z→A, Spalten ausbalancieren',
            'json.inspector.title': 'Gruppen JSON Inspector',
            'json.inspector.info': 'Vollständige JSON-Darstellung des Gruppenobjekts',
            'json.inspector.copy': 'JSON kopieren',
            'json.inspector.stats': 'Statistiken',
            'error.eventlog.ownerOnly': 'Nur der Eigentümer kann das Event-Log für diese Gruppe aktivieren',
            'Are you sure?': 'Bist du sicher?',
            'tools': 'Werkzeuge',
            'snapshots.title': 'Snapshots',
            'snapshots.save': 'Snapshot speichern',
            'snapshots.none': 'Noch keine Snapshots',
            'snapshots.promptName': 'Name für Snapshot:',
            'snapshots.restore.confirm': 'Diesen Snapshot wiederherstellen? Der aktuelle Stand wird zum Rückgängig-Verlauf hinzugefügt.',
            'snapshots.delete.confirm': 'Diesen Snapshot löschen?',
            'clear': 'Leeren',
            'undo': 'Rückgängig',
            'redo': 'Wiederholen',
            'savedSearches.placeholder': 'Gespeicherte Suchen…',
            'savedSearches.save': 'Suche speichern',
            'savedSearches.delete': 'Gespeicherte Suche löschen',
            'savedSearches.delete.confirm': 'Ausgewählte gespeicherte Suche löschen?',
            'savedSearches.promptName': 'Name für diese Suche:',
            'savedSearches.empty': 'Bitte zuerst einen Suchbegriff eingeben.',
            'duplicates.find': 'Duplikate finden',
            'duplicates.title': 'Gefundene Duplikate',
            'duplicates.description': 'Die folgenden Links erscheinen in mehreren Gruppen:',
            'duplicates.none': 'Keine Duplikate gefunden.',
            'duplicates.copies': 'Kopien',
            'duplicates.keep': 'Behalten',
            'duplicates.remove': 'Entfernen',
            'duplicates.info': 'Das erste Vorkommen jedes Links wird behalten. Nicht angekreuzte Einträge werden nicht gelöscht.',
            'duplicates.removeSelected': 'Ausgewählte Duplikate entfernen',
            'duplicates.confirmDelete': '%s Duplikat(e) löschen und den ersten Eintrag behalten?',
            'duplicates.deleted': '%s Duplikat(e) gelöscht.',
            'bookmarklet.addCurrentTab': 'Bookmarklet: Aktuellen Tab hinzufügen',
            'bookmarklet.instructions': 'Ziehe diesen Link in die Lesezeichenleiste. Ein Klick darauf öffnet diese App und übernimmt die aktuelle Seite.'
            , 'bookmarklet.helpTitle': 'Aktuellen Tab hinzufügen (Clipboard-Bookmarklet)'
            , 'bookmarklet.dragThis': 'Diesen Link in die Lesezeichenleiste ziehen'
            , 'bookmarklet.step.drag': 'Ziehe den Button unten in die Lesezeichenleiste.'
            , 'bookmarklet.step.clickAnyPage': 'Klicke das Bookmarklet auf einer beliebigen Seite, um URL und Titel in die Zwischenablage zu kopieren.'
            , 'bookmarklet.step.switchBack': 'Wechsle zurück zu dieser App und klicke „Aus Zwischenablage einfügen“, um den Link hinzuzufügen.'
            , 'clipboard.paste': 'Aus Zwischenablage einfügen'
            , 'clipboard.pastePrompt': 'Füge den Inhalt der Zwischenablage hier ein (JSON oder URL):'
            , 'clipboard.empty': 'Zwischenablage ist leer.'
            , 'clipboard.invalid': 'Der Inhalt ist keine gültige URL oder kein gültiges JSON.'
            , 'clipboard.noPermission': 'Zwischenablage konnte nicht gelesen werden. Bitte manuell einfügen, wenn gefragt.'
            , 'clipboard.modalTitle': 'Aus Zwischenablage hinzufügen'
            , 'clipboard.instructions': 'Klicke „Aus Zwischenablage lesen“ oder füge JSON {url,title} bzw. eine URL unten ein.'
            , 'clipboard.read': 'Aus Zwischenablage lesen'
            , 'clipboard.add': 'Hinzufügen'
            , 'clipboard.cancel': 'Abbrechen'
            , 'clipboard.placeholder': 'Füge JSON {"url":"https://…","title":"…"} oder eine URL ein'
            // Einladungsdialog Übersetzungen
            , 'invitation.groupTitle': 'Einladung zur geteilten Gruppe'
            , 'invitation.linkTitle': 'Geteilte Links erhalten'
            , 'share.groupTitle': 'Gruppe erhalten'
            , 'share.linkTitle': 'Links erhalten'
            , 'invitation.from': 'Von'
            , 'invitation.groupName': 'Gruppenname'
            , 'invitation.linkCount': 'Anzahl Links'
            , 'invitation.linksToAdd': 'Zu hinzufügende Links'
            , 'invitation.groupDescription': 'Möchten Sie diese geteilte Gruppe hinzufügen? Sie können dann Links mit anderen Mitgliedern der Gruppe teilen.'
            , 'invitation.linkDescription': 'Möchten Sie diese Links zu Ihrer ausgewählten Gruppe hinzufügen?'
            , 'invitation.sharedGroupDescription': 'Möchten Sie diese geteilte Gruppe mit allen Links hinzufügen?'
            , 'share.groupDescription': 'Möchten Sie diese Gruppe mit allen Links hinzufügen?'
            , 'share.linkDescription': 'Möchten Sie diese Links hinzufügen?'
            , 'share.add': 'Hinzufügen'
            , 'share.cancel': 'Abbrechen'
            , 'invitation.reject': 'Ablehnen'
            , 'invitation.accept': 'Annehmen'
            // Browser Extension Übersetzungen
            , 'extension.importBookmarks': 'Browser-Lesezeichen importieren'
            , 'extension.enrichMetadata': 'Links mit Metadaten anreichern'
            , 'extension.notInstalled': 'Browser-Erweiterung nicht installiert'
            , 'extension.installHint': 'Installiere die MyBookmarks-Erweiterung aus local2/extensions/'
            , 'extension.imported': '{count} Lesezeichen in {groups} Gruppen importiert!'
            , 'extension.enriched': '{count} Links mit Metadaten angereichert!'
            , 'extension.allHaveMetadata': 'Alle Links haben bereits Metadaten!'
            , 'extension.fetchMetadataConfirm': 'Metadaten für {count} Links abrufen?'
            , 'extension.error': 'Fehler: {message}'

            // Event-Log Tab Übersetzungen
            , 'eventlog.time': 'Zeit'
            , 'eventlog.type': 'Typ'
            , 'eventlog.author': 'Autor'
            , 'eventlog.details': 'Details'
            , 'eventlog.changes': 'Änderungen'
            
            // Snapshot Tab Übersetzungen
            , 'snapshot.info': 'Snapshot-Informationen'
            , 'snapshot.created': 'Erstellt'
            , 'snapshot.eventId': 'Event-ID'
            , 'snapshot.links': 'Links im Snapshot'
            , 'snapshot.members': 'Mitglieder im Snapshot'
            , 'snapshot.version': 'Version'
            , 'snapshot.vectorClock': 'Vector Clock'
            , 'snapshot.member': 'Mitglied'
            , 'snapshot.eventCount': 'Event-Anzahl'
            , 'snapshot.noVectorClock': 'Keine Vector Clock Daten'
            , 'snapshot.showData': 'Snapshot-Daten anzeigen'
            
            // Event-Log & Sync Einstellungen
            , 'options.eventlog.title': 'Event-Log & Sync'
            , 'options.eventlog.snapshotInterval': 'Snapshot nach Events'
            , 'options.eventlog.snapshotInterval.help': 'Snapshot nach dieser Anzahl von Events erstellen (reduziert Speicherverbrauch)'
            , 'options.eventlog.maxEvents': 'Max. Events behalten'
            , 'options.eventlog.maxEvents.help': 'Maximale Events vor erzwungener Bereinigung (harte Grenze)'
            , 'options.eventlog.syncStrategy': 'Sync-Strategie'
            , 'options.eventlog.syncStrategy.help': 'Wie Konflikte beim Synchronisieren behandelt werden'
            , 'options.eventlog.syncStrategy.ownerLeads': 'Besitzer führt (empfohlen)'
            , 'options.eventlog.syncStrategy.allEqual': 'Alle Mitglieder gleich'
            , 'options.eventlog.syncStrategy.smartMerge': 'Smart Merge (experimentell)'
            , 'Events': 'Ereignisse'
            , 'options.eventlog.note': 'Hinweis:'
            , 'options.eventlog.note.text': 'Event-Log-Einstellungen gelten, wenn Sie der Gruppenbesitzer sind. Mitglieder verwenden die Einstellungen des Besitzers.'
            
            // CSS Dialog Übersetzungen
            , 'css.format': 'CSS-Format'
            , 'css.noStyle': 'Kein benutzerdefinierter Stil'
            , 'css.clear': 'Löschen'
            , 'css.preview.text': 'Vorschautext'
            , 'css.opacity.warning': 'Hinweis:'
            , 'css.opacity.websiteBackgroundInfo': 'Für den Website-Hintergrund wird die Deckkraft nur auf die Hintergrundfarbe angewendet (mittels rgba). Dadurch bleiben Dialoge sichtbar.'
            , 'css.background': 'Hintergrund (Kurzform)'
            , 'css.backgroundColor': 'Hintergrundfarbe'
            , 'css.backgroundOpacity': 'Deckkraft'
            , 'css.text': 'Text'
            , 'css.textColor': 'Textfarbe'
            , 'css.fontFamily': 'Schriftfamilie'
            , 'css.default': 'Standard'
            , 'css.fontSize': 'Schriftgröße'
            , 'css.fontWeight': 'Schriftstärke'
            , 'css.normal': 'Normal'
            , 'css.bold': 'Fett'
            , 'css.lighter': 'Leichter'
            , 'css.fontStyle': 'Schriftstil'
            , 'css.italic': 'Kursiv'
            , 'css.oblique': 'Schräg'
            , 'css.textDecoration': 'Textdekoration'
            , 'css.underline': 'Unterstrichen'
            , 'css.overline': 'Überstrichen'
            , 'css.lineThrough': 'Durchgestrichen'
            , 'css.underlineOverline': 'Unter- + Überstrichen'
            , 'css.border': 'Rahmen'
            , 'css.borderStyle': 'Rahmenstil'
            , 'css.none': 'Keiner'
            , 'css.solid': 'Durchgezogen'
            , 'css.dashed': 'Gestrichelt'
            , 'css.dotted': 'Gepunktet'
            , 'css.double': 'Doppelt'
            , 'css.groove': 'Vertieft'
            , 'css.ridge': 'Erhöht'
            , 'css.inset': 'Eingelassen'
            , 'css.outset': 'Hervorstehend'
            , 'css.borderWidth': 'Rahmenbreite'
            , 'css.borderColor': 'Rahmenfarbe'
            , 'css.borderRadius': 'Rahmenradius'
            , 'css.shadow': 'Schatten'
            , 'css.boxShadow': 'Box-Schatten'
            , 'css.shadowPresets': 'Vorlagen'
            , 'css.shadowSubtle': 'Dezent'
            , 'css.shadowMedium': 'Mittel'
            , 'css.shadowStrong': 'Stark'
            , 'css.shadowInset': 'Innen'
            , 'css.generatedCode': 'Generiertes CSS:'
            , 'css.apply': 'Anwenden'
            , 'css.cancel': 'Abbrechen'
            , 'css.shorthand': 'Kurzform'
            , 'css.spacing': 'Abstände'
            , 'css.padding': 'Innenabstand (Padding)'
            , 'css.margin': 'Außenabstand (Margin)'
            , 'css.top': 'Oben'
            , 'css.right': 'Rechts'
            , 'css.bottom': 'Unten'
            , 'css.left': 'Links'
            , 'css.resetAll': 'Alle zurücksetzen'

            // Visual CSS Editor Übersetzungen
            , 'css.visual.title': 'Visueller CSS Editor'
            , 'css.visual.templates': 'CSS Vorlagen'
            , 'css.visual.rules': 'CSS Regeln'
            , 'css.visual.generated': 'Generiertes CSS'
            , 'css.visual.designTokens': 'Design Tokens'
            , 'css.visual.addToken': 'Token hinzufügen'
            , 'css.visual.noTokens': 'Noch keine Tokens. Füge welche hinzu (z. B. brand-primary (ohne --), #3b82f6)'
            , 'css.visual.tokensHint': 'Tokens per Dropdown neben den Properties einsetzen (var(--token)).'
            , 'css.visual.tokensSelect': '-- Token wählen --'
            , 'css.visual.valuePlaceholder': 'Wert eingeben (z. B. #ff0000, rgb(), var(--...))'
            , 'css.visual.tokenName': 'Token-Name'
            , 'css.visual.tokenValue': 'Token-Wert'
            , 'css.visual.invalidCssValue': 'Ungültiger CSS-Wert'
            , 'css.visual.missingTokens': 'Fehlende Tokens'
            , 'css.visual.invalidTokenValue': 'Ungültiger Token-Wert (z. B. #rrggbb, rgb(), linear-gradient(), var(--name))'
            , 'extension.clearCache': 'Extension-Cache leeren'
            , 'extension.cacheCleared': 'Extension-Cache geleert'
            , 'extension.cacheClearFailed': 'Extension-Cache konnte nicht geleert werden'
            , 'extension.notAvailable': 'Extension nicht verfügbar'
            , 'extension.refetchFavicons': 'Favicons werden neu geladen…'
            
            , 'css.visual.pickElement': 'Element wählen'
            , 'css.visual.pickerActive': 'Element-Picker aktiv: Klicke ein Element im Inhalt'
            , 'css.visual.picked': 'Ausgewählt'
            , 'css.visual.applyPreset': 'Preset anwenden…'
            , 'css.visual.presetApplied': 'Preset angewendet'
            , 'css.visual.addRule': 'Neue CSS Regel hinzufügen'
            , 'css.visual.deleteRule': 'Regel löschen'
            , 'css.visual.element': 'Element'
            , 'css.visual.selectElement': '-- Element wählen --'
            , 'css.visual.group': 'Gruppe'
            , 'css.visual.selectGroup': '-- Alle Gruppen --'
            , 'css.visual.link': 'Link'
            , 'css.visual.selectLink': '-- Alle Links --'
            , 'css.visual.properties': 'CSS Eigenschaften'
            , 'css.visual.addProperty': '+ Eigenschaft hinzufügen...'
            , 'css.visual.colors': 'Farben'
            , 'css.visual.typography': 'Typografie'
            , 'css.visual.borders': 'Rahmen'
            , 'css.visual.sizes': 'Größen'
            , 'css.visual.complete': 'komplett'
            , 'css.outline': 'Umrisslinie'
            , 'css.outlineWidth': 'Umrissbreite'
            , 'css.outlineStyle': 'Umrissstil'
            , 'css.outlineColor': 'Umrissfarbe'
            , 'css.outlineOffset': 'Umrissabstand'
            , 'css.width': 'Breite'
            , 'css.height': 'Höhe'
            , 'css.opacity': 'Transparenz'
            , 'css.textAlign': 'Textausrichtung'
            , 'css.topLeft': 'oben links'
            , 'css.topRight': 'oben rechts'
            , 'css.bottomLeft': 'unten links'
            , 'css.bottomRight': 'unten rechts'
            , 'css.visual.layout': 'Layout'
            , 'css.visual.effects': 'Effekte'
            , 'css.visual.importantHint': 'Erzwinge diesen Style über andere (!important)'
            , 'css.visual.rule': 'Regel'
            , 'css.visual.doubleClickToEdit': 'Doppelklick zum Bearbeiten'
            , 'css.visual.copy': 'Kopie'
            , 'css.visual.toggleCollapse': 'Ein-/Ausklappen'
            , 'css.visual.expandAll': 'Alle aufklappen'
            , 'css.visual.collapseAll': 'Alle zuklappen'
            , 'css.visual.activate': 'Aktivieren'
            , 'css.visual.deactivate': 'Deaktivieren'
            , 'css.visual.selectElementShort': 'Element wählen'
            , 'css.visual.customCss': 'Custom CSS'
            , 'css.visual.moveUp': 'Nach oben'
            , 'css.visual.moveDown': 'Nach unten'
            , 'css.visual.duplicate': 'Duplizieren'
            , 'css.visual.delete': 'Löschen'
            , 'css.visual.selectTemplate': '-- Vorlage wählen --'
            , 'css.visual.defaultTemplates': 'Standard-Vorlagen'
            , 'css.visual.appLevel': 'App-Ebene'
            , 'css.visual.groupLevel': 'Gruppen-Ebene'
            , 'css.visual.linkLevel': 'Link-Ebene'
            , 'css.visual.allGroups': 'Alle Gruppen'
            , 'css.visual.groupHeader': 'Gruppen Header'
            , 'css.visual.groupTitle': 'Gruppen Titel'
            , 'css.visual.groupContent': 'Gruppen Inhalt'
            , 'css.visual.allLinks': 'Alle Links'
            , 'css.visual.linkHover': 'Link (Hover)'
            , 'css.visual.linkAnchor': 'Link Anchor'
            , 'css.visual.linkUrl': 'Link URL'
            , 'css.visual.linkIcon': 'Link Icon'
            , 'css.visual.keywords': 'Keywords'
            , 'css.visual.allKeywords': 'Alle Keywords (Keyword-Bar)'
            , 'css.visual.keywordsHierarchical': 'Keywords (Hierarchisch)'
            , 'css.visual.keywordByName': 'Keyword nach Name'
            , 'css.visual.selectKeyword': '-- Alle Keywords --'
            , 'css.visual.keyword': 'Keyword'
            , 'css.visual.copy': 'Kopieren'
            , 'css.visual.apply': 'Anwenden'
            , 'css.visual.save': 'Speichern'
            , 'css.visual.migrationNotice': 'Hinweis: Ihr bisheriges Custom CSS wurde importiert. Sie können es oben als "Legacy CSS" Regel bearbeiten oder löschen.'
            , 'css.visual.customProperties': 'Custom CSS Eigenschaften'
            , 'css.visual.customPropertiesHint': 'z.B. display: flex;\njustify-content: center;'
            , 'css.visual.customPropertiesHelp': 'Geben Sie beliebige CSS-Eigenschaften ein (eine pro Zeile)'
            , 'css.visual.generatedSelector': 'Generierter Selektor'
            , 'css.visual.ruleSets': 'Regel-Sätze'
            , 'css.visual.loadRuleSet': 'Regel-Satz laden'
            , 'css.visual.saveCurrentRules': 'Aktuelle Regeln speichern'
            , 'css.visual.savedRuleSets': 'Gespeicherte Sätze'
            , 'css.visual.rulesCount': 'Regeln'
            , 'css.visual.deleteRuleSet': 'Löschen'
            , 'css.visual.ruleSetName': 'Name für Regel-Satz:'
            , 'css.visual.ruleSetSaved': 'Regel-Satz gespeichert!'
            , 'css.visual.loadRuleSetConfirm': 'Möchten Sie diesen Regel-Satz laden? Ihre aktuellen Regeln werden ersetzt.'
            , 'css.visual.deleteRuleSetConfirm': 'Möchten Sie diesen Regel-Satz wirklich löschen?'
            , 'css.visual.selectRuleSet': '-- Wählen --'
            , 'css.visual.ruleSetLoaded': 'Regel-Satz geladen'
            , 'css.visual.ruleSetDeleted': 'Regel-Satz gelöscht'
            , 'css.visual.clearAll': 'Alles löschen'
            , 'css.visual.clearAllTooltip': 'Alle CSS Einstellungen löschen'
            , 'css.visual.clearAllConfirm': 'Möchten Sie wirklich ALLE CSS-Einstellungen löschen?\n\nDies entfernt:\n• Alle CSS-Regeln\n• Das ausgewählte Template\n• Alle gespeicherten Regel-Sätze\n\nDiese Aktion kann nicht rückgängig gemacht werden!'
            , 'css.visual.clearedAll': 'Alle CSS-Einstellungen wurden gelöscht'
            , 'css.visual.clearProperties': 'Eigenschaften löschen'
            , 'css.visual.clearPropertiesTitle': 'Alle Eigenschaften dieser Regel löschen'
            , 'css.visual.propertiesCleared': 'Eigenschaften gelöscht'
            , 'css.visual.propertyAlreadyExists': 'Diese Eigenschaft existiert bereits in dieser Regel'

            // Generische Button-Übersetzungen
            , 'apply': 'Anwenden'
            , 'cancel': 'Abbrechen'
            , 'save': 'Speichern'
            , 'members.select': 'Mitgliedsnummer auswählen:'
            , 'close': 'Schließen'
            , 'ok': 'OK'
          }
        };

    MB.I18n = (function() {
      const defaultLocale = 'en';
      const translations = MB_I18N_TRANSLATIONS;

      function normalizeLocale(locale) {
        if (!locale) return defaultLocale;
        return String(locale).trim().toLowerCase() || defaultLocale;
      }

      return {
        defaultLocale,
        getAvailableLocales() {
          return Object.keys(translations);
        },
        getTranslations(locale) {
          return translations[normalizeLocale(locale)] || translations[defaultLocale] || {};
        },
        get(locale, key) {
          if (!key) return '';
          const normalized = normalizeLocale(locale);
          const preferred = translations[normalized]?.[key];
          if (preferred !== undefined) return preferred;
          if (normalized !== defaultLocale) {
            const fallback = translations[defaultLocale]?.[key];
            if (fallback !== undefined) return fallback;
          }
          return '';
        },
        setTranslations(locale, entries) {
          if (!locale || typeof entries !== 'object') return;
          const normalized = normalizeLocale(locale);
          const target = translations[normalized] || (translations[normalized] = {});
          Object.assign(target, entries);
        },
        replaceTranslations(locale, entries) {
          if (!locale || typeof entries !== 'object') return;
          translations[normalizeLocale(locale)] = Object.assign({}, entries);
        }
      };
    })();



    MB.Network = {
      DEFAULT_TIMEOUT: DEFAULT_PROXY_TIMEOUT_MS,
      getProxyConfig() {
        const app = window.app;
        const opts = app?.data?.options?.proxy;
        if (opts) return opts;
        return initialData.options.proxy;
      },
      isProxyEnabled() {
        const config = this.getProxyConfig() || {};
        if (!config.enabled) return false;
        return !!(config.baseUrl && config.baseUrl.trim());
      },
      getProxyBaseUrl() {
        const base = (this.getProxyConfig()?.baseUrl || '').trim();
        return base.replace(/\/$/, '');
      },
      getProxyHeaders() {
        const config = this.getProxyConfig() || {};
        const headers = {};
        const token = (config.apiKey || '').trim();
        if (token) headers['Authorization'] = `Bearer ${token}`;
        const extra = (config.extraHeaders || '').split('\n');
        extra.forEach(line => {
          const trimmed = line.trim();
          if (!trimmed) return;
          const idx = trimmed.indexOf(':');
          if (idx === -1) return;
          const key = trimmed.slice(0, idx).trim();
          const value = trimmed.slice(idx + 1).trim();
          if (!key) return;
          headers[key] = value;
        });
        return headers;
      },
      normalizeRequestConfig(config = {}) {
        const normalized = Object.assign({ method: 'POST', headers: {} }, config);
        normalized.method = (normalized.method || 'POST').toUpperCase();
        if (!normalized.headers || typeof normalized.headers !== 'object') normalized.headers = {};
        const headers = {};
        Object.entries(normalized.headers).forEach(([key, value]) => {
          if (key) headers[key] = value;
        });
        normalized.headers = headers;
        const hasJsonContentType = Object.keys(headers).some(h => h.toLowerCase() === 'content-type' && /json/i.test(String(headers[h])));
        if (normalized.body && typeof normalized.body !== 'string' && normalized.method !== 'GET' && normalized.method !== 'HEAD') {
          if (!hasJsonContentType) headers['Content-Type'] = 'application/json';
          normalized.body = JSON.stringify(normalized.body);
        }
        if (normalized.timeoutMs === undefined) normalized.timeoutMs = this.DEFAULT_TIMEOUT;
        return normalized;
      },
      async fetchViaProxy(request) {
        if (!this.isProxyEnabled()) {
          const err = new Error('proxyDisabled');
          err.code = 'proxyDisabled';
          throw err;
        }
        const baseUrl = this.getProxyBaseUrl();
        if (!baseUrl) {
          const err = new Error('proxyMissingBaseUrl');
          err.code = 'proxyMissingBaseUrl';
          throw err;
        }
        const endpoint = `${baseUrl}/fetch`;
        const payload = { request };
        const headers = Object.assign({ 'Content-Type': 'application/json' }, this.getProxyHeaders());
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), request.timeoutMs || this.DEFAULT_TIMEOUT);
        try {
          const response = await fetch(endpoint, {
            method: 'POST',
            headers,
            body: JSON.stringify(payload),
            signal: controller.signal,
            credentials: 'omit'
          });
          const json = await response.json().catch(() => null);
          if (!response.ok) {
            const err = new Error(json?.error || `${response.status} ${response.statusText}`);
            err.code = 'proxyFetchFailed';
            throw err;
          }
          return json;
        } catch (error) {
          if (error.name === 'AbortError') {
            const err = new Error('proxyTimeout');
            err.code = 'proxyTimeout';
            throw err;
          }
          throw error;
        } finally {
          clearTimeout(timeout);
        }
      },
      hasExtensionTransport() {
        return !!(window.MyBookmarksExtension && typeof window.MyBookmarksExtension.proxyFetch === 'function');
      },
      async performRequest(config) {
        const normalized = this.normalizeRequestConfig(config);
        if (this.isProxyEnabled()) {
          return await this.fetchViaProxy(normalized);
        }
        if (this.hasExtensionTransport()) {
          return await MB.Extension.proxyFetch(normalized);
        }
        const err = new Error('noTransport');
        err.code = 'noTransport';
        throw err;
      }
    };

    function resolveDomain(labelValue, baseUrl, fallback) {
      const trimmed = (labelValue || '').trim();
      if (trimmed) return trimmed;
      if (baseUrl) {
        try {
          return new URL(baseUrl).hostname;
        } catch {}
      }
      return fallback || '';
    }

    function parseJsonResponse(response, provider) {
      let data = null;
      try {
        data = response?.bodyText ? JSON.parse(response.bodyText) : {};
      } catch (err) {
        throw new Error(`${provider} returned invalid JSON`);
      }
      if (!response?.ok) {
        const message = data?.message || data?.error || data?.description || data?.errors?.[0]?.message || response?.statusText || `HTTP ${response?.status}`;
        throw new Error(message);
      }
      return data || {};
    }

    const initialData = {
      groups: [],
      savedSearches: [],
      snapshots: [],
      schemaVersion: 1,
      identity: { uuid: '', name: '', pubKey: '', privKey: '' },
      contacts: [],
      inbox: [],
      pendingNcDeletes: [],
      options: { // Default options structure
        common: {
          language: 'en',
          pageTitle: 'My Bookmarks',
          searchAsYouType: false,
          confirmDeleteGroup: true,
        confirmDeleteLink: true,
        },
        groups: {
          collapseGroupsOnStart: false,
          hoverExpandDelayMs: CONSTS.HOVER_EXPAND_DELAY_MS,
          hoverExpandEnabled: true,
          defaultGroupFormatting: '',
          defaultGroupTitleFormatting: '',
          defaultGroupLinkFormatting: '',
          defaultGroupBadgeFormatting: '',
          defaultGroupPillFormatting: '',
          defaultLinkFormatting: '',
          clearClosesAllGroups: false,
          keywordClickExpandsAll: false,
          searchAutoExpandFound: false,
        },
        links: {
          openInNewTab: true,
          addViaDialog: false,
          autoFetchTitle: false,
          autoFetchFavicon: false,
          showLinkBadges: false,
          showLinkPopover: true,
          progressiveLoadingThreshold: CONSTS.PROGRESSIVE_LOADING_THRESHOLD,
          copyUrlFormat: '{title}: {url}', // Customizable format for copying links
          defaultUrlPrefix: CONSTS.DEFAULT_URL_PREFIX,
          faviconRules: getDefaultFaviconRules()
        },
        linkShorteners: {
          enabledServices: [],
          accounts: {}
        },
        proxy: {
          enabled: false,
          baseUrl: '',
          apiKey: '',
          extraHeaders: ''
        },
        buttons: {
          // Group quick-action buttons
          showAddLink: true,      // Show "Add link" button in group header
          showDeleteGroup: true,  // Show "Delete group" button in group header
          // Link quick-action buttons
          showCopyUrl: true,      // Show "Copy URL" button for links
          showQrCode: true,       // Show "QR Code" button for links
          showDeleteLink: true    // Show "Delete link" button for links
        },
        sharing: {
          ntfyServerUrl: 'https://ntfy.sh',
          ntfyAuthToken: '',
          defaultTtl: 0,
          quickCodeTtlSec: CONSTS.QUICK_CODE_TTL_SEC,
          contactOnlineTimeoutSeconds: CONSTS.CONTACT_ONLINE_TIMEOUT_SEC,
        },
        groupSharing: {
          topicPrefix: 'mb-g-',
        },
        colors: {
          background: '',  // Changed from websiteBackground to match optionPath
          toolbarBackground: '',
          titleBarBackground: '',
          titleTextColor: '',
          keywordContainer: '',
          keywordBackground: ''  // Default keyword formatting (container and badges background)
        },
        customCss: '',
        eventlog: {
          snapshotInterval: CONSTS.EVENT_LOG_SNAPSHOT_INTERVAL,
          maxEvents: CONSTS.EVENT_LOG_MAX_EVENTS * 2, // Double for main setting
          syncStrategy: 'owner-leads'
        },
        // CardDAV configuration defaults
        carddav: {
          serverUrl: '',
          username: '',
          password: '',
          addressbookPath: '',
          createAddressbookIfMissing: true,
          syncIntervalSec: 0, // 0 = manual only
          lastSyncAt: 0,
          addressbookUrl: '',
          syncToken: ''
        },
        // Nextcloud Bookmarks settings
        bookmarks: {
          serverUrl: '',
          username: '',
          password: '',
          rootFolderId: 0, // 0 = all folders
          syncIntervalSec: 0,
          folderHashes: {}
        },
        performance: {
          virtualizeLinks: false,
          initialLimit: 200,
          pageSize: 200
        }
      },
    };


    MB.LinkShorteners = (function() {
      const DEFAULTS = initialData.options?.linkShorteners || { enabledServices: [], accounts: {} };

      const cloneDefaults = () => JSON.parse(JSON.stringify(DEFAULTS || { enabledServices: [], accounts: {} }));

      function ensureStructure(vm, target) {
        if (!target) return target;
        if (!Array.isArray(target.enabledServices)) {
          vm?.$set ? vm.$set(target, 'enabledServices', []) : (target.enabledServices = []);
        }
        if (!target.accounts || typeof target.accounts !== 'object') {
          vm?.$set ? vm.$set(target, 'accounts', {}) : (target.accounts = {});
        }
        return target;
      }

      function getOptions(vm, { preferDraft = false, createIfMissing = false } = {}) {
        if (!vm) return null;
        let container = null;

        if (preferDraft && vm.genericEditConfig?.type === 'options' && vm.genericEditData) {
          if (!vm.genericEditData.linkShorteners || typeof vm.genericEditData.linkShorteners !== 'object') {
            if (!createIfMissing) return null;
            const defaults = cloneDefaults();
            vm.$set ? vm.$set(vm.genericEditData, 'linkShorteners', defaults) : (vm.genericEditData.linkShorteners = defaults);
          }
          container = vm.genericEditData.linkShorteners;
        } else {
          vm?.fixOptions?.();
          if (!vm.data) return null;
          if (!vm.data.options) {
            if (!createIfMissing) return vm.data.options?.linkShorteners || null;
            vm.$set ? vm.$set(vm.data, 'options', {}) : (vm.data.options = {});
          }
          if (!vm.data.options.linkShorteners || typeof vm.data.options.linkShorteners !== 'object') {
            if (!createIfMissing) return vm.data.options.linkShorteners || null;
            const defaults = cloneDefaults();
            vm.$set ? vm.$set(vm.data.options, 'linkShorteners', defaults) : (vm.data.options.linkShorteners = defaults);
          }
          container = vm.data.options.linkShorteners;
        }

        return ensureStructure(vm, container);
      }

      function isServiceEnabled(vm, serviceId, { preferDraft = true } = {}) {
        const options = getOptions(vm, { preferDraft });
        const enabled = options?.enabledServices;
        return Array.isArray(enabled) && enabled.includes(serviceId);
      }

      function toggleService(vm, serviceId, enabled, { preferDraft = true } = {}) {
        const options = getOptions(vm, { preferDraft, createIfMissing: true });
        if (!options) return;
        const current = Array.isArray(options.enabledServices) ? [...options.enabledServices] : [];
        const index = current.indexOf(serviceId);
        if (enabled && index === -1) {
          current.push(serviceId);
        } else if (!enabled && index !== -1) {
          current.splice(index, 1);
        }
        vm?.$set ? vm.$set(options, 'enabledServices', current) : (options.enabledServices = current);
      }

      function ensureAccount(vm, serviceId, { preferDraft = true } = {}) {
        const options = getOptions(vm, { preferDraft, createIfMissing: true });
        if (!options) return null;
        if (!options.accounts[serviceId]) {
          const placeholder = { label: '', apiKey: '' };
          vm?.$set ? vm.$set(options.accounts, serviceId, placeholder) : (options.accounts[serviceId] = placeholder);
        }
        return options.accounts[serviceId];
      }

      function getAccount(vm, serviceId, { preferDraft = true } = {}) {
        const options = getOptions(vm, { preferDraft });
        const account = options?.accounts?.[serviceId];
        if (account) return account;
        return { label: '', apiKey: '' };
      }

      function updateAccount(vm, serviceId, field, value, opts) {
        const account = ensureAccount(vm, serviceId, opts);
        if (!account) return;
        vm?.$set ? vm.$set(account, field, value) : (account[field] = value);
      }

      function clearAccount(vm, serviceId, { preferDraft = true } = {}) {
        const options = getOptions(vm, { preferDraft });
        if (!options?.accounts || !options.accounts[serviceId]) return;
        if (vm?.$delete) vm.$delete(options.accounts, serviceId);
        else delete options.accounts[serviceId];
      }

      function getServiceText(service, key, { vm, lang } = {}) {
        if (!service) return '';
        const translationKey = service[`${key}Key`];
        if (translationKey && vm) {
          const translated = vm.getTranslation?.(translationKey);
          if (translated && translated !== translationKey) {
            return translated;
          }
        }
        const directValue = service[key];
        if (!directValue) return '';
        if (typeof directValue === 'string') return directValue;
        const language = (lang || vm?.data?.options?.common?.language || 'en').toLowerCase();
        if (directValue[language]) return directValue[language];
        return directValue.en || directValue.de || '';
      }

      function normalizeBase(service) {
        const base = (service?.demoDomain || service?.baseUrl || `https://${service?.id || 'short'}.example`).trim();
        if (!base) return 'https://short.example';
        return base.replace(/\/+$/, '');
      }

      function generateSlug(input, length = 7) {
        const text = String(input || '');
        let hash = 0;
        for (let i = 0; i < text.length; i += 1) {
          hash = (hash << 5) - hash + text.charCodeAt(i);
          hash |= 0;
        }
        let slug = Math.abs(hash).toString(36);
        while (slug.length < length) {
          slug += Math.random().toString(36).slice(2);
        }
        return slug.slice(0, length).toLowerCase();
      }

      async function runAdapter({
        vm,
        service,
        contextLink,
        contextGroup,
        extensionAvailable = true,
        getTranslation,
        hasNetworkTransport,
        performNetworkRequest,
        copyToClipboard
      } = {}) {
        const t = (key) => {
          if (typeof getTranslation === 'function') return getTranslation(key);
          if (vm?.getTranslation) return vm.getTranslation(key);
          return key;
        };

        const makeResult = (ok, type, message, extra = {}) => Object.assign({ ok, type, message }, extra);

        if (!service) {
          return makeResult(false, 'error', t('shorteners.toast.error') || 'Could not create a short link.');
        }

        const linkUrl = contextLink?.url || '';
        if (!linkUrl) {
          return makeResult(false, 'warning', t('menu.link.shorten.noUrl') || 'No URL available');
        }

        if (!extensionAvailable) {
          return makeResult(false, 'warning', t('shorteners.toast.extensionMissing') || 'Browser extension required.');
        }

        if (typeof hasNetworkTransport === 'function' && !hasNetworkTransport.call(vm)) {
          return makeResult(false, 'warning', t('shorteners.toast.noTransport') || 'No network transport configured.');
        }

        if (!isServiceEnabled(vm, service.id, { preferDraft: false })) {
          const msg = (t('shorteners.toast.disabled') || '{service} is not enabled.').replace('{service}', service.name);
          return makeResult(false, 'info', msg);
        }

        const account = getAccount(vm, service.id, { preferDraft: false }) || { label: '', apiKey: '' };
        const hasAccount = !!(account.apiKey || account.label);
        if (service.accountRequired && !hasAccount) {
          const msg = (t('shorteners.toast.missingAccount') || 'Please add account details for {service}.')
            .replace('{service}', service.name);
          return makeResult(false, 'warning', msg);
        }

        const adapter = LINK_SHORTENER_ADAPTERS[service.id];
        if (typeof adapter !== 'function') {
          const msg = (t('shorteners.toast.notSupported') || '{service} is not yet supported.')
            .replace('{service}', service.name);
          return makeResult(false, 'info', msg);
        }

        const normalizedUrl = MB.Utils.ensureProtocol(linkUrl);
        if (!MB.Utils.isValidHttpUrl(normalizedUrl)) {
          return makeResult(false, 'warning', t('menu.link.shorten.noUrl') || 'No URL available');
        }

        try {
          const adapterOptions = {
            baseUrl: normalizeBase(service),
            suggestedSlug: generateSlug(`${service?.id || 'short'}-${normalizedUrl}`),
            linkId: contextLink?.uuid || null,
            groupId: contextGroup?.uuid || null,
            context: {
              serviceName: service.name,
              linkText: contextLink?.text || '',
              keywords: contextLink?.keywords || ''
            },
            timeoutMs: DEFAULT_PROXY_TIMEOUT_MS
          };

          const adapterResult = await adapter({ url: normalizedUrl, account, options: adapterOptions });
          if (!adapterResult || !adapterResult.request) {
            throw new Error('Shortener adapter did not return a request configuration');
          }

          const requestConfig = Object.assign({}, adapterResult.request);
          if (!requestConfig.url) {
            throw new Error('Adapter request missing URL');
          }
          requestConfig.method = (requestConfig.method || 'POST').toUpperCase();
          requestConfig.timeoutMs = requestConfig.timeoutMs || adapterOptions.timeoutMs;

          const normalizedHeaders = {};
          if (requestConfig.headers && typeof requestConfig.headers === 'object') {
            Object.entries(requestConfig.headers).forEach(([key, value]) => {
              if (key) normalizedHeaders[key] = value;
            });
          }
          requestConfig.headers = normalizedHeaders;

          const hasJsonContentType = Object.keys(normalizedHeaders).some(h => h.toLowerCase() === 'content-type' && /json/i.test(String(normalizedHeaders[h])));
          if (requestConfig.body && typeof requestConfig.body !== 'string') {
            if (!hasJsonContentType) {
              normalizedHeaders['Content-Type'] = 'application/json';
            }
            requestConfig.body = JSON.stringify(requestConfig.body);
          }

          const response = typeof performNetworkRequest === 'function'
            ? await performNetworkRequest(requestConfig)
            : await MB.Network.performRequest(requestConfig);

          if (!response) {
            throw new Error('No response from proxy fetch');
          }
          if (response.error) {
            throw new Error(response.error);
          }

          const parseFn = typeof adapterResult.parse === 'function'
            ? adapterResult.parse
            : (resp) => ({ shortUrl: (resp.bodyText || '').trim() });

          const parsedResult = await parseFn(response, { service, account, options: adapterOptions });
          const shortUrl = parsedResult?.shortUrl || (typeof parsedResult === 'string' ? parsedResult : '');
          if (!shortUrl) {
            throw new Error('No short URL returned');
          }

          if (typeof copyToClipboard === 'function') {
            await copyToClipboard(shortUrl);
          }

          const successTemplate = (t('shorteners.toast.success') || 'Short link copied: {shortUrl}')
            .replace('{service}', service.name)
            .replace('{shortUrl}', shortUrl);

          return makeResult(true, 'success', successTemplate, { shortUrl });
        } catch (error) {
          debugLog('warn', '[SHORTENER] Failed to create short link', { service: service?.id, error });
          const detail = error?.message ? ` (${error.message})` : '';
          const template = t('shorteners.toast.error') || 'Could not create a short link. {message}';
          return makeResult(false, 'error', template.replace('{message}', detail).trim(), { error });
        }
      }

      return {
        getOptions,
        isServiceEnabled,
        toggleService,
        ensureAccount,
        getAccount,
        updateAccount,
        clearAccount,
        getServiceText,
        normalizeBase,
        generateSlug,
        runAdapter
      };
    })();


    MB.Security = (function() {
      function normalizeResult(result) {
        const issues = Array.isArray(result?.issues) ? result.issues : [];
        const severity = typeof result?.severity === 'number'
          ? result.severity
          : issues.reduce((max, issue) => Math.max(max, issue.severity || 0), 0);
        return { severity, issues };
      }

      function analyze(url) {
        const issues = [];
        const addIssue = (severity, code, meta = {}) => issues.push({ severity, code, meta });

        if (!url || typeof url !== 'string') {
          addIssue(3, 'malformed');
          return normalizeResult({ severity: 3, issues });
        }

        let parsed;
        try {
          parsed = new URL(url);
        } catch (error) {
          addIssue(3, 'malformed');
          return normalizeResult({ severity: 3, issues });
        }

        const protocol = parsed.protocol.toLowerCase();
        if (!/^https?:$/.test(protocol)) {
          if (LINK_DANGEROUS_PROTOCOLS.includes(protocol)) {
            addIssue(3, 'dangerProtocol', { protocol });
          } else {
            addIssue(2, 'unusualProtocol', { protocol });
          }
        }

        const hostname = parsed.hostname.toLowerCase();
        if (hostname.startsWith('xn--') || hostname.includes('---') || hostname.includes('--')) {
          addIssue(2, 'punycode', { host: hostname });
        }

        if (/^\d{1,3}(\.\d{1,3}){3}$/.test(hostname)) {
          addIssue(1, 'ipAddress', { host: hostname });
        }

        if (typeof LINK_SHORTENER_DOMAINS !== 'undefined' && LINK_SHORTENER_DOMAINS.has(hostname)) {
          addIssue(1, 'shortener', { host: hostname });
        }

        try {
          const query = new URLSearchParams(parsed.search);
          for (const key of query.keys()) {
            const lowered = key.toLowerCase();
            if (LINK_SUSPICIOUS_QUERY_KEYS.includes(lowered)) {
              addIssue(2, 'sensitiveQuery', { key: lowered });
            }
          }
        } catch (error) {
        }

        const fullUrlLower = url.toLowerCase();
        for (const pattern of LINK_SUSPICIOUS_PATTERNS) {
          if (fullUrlLower.includes(pattern)) {
            addIssue(3, 'suspiciousPattern', { pattern });
            break;
          }
        }

        return normalizeResult({ issues });
      }

      function formatIssue(issue, translator) {
        const code = issue?.code || 'generic';
        const meta = issue?.meta || {};

        const t = (key, fallback) => {
          if (typeof translator === 'function') {
            const result = translator(key);
            if (result && result !== key) return result;
          }
          return fallback;
        };

        switch (code) {
          case 'malformed':
            return t('link.security.danger.malformed', 'Malformed URL');
          case 'dangerProtocol':
            return (t('link.security.danger.protocol', 'Disallowed protocol: {protocol}') || '').replace('{protocol}', meta.protocol || '');
          case 'unusualProtocol':
            return (t('link.security.warning.protocol', 'Unusual protocol: {protocol}') || '').replace('{protocol}', meta.protocol || '');
          case 'punycode':
            return (t('link.security.warning.punycode', 'Hostname uses punycode: {host}') || '').replace('{host}', meta.host || '');
          case 'ipAddress':
            return (t('link.security.info.ip', 'Hostname is an IP address: {host}') || '').replace('{host}', meta.host || '');
          case 'shortener':
            return (t('link.security.info.shortener', 'URL uses a shortener service: {host}') || '').replace('{host}', meta.host || '');
          case 'sensitiveQuery':
            return (t('link.security.warning.query', 'Sensitive parameter detected: {key}') || '').replace('{key}', meta.key || '');
          case 'suspiciousPattern':
            return t('link.security.danger.suspicious', 'Suspicious pattern detected in URL');
          default:
            return t('link.security.warning.generic', 'Potential issue detected');
        }
      }

      function badgeClass(data, opts = {}) {
        const severity = data?.severity ?? 0;
        const classes = [];
        if (opts.asPill) classes.push('rounded-pill');
        if (severity >= 3) classes.push('bg-danger');
        else if (severity === 2) classes.push('bg-warning', 'text-dark');
        else if (severity === 1) classes.push('bg-info', 'text-dark');
        else classes.push('bg-success');
        return classes.join(' ');
      }

      function summaryText(data, translator) {
        const result = normalizeResult(data);
        if (!result?.issues || result.issues.length === 0 || result.severity === 0) {
          return typeof translator === 'function'
            ? translator('link.security.safe') || 'No issues detected.'
            : 'No issues detected.';
        }
        const sorted = [...result.issues].sort((a, b) => (b.severity || 0) - (a.severity || 0));
        return formatIssue(sorted[0], translator);
      }

      return {
        analyze,
        formatIssue,
        badgeClass,
        summaryText,
        normalizeResult,
      };
    })();


        let linksDb = null;
    let sharing = null;

    

    // Small debounce helper
    function debounce(fn, wait) {
      let t = null;
      function debounced(...args) {
        const ctx = this;
        if (t) clearTimeout(t);
        t = setTimeout(() => fn.apply(ctx, args), wait);
      }
      debounced.cancel = () => { if (t) { clearTimeout(t); t = null; } };
      return debounced;
    }

    // Custom directive for focusing elements
    Vue.directive('focus', {
      inserted: function (el, binding) {
        if (binding.value) {
          el.focus();
        }
      },
      update: function (el, binding) {
        if (binding.value && binding.oldValue !== binding.value) {
          // Need $nextTick to ensure the element is visible/rendered before focusing
          Vue.nextTick(() => {
            el.focus();
          });
        }
      }
    });


    // Main Vue instance
    let app = new Vue({
      el: '#app',
      directives: {
        focus: {
          inserted: function(el, binding) {
            // Store element reference for later use
            el._focusHandler = () => {
              const focusElement = () => {
                el.focus();
                el.select();
                // Keep trying if focus was stolen
                if (document.activeElement !== el) {
                  setTimeout(() => {
                    el.focus();
                    el.select();
                  }, 100);
                }
              };
              
              // Try multiple times to ensure focus stays
              setTimeout(focusElement, CONSTS.FOCUS_DELAY_SHORT_MS);
              setTimeout(focusElement, CONSTS.FOCUS_DELAY_MEDIUM_MS);
              setTimeout(focusElement, CONSTS.FOCUS_DELAY_LONG_MS);
            };
            
            // Focus on initial insert if value is true
            if (binding.value) {
              el._focusHandler();
            }
          },
          update: function(el, binding) {
            // When value changes from false/null to true, focus the element
            if (binding.value && !binding.oldValue) {
              if (el._focusHandler) {
                el._focusHandler();
              }
            }
          },
          unbind: function(el) {
            // Clean up
            delete el._focusHandler;
          }
        }
      },
      data: {
        title: 'My Bookmarks', // Will be updated from options
        filterText: '',
        data: JSON.parse(JSON.stringify(initialData)), // Deep clone initial data
        dataId: -1, // ID for the IndexedDB record
        isDarkMode: false, // Dark mode state
        // Sync progress UI
        syncInProgress: false,
        syncProgress: 0,
        syncProgressText: '' ,
        storageUsed: 0, // Current storage usage in bytes
        customColors: {
          background: '#fafbfc',
          toolbar: '#ffffff',
          titleBar: '#f8f9fa',
          titleText: '#1a1a1a',
          keywordContainer: '#f0f0f0'
        },
        // UI State
        contextMenuTarget: null, // { type: 'link'/'group', item: object }
        isLinkMenuVisible: false,
        // Conflict Resolution UI
        showConflictNotification: false,
        conflictNotificationText: '',
        conflictNotificationTimeout: null,
        // Visual CSS Editor
        cssSidebarVisible: false,
        visualCssRules: [],
        visualCssAvailableSelectors: [],
        showMigrationNotice: false,
        customCssDraft: '', // Keep for computed properties compatibility
        cssSidebarWidth: 400,
        isCssSidebarWidthResizing: false,
        selectedVisualTemplate: null,
        editingRuleId: null,
        editingRuleName: '',
        collapsedRules: [],
        designTokensCollapsed: false,
        // Feature Overview Sidebar
        featureSidebarVisible: false,
        helpLanguageTab: 'de', // Default to German
        selectedColor: '#000000',
        // Browser Extension
        extensionAvailable: false,
        extensionVersion: null,
        autoFetchTimeout: null, // Timeout for debounced auto-fetch
        // CSS Templates
        cssTemplates: [],
        selectedTemplateId: null,
        showSaveTemplateDialog: false,
        newTemplateName: '',
        // Custom Rule Sets
        customRuleSets: {},
        selectedRuleSetName: null,
        showSaveRuleSetDialog: false,
        linkShortenerServices: LINK_SHORTENER_SERVICES,

        // Visual CSS Rules search
        rulesFilterQuery: '',
        newRuleSetName: '',
        // Toast Notifications
        toastMessage: '',
        toastType: 'success', // success, error, info
        toastVisible: false,
        // CSS Sidebar resize
        isCssSidebarResizing: false,
        cssSidebarTopHeight: 300, // Default height in pixels
        cssSidebarStartY: 0,
        cssSidebarStartHeight: 0,
        // CSS Sidebar width resize
        isCssSidebarWidthResizing: false,
        cssSidebarWidth: 400, // Default width in pixels
        cssSidebarStartX: 0,
        cssSidebarStartWidth: 0,
        // Element Picker & Pseudo States
        elementPickerActive: false,
        currentPickerRule: null,
        lastHighlightedEl: null,
        lastHighlightedOutline: null,
        // Design Tokens
        designTokens: [],
        // CSS Presets
        cssPresets: [
          { id: 'card-shadow', name: 'Card Shadow', properties: {
            'box-shadow': '0 2px 8px rgba(0,0,0,0.12)',
            'border-radius': '12px',
            'background-color': '#ffffff'
          }},
          { id: 'subtle-border', name: 'Subtle Border', properties: {
            'border': '1px solid rgba(0,0,0,0.08)',
            'border-radius': '8px',
            'background-color': '#ffffff'
          }},
          { id: 'button-primary', name: 'Button Primary', properties: {
            'background-color': '#0d6efd',
            'color': '#ffffff',
            'border': '1px solid #0d6efd',
            'padding': '0.375rem 0.75rem',
            'border-radius': '0.375rem'
          }}
        ],
        cssHookClasses: [
          'body',
          '#app.container-fluid.mb-app',
          '.mb-titlebar',
          '.mb-titlebar h1',
          '.mb-toolbar',
          '.btn-toolbar',
          '.mb-tools',
          '.mb-toolbar__search',
          '.mb-toolbar__search .input-group-text',
          '.mb-toolbar__storage',
          '.mb-footer',
          '.groupContainer',
          '.mb-group',
          '.groupContainerHeader',
          '.mb-group__header',
          '.groupTitle',
          '.mb-group__title',
          '.groupLinkCount',
          '.mb-linkcount-badge',
          '.mb-group__badges',
          '.group-info-section',
          '.mb-group-info-section',
          '.mb-group-info-header',
          '.mb-group-info-label',
          '.mb-group-info-content',
          '.linkContainer',
          '.mb-link',
          '.mb-links',
          '.linkText',
          '.linkText a',
          '.mb-link__anchor',
          '.linkTextCategory',
          '.mb-link__badges',
          '.badge',
          '.keyword-badge',
          '.mb-keyword',
          '.mb-group__keyword-badge',
          '.mb-link__keyword-badge',
          '.mb-keywords-cloud',
          '.mb-keyword-label',
          '.keyword-container',
          '.mb-keyword-bar',
          '.btn',
          '.mb-btn',
          '.btn-primary',
          '.btn-success',
          '.btn-danger',
          '.btn-secondary',
          '.btn-outline-secondary',
          '.form-control',
          '.form-select',
          '.modal',
          '.mb-modal',
          '.modal-content',
          '.modal-header',
          '.modal-body',
          '.modal-footer',
          '.mb-context-menu',
          '.mb-css-sidebar',
          '.mb-css-sidebar-header',
          '.mb-css-sidebar-title',
          '.mb-css-sidebar-close',
          '.mb-css-sidebar-container',
          '.mb-css-sidebar-help',
          '.mb-css-sidebar-help-content',
          '.mb-css-help-hint',
          '.mb-css-help-code',
          '.mb-css-sidebar-divider',
          '.mb-css-sidebar-editor-section',
          '.mb-css-editor',
          '.mb-css-editor-wrapper',
          '.mb-css-editor-toolbar',
          '.mb-css-editor-title',
          '.mb-css-editor-buttons',
          '.mb-css-editor-textarea',
          '.mb-css-highlighted-container',
          '.mb-css-highlighted-pre',
          '.mb-css-highlighted-code',
          '.mb-css-save-btn',
          '.mb-css-cancel-btn',
          '.mb-css-reset-btn',
          '.mb-css-colorpicker-btn',
          '.mb-css-template-select',
          '.mb-css-template-buttons',
          '.mb-css-hook-insert-btn',
          '.mb-css-hook-selector',
          '.css-sidebar-resize-handle',
          '.sidebar-split-container',
          '.sidebar-top-section',
          '.sidebar-bottom-section',
          '.sidebar-divider',
          '.editor-header',
          '.editor-content',
          '.sidebar-content',
          '.mb-feature-sidebar',
          '.mb-feature-sidebar-header',
          '.mb-feature-sidebar-title',
          '.mb-feature-sidebar-close',
          '.mb-feature-sidebar-content',
          '.feature-sidebar',
          '.feature-section',
          '.feature-card',
          '.context-menu',
          '.context-menu-visible',
          '.context-menu ul',
          '.context-menu ul li',
          '.context-menu .separator',
          '.context-menu .submenu',
          '.context-menu .submenu::after',
          '.context-submenu',
          '.context-submenu li',
          '.mb-context-menu',
          '.mb-context-menu-visible',
          '.mb-context-menu ul',
          '.mb-context-menu ul li',
          '.mb-context-menu-separator',
          '.mb-context-submenu',
          '.mb-context-submenu-item',
          '.mb-context-submenu::after',
          '.mb-group-menu-btn',
          '.mb-link-menu-btn',
          '.mb-snapshots-dropdown',
          '.mb-snapshots-btn',
          '.mb-snapshots-menu',
          '.mb-edit-modal-title',
          '.mb-edit-modal-body',
          '.mb-edit-modal-footer',
          '.mb-edit-form',
          '.mb-edit-filter-container',
          '.mb-edit-filter-group',
          '.mb-edit-filter-input',
          '.mb-edit-section',
          '.mb-edit-section-header',
          '.mb-edit-section-body',
          '.mb-edit-field-row',
          '.mb-edit-field-label',
          '.mb-edit-field-help',
          '.mb-edit-text-input',
          '.mb-edit-url-input',
          '.mb-edit-number-input',
          '.mb-edit-checkbox',
          '.mb-edit-select',
          '.mb-edit-save-btn',
          '.mb-edit-cancel-btn',
          '.mb-edit-reset-btn',
          '.mb-toast',
          '.mb-toast-success',
          '.mb-toast-error',
          '.mb-toast-warning',
          '.mb-toast-info',
          '.mb-toast-content',
          '.mb-toast-title',
          '.mb-toast-body',
          '.mb-toast-close',
          '.mb-toast-progress',
          '.mb-toast-progress-fill',
          '.group-uuid-<uuid>',
          '.link-uuid-<uuid>'
        ],
        // Sync All state
        syncAllCooldown: 0,
        isSyncingAll: false,
        lastSyncAllTime: 0,
        isGroupMenuVisible: false,
        contextMenuStyle: { top: '0px', left: '0px' },
        editLink: null, // Link being edited in modal
        editLinkOriginalValues: null, // Original values before editing (for event-log)
        linkModalVisible: false, // Track when link edit modal is visible
        // Metadata fetch UI state (for edit/add dialog)
        titleFetchState: 'idle', // idle|loading|ok|fail
        faviconFetchState: 'idle', // idle|loading|ok|fail
        metadataMessage: '',
        editGroup: null, // Group being edited in modal
        editGroupEnableStyling: true, // UI switch for per-group styling
        qrCodeUrl: '',
        bookmarkletHref: '',
        // Duplicates dialog
        duplicatesFound: {},
        showDuplicatesDialog: false,
        pasteContent: '',
        pasteHint: '',
        parsedLinks: null,
        detectedFormat: '',
        importGroupTitle: '',
        isFullExport: false,
        fullExportData: null,
        importUrl: '',
        fetchingUrl: false,
        urlFetchError: '',
        fetchingBrowserBookmarks: false,
        browserBookmarksInfo: '',
        importCollapsedGroups: {}, // Track which groups are collapsed in import preview
        exportSelection: [],
        exportFormat: 'json',
        
        prevIdentityName: '',
        // NC Folder Picker state
        ncFolders: [],
        ncFoldersLoading: false,
        ncFolderSelected: 0,
        // Drag & Drop
        dropManager: null, // Will be initialized in mounted()
        dragState: null, // Reactive state for drag & drop
        expandHoverTimers: {}, // timers for auto-expanding collapsed groups while dragging links

        // Saved searches
        savedSearches: [],
        
        // Info popup
        infoPopupContent: '',
        infoPopupTimer: null,
        linkPopover: {
          visible: false,
          link: null,
          style: { top: '0px', left: '0px' },
          titleHtml: '',
          displayUrl: '',
          url: '',
          rawUrlInput: '',
          favicon: '',
          keywords: [],
          emoji: '',
          uuid: '',
          createdAt: { full: '—', relative: '', raw: null },
          updatedAt: { full: '—', relative: '', raw: null }
        },
        linkPopoverHideTimer: null,
        selectedSavedSearch: '',
        
        // JSON Inspector
        inspectedGroup: null,
        inspectedGroupJSON: '',

        // History (Undo/Redo)
        appInitialized: false,
        historyPast: [],
        historyFuture: [],
        historyLock: false,
        lastSavedJson: '',
        carddavTimer: null,

        // Quick-Connect dialog state
        qcDialog: { visible: false, mode: 'receive', code: '', status: [], progress: 'idle' },
        contactsDialog: { visible: false, tab: 'contacts' },
        shareDialog: { visible: false, mode: 'link', payload: null, selectedContacts: {} },
        // Contact online status tracking
        contactOnlineStatus: {}, // { contactUuid: { online: boolean, lastCheck: timestamp } }
        pendingPings: {}, // { pingId: { resolve: function, reject: function, timeout: timeoutId } }
        // Removed from group notification
        removedGroupInfo: {
          groupName: '',
          ownerName: '',
          removedAt: null,
          groupId: null
        },
        // Invitation dialog for immediate acceptance/rejection
        invitationDialog: { 
          visible: false, 
          type: '', // 'group' or 'link'
          env: null, 
          groupName: '', 
          linkCount: 0,
          fromName: '',
          preview: [] // Preview of links to be added
        },
        processedMsgIds: new Set(),

        // --- Generic Edit Dialog Data ---
        genericEditConfig: {
          title: '',
          type: '', // 'options', 'group', or 'link'
          design: {}, // The design structure
          saveCallback: null
        },
        genericEditData: null, // The data being edited
        genericFilterText: '', // Filter text for generic dialog
        genericExpandedSections: {}, // Track which sections are expanded
        // Legacy properties for old dialogs - kept for compatibility
        expandedLinkSections: {},
        expandedGroupSections: {},
        expandedSections: {},
        settingsFilterText: '',
        optionsDesign: { // Struktur für generischen Dialog
          common: {
            translateKey: 'options.common',
            fields: {
              language: { id: 'CommonLanguage', type: 'select', translateKey: 'options.common.language', values: { 'en': 'options.common.language.english', 'de': 'options.common.language.german' }, optionPath: 'common.language', helpText: 'options.common.language.help' },
              pageTitle: { id: 'CommonPageTitle', type: 'text', translateKey: 'options.common.pageTitle', optionPath: 'common.pageTitle', helpText: 'options.common.pageTitle.help' },
              
              searchAsYouType: { id: 'SearchAsYouType', type: 'checkbox', translateKey: 'options.common.searchAsYouType', optionPath: 'common.searchAsYouType', helpText: 'options.common.searchAsYouType.help' },
              confirmDeleteGroup: { id: 'CommonConfirmDeleteGroup', type: 'checkbox', translateKey: 'options.common.confirmDeleteGroup', optionPath: 'common.confirmDeleteGroup', helpText: 'options.common.confirmDeleteGroup.help' },
              confirmDeleteLink: { id: 'CommonConfirmDeleteLink', type: 'checkbox', translateKey: 'options.common.confirmDeleteLink', optionPath: 'common.confirmDeleteLink', helpText: 'options.common.confirmDeleteLink.help' }
            }
          },
          groups: {
            translateKey: 'options.groups',
            fields: {
              collapseGroupsOnStart: {
                id: 'GroupsCollapseGroupsOnStart',
                type: 'checkbox',
                translateKey: 'options.groups.collapseGroupsOnStart',
                optionPath: 'groups.collapseGroupsOnStart',
                helpText: 'options.groups.collapseGroupsOnStart.help'
              },
              hoverExpandEnabled: {
                id: 'GroupsHoverExpandEnabled',
                type: 'checkbox',
                translateKey: 'options.groups.hoverExpandEnabled',
                optionPath: 'groups.hoverExpandEnabled',
                helpText: 'options.groups.hoverExpandEnabled.help'
              },
              hoverExpandDelay: {
                id: 'GroupsHoverExpandDelay',
                type: 'number',
                translateKey: 'options.groups.hoverExpandDelay',
                optionPath: 'groups.hoverExpandDelayMs',
                helpText: 'options.groups.hoverExpandDelay.help'
              },
              clearClosesAllGroups: {
                id: 'GroupsClearClosesAll',
                type: 'checkbox',
                translateKey: 'options.groups.clearClosesAllGroups',
                optionPath: 'groups.clearClosesAllGroups',
                helpText: 'options.groups.clearClosesAllGroups.help'
              },
              keywordClickExpandsAll: {
                id: 'GroupsKeywordClickExpandsAll',
                type: 'checkbox',
                translateKey: 'options.groups.keywordClickExpandsAll',
                optionPath: 'groups.keywordClickExpandsAll',
                helpText: 'options.groups.keywordClickExpandsAll.help'
              },
              searchAutoExpandFound: {
                id: 'GroupsSearchAutoExpandFound',
                type: 'checkbox',
                translateKey: 'options.groups.searchAutoExpandFound',
                optionPath: 'groups.searchAutoExpandFound',
                helpText: 'options.groups.searchAutoExpandFound.help'
              }
            }
          },
          links: {
            translateKey: 'options.links',
            fields: {
              openInNewTab: {
              id: 'LinksOpenInNewTab',
              type: 'checkbox',
              translateKey: 'options.links.openInNewTab',
              optionPath: 'links.openInNewTab',
              helpText: 'options.links.openInNewTab.help'
              },
              progressiveLoadingThreshold: {
              id: 'LinksProgressiveLoadingThreshold',
              type: 'number',
              translateKey: 'options.links.progressiveLoadingThreshold',
              optionPath: 'links.progressiveLoadingThreshold',
              helpText: 'options.links.progressiveLoadingThreshold.help',
              defaultValue: 100
              },
              addViaDialog: {
              id: 'LinksAddViaDialog',
              type: 'checkbox',
              translateKey: 'options.links.addViaDialog',
              optionPath: 'links.addViaDialog',
              helpText: 'options.links.addViaDialog.help'
              },
              defaultUrlPrefix: {
              id: 'LinksDefaultUrlPrefix',
              type: 'text',
              translateKey: 'options.links.defaultUrlPrefix',
              optionPath: 'links.defaultUrlPrefix',
              helpText: 'options.links.defaultUrlPrefix.help',
              placeholder: 'https://'
              },
              autoFetchTitle: {
              id: 'LinksAutoFetchTitle',
              type: 'checkbox',
              translateKey: 'options.links.autoFetchTitle',
              optionPath: 'links.autoFetchTitle',
              helpText: 'options.links.autoFetchTitle.help'
              },
              autoFetchFavicon: {
              id: 'LinksAutoFetchFavicon',
              type: 'checkbox',
              translateKey: 'options.links.autoFetchFavicon',
              optionPath: 'links.autoFetchFavicon',
              helpText: 'options.links.autoFetchFavicon.help'
              },
              showLinkBadges: {
              id: 'LinksShowLinkBadges',
              type: 'checkbox',
              translateKey: 'options.links.showLinkBadges',
              optionPath: 'links.showLinkBadges',
              helpText: 'options.links.showLinkBadges.help'
              },
              showLinkPopover: {
              id: 'LinksShowLinkPopover',
              type: 'checkbox',
              translateKey: 'options.links.showLinkPopover',
              optionPath: 'links.showLinkPopover',
              helpText: 'options.links.showLinkPopover.help',
              defaultValue: true
              },
              copyUrlFormat: {
                id: 'LinksCopyUrlFormat',
                type: 'text',
                translateKey: 'options.links.copyUrlFormat',
                optionPath: 'links.copyUrlFormat',
                helpText: 'options.links.copyUrlFormat.help',
                defaultValue: '{title}: {url}',
                placeholder: '{title}: {url}'
              },
              
            }
          },
          linkShorteners: {
            translateKey: 'options.linkShorteners.title',
            fields: {
              services: {
                id: 'LinkShortenersServices',
                type: 'linkShorteners',
                translateKey: 'options.linkShorteners.services',
                optionPath: 'linkShorteners',
                helpText: 'options.linkShorteners.services.help'
              }
            }
          },
          proxy: {
            translateKey: 'options.proxy.title',
            fields: {
              enabled: {
                id: 'ProxyEnabled',
                type: 'checkbox',
                translateKey: 'options.proxy.enabled',
                optionPath: 'proxy.enabled',
                helpText: 'options.proxy.enabled.help'
              },
              baseUrl: {
                id: 'ProxyBaseUrl',
                type: 'text',
                translateKey: 'options.proxy.baseUrl',
                optionPath: 'proxy.baseUrl',
                helpText: 'options.proxy.baseUrl.help',
                placeholder: 'https://proxy.example.com'
              },
              apiKey: {
                id: 'ProxyApiKey',
                type: 'text',
                translateKey: 'options.proxy.apiKey',
                optionPath: 'proxy.apiKey',
                helpText: 'options.proxy.apiKey.help',
                placeholder: 'Optional API token'
              },
              extraHeaders: {
                id: 'ProxyExtraHeaders',
                type: 'textarea',
                translateKey: 'options.proxy.extraHeaders',
                optionPath: 'proxy.extraHeaders',
                helpText: 'options.proxy.extraHeaders.help',
                rows: 3,
                placeholder: 'Header-Name: Wert'
              }
            }
          },
          buttons: {
            translateKey: 'options.buttons',
            fields: {
              showAddLink: {
                id: 'ButtonsShowAddLink',
                type: 'checkbox',
                translateKey: 'options.buttons.showAddLink',
                optionPath: 'buttons.showAddLink',
                helpText: 'options.buttons.showAddLink.help',
                defaultValue: true
              },
              showDeleteGroup: {
                id: 'ButtonsShowDeleteGroup',
                type: 'checkbox',
                translateKey: 'options.buttons.showDeleteGroup',
                optionPath: 'buttons.showDeleteGroup',
                helpText: 'options.buttons.showDeleteGroup.help',
                defaultValue: true
              },
              showCopyUrl: {
                id: 'ButtonsShowCopyUrl',
                type: 'checkbox',
                translateKey: 'options.buttons.showCopyUrl',
                optionPath: 'buttons.showCopyUrl',
                helpText: 'options.buttons.showCopyUrl.help',
                defaultValue: true
              },
              showQrCode: {
                id: 'ButtonsShowQrCode',
                type: 'checkbox',
                translateKey: 'options.buttons.showQrCode',
                optionPath: 'buttons.showQrCode',
                helpText: 'options.buttons.showQrCode.help',
                defaultValue: true
              },
              showDeleteLink: {
                id: 'ButtonsShowDeleteLink',
                type: 'checkbox',
                translateKey: 'options.buttons.showDeleteLink',
                optionPath: 'buttons.showDeleteLink',
                helpText: 'options.buttons.showDeleteLink.help',
                defaultValue: true
              }
            }
          },
          sharing: {
            translateKey: 'options.sharing',
            fields: {
              // Move display name here to show above ntfy server URL
              identityName: { id: 'CommonIdentityName', type: 'text', translateKey: 'options.common.identityName', optionPath: 'common.identityName', helpText: 'options.common.identityName.help' },
              ntfyServerUrl: { id: 'SharingNtfyServer', type: 'text', translateKey: 'options.sharing.ntfyServerUrl', optionPath: 'sharing.ntfyServerUrl', helpText: 'options.sharing.ntfyServerUrl.help' },
              ntfyAuthToken: { id: 'SharingNtfyToken', type: 'text', translateKey: 'options.sharing.ntfyAuthToken', optionPath: 'sharing.ntfyAuthToken', helpText: 'options.sharing.ntfyAuthToken.help' },
              defaultTtl: { id: 'SharingDefaultTtl', type: 'number', translateKey: 'options.sharing.defaultTtl', optionPath: 'sharing.defaultTtl', helpText: 'options.sharing.defaultTtl.help' },
              quickCodeTtlSec: { id: 'SharingQuickCodeTtl', type: 'number', translateKey: 'options.sharing.quickCodeTtl', optionPath: 'sharing.quickCodeTtlSec', helpText: 'options.sharing.quickCodeTtl.help' },
              contactOnlineTimeoutSeconds: { id: 'SharingContactOnlineTimeout', type: 'number', translateKey: 'options.sharing.contactOnlineTimeout', optionPath: 'sharing.contactOnlineTimeoutSeconds', helpText: 'options.sharing.contactOnlineTimeout.help' }
            }
          },
          sync: {
            translateKey: 'options.sync',
            fields: {
              // Settings for all users (Owner & Member)
              conflictNotificationLevel: { 
                id: 'SyncConflictNotifications', 
                type: 'select', 
                translateKey: 'options.sync.conflictNotificationLevel', 
                optionPath: 'sync.conflictNotificationLevel',
                helpText: 'options.sync.conflictNotificationLevel.help',
                roleScope: 'all', // For everyone
                values: {
                  'silent': 'options.sync.conflictNotificationLevel.silent',
                  'minimal': 'options.sync.conflictNotificationLevel.minimal',
                  'verbose': 'options.sync.conflictNotificationLevel.verbose'
                }
              },
              autoSyncInterval: {
                id: 'SyncAutoInterval',
                type: 'select',
                translateKey: 'options.sync.autoSyncInterval',
                optionPath: 'sync.autoSyncInterval',
                helpText: 'options.sync.autoSyncInterval.help',
                roleScope: 'all',
                values: {
                  '300': 'options.sync.autoSyncInterval.5min',
                  '600': 'options.sync.autoSyncInterval.10min',
                  '1800': 'options.sync.autoSyncInterval.30min',
                  '3600': 'options.sync.autoSyncInterval.1hour',
                  '0': 'options.sync.autoSyncInterval.manual'
                }
              },
              offlineMode: {
                id: 'SyncOfflineMode',
                type: 'select',
                translateKey: 'options.sync.offlineMode',
                optionPath: 'sync.offlineMode',
                helpText: 'options.sync.offlineMode.help',
                roleScope: 'all',
                values: {
                  'optimistic': 'options.sync.offlineMode.optimistic',
                  'conservative': 'options.sync.offlineMode.conservative'
                }
              },
              // Settings only for Owners
              conflictResolution: {
                id: 'SyncConflictResolution',
                type: 'select',
                translateKey: 'options.sync.conflictResolution',
                optionPath: 'sync.conflictResolution',
                helpText: 'options.sync.conflictResolution.help',
                roleScope: 'owner', // Only for group owners
                values: {
                  'owner-wins': 'options.sync.conflictResolution.ownerWins',
                  'last-write-wins': 'options.sync.conflictResolution.lastWriteWins',
                  'manual': 'options.sync.conflictResolution.manual'
                }
              },
              memberRateLimit: {
                id: 'SyncMemberRateLimit',
                type: 'number',
                translateKey: 'options.sync.memberRateLimit',
                optionPath: 'sync.memberRateLimit',
                helpText: 'options.sync.memberRateLimit.help',
                roleScope: 'owner',
                min: 0,
                max: 100,
                suffix: 'options.sync.memberRateLimit.suffix'
              },
              validationLevel: {
                id: 'SyncValidationLevel',
                type: 'select',
                translateKey: 'options.sync.validationLevel',
                optionPath: 'sync.validationLevel',
                helpText: 'options.sync.validationLevel.help',
                roleScope: 'owner',
                values: {
                  'strict': 'options.sync.validationLevel.strict',
                  'moderate': 'options.sync.validationLevel.moderate',
                  'permissive': 'options.sync.validationLevel.permissive'
                }
              },
              // Settings only for Members
              localCacheStrategy: {
                id: 'SyncLocalCache',
                type: 'select',
                translateKey: 'options.sync.localCacheStrategy',
                optionPath: 'sync.localCacheStrategy',
                helpText: 'options.sync.localCacheStrategy.help',
                roleScope: 'member', // Only for members
                values: {
                  'full': 'options.sync.localCacheStrategy.full',
                  'minimal': 'options.sync.localCacheStrategy.minimal'
                }
              },
              errorHandling: {
                id: 'SyncErrorHandling',
                type: 'select',
                translateKey: 'options.sync.errorHandling',
                optionPath: 'sync.errorHandling',
                helpText: 'options.sync.errorHandling.help',
                roleScope: 'member',
                values: {
                  'retry': 'options.sync.errorHandling.retry',
                  'queue': 'options.sync.errorHandling.queue',
                  'discard': 'options.sync.errorHandling.discard'
                }
              }
            }
          },
          syncEngine: {
            translateKey: 'options.sync.engine',
            fields: {
              backend: {
                id: 'SyncBackend', type: 'select', translateKey: 'options.sync.backend', optionPath: 'sync.backend', helpText: 'options.sync.backend.help',
                values: { 'carddav': 'options.sync.backend.carddav', 'nc-bookmarks': 'options.sync.backend.nc' }
              }
            }
          },
          bookmarks: {
            translateKey: 'bookmarks.title',
            fields: {
              serverUrl: { id: 'BkServerUrl', type: 'text', translateKey: 'bookmarks.serverUrl', optionPath: 'bookmarks.serverUrl', helpText: 'bookmarks.serverUrl.help' },
              username:  { id: 'BkUsername',  type: 'text', translateKey: 'bookmarks.username',  optionPath: 'bookmarks.username',  helpText: 'bookmarks.username.help' },
              password:  { id: 'BkPassword',  type: 'text', translateKey: 'bookmarks.password',  optionPath: 'bookmarks.password',  helpText: 'bookmarks.password.help' },
              rootFolderId: { id: 'BkRootFolder', type: 'select', translateKey: 'bookmarks.rootFolderId', optionPath: 'bookmarks.rootFolderId', helpText: 'bookmarks.rootFolderId.help', values: { '0': 'All folders' } },
              autoCreateFolders: { id: 'BkAutoCreate', type: 'checkbox', translateKey: 'bookmarks.autoCreate', optionPath: 'bookmarks.autoCreateFolders', helpText: 'bookmarks.autoCreate.help' },
              autoRenameFolders: { id: 'BkAutoRename', type: 'checkbox', translateKey: 'bookmarks.autoRename', optionPath: 'bookmarks.autoRenameFolders', helpText: 'bookmarks.autoRename.help' },
              syncIntervalSec: { id: 'BkSyncInterval', type: 'select', translateKey: 'carddav.syncInterval', optionPath: 'bookmarks.syncIntervalSec', helpText: 'carddav.syncInterval.help', values: { '0':'carddav.syncInterval.manual','300':'carddav.syncInterval.5min','600':'carddav.syncInterval.10min','1800':'carddav.syncInterval.30min','3600':'carddav.syncInterval.1hour' } },
              // Actions at the end of the section: Test + Reset in one row
              actionsRow: { type: 'actions', actions: [
                { key: 'testConnection', translateKey: 'carddav.testConnection', buttonClass: 'btn-outline-primary' },
                { key: 'resetBindings', translateKey: 'sync.resetBindings', buttonLabel: 'sync.resetBindings', buttonClass: 'btn-outline-danger' }
              ]}
            }
          },
          carddav: {
            translateKey: 'carddav.title',
            fields: {
              serverUrl: { id: 'CardDAVServerUrl', type: 'text', translateKey: 'carddav.serverUrl', optionPath: 'carddav.serverUrl', helpText: 'carddav.serverUrl.help' },
              username: { id: 'CardDAVUsername', type: 'text', translateKey: 'carddav.username', optionPath: 'carddav.username', helpText: 'carddav.username.help' },
              password: { id: 'CardDAVPassword', type: 'text', translateKey: 'carddav.password', optionPath: 'carddav.password', helpText: 'carddav.password.help' },
              addressbookPath: { id: 'CardDAVAddressbookPath', type: 'text', translateKey: 'carddav.addressbookPath', optionPath: 'carddav.addressbookPath', helpText: 'carddav.addressbookPath.help' },
              createAddressbookIfMissing: { id: 'CardDAVCreateAB', type: 'checkbox', translateKey: 'carddav.createAddressbookIfMissing', optionPath: 'carddav.createAddressbookIfMissing', helpText: 'carddav.createAddressbookIfMissing.help' },
              syncIntervalSec: {
                id: 'CardDAVSyncInterval', type: 'select', translateKey: 'carddav.syncInterval', optionPath: 'carddav.syncIntervalSec', helpText: 'carddav.syncInterval.help',
                values: { '0': 'carddav.syncInterval.manual', '300': 'carddav.syncInterval.5min', '600': 'carddav.syncInterval.10min', '1800': 'carddav.syncInterval.30min', '3600': 'carddav.syncInterval.1hour' }
              }
            }
          },
          eventlog: {
            translateKey: 'options.eventlog.title',
            fields: {
              snapshotInterval: {
                id: 'eventLogSnapshotInterval',
                type: 'number',
                translateKey: 'options.eventlog.snapshotInterval',
                optionPath: 'eventlog.snapshotInterval',
                helpText: 'options.eventlog.snapshotInterval.help',
                min: 10,
                max: 1000,
                suffix: 'Events'
              },
              maxEvents: {
                id: 'eventLogMaxEvents',
                type: 'number',
                translateKey: 'options.eventlog.maxEvents',
                optionPath: 'eventlog.maxEvents',
                helpText: 'options.eventlog.maxEvents.help',
                min: 100,
                max: 10000,
                suffix: 'Events'
              },
              syncStrategy: {
                id: 'syncStrategy',
                type: 'select',
                translateKey: 'options.eventlog.syncStrategy',
                optionPath: 'eventlog.syncStrategy',
                helpText: 'options.eventlog.syncStrategy.help',
                values: {
                  'owner-leads': 'options.eventlog.syncStrategy.ownerLeads',
                  'all-equal': 'options.eventlog.syncStrategy.allEqual',
                  'smart-merge': 'options.eventlog.syncStrategy.smartMerge'
                }
              }
            }
          }
        },
        // Group Edit Dialog Configuration
        groupEditDesign: {
          basic: {
            translateKey: 'group.basic',
            fields: {
              name: {
                type: 'text',
                translateKey: 'group.name',
                placeholder: 'Enter group name',
                helpText: 'group.name.help'
              },
              emoji: {
                type: 'emoji',
                translateKey: 'group.emoji',
                placeholder: 'group.emoji.placeholder',
                helpText: 'group.emoji.help'
              },
              keywords: {
                type: 'text',
                translateKey: 'group.keywords',
                placeholder: 'e.g. work, personal, docs',
                helpText: 'group.keywords.help'
              }
            }
          },
          advanced: {
            translateKey: 'group.advanced',
            fields: {
              infoHtml: {
                type: 'textarea',
                translateKey: 'group.infoHtml',
                placeholder: 'group.infoHtml.placeholder',
                helpText: 'group.infoHtml.help',
                rows: 4
              }
            }
          }
        },
        // Link Edit Dialog Configuration
        linkEditDesign: {
          basic: {
            translateKey: 'link.basic',
            fields: {
              text: {
                type: 'text',
                translateKey: 'link.text',
                placeholder: 'Enter link text',
                helpText: 'link.text.help'
              },
              url: {
                type: 'url',
                translateKey: 'link.url',
                placeholder: 'https://example.com',
                helpText: 'link.url.info',
                validation: 'url',
                autofocus: true
              },
              emoji: {
                type: 'emoji',
                translateKey: 'link.emoji',
                placeholder: 'link.emoji.placeholder',
                helpText: 'link.emoji.help'
              },
              keywords: {
                type: 'text',
                translateKey: 'link.keywords',
                placeholder: 'e.g. work, personal, docs',
                helpText: 'link.keywords.help'
              }
            }
          },
          advanced: {
            translateKey: 'link.advanced',
            fields: {
              infoHtml: {
                type: 'textarea',
                translateKey: 'link.infoHtml',
                placeholder: 'link.infoHtml.placeholder',
                helpText: 'link.infoHtml.help',
                rows: 4
              }
            }
          }
        },
        // Favicon Rules working state (Options modal)
        faviconRulesWorking: [],
        faviconRulesTestUrl: '',
      },
      watch: {
        // Focus template name input when dialog opens
        showSaveTemplateDialog(newVal) {
          if (newVal) {
            this.$nextTick(() => {
              if (this.$refs.templateNameInput) {
                this.$refs.templateNameInput.focus();
              }
            });
          }
        },
        // When editing/adding a link, try to auto-fetch metadata after URL changes
        'editLink.url'(newVal, oldVal) {
          if (!this.editLink) return;
          if (!this.data.options?.links) return;
          if (!(this.data.options.links.autoFetchTitle || this.data.options.links.autoFetchFavicon)) return;
          // Only run when user actually changes the field, not on initial dialog open/programmatic set
          if (this._suppressMeta) return;
          if (typeof oldVal === 'undefined') return;
          const a = (newVal || '').trim();
          const b = (oldVal || '').trim();
          if (a === b || !a) return;
          if (!this._debouncedMeta) this._debouncedMeta = debounce(() => this.fetchMetadataForEditLink(false), 500).bind(this);
          this._debouncedMeta();
        },
        filterText(newVal, oldVal) {
          if (!this.data?.options?.groups?.searchAutoExpandFound) return;
          // Save collapsed state once when starting a search
          if (newVal && !oldVal && !this._savedCollapsedStates) {
            this._savedCollapsedStates = {};
            (this.data.groups || []).forEach(g => { this._savedCollapsedStates[g.id] = !!g.collapsed; });
          }
          if (newVal) {
            // Expand matched groups
            (this.data.groups || []).forEach(g => {
              if (this.isGroupMatched(g, newVal)) this.$set(g, 'collapsed', false);
            });
          } else if (!newVal && this._savedCollapsedStates) {
            // Restore previous collapsed states after clearing search
            (this.data.groups || []).forEach(g => {
              const prev = this._savedCollapsedStates[g.id];
              if (prev !== undefined) this.$set(g, 'collapsed', prev);
            });
            this._savedCollapsedStates = null;
          }
        },
        dragState(newValue, oldValue) {
          debugLog('log', "dragState changed from", oldValue, "to", newValue);
          if (newValue) {
            debugLog('log', "#app should now have class 'dragging-" + newValue + "'");
            // Let's verify the CSS classes are actually applied
            this.$nextTick(() => {
              const appElement = document.getElementById('app');
              if (appElement) {
                debugLog('log', "App element classes after dragState change:", appElement.className);
                const dropZones = document.querySelectorAll('.group-drop-zone');
                debugLog('log', "Found", dropZones.length, "drop zones");
                dropZones.forEach((zone, index) => {
                  const computedStyle = window.getComputedStyle(zone);
                  debugLog('log', `Drop zone ${index} display:`, computedStyle.display);
                });
              }
            });
          } else {
            debugLog('log', "#app should now remove all dragging-* classes");
          }
        }
      },
      computed: {
        linkShortenerEnabledIds() {
          const enabled = this.data.options?.linkShorteners?.enabledServices;
          return Array.isArray(enabled) ? enabled : [];
        },
        linkShortenerEnabledSet() {
          return new Set(this.linkShortenerEnabledIds);
        },
        linkShortenerMenuEntries() {
          const enabledSet = this.linkShortenerEnabledSet;
          if (!Array.isArray(this.linkShortenerServices) || enabledSet.size === 0) {
            return [];
          }
          return this.linkShortenerServices
            .filter(service => enabledSet.has(service.id))
            .sort((a, b) => a.name.localeCompare(b.name));
        },
        // Check if custom CSS has changes
        hasCustomCssChanges() {
          const currentCss = this.data.options?.customCss || '';
          return this.customCssDraft !== currentCss;
        },
        
        // Syntax highlighted CSS for display
        highlightedCss() {
          if (!this.customCssDraft) return '';
          try {
            if (typeof hljs !== 'undefined') {
              const result = hljs.highlight(this.customCssDraft, { language: 'css' });
              return result.value;
            }
          } catch (e) {
            console.warn('Highlight.js error:', e);
          }
          // Fallback: escape HTML
          return this.customCssDraft
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        },
        
        settingsMatchesFilter() {
          // Returns a function to check if a setting matches the filter
          return (settingName, helpText) => {
            if (!this.settingsFilterText) return true;
            const filter = this.settingsFilterText.toLowerCase();
            const nameTranslated = this.getTranslation(settingName) || settingName || '';
            const helpTranslated = this.getTranslation(helpText) || helpText || '';
            return nameTranslated.toLowerCase().includes(filter) || 
                   helpTranslated.toLowerCase().includes(filter);
          };
        },
        sectionHasVisibleSettings() {
          // Check if a section has any visible settings based on the filter
          return (section) => {
            if (!this.settingsFilterText) return true;
            
            // Check each section's settings
            if (section === 'common') {
              return this.settingsMatchesFilter(this.optionsDesign.common.language.translateKey, this.optionsDesign.common.language.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.common.pageTitle.translateKey, this.optionsDesign.common.pageTitle.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.common.searchAsYouType.translateKey, this.optionsDesign.common.searchAsYouType.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.common.confirmDeleteGroup.translateKey, this.optionsDesign.common.confirmDeleteGroup.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.common.confirmDeleteLink.translateKey, this.optionsDesign.common.confirmDeleteLink.helpText);
            }
            
            if (section === 'appearanceColors' || section === 'colors') {
              // Check all fields in appearanceColors section
              if (this.optionsDesign.appearanceColors && this.optionsDesign.appearanceColors.fields) {
                for (const [fieldKey, field] of Object.entries(this.optionsDesign.appearanceColors.fields)) {
                  if (this.settingsMatchesFilter(field.translateKey, field.helpText)) {
                    return true;
                  }
                }
              }
              return false;
            }
            
            if (section === 'groups') {
              return this.settingsMatchesFilter(this.optionsDesign.groups.collapseGroupsOnStart.translateKey, this.optionsDesign.groups.collapseGroupsOnStart.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.groups.hoverExpandEnabled.translateKey, this.optionsDesign.groups.hoverExpandEnabled.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.groups.hoverExpandDelay.translateKey, this.optionsDesign.groups.hoverExpandDelay.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.groups.clearClosesAllGroups.translateKey, this.optionsDesign.groups.clearClosesAllGroups.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.groups.keywordClickExpandsAll.translateKey, this.optionsDesign.groups.keywordClickExpandsAll.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.groups.searchAutoExpandFound.translateKey, this.optionsDesign.groups.searchAutoExpandFound.helpText);
            }
            
            if (section === 'links') {
              return this.settingsMatchesFilter(this.optionsDesign.links.openInNewTab.translateKey, this.optionsDesign.links.openInNewTab.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.links.addViaDialog.translateKey, this.optionsDesign.links.addViaDialog.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.links.defaultUrlPrefix.translateKey, this.optionsDesign.links.defaultUrlPrefix.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.links.autoFetchTitle.translateKey, this.optionsDesign.links.autoFetchTitle.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.links.autoFetchFavicon.translateKey, this.optionsDesign.links.autoFetchFavicon.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.links.showLinkBadges.translateKey, this.optionsDesign.links.showLinkBadges.helpText);
            }

            if (section === 'linkShorteners') {
              return this.settingsMatchesFilter('options.linkShorteners.services', 'options.linkShorteners.services.help');
            }
            
            if (section === 'sharing') {
              return this.settingsMatchesFilter(this.optionsDesign.sharing.ntfyServerUrl.translateKey, this.optionsDesign.sharing.ntfyServerUrl.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.sharing.ntfyAuthToken.translateKey, this.optionsDesign.sharing.ntfyAuthToken.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.sharing.defaultTtl.translateKey, this.optionsDesign.sharing.defaultTtl.helpText) ||
                     this.settingsMatchesFilter(this.optionsDesign.sharing.quickCodeTtlSec.translateKey, this.optionsDesign.sharing.quickCodeTtlSec.helpText);
            }
            
            if (section === 'eventlog') {
              return this.settingsMatchesFilter('options.eventlog.snapshotInterval', 'options.eventlog.snapshotInterval.help') ||
                     this.settingsMatchesFilter('options.eventlog.maxEvents', 'options.eventlog.maxEvents.help') ||
                     this.settingsMatchesFilter('options.eventlog.syncStrategy', 'options.eventlog.syncStrategy.help');
            }
            
            return false;
          };
        },
        contextLink() {
          return this.contextMenuTarget?.type === 'link' ? this.contextMenuTarget.item : null;
        },
        contextGroup() {
          // For group menu, return the group item
          if (this.contextMenuTarget?.type === 'group') {
            return this.contextMenuTarget.item;
          }
          // For link menu, return the group context
          if (this.contextMenuTarget?.type === 'link') {
            return this.contextMenuTarget.groupContext;
          }
          return null;
        },
        allKeywords() {
          const set = new Set();
          (this.data.groups || []).forEach(g => {
            const add = (keywords) => {
              if (!keywords) return;
              // Handle both string and array formats
              this.parseKeywords(keywords).forEach(k => set.add(k));
            };
            add(g.keywords);
            (g.links || []).forEach(l => add(l.keywords));
          });
          return Array.from(set).sort((a, b) => a.localeCompare(b));
        },
        keywordColorMap() {
          const map = {};

          const ensureSet = (kw) => { if (!map[kw]) map[kw] = new Set(); };

          const addColors = (kw, colors) => {
            if (!kw) return;
            ensureSet(kw);
            (colors || []).forEach(c => { if (c && c.trim()) map[kw].add(c.trim()); });
          };

          const extractColorsFromValue = (value) => {
            if (!value) return [];
            // Try JSON primary color
            try {
              const primary = this.getPrimaryColorFromCss(value, '');
              if (primary) return [primary];
            } catch {}
            if (typeof value !== 'string') return [];
            const v = value.trim();
            if (!v) return [];
            // If linear-gradient, extract all color tokens (hex/rgb[a])
            if (v.includes('gradient')) {
              const tokens = v.match(/#([0-9a-fA-F]{3,6})|rgba?\([^\)]+\)/g);
              return tokens || [];
            }
            // Simple color string
            return [v];
          };

          const effectiveBadgeColors = (group, link) => {
            const merged = this.mergeFormattingSettings(
              this.data.options?.colors?.background,
              this.data.options?.groups?.defaultGroupBadgeFormatting,
              group?.badgeFormatting,
              link ? link.badgeFormatting : undefined
            );
            const colors = [];
            if (merged.backgroundColor) colors.push(merged.backgroundColor);
            if (merged.background) colors.push(...extractColorsFromValue(merged.background));
            // Fallbacks when no badge background is set
            if (colors.length === 0) {
              if (link) {
                colors.push(...extractColorsFromValue(link.formatting));
                colors.push(...extractColorsFromValue(link.color));
              }
              colors.push(...extractColorsFromValue(group?.titleFormatting));
              colors.push(...extractColorsFromValue(group?.color));
            }
            return colors.filter(Boolean);
          };

          const groups = this.data.groups || [];
          groups.forEach(g => {
            const addFrom = (keywords, link) => {
              if (!keywords) return;
              const colors = effectiveBadgeColors(g, link);
              const list = this.parseKeywords(keywords);
              list.forEach(kw => addColors(kw.trim(), colors));
            };

            // Group-level keywords
            addFrom(g.keywords, null);

            // Link-level keywords
            (g.links || []).forEach(l => addFrom(l.keywords, l));
          });

          const result = {};
          Object.keys(map).forEach(k => result[k] = Array.from(map[k]));
          return result;
        },

        
      },
        created() {
          this.initDatabase();
          sharing = new SharingService(this);
          // Expose sharing service globally for legacy call sites
          try { window.sharing = sharing; } catch {}

          // Load and apply Visual CSS rules on startup
          this.loadVisualCssRules();
          // Restore collapsed state of rule cards
          this.loadCollapsedRules();
          // Restore design tokens collapsed state
          this.loadDesignTokensCollapsed();

          // No wrapping of confirmShare; extend main confirmShare handler directly
          window.addEventListener('keyup', (e) => {
          if (e.key === 'Escape') {
            this.dropManager.reset();
            this.hideMenus();
            this.cancelEditing(this.editGroup); // Cancel group editing
            this.cancelEditing(this.editLink); // Cancel link editing
          }
        });
        // Global click listener to hide menus
        window.addEventListener('click', this.handleGlobalClick, true); // Use capture phase
        document.addEventListener('keydown', this.handleGlobalKeyDown); // Search-as-you-type
      },
      beforeDestroy() {
        // Clean up global listeners
        window.removeEventListener('click', this.handleGlobalClick, true);
        document.removeEventListener('keydown', this.handleGlobalKeyDown);
        
        // Clean up all timers to prevent memory leaks
        this.clearExpandHoverTimers();
        
        // Clean up DropManager timers if they exist
        if (this.dropManager) {
          if (this.dropManager.dragTimeout) {
            clearTimeout(this.dropManager.dragTimeout);
            this.dropManager.dragTimeout = null;
          }
          if (this.dropManager.delayedResetTimeout) {
            clearTimeout(this.dropManager.delayedResetTimeout);
            this.dropManager.delayedResetTimeout = null;
          }
        }
        
        // Clean up any debounced save timer
        if (this._debouncedSave && this._debouncedSave.cancel) {
          this._debouncedSave.cancel();
        }
      },
      mounted() { // Example placement
        debugLog('log', '[MOUNTED] Vue app mounted, starting initialization');
        this.initializeDropManager();

        // Initialize browser extension communication
        this.initializeExtension();

        // Add event listener for import modal close to clean up memory
        const importModal = document.getElementById('pasteClipboardModal');
        if (importModal) {
          importModal.addEventListener('hidden.bs.modal', () => {
            this.resetImportDialog();
          });
        }

        // Configure moment.js with German locale
        if (typeof moment !== 'undefined') {
          // Set German as default locale
          moment.locale('de');
          
          // Configure relative time strings for German if not already set
          moment.updateLocale('de', {
            relativeTime: {
              future: 'in %s',
              past: 'vor %s',
              s: 'ein paar Sekunden',
              ss: '%d Sekunden',
              m: 'einer Minute',
              mm: '%d Minuten',
              h: 'einer Stunde',
              hh: '%d Stunden',
              d: 'einem Tag',
              dd: '%d Tagen',
              M: 'einem Monat',
              MM: '%d Monaten',
              y: 'einem Jahr',
              yy: '%d Jahren'
            }
          });
          
          debugLog('log', '[INIT] Moment.js configured with German locale');
        }
        
        // Initialize dark mode
        this.initDarkMode();
        // Don't init colors here - will be done in updateSettings after data loads
        
        // Load saved sidebar height
        const savedHeight = localStorage.getItem('sidebarTopHeight');
        if (savedHeight) {
          this.sidebarTopHeight = parseInt(savedHeight, 10);
        }
        
        // Load saved CSS sidebar width
        const savedCssSidebarWidth = localStorage.getItem('cssSidebarWidth');
        if (savedCssSidebarWidth) {
          this.cssSidebarWidth = parseInt(savedCssSidebarWidth, 10);
        }
        // Initialize Event-Log Manager for advanced sync with settings
        const eventlogOptions = this.data.options?.eventlog || { snapshotInterval: 100, maxEvents: 500 };
        this.eventLogManager = new EventLogManager(eventlogOptions.maxEvents, eventlogOptions.snapshotInterval);
        debugLog('log', '[INIT] EventLogManager initialized with settings', eventlogOptions);
        debugLog('log', '[INIT] Total groups:', this.data.groups?.length || 0);
        debugLog('log', '[INIT] Groups overview:', this.data.groups?.map(g => ({
          name: g.name,
          groupId: g.groupId,
          useEventLog: g.useEventLog,
          hasEventLog: !!g.eventLog,
          isShared: g.shared
        })));
        this.ensureAllTimestamps();
        
        // Calculate initial storage usage
        this.calculateStorageUsage();
        // Apply saved custom CSS
        try { this.applyCustomCss(this.data.options?.customCss || ''); } catch {}
        
        // AUTO-ENABLE: Activate event-log for all groups and fix existing issues
        debugLog('log', '[AUTO-ENABLE] Checking auto-enable setting:', this.data.options?.eventlog);
        if (this.data.options?.eventlog?.autoEnable !== false) {
          setTimeout(() => {
            debugLog('log', '[AUTO-ENABLE] Processing groups for event-log migration:', this.data.groups.length);

            // Ensure we have a user UUID
            if (!this.data.identity?.uuid) {
              if (!this.data.identity) {
                this.$set(this.data, 'identity', {
                  uuid: this.generateUUID(),
                  name: '',
                  pubKey: '',
                  privKey: ''
                });
              } else {
                this.$set(this.data.identity, 'uuid', this.generateUUID());
              }
              debugLog('log', '[AUTO-ENABLE] Generated user UUID:', this.data.identity.uuid);
            }

            const userUuid = this.data.identity.uuid;

            this.data.groups.forEach(group => {
              debugLog('log', '[AUTO-ENABLE] Checking group:', {
                name: group.name,
                hasEventLog: !!group.eventLog,
                useEventLog: group.useEventLog,
                groupId: group.groupId,
                isShared: group.shared,
                vectorClock: group.vectorClock
              });

              // Fix groups with "system" author in event-log
              if (group.eventLog && group.eventLog.length > 0) {
                let needsFix = false;
                group.eventLog.forEach(event => {
                  if (event.author === 'system') {
                    event.author = userUuid;
                    needsFix = true;
                    debugLog('log', '[AUTO-ENABLE] Fixed system author in event:', event.eventId);
                  }
                });

                // Fix vector clock if it has "system" entries
                if (group.vectorClock && group.vectorClock['system']) {
                  const systemCount = group.vectorClock['system'];
                  delete group.vectorClock['system'];
                  group.vectorClock[userUuid] = (group.vectorClock[userUuid] || 0) + systemCount;
                  needsFix = true;
                  debugLog('log', '[AUTO-ENABLE] Fixed system in vector clock for group:', group.name, 'new clock:', group.vectorClock);
                }

                if (needsFix) {
                  debugLog('log', '[AUTO-ENABLE] Repaired event-log for group:', group.name);
                }
              }

              if (!group.eventLog) {
                debugLog('log', '[AUTO-ENABLE] Enabling event-log for group:', group.name);
                // Migrate to event-log system
                this.migrateGroupToEventLog(group);
                this.$set(group, 'useEventLog', true);
                debugLog('log', '[AUTO-ENABLE] After migration:', {
                  name: group.name,
                  hasEventLog: !!group.eventLog,
                  useEventLog: group.useEventLog,
                  eventLogLength: group.eventLog?.length || 0
                });
              }
            });
            this.saveData();
          }, 1000);
        } else {
          debugLog('log', '[AUTO-ENABLE] Event-log auto-enable is disabled');
        }
        // Initialize sharing
        this.fixOptions();
        sharing.applyConfig();
        // Initialize Smart Sync for offline recovery
        this.initSmartSync();
        // Subscribe to all shared groups on startup
        if (Array.isArray(this.data.groups)) {
          this.data.groups.forEach(g => {
            if (g.shared && g.groupTopic && g.groupKey) {
              try {
                debugLog('log', '[INIT] Subscribing to shared group:', g.name, g.groupId);
                // Don't request updates on startup - Smart Sync will handle it
                sharing.subscribeGroup(g, false);
              } catch (e) {
                debugLog('warn', '[INIT] Failed to subscribe to group:', g.name, e);
              }
            }
          });
        }
        // Register service worker only on allowed schemes (https or http on localhost)
        if ('serviceWorker' in navigator) {
          const isLocalhost = ['localhost', '127.0.0.1', '::1'].includes(location.hostname);
          const isAllowed = location.protocol === 'https:' || (location.protocol === 'http:' && isLocalhost);
          if (isAllowed) {
            navigator.serviceWorker.register('sw.js').catch((e) => debugLog('warn', 'SW register failed:', e));
          } else {
            debugLog('warn', 'Skipping Service Worker on protocol:', location.protocol);
          }
        }
        this.handleBookmarkletAdd();
        this.appInitialized = true;
      },
        methods: {
        // ===== LINK SHORTENER SUPPORT =====
        getMutableLinkShortenerOptions(preferDraft = true) {
          return MB.LinkShorteners.getOptions(this, { preferDraft, createIfMissing: true });
        },
        isShortenerEnabled(serviceId, preferDraft = true) {
          return MB.LinkShorteners.isServiceEnabled(this, serviceId, { preferDraft });
        },
        toggleShortenerService(serviceId, enabled) {
          MB.LinkShorteners.toggleService(this, serviceId, enabled, { preferDraft: true });
        },
        ensureShortenerAccount(serviceId) {
          return MB.LinkShorteners.ensureAccount(this, serviceId, { preferDraft: true });
        },
        getShortenerAccount(serviceId, preferDraft = true) {
          return MB.LinkShorteners.getAccount(this, serviceId, { preferDraft });
        },
        updateShortenerAccount(serviceId, field, value) {
          MB.LinkShorteners.updateAccount(this, serviceId, field, value, { preferDraft: true });
        },
        clearShortenerAccount(serviceId) {
          MB.LinkShorteners.clearAccount(this, serviceId, { preferDraft: true });
        },
        getServiceText(service, key) {
          return MB.LinkShorteners.getServiceText(service, key, { vm: this });
        },
        formatIntegrationScore(score) {
          if (score === null || score === undefined) return '';
          const prefix = score > 0 ? '+' : '';
          return `${prefix}${score}`;
        },
        getProxyConfig() {
          return MB.Network.getProxyConfig();
        },
        isProxyEnabled() {
          return MB.Network.isProxyEnabled();
        },
        getProxyBaseUrl() {
          return MB.Network.getProxyBaseUrl();
        },
        getProxyHeaders() {
          return MB.Network.getProxyHeaders();
        },
        hasNetworkTransport() {
          return MB.Network.isProxyEnabled() || MB.Network.hasExtensionTransport();
        },
        normalizeRequestConfig(config = {}) {
          return MB.Network.normalizeRequestConfig(config);
        },
        async fetchViaConfiguredProxy(requestConfig) {
          try {
            return await MB.Network.fetchViaProxy(requestConfig);
          } catch (error) {
            throw error;
          }
        },
        async performNetworkRequest(request) {
          const normalized = this.normalizeRequestConfig(request);
          try {
            return await MB.Network.performRequest(normalized);
          } catch (error) {
            if (error?.code === 'proxyMissingBaseUrl') {
              throw new Error(this.getTranslation('proxy.error.missingBaseUrl') || 'Proxy base URL missing');
            }
            if (error?.code === 'proxyTimeout') {
              throw new Error(this.getTranslation('proxy.error.fetchFailed')?.replace('{message}', 'Timeout') || 'Proxy request timed out');
            }
            if (error?.code === 'noTransport') {
              throw new Error(this.getTranslation('proxy.error.noTransport') || 'No network transport available');
            }
            if (error?.code === 'proxyFetchFailed') {
              const message = error.message || '';
              throw new Error(this.getTranslation('proxy.error.fetchFailed')?.replace('{message}', message) || message);
            }
            throw error;
          }
        },
        evaluateLinkSecurity(url) {
          return MB.Security.analyze(url);
        },
        translateSecurityIssue(issue) {
          return MB.Security.formatIssue(issue, this.getTranslation.bind(this));
        },
        getLinkSecurity(link) {
          const url = link?.url || '';
          return MB.Security.analyze(url);
        },
        linkSecurityBadgeClass(link, opts = {}) {
          const data = typeof link === 'object' ? this.getLinkSecurity(link) : MB.Security.normalizeResult(link);
          return MB.Security.badgeClass(data, opts);
        },
        linkSecuritySummary(link) {
          const data = this.getLinkSecurity(link);
          return MB.Security.summaryText(data, this.getTranslation.bind(this));
        },
        linkSecurityScore(link) {
          const data = this.getLinkSecurity(link);
          const severity = data?.severity ?? 0;
          const deductions = (data?.issues?.length || 0) * 5;
          let baseScore;
          if (severity >= 3) baseScore = 20;
          else if (severity === 2) baseScore = 50;
          else if (severity === 1) baseScore = 80;
          else baseScore = 95;
          const score = Math.max(5, Math.min(100, baseScore - deductions));
          return Math.round(score);
        },
        linkSecurityScoreLabel(link) {
          const score = this.linkSecurityScore(link);
          return (this.getTranslation('link.security.scoreLabel') || 'Security score: {score}/100').replace('{score}', score);
        },
        async shortenLinkWithService(service) {
          const extensionReady = this.extensionAvailable && (typeof MB.Extension?.isAvailable === 'function' ? MB.Extension.isAvailable() : true);
          const result = await MB.LinkShorteners.runAdapter({
            vm: this,
            service,
            contextLink: this.contextLink,
            contextGroup: this.contextGroup,
            extensionAvailable: extensionReady,
            getTranslation: this.getTranslation.bind(this),
            hasNetworkTransport: this.hasNetworkTransport.bind(this),
            performNetworkRequest: this.performNetworkRequest.bind(this),
            copyToClipboard: this.copyToClipboard.bind(this)
          });

          this.hideMenus();

          if (!result) return;
          if (result.ok) {
            if (result.message) {
              this.showToast(result.message, result.type || 'success');
            }
          } else {
            const fallbackMessage = result.message || result.error?.message;
            if (fallbackMessage) {
              this.showToast(fallbackMessage, result.type || 'error');
            }
          }
        },

        // ===== BROWSER EXTENSION INTEGRATION =====

        initializeExtension() {
          debugLog('log', 'Initializing browser extension support...');

          // Listen for extension ready event
          window.addEventListener('mybookmarks-extension-ready', (event) => {
            debugLog('log', 'MyBookmarks Extension is ready!', event.detail);
            this.extensionAvailable = true;
            this.extensionVersion = event.detail.version;

            // Enrich existing links with favicons when extension becomes available
            if (this.data.options?.links?.autoFetchFavicon) {
              debugLog('log', 'Extension ready - enriching existing links with favicons');
              this.enrichExistingLinksWithFavicons();
            }

            // Schedule CardDAV auto-sync if configured
            try { this.scheduleCardDavAutoSync(); } catch {}
          });

          // Check if extension is available on load with a delay
          setTimeout(() => {
            debugLog('log', 'Checking for MyBookmarksExtension object:', typeof window.MyBookmarksExtension);

            if (window.MyBookmarksExtension) {
              debugLog('log', 'MyBookmarksExtension found, checking availability...');
              this.checkExtensionAvailable().then(available => {
                debugLog('log', 'Extension availability check result:', available);
              if (available) {
                debugLog('log', 'MyBookmarks Extension detected and verified!');
                this.extensionAvailable = true;

                  // Enrich existing links with favicons
                  if (this.data.options?.links?.autoFetchFavicon) {
                    debugLog('log', 'Extension available - enriching existing links with favicons');
                    this.enrichExistingLinksWithFavicons();
                  }

                  // Schedule CardDAV auto-sync
                  try { this.scheduleCardDavAutoSync(); } catch {}
                }
              }).catch(err => {
                debugLog('error', 'Error checking extension availability:', err);
              });
            } else {
              debugLog('log', 'MyBookmarksExtension object not found');
            }
          }, 500);
        },

        async checkExtensionAvailable() {
          return await MB.Extension.checkAvailability();
        },

        async importBookmarksFromBrowser() {
          try {
            const hasExtension = await this.checkExtensionAvailable();
            if (!hasExtension) {
              alert(this.getTranslation('extension.installHint') || 'Bitte installiere die MyBookmarks-Erweiterung aus local2/extensions/');
              return;
            }

            const bookmarksData = await MB.Extension.getBookmarks();
            debugLog('log', 'Received bookmarks data:', bookmarksData);

            // Handle the response structure from the extension
            let bookmarksRoot;
            if (bookmarksData.success && bookmarksData.bookmarks) {
              bookmarksRoot = bookmarksData.bookmarks;
            } else if (bookmarksData) {
              bookmarksRoot = bookmarksData;
            } else {
              throw new Error('No bookmarks data received from extension');
            }

            const imported = { groups: [], linkCount: 0 };

            const processBookmark = (bookmark, parentGroup = null) => {
              if (!bookmark) return;

              if (bookmark.children && Array.isArray(bookmark.children)) {
                // It's a folder
                const group = {
                  uuid: this.generateUUID(),
                  id: this.getNextId(),
                  name: bookmark.title || bookmark.text || 'Imported Folder',
                  links: [],
                  deleted: false,
                  collapsed: false,
                  keywords: '',
                  color: '',
                  emoji: ''
                };

                if (parentGroup) {
                  // Nested folder - add as a subgroup (note: might need different handling)
                  debugLog('log', 'Nested folder found:', group.name);
                } else {
                  // Top-level folder - add to groups
                  this.data.groups.push(group);
                  imported.groups.push(group);
                }

                // Process children
                bookmark.children.forEach(child => processBookmark(child, group));
              } else if (bookmark.links && Array.isArray(bookmark.links)) {
                // It's a group with links array (our format)
                bookmark.links.forEach(link => {
                  if (link.url) {
                    const newLink = {
                      uuid: this.generateUUID(),
                      id: this.getNextId(),
                      text: link.text || link.title || link.url,
                      url: link.url,
                      keywords: '',
                      emoji: '',
                      deleted: false
                    };
                    if (parentGroup) {
                      parentGroup.links.push(newLink);
                      imported.linkCount++;
                    }
                  }
                });
              } else if (bookmark.url) {
                // It's a direct link
                const link = {
                  uuid: this.generateUUID(),
                  id: this.getNextId(),
                  text: bookmark.text || bookmark.title || bookmark.url,
                  url: bookmark.url,
                  keywords: '',
                  emoji: '',
                  deleted: false
                };
                if (parentGroup) {
                  parentGroup.links.push(link);
                  imported.linkCount++;
                }
              }
            };

            // Process the bookmarks tree
            if (Array.isArray(bookmarksRoot)) {
              bookmarksRoot.forEach(bookmark => processBookmark(bookmark));
            } else if (bookmarksRoot && typeof bookmarksRoot === 'object') {
              // Single root object
              processBookmark(bookmarksRoot);
            } else {
              throw new Error('Invalid bookmarks format');
            }

            this.saveData();
            const msg = (this.getTranslation('extension.imported') || '{count} Lesezeichen in {groups} Gruppen importiert!')
              .replace('{count}', imported.linkCount)
              .replace('{groups}', imported.groups.length);
            alert(msg);
          } catch (error) {
            debugLog('error', 'Fehler beim Importieren der Lesezeichen:', error);
            const msg = (this.getTranslation('extension.error') || 'Fehler: {message}')
              .replace('{message}', error.message);
            alert(msg);
          }
        },

        getFaviconText(key) {
          const type = this.genericEditConfig?.type === 'group' ? 'group' : 'link';
          const fallbackMap = {
            upload: { link: 'Upload favicon', group: 'Upload group icon' },
            remove: { link: 'Remove', group: 'Remove icon' },
            invalidFile: { link: 'Please select an image file', group: 'Please select an image file' },
            tooLarge: { link: 'Image is too large (max 256KB)', group: 'Image is too large (max 256KB)' },
            readError: { link: 'Could not read image file', group: 'Could not read image file' },
            uploaded: { link: 'Favicon uploaded', group: 'Group icon updated' }
          };
          const fallback = (fallbackMap[key] && fallbackMap[key][type]) || '';
          return this.getTranslation(`${type}.favicon.${key}`) || fallback;
        },

        // Handle favicon upload in link/group edit dialog
        onFaviconFileSelected(event) {
          try {
            const file = event?.target?.files?.[0];
            if (!file) return;
            if (!file.type || !file.type.startsWith('image/')) {
              this.showToast(this.getFaviconText('invalidFile'), 'warning');
              event.target.value = '';
              return;
            }
            // Optional size limit ~256KB
            if (file.size > 256 * 1024) {
              this.showToast(this.getFaviconText('tooLarge'), 'warning');
              // still allow, or block? We'll allow but warn
            }
            const reader = new FileReader();
            reader.onload = () => {
              const dataUrl = reader.result;
              if (typeof dataUrl === 'string' && dataUrl.startsWith('data:')) {
                this.$set(this.genericEditData, 'favicon', dataUrl);
                this.$set(this.genericEditData, 'faviconError', false);
                this.$set(this.genericEditData, 'faviconLoading', false);
                this.$set(this.genericEditData, 'faviconSource', 'upload');
                this.$set(this.genericEditData, 'faviconRuleId', null);
                this.showToast(this.getFaviconText('uploaded'), 'success');
              } else {
                this.showToast(this.getFaviconText('readError'), 'error');
              }
              try { event.target.value = ''; } catch {}
            };
            reader.onerror = () => {
              this.showToast(this.getFaviconText('readError'), 'error');
              try { event.target.value = ''; } catch {}
            };
            reader.readAsDataURL(file);
          } catch (e) {
            this.showToast(this.getFaviconText('readError'), 'error');
          }
        },
        clearEditedFavicon() {
          if (!this.genericEditData) return;
          this.$set(this.genericEditData, 'favicon', '');
          this.$set(this.genericEditData, 'faviconError', false);
          this.$set(this.genericEditData, 'faviconLoading', false);
          this.$set(this.genericEditData, 'faviconSource', null);
          this.$set(this.genericEditData, 'faviconRuleId', null);
        },

        // Clear extension (companion) caches like metadata cache
        clearExtensionCache() {
          if (!this.extensionAvailable) {
            this.showToast(this.getTranslation('extension.notAvailable') || 'Extension not available', 'warning');
            return;
          }
          return new Promise((resolve) => {
            let resolved = false;
            const handler = (event) => {
              if (!event || !event.data || event.source !== window) return;
              if (event.data.type === 'CLEAR_CACHE_RESPONSE') {
                resolved = true;
                window.removeEventListener('message', handler);
                const ok = event.data.result && event.data.result.success;
                if (ok) {
                  this.showToast((this.getTranslation('extension.cacheCleared') || 'Extension cache cleared') + (event.data.result.cleared !== undefined ? ` (${event.data.result.cleared})` : ''), 'success');
                  // After clearing extension cache, also clear local favicons and re-fetch if enabled
                  if (this.extensionAvailable && this.data.options?.links?.autoFetchFavicon) {
                    try {
                      let clearedIcons = 0;
                      (this.data.groups || []).forEach(g => {
                        (g.links || []).forEach(l => {
                          if (l && l.url) {
                            if (l.favicon) { this.$set(l, 'favicon', null); clearedIcons++; }
                            if (l.faviconError) this.$set(l, 'faviconError', false);
                            if (l.faviconLoading) this.$set(l, 'faviconLoading', false);
                          }
                        });
                      });
                      if (clearedIcons > 0) this.saveData();
                      this.showToast(this.getTranslation('extension.refetchFavicons') || 'Re-fetching favicons…', 'info');
                      setTimeout(() => { try { this.enrichExistingLinksWithFavicons(); } catch {} }, 50);
                    } catch {}
                  }
                } else {
                  const err = (event.data.result && event.data.result.error) || 'Unknown error';
                  this.showToast((this.getTranslation('extension.cacheClearFailed') || 'Failed to clear extension cache') + ': ' + err, 'error');
                }
                resolve();
              }
            };
            window.addEventListener('message', handler);
            // Send request
            try {
              window.postMessage({ type: 'CLEAR_EXTENSION_CACHE' }, '*');
            } catch (e) {
              window.removeEventListener('message', handler);
              this.showToast((this.getTranslation('extension.cacheClearFailed') || 'Failed to clear extension cache') + ': ' + e.message, 'error');
              resolve();
            }
            // Fallback timeout
            setTimeout(() => {
              if (!resolved) {
                window.removeEventListener('message', handler);
                this.showToast(this.getTranslation('extension.cacheClearFailed') || 'Failed to clear extension cache', 'error');
                resolve();
              }
            }, 4000);
          });
        },

        // --- CardDAV Sync (gated by extension availability) ---
      async syncCardDavNow() {
        if (!this.extensionAvailable || !window.MyBookmarksExtension || typeof window.MyBookmarksExtension.davRequest !== 'function') {
          alert(this.getTranslation('carddav.extensionRequired') || 'Browser extension with CardDAV support required');
          return;
        }
        if ((this.data.options?.sync?.backend||'') !== 'carddav') {
          alert(this.getTranslation('carddav.notEnabled') || 'CardDAV is disabled in options');
          return;
        }
        try {
          debugLog('log', '[CardDAV] Manual read sync triggered');
          showAppToast(this.getTranslation('carddav.syncStarted') || 'CardDAV sync started', 'info');

          const opts = this.data.options?.carddav || {};
          let serverUrl = (opts.serverUrl || '').trim();
          if (!serverUrl) {
            alert((this.getTranslation('carddav.addressbookPathMissing') || 'Please configure Server URL and Addressbook Path in Options'));
            return;
          }
          const auth = MB.CardDAV.buildBasicAuthHeader(opts.username || '', opts.password || '');
          // Push auth to extension for header injection
          try { await MB.Extension.setDavAuth(serverUrl, opts.username || '', opts.password || ''); } catch {}

          // Resolve addressbook URL with robust discovery (Nextcloud/SabreDAV)
          // Priority: explicit addressbookPath > stored addressbookUrl > discovery
          let addressbookUrl = '';
          if (opts.addressbookPath && opts.addressbookPath.trim()) {
            addressbookUrl = MB.CardDAV.joinUrl(serverUrl, opts.addressbookPath.trim());
            // Persist the derived URL so future runs keep using it
            this.$set(this.data.options.carddav, 'addressbookUrl', addressbookUrl);
            this.saveData();
          } else {
            addressbookUrl = (opts.addressbookUrl || '').trim();
            if (!addressbookUrl) {
              // Try well-known redirect first
              try { serverUrl = await MB.CardDAV.followWellKnown(serverUrl) || serverUrl; } catch {}
              // Try common DAV bases
              const candidates = ['/', '/remote.php/dav/', '/dav/', '/carddav/']
                .map(p => MB.CardDAV.joinUrl(serverUrl, p));
              let baseDav = null;
              for (const base of candidates) {
                try {
                  const rel = await MB.CardDAV.getCurrentUserPrincipal(base, auth);
                  debugLog('log', `[CardDAV] Probe base ${base} -> principal rel:`, rel);
                  if (rel) { baseDav = base; break; }
                } catch {}
              }
              if (!baseDav) {
                // Last resort: assume Nextcloud base
                baseDav = MB.CardDAV.joinUrl(serverUrl, '/remote.php/dav/');
              }

              // Derive principal
              let principalRel = null;
              try { principalRel = await MB.CardDAV.getCurrentUserPrincipal(baseDav, auth); } catch {}
              let principalUrl = principalRel ? MB.CardDAV.joinUrl(baseDav, principalRel) : null;

              // If still unknown, try constructing principal from username (Nextcloud/SabreDAV)
              if (!principalUrl && opts.username) {
                principalUrl = MB.CardDAV.joinUrl(baseDav, `/principals/users/${encodeURIComponent(opts.username)}/`);
              }

              // Get addressbook-home-set; fallback to default path
              let homeRel = null;
              try { if (principalUrl) homeRel = await MB.CardDAV.getAddressbookHome(principalUrl, auth); } catch {}
              let homeUrl = homeRel ? MB.CardDAV.joinUrl(baseDav, homeRel) : null;
              if (!homeUrl && opts.username) {
                homeUrl = MB.CardDAV.joinUrl(baseDav, `/addressbooks/users/${encodeURIComponent(opts.username)}/`);
              }
              if (!homeUrl) throw new Error('addressbook-home-set not found');
              if (!homeUrl.endsWith('/')) homeUrl += '/';
              debugLog('log', '[CardDAV] homeUrl resolved to:', homeUrl);

              // List or create addressbook
              let books = await MB.CardDAV.listAddressbooks(homeUrl, auth);
              debugLog('log', `[CardDAV] Found ${books.length} addressbooks at homeUrl`);
              let pick = books.find(b => (b.displayname||'').toLowerCase() === 'mybookmarks') || books.find(b => (b.displayname||'').toLowerCase() === 'contacts') || books[0];
              if (!pick && opts.createAddressbookIfMissing) {
                try { const created = await MB.CardDAV.mkcolAddressbook(homeUrl, 'MyBookmarks', auth); pick = created; debugLog('log', '[CardDAV] Created addressbook MyBookmarks at', created.href); } catch (e) { debugLog('warn', '[CardDAV] MKCOL MyBookmarks failed', e); }
              }
              // Fallback: probe typical Nextcloud default addressbook "contacts/"
              if (!pick && opts.username) {
                const contactsHref = MB.CardDAV.joinUrl(homeUrl, 'contacts/');
                try {
                  const probe = await MB.CardDAV.propfind(contactsHref, 0,
                    `<?xml version="1.0"?><D:propfind xmlns:D="DAV:"><D:prop><D:resourcetype/><D:displayname/></D:prop></D:propfind>`, auth);
                  if (probe.ok) {
                    const x = MB.CardDAV.parseXml(probe.bodyText||'');
                    const rt = x.getElementsByTagNameNS('DAV:','resourcetype')[0];
                    const isAB = !!(rt && (rt.getElementsByTagNameNS('urn:ietf:params:xml:ns:carddav','addressbook')[0]));
                    if (isAB) {
                      pick = { href: contactsHref, displayname: (x.getElementsByTagNameNS('DAV:','displayname')[0]?.textContent || 'contacts') };
                    }
                  }
                } catch (e) { debugLog('warn','[CardDAV] probe contacts/ failed', e); }
              }
              if (!pick) throw new Error('No addressbook found');
              addressbookUrl = MB.CardDAV.joinUrl(baseDav, pick.href || '');
              this.$set(this.data.options.carddav, 'addressbookUrl', addressbookUrl);
              this.saveData();
            }
          }

          debugLog('log', '[CardDAV] Using addressbookUrl:', addressbookUrl);

          // Incremental or initial sync via sync-collection
          const prevToken = (this.data.options?.carddav?.syncToken || '').trim();
          let changes = [];
          let deletions = [];
          let nextToken = '';
          try {
            const r = await MB.CardDAV.syncCollection(addressbookUrl, prevToken || null, auth);
            changes = r.changes; deletions = r.deletions; nextToken = r.nextToken;
          } catch (err) {
            debugLog('warn', '[CardDAV] sync-collection failed; falling back to full query', err);
          }
          if (!prevToken && changes.length === 0 && (!nextToken || nextToken.length === 0)) {
            changes = await MB.CardDAV.addressbookQueryAll(addressbookUrl, auth);
          }

          // Merge into local data
          let createdGroups = 0, updatedLinks = 0, createdLinks = 0;
          const ensureGroupByName = (name) => {
            let g = (this.data.groups || []).find(x => (x.name||'') === name);
            if (!g) { g = this.getNewGroupTemplate(name); this.data.groups.push(g); createdGroups++; }
            return g;
          };

          // Apply deletions by href
          const removeByHref = (href) => {
            for (const g of (this.data.groups||[])) {
              if (!Array.isArray(g.links)) continue;
              g.links = g.links.filter(l => !(l.carddav && l.carddav.href === href));
            }
          };
          deletions.forEach(d => { try { removeByHref(d.href); } catch {} });

          for (const it of changes) {
            const card = MB.CardDAV.parseVCard(it.vcard || '');
            const uid = card.uid || this.generateUUID();
            const linkObj = {
              uuid: uid,
              text: card.fn || card.url || uid,
              url: card.url || '',
              keywords: (card.mbKeywords || (Array.isArray(card.categories) ? card.categories.join(', ') : '') || ''),
              infoHtml: card.note || '',
              emoji: card.mbMeta?.emoji || '',
              deleted: false,
              carddav: { href: it.href, etag: it.etag, lastSyncedAt: Date.now() }
            };
            const categories = Array.isArray(card.categories) ? card.categories : ['Imported'];
            for (const cat of categories) {
              const group = ensureGroupByName(cat || 'Imported');
              const existing = (group.links || []).find(l => l.uuid === uid) || (group.links || []).find(l => l.carddav && l.carddav.href === it.href) || (group.links || []).find(l => l.url && card.url && l.url === card.url);
              if (existing) {
                existing.text = linkObj.text;
                existing.url = linkObj.url;
                existing.keywords = linkObj.keywords;
                existing.infoHtml = linkObj.infoHtml;
                existing.emoji = linkObj.emoji;
                existing.carddav = linkObj.carddav;
                updatedLinks++;
              } else {
                if (!group.links) this.$set(group, 'links', []);
                group.links.push(linkObj);
                createdLinks++;
              }
            }
          }

          if (nextToken) {
            this.$set(this.data.options.carddav, 'syncToken', nextToken);
            this.$set(this.data.options.carddav, 'lastSyncAt', Date.now());
            this.$set(this.data.options.carddav, 'addressbookUrl', addressbookUrl);
          }
          this.saveData();
          debugLog('log', `[CardDAV] Merge done. Groups+${createdGroups} Links+${createdLinks} Updated+${updatedLinks} Deleted+${deletions.length}`);
          showAppToast(`CardDAV: +${createdLinks}, ~${updatedLinks}, -${deletions.length}, groups +${createdGroups}`, 'success');

          // Optional: upload local changes after read sync
          await this.syncCardDavUpload(addressbookUrl, auth);
        } catch (e) {
          debugLog('error', '[CardDAV] Sync failed', e);
          const msg = (this.getTranslation('carddav.syncFailed') || 'CardDAV sync failed: {message}')
            .replace('{message}', e?.message || String(e));
          showAppToast(msg, 'error');
        }
      },

      // Generic sync/test routing
      async syncNowGeneric() {
        try {
          const backend = this.data.options?.sync?.backend || (this.data.options?.carddav?.enabled ? 'carddav' : null);
          const adapter = MB.SyncAdapters.get(backend);
          if (!adapter) throw new Error('No sync backend selected');
          await adapter.syncNow(this);
        } catch (e) {
          showAppToast((this.getTranslation('carddav.syncFailed')||'Sync failed: {message}').replace('{message}', e?.message||String(e)), 'error');
        }
      },
      async testConnectionGeneric() {
        try {
          const backend = this.data.options?.sync?.backend || (this.data.options?.carddav?.enabled ? 'carddav' : null);
          const adapter = MB.SyncAdapters.get(backend);
          if (!adapter) throw new Error('No sync backend selected');
          const r = await adapter.testConnection(this);
          if (r?.ok || (r?.status>=200 && r?.status<300)) showAppToast('Connection OK', 'success'); else throw new Error('Status '+(r?.status||'??'));
        } catch (e) {
          showAppToast('Connection failed: '+(e?.message||String(e)), 'error');
        }
      },
      isFieldDisabled(sectionKey, fieldKey) {
        const backend = this.data.options?.sync?.backend || '';
        if (sectionKey === 'carddav') return backend !== 'carddav';
        if (sectionKey === 'bookmarks') return backend !== 'nc-bookmarks';
        return false;
      },

      // NC Folder Picker
      async openNcFolderPicker() {
        this.ncFolders = [];
        this.ncFoldersLoading = true;
        this.ncFolderSelected = this.data.options?.bookmarks?.rootFolderId || 0;
        const modal = bootstrap.Modal.getOrCreateInstance(document.getElementById('ncFolderPickerModal'));
        modal.show();
        try { await this.loadNcFolders(); } catch {} finally { this.ncFoldersLoading = false; }
      },
      async loadNcFolders() {
        try {
          const bk = this.data.options?.bookmarks||{};
          const serverUrl = (bk.serverUrl||'').trim(); if (!serverUrl) throw new Error('No serverUrl');
          await MB.Extension.setDavAuth(serverUrl, bk.username||'', bk.password||'');
          const auth = MB.CardDAV.buildBasicAuthHeader(bk.username||'', bk.password||'');
          const url = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
          const res = await MB.Extension.davRequest({ method:'GET', url, headers:{ 'Accept':'application/json', 'OCS-APIREQUEST':'true', 'X-Requested-With':'XMLHttpRequest', 'Authorization':auth }, username: bk.username||'', password: bk.password||'' });
          if (!res.ok) throw new Error('Status '+res.status);
          let parsed = null; try { parsed = JSON.parse(res.bodyText||'[]'); } catch {}
          let arr = Array.isArray(parsed) ? parsed : (parsed && Array.isArray(parsed.data) ? parsed.data : []);
          this.ncFolders = arr;
        } catch (e) {
          showAppToast('Folder list failed: '+(e?.message||String(e)), 'error');
        }
      },
      applyNcFolderSelection() {
        const id = Number(this.ncFolderSelected||0);
        this.$set(this.data.options.bookmarks, 'rootFolderId', id);
        this.saveData();
        const modal = bootstrap.Modal.getInstance(document.getElementById('ncFolderPickerModal'));
        modal && modal.hide();
        showAppToast('Root folder set to #'+id, 'success');
      },
      async testCardDavConnection() {
        try {
          const opts = this.data.options?.carddav || {};
          const serverUrl = (opts.serverUrl||'').trim();
          const path = (opts.addressbookPath||'').trim();
          if (!serverUrl || !path) { alert('Bitte Server-URL und Adressbuch-Pfad setzen'); return; }
          const auth = MB.CardDAV.buildBasicAuthHeader(opts.username||'', opts.password||'');
          await MB.Extension.setDavAuth(serverUrl, opts.username||'', opts.password||'');

          const addressbookUrl = MB.CardDAV.joinUrl(serverUrl, path);
          const results = [];
          results.push({ step: 'well-known', url: MB.CardDAV.joinUrl(serverUrl,'/.well-known/carddav') });
          try { const r = await MB.CardDAV.request({ method:'GET', url: results[0].url, headers:{} }); results[0].status = r.status; results[0].www = (r.headers||{})['www-authenticate']||''; } catch(e){ results[0].error = e.message; }

          // PROPFIND Depth:0 on addressbook
          const prop0 = { step:'propfind-0', url: addressbookUrl };
          try { const r = await MB.CardDAV.propfind(addressbookUrl, 0, `<?xml version="1.0"?><D:propfind xmlns:D="DAV:"><D:prop><D:resourcetype/></D:prop></D:propfind>`, auth); prop0.status=r.status; prop0.www=(r.headers||{})['www-authenticate']||''; } catch(e){ prop0.error=e.message; }
          results.push(prop0);

          // REPORT addressbook-query
          const rep = { step:'report', url: addressbookUrl };
          try { const rs = await MB.CardDAV.addressbookQueryAll(addressbookUrl, auth); rep.status=200; rep.count=rs.length; } catch(e){ rep.error=e.message; }
          results.push(rep);

          const lines = results.map(x=>`${x.step}: ${x.status||''} ${x.error||''} ${x.count!==undefined?('items='+x.count):''} ${x.www?('WWW-Auth='+x.www):''} url=${x.url}`);
          console.log('[CardDAV][Test]', results);
          alert(lines.join('\n'));
        } catch (e) {
          alert('Test fehlgeschlagen: ' + (e?.message||String(e)));
        }
      },

      // Upload local changes (create/update/delete) strictly via CardDAV
      async syncCardDavUpload(addressbookUrl, authHeader) {
        try {
          // Aggregate links by UUID across groups, collect categories (group names)
          const aggregated = new Map(); // uuid -> { linkRef, categories:Set, occurrences:[], deleted }
          for (const g of (this.data.groups || [])) {
            for (const l of (g.links || [])) {
              const uuid = l.uuid || (l.carddav && l.carddav.href) || null;
              if (!uuid) continue;
              if (!aggregated.has(uuid)) aggregated.set(uuid, { link: l, categories: new Set(), occ: [], deleted: !!l.deleted });
              const entry = aggregated.get(uuid);
              entry.occ.push({ group: g, link: l });
              if (g.name) entry.categories.add(g.name);
              // If any occurrence is marked deleted, treat as deleted
              if (l.deleted) entry.deleted = true;
            }
          }

          // Helper: compute stable hash for change detection
          const computeHash = (link, categories) => {
            const payload = {
              text: link.text||'', url: link.url||'', keywords: link.keywords||'', infoHtml: link.infoHtml||'', emoji: link.emoji||'',
              categories: Array.from(categories).sort()
            };
            try { return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))); } catch { return JSON.stringify(payload); }
          };

          let created = 0, updated = 0, removed = 0, skipped = 0;

          for (const [uuid, entry] of aggregated.entries()) {
            const categories = entry.categories;
            const link = entry.link; // use first occurrence as source
            const href = link.carddav?.href;
            const etag = link.carddav?.etag;
            const lastHash = link.carddav?.lastHash || '';
            const nextHash = computeHash(link, categories);

            if (entry.deleted) {
              if (href) {
                const delRes = await MB.CardDAV.delete(href, authHeader, etag);
                if (delRes.ok || delRes.status === 404) {
                  // Clear metadata on all occurrences
                  entry.occ.forEach(({link}) => { this.$set(link, 'carddav', null); });
                  removed++;
                } else {
                  skipped++;
                }
              }
              continue;
            }

            // Build vCard model
            const model = {
              uid: link.uuid,
              fn: link.text || link.url || link.uuid,
              url: link.url || '',
              categories: Array.from(categories),
              note: link.infoHtml || '',
              keywords: link.keywords || '',
              meta: { emoji: link.emoji || '', updatedAt: Date.now() }
            };
            const vcard = MB.CardDAV.buildVCard(model);

            if (!href) {
              // Create new card
              const targetHref = MB.CardDAV.joinUrl(addressbookUrl, (link.uuid || uuid) + '.vcf');
              const putRes = await MB.CardDAV.put(targetHref, vcard, authHeader, null, '*');
              if (putRes.ok || putRes.status === 201 || putRes.status === 200) {
                const newEtag = putRes.headers?.etag || '';
                entry.occ.forEach(({link}) => { this.$set(link, 'carddav', { href: targetHref, etag: newEtag, lastSyncedAt: Date.now(), lastHash: nextHash }); });
                created++;
              } else {
                skipped++;
              }
              continue;
            }

            // Update existing if changed
            if (lastHash && lastHash === nextHash) { skipped++; continue; }

            const putRes = await MB.CardDAV.put(href, vcard, authHeader, etag || null, null);
            if (putRes.ok) {
              const newEtag = putRes.headers?.etag || '';
              entry.occ.forEach(({link}) => { this.$set(link, 'carddav', { href, etag: newEtag, lastSyncedAt: Date.now(), lastHash: nextHash }); });
              updated++;
            } else if (putRes.status === 412) {
              // Conflict: fetch server version and prefer server for URL; union categories/keywords; keep client FN if server has no meta timestamp
              try {
                const getRes = await MB.CardDAV.get(href, authHeader);
                if (getRes.ok) {
                  const serverCard = MB.CardDAV.parseVCard(getRes.bodyText || '');
                  const serverMetaTs = serverCard.mbMeta?.updatedAt || 0;
                  const clientTs = model.meta.updatedAt;
                  const resolved = {
                    uid: model.uid,
                    fn: (clientTs > serverMetaTs ? model.fn : (serverCard.fn || model.fn)),
                    url: (serverCard.url || model.url), // server-first URL
                    categories: Array.from(new Set([...(serverCard.categories||[]), ...model.categories])),
                    note: (clientTs > serverMetaTs ? model.note : (serverCard.note || model.note)),
                    keywords: Array.from(new Set([...(model.keywords||'').split(',').map(s=>s.trim()).filter(Boolean), ...((serverCard.mbKeywords||'').split(',').map(s=>s.trim()).filter(Boolean))])).join(', '),
                    meta: { emoji: model.meta.emoji || serverCard.mbMeta?.emoji || '', updatedAt: Date.now() }
                  };
                  const mergedVcf = MB.CardDAV.buildVCard(resolved);
                  const retry = await MB.CardDAV.put(href, mergedVcf, authHeader, null, null); // drop If-Match to accept latest
                  if (retry.ok) {
                    const newEtag = retry.headers?.etag || '';
                    entry.occ.forEach(({link}) => { this.$set(link, 'carddav', { href, etag: newEtag, lastSyncedAt: Date.now(), lastHash: nextHash }); });
                    updated++;
                  } else {
                    skipped++;
                  }
                } else {
                  skipped++;
                }
              } catch { skipped++; }
            } else {
              skipped++;
            }
          }

          this.saveData();
          debugLog('log', `[CardDAV] Upload done. +${created} ~${updated} -${removed} =${skipped}`);
          showAppToast(`CardDAV upload: +${created}, ~${updated}, -${removed}`, 'success');
        } catch (e) {
          debugLog('error', '[CardDAV] Upload failed', e);
          showAppToast((this.getTranslation('carddav.syncFailed') || 'CardDAV sync failed: {message}').replace('{message}', e?.message || String(e)), 'error');
        }
      },

        async enrichLinkWithMetadata(link) {
          if (!window.MyBookmarksExtension) return false;

          try {
            const metadata = await window.MyBookmarksExtension.fetchMetadata(link.url);
            if (metadata.title && !link.text) link.text = metadata.title;
            if (metadata.favicon) link.favicon = metadata.favicon;
            if (metadata.description) link.description = metadata.description;
            return true;
          } catch (error) {
            debugLog('error', 'Error fetching metadata:', error);
            return false;
          }
        },

        showExtensionNotInstalledHint() {
          alert(this.getTranslation('extension.installHint') || 'Bitte installiere die MyBookmarks-Erweiterung aus local2/extensions/');
        },

        async enrichExistingLinksWithFavicons() {
          // Silent enrichment of links with favicons when extension becomes available
          if (!this.extensionAvailable || !window.MyBookmarksExtension) return;

          debugLog('log', 'Starting silent favicon enrichment for existing links');

          const linksToEnrich = [];
          this.data.groups.forEach(group => {
            group.links.forEach(link => {
              // Only enrich links that have a URL but no base64 favicon yet
              const fav = link && link.favicon ? String(link.favicon) : '';
              const isBase64 = fav.startsWith('data:');
              if (link.url && !link.deleted && !isBase64 && !link.faviconError) {
                linksToEnrich.push(link);
              }
            });
          });

          if (linksToEnrich.length === 0) {
            debugLog('log', 'No links need favicon enrichment');
            return;
          }

          debugLog('log', `Enriching ${linksToEnrich.length} links with favicons`);

          for (const link of linksToEnrich) {
            try {
              await this.tryFetchAndSetFavicon(link, link.url);
              // Small delay to avoid overwhelming the extension
              await new Promise(r => setTimeout(r, 100));
            } catch (error) {
              debugLog('warn', 'Error enriching link with favicon:', error);
            }
          }

          this.saveData();
          debugLog('log', 'Favicon enrichment complete');
        },

        async enrichAllLinksWithMetadata() {
          const hasExtension = await this.checkExtensionAvailable();
          if (!hasExtension) {
            alert('Bitte installiere die MyBookmarks Browser-Erweiterung aus local2/extensions/');
            return;
          }

          const linksToEnrich = [];
          this.data.groups.forEach(group => {
            group.links.forEach(link => {
              if (link.url && !link.deleted && !link.favicon) {
                linksToEnrich.push(link);
              }
            });
          });

          if (linksToEnrich.length === 0) {
            alert(this.getTranslation('extension.allHaveMetadata') || 'Alle Links haben bereits Metadaten!');
            return;
          }

          const confirmMsg = (this.getTranslation('extension.fetchMetadataConfirm') || 'Metadaten für {count} Links abrufen?')
            .replace('{count}', linksToEnrich.length);
          if (!confirm(confirmMsg)) return;

          let enriched = 0;
          for (const link of linksToEnrich) {
            try {
              if (await this.enrichLinkWithMetadata(link)) enriched++;
              await new Promise(r => setTimeout(r, 200));
            } catch (error) {
              debugLog('error', 'Fehler beim Anreichern des Links:', error);
            }
          }

          this.saveData();
          const msg = (this.getTranslation('extension.enriched') || '{count} Links mit Metadaten angereichert!')
            .replace('{count}', enriched);
          alert(msg);
        },

        // Get all links from all groups
        getAllLinks() {
          const links = [];
          if (this.data.groups) {
            this.data.groups.forEach(group => {
              if (group.links) {
                group.links.forEach(link => {
                  if (link.uuid) {
                    links.push({
                      ...link,
                      groupName: group.name,
                      groupUuid: group.uuid
                    });
                  }
                });
              }
            });
          }
          return links;
        },
        
        // Get all Group > Keyword combinations
        getGroupKeywords() {
          const results = [];
          const seenCombos = new Set();
          
          if (this.data.groups) {
            this.data.groups.forEach(group => {
              const groupKeywords = new Set();
              
              // Collect all keywords from all links in this group
              if (group.links) {
                group.links.forEach(link => {
                  if (link.keywords) {
                    const keywords = typeof link.keywords === 'string' 
                      ? link.keywords.split(',').map(k => k.trim()).filter(k => k)
                      : [];
                    keywords.forEach(kw => groupKeywords.add(kw));
                  }
                });
              }
              
              // Add keywords from group itself if it has any
              if (group.keywords) {
                const keywords = typeof group.keywords === 'string' 
                  ? group.keywords.split(',').map(k => k.trim()).filter(k => k)
                  : [];
                keywords.forEach(kw => groupKeywords.add(kw));
              }
              
              // Create entries for each unique keyword in this group
              groupKeywords.forEach(keyword => {
                const slug = this.keywordSlug(keyword);
                const comboKey = `${group.uuid}-${slug}`;
                
                if (!seenCombos.has(comboKey)) {
                  seenCombos.add(comboKey);
                  results.push({
                    key: comboKey,
                    groupName: group.name.substring(0, 20) + (group.name.length > 20 ? '...' : ''),
                    keyword: keyword,
                    selector: `.keyword-badge[data-group-uuid='${group.uuid}'][data-keyword='${slug}']`
                  });
                }
              });
            });
          }
          
          return results;
        },
        
        // Get all Group > Link > Keyword combinations
        getGroupLinkKeywords() {
          const results = [];
          if (this.data.groups) {
            this.data.groups.forEach(group => {
              if (group.links) {
                group.links.forEach(link => {
                  if (link.uuid && link.keywords) {
                    const keywords = typeof link.keywords === 'string' 
                      ? link.keywords.split(',').map(k => k.trim()).filter(k => k)
                      : [];
                    keywords.forEach(keyword => {
                      const slug = this.keywordSlug(keyword);
                      results.push({
                        key: `${group.uuid}-${link.uuid}-${slug}`,
                        groupName: group.name.substring(0, 15) + (group.name.length > 15 ? '...' : ''),
                        linkText: (link.text || link.url).substring(0, 15) + ((link.text || link.url).length > 15 ? '...' : ''),
                        keyword: keyword,
                        selector: `.keyword-badge[data-group-uuid='${group.uuid}'][data-link-uuid='${link.uuid}'][data-keyword='${slug}']`
                      });
                    });
                  }
                });
              }
            });
          }
          return results;
        },
        
        // Extract color styles from custom CSS for a specific keyword
        getKeywordColorFromCustomCSS(keyword) {
          try {
            const customCss = this.data.options?.customCss || '';
            if (!customCss) return null;
            
            const slug = this.keywordSlug(keyword);
            if (!slug) return null;
            
            // Look for CSS rules that target this keyword
            const patterns = [
              new RegExp(`\\.mb-keyword-kw-${slug}\\s*\\{([^}]+)\\}`, 'gi'),
              new RegExp(`\\.keyword-badge\\[data-keyword=['"]?${slug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
              new RegExp(`\\[data-keyword=['"]?${slug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
            ];
            
            let styles = {};
            
            for (const pattern of patterns) {
              const matches = customCss.matchAll(pattern);
              for (const match of matches) {
                const rules = match[1];
                // Extract background-color
                const bgColorMatch = rules.match(/background-color\s*:\s*([^;!]+)/i);
                if (bgColorMatch) {
                  styles.backgroundColor = bgColorMatch[1].trim().replace(/!important/gi, '').trim();
                }
                // Extract background (for gradients)
                const bgMatch = rules.match(/background\s*:\s*([^;!]+)/i);
                if (bgMatch && !bgMatch[1].includes('none')) {
                  styles.background = bgMatch[1].trim().replace(/!important/gi, '').trim();
                }
                // Extract text color
                const colorMatch = rules.match(/(?<!background-)color\s*:\s*([^;!]+)/i);
                if (colorMatch) {
                  styles.color = colorMatch[1].trim().replace(/!important/gi, '').trim();
                }
              }
            }
            
            return styles;
          } catch (e) {
            console.warn('Error extracting keyword color from CSS:', e);
            return null;
          }
        },
        
        // Get inline style object for keyword badges in the keyword cloud
        getKeywordInlineStyle(keyword) {
          const customStyles = this.getKeywordColorFromCustomCSS(keyword);
          if (!customStyles || Object.keys(customStyles).length === 0) {
            return null;
          }
          
          const style = {};
          if (customStyles.background) {
            style.background = customStyles.background;
          } else if (customStyles.backgroundColor) {
            style.backgroundColor = customStyles.backgroundColor;
          }
          if (customStyles.color) {
            style.color = customStyles.color;
          }
          
          return style;
        },
        
        // Collect all colors for a keyword from all contexts where it appears
        collectAllKeywordColors(keyword) {
          try {
            const colors = [];
            const customCss = this.cssSidebarVisible 
              ? (this.customCssDraft || '') 
              : (this.data.options?.customCss || '');
            
            if (!customCss) return colors;
            
            const slug = this.keywordSlug(keyword);
            if (!slug) return colors;
            
            // Track which contexts have this keyword
            const contextsWithKeyword = [];
            
            // Find all groups that have this keyword
            this.data.groups.forEach(group => {
              if (!group.deleted && group.keywords && group.keywords.includes(keyword)) {
                contextsWithKeyword.push({
                  type: 'group',
                  uuid: group.uuid,
                  name: group.name
                });
              }
              
              // Find all links that have this keyword
              if (group.links) {
                group.links.forEach(link => {
                  if (!link.deleted && link.keywords && link.keywords.includes(keyword)) {
                    contextsWithKeyword.push({
                      type: 'link',
                      groupUuid: group.uuid,
                      linkUuid: link.uuid,
                      text: link.text
                    });
                  }
                });
              }
            });
            
            // Extract color for each context from CSS
            const escapedSlug = slug.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            
            contextsWithKeyword.forEach((ctx, idx) => {
              let color = null;
              
              if (ctx.type === 'group' && ctx.uuid) {
                // Look for group-specific keyword color
                const groupUuidEscaped = ctx.uuid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                
                // First try: specific keyword in specific group
                const specificPatterns = [
                  new RegExp(`\\[data-group-uuid=['"]?${groupUuidEscaped}['"]?\\]\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
                  new RegExp(`\\.keyword-badge\\[data-group-uuid=['"]?${groupUuidEscaped}['"]?\\]\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
                ];
                
                // Second try: ALL keywords in this group (fallback)
                const groupPatterns = [
                  new RegExp(`\\.keyword-badge\\[data-group-uuid=['"]?${groupUuidEscaped}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
                  new RegExp(`\\[data-group-uuid=['"]?${groupUuidEscaped}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
                ];
                
                const allPatterns = [...specificPatterns, ...groupPatterns];
                
                for (const pattern of allPatterns) {
                  if (color) break;
                  const matches = customCss.matchAll(pattern);
                  for (const match of matches) {
                    const rules = match[1];
                    const bgMatch = rules.match(/background\s*:\s*([^;!]+)/i);
                    if (bgMatch && !bgMatch[1].includes('gradient')) {
                      color = bgMatch[1].trim().replace(/!important/gi, '').trim();
                      break;
                    }
                    const bgColorMatch = rules.match(/background-color\s*:\s*([^;!]+)/i);
                    if (bgColorMatch) {
                      color = bgColorMatch[1].trim().replace(/!important/gi, '').trim();
                      break;
                    }
                  }
                }
              } else if (ctx.type === 'link' && ctx.linkUuid) {
                // Look for link-specific keyword color
                const linkUuidEscaped = ctx.linkUuid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                
                // First try: specific keyword on specific link
                const specificPatterns = [
                  new RegExp(`\\[data-link-uuid=['"]?${linkUuidEscaped}['"]?\\]\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
                  new RegExp(`\\.keyword-badge\\[data-link-uuid=['"]?${linkUuidEscaped}['"]?\\]\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
                ];
                
                // Second try: ALL keywords on this link (fallback)
                const linkPatterns = [
                  new RegExp(`\\.keyword-badge\\[data-link-uuid=['"]?${linkUuidEscaped}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
                  new RegExp(`\\[data-link-uuid=['"]?${linkUuidEscaped}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
                ];
                
                const allPatterns = [...specificPatterns, ...linkPatterns];
                
                for (const pattern of allPatterns) {
                  if (color) break;
                  const matches = customCss.matchAll(pattern);
                  for (const match of matches) {
                    const rules = match[1];
                    const bgMatch = rules.match(/background\s*:\s*([^;!]+)/i);
                    if (bgMatch && !bgMatch[1].includes('gradient')) {
                      color = bgMatch[1].trim().replace(/!important/gi, '').trim();
                      break;
                    }
                    const bgColorMatch = rules.match(/background-color\s*:\s*([^;!]+)/i);
                    if (bgColorMatch) {
                      color = bgColorMatch[1].trim().replace(/!important/gi, '').trim();
                      break;
                    }
                  }
                }
              }
              
              if (color) {
                colors.push(color);
              }
            });
            
            // FIRST check for general keyword color (as fallback for all contexts)
            let generalColor = null;
            const generalPatterns = [
              new RegExp(`\\.mb-keyword-kw-${escapedSlug}\\s*\\{([^}]+)\\}`, 'gi'),
              new RegExp(`\\.keyword-badge\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi'),
              new RegExp(`\\[data-keyword=['"]?${escapedSlug}['"]?\\]\\s*\\{([^}]+)\\}`, 'gi')
            ];
            
            for (const pattern of generalPatterns) {
              if (generalColor) break;
              const matches = customCss.matchAll(pattern);
              for (const match of matches) {
                const rules = match[1];
                const bgMatch = rules.match(/background\s*:\s*([^;!]+)/i);
                if (bgMatch) {
                  generalColor = bgMatch[1].trim().replace(/!important/gi, '').trim();
                  if (generalColor.includes('gradient')) {
                    generalColor = null; // Ignore gradients in general color
                  } else {
                    break;
                  }
                }
                const bgColorMatch = rules.match(/background-color\s*:\s*([^;!]+)/i);
                if (bgColorMatch && !generalColor) {
                  generalColor = bgColorMatch[1].trim().replace(/!important/gi, '').trim();
                  break;
                }
              }
            }
            
            // If we found a general color, use it for ALL contexts that don't have specific colors
            if (generalColor && contextsWithKeyword.length > 0) {
              // Add the general color once for each context
              contextsWithKeyword.forEach(() => {
                colors.push(generalColor);
              });
            } else if (generalColor) {
              // No specific contexts, but we have a general color
              colors.push(generalColor);
            }
            
            // Remove duplicates while preserving order
            return [...new Set(colors)];
          } catch (e) {
            console.warn('Error collecting keyword colors:', e);
            return [];
          }
        },
        
        // Get gradient style for keyword badge in keyword bar (returns style string)
        getKeywordGradientStyle(keyword) {
          try {
            const colors = this.collectAllKeywordColors(keyword);
            
            if (colors.length === 0) {
              return '';
            } else if (colors.length === 1) {
              // Single color
              return `background-color: ${colors[0]} !important`;
            } else {
              // Multiple colors - create linear gradient
              const gradient = `linear-gradient(90deg, ${colors.join(', ')})`;
              return `background: ${gradient} !important`;
            }
          } catch (e) {
            console.warn('Error creating keyword gradient:', e);
            return '';
          }
        },
        
        cssClassFromUuid(prefix, uuid) {
          try {
            const base = String(uuid || '').toLowerCase();
            const safe = base.replace(/[^a-z0-9_-]/g, '-');
            return `${prefix}-uuid-${safe}`;
          } catch { return `${prefix}-uuid-unknown`; }
        },
        async copyToClipboard(text) {
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
            } else {
              const ta = document.createElement('textarea');
              ta.value = text;
              document.body.appendChild(ta);
              ta.select();
              document.execCommand('copy');
              document.body.removeChild(ta);
            }
            debugLog('log', '[CSS] Copied to clipboard:', text);
          } catch (e) { debugLog('warn', '[CSS] Copy failed', e); }
        },
        async copyGroupCssClass(group) {
          if (!group) return;
          const cls = this.cssClassFromUuid('group', group.uuid);
          await this.copyToClipboard('.' + cls + ' { }');
        },
        async copyLinkCssClass(link) {
          if (!link) return;
          const cls = this.cssClassFromUuid('link', link.uuid);
          await this.copyToClipboard('.' + cls + ' { }');
        },
        
        // Copy Group UUID to clipboard
        async copyGroupUuid(group, event) {
          if (!group || !group.uuid) return;
          try {
            // Check if Shift key is pressed - if so, copy as CSS selector
            let textToCopy = group.uuid;
            if (event && event.shiftKey) {
              textToCopy = `[data-group-uuid="${group.uuid}"]`;
            }
            
            await this.copyToClipboard(textToCopy);
            
            // Show success feedback
            const btn = event ? event.target : null;
            if (btn) {
              const originalText = btn.textContent;
              btn.textContent = '✅';
              setTimeout(() => {
                btn.textContent = originalText;
              }, 1000);
            }
            
            // If CSS Editor is open and shift key pressed, insert at cursor
            if (event && event.shiftKey && this.cssSidebarVisible && this.$refs.cssTextarea) {
              this.insertTextAtCursor(textToCopy);
            }
          } catch (e) {
            console.warn('Failed to copy UUID:', e);
          }
        },
        
        // Copy Link UUID to clipboard
        async copyLinkUuid(link, event) {
          if (!link || !link.uuid) return;
          try {
            // Check if Shift key is pressed - if so, copy as CSS selector
            let textToCopy = link.uuid;
            if (event && event.shiftKey) {
              textToCopy = `[data-link-uuid="${link.uuid}"]`;
            }
            
            await this.copyToClipboard(textToCopy);
            
            // Show success feedback
            const btn = event ? event.target : null;
            if (btn) {
              const originalText = btn.textContent;
              btn.textContent = '✅';
              setTimeout(() => {
                btn.textContent = originalText;
              }, 1000);
            }
            
            // If CSS Editor is open and shift key pressed, insert at cursor
            if (event && event.shiftKey && this.cssSidebarVisible && this.$refs.cssTextarea) {
              this.insertTextAtCursor(textToCopy);
            }
          } catch (e) {
            console.warn('Failed to copy UUID:', e);
          }
        },
        
        // Insert text at cursor position in CSS editor
        insertTextAtCursor(text) {
          const textarea = this.$refs.cssTextarea;
          if (!textarea) return;
          
          const start = textarea.selectionStart;
          const end = textarea.selectionEnd;
          const currentText = this.customCssDraft || '';
          
          // Insert text at cursor position
          this.customCssDraft = currentText.substring(0, start) + text + currentText.substring(end);
          
          // Apply the CSS
          this.applyCustomCssFromTextarea(false);
          
          // Restore cursor position after Vue updates the textarea
          this.$nextTick(() => {
            textarea.focus();
            const newPosition = start + text.length;
            textarea.setSelectionRange(newPosition, newPosition);
          });
        },
        
        // Handle keydown events in CSS textarea
        handleCssKeydown(event) {
          // Handle Tab key
          if (event.key === 'Tab') {
            event.preventDefault();
            
            const textarea = event.target;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;
            
            if (event.shiftKey) {
              // Shift+Tab: Remove indentation
              if (start === end) {
                // No selection - remove up to 2 spaces before cursor
                const lineStart = text.lastIndexOf('\n', start - 1) + 1;
                const beforeCursor = text.substring(lineStart, start);
                const spacesToRemove = beforeCursor.match(/^( {1,2})/);
                
                if (spacesToRemove) {
                  const removeCount = spacesToRemove[1].length;
                  this.customCssDraft = text.substring(0, lineStart) + 
                                       text.substring(lineStart + removeCount);
                  this.$nextTick(() => {
                    textarea.setSelectionRange(start - removeCount, start - removeCount);
                  });
                }
              } else {
                // Selection - remove indentation from all selected lines
                const lineStart = text.lastIndexOf('\n', start - 1) + 1;
                const lineEnd = text.indexOf('\n', end);
                const endPos = lineEnd === -1 ? text.length : lineEnd;
                
                const selectedLines = text.substring(lineStart, endPos);
                const dedentedLines = selectedLines.split('\n').map(line => {
                  return line.replace(/^( {1,2})/, '');
                }).join('\n');
                
                const lengthDiff = selectedLines.length - dedentedLines.length;
                this.customCssDraft = text.substring(0, lineStart) + dedentedLines + text.substring(endPos);
                
                this.$nextTick(() => {
                  textarea.setSelectionRange(
                    Math.max(lineStart, start - (start === lineStart ? 0 : Math.min(2, lengthDiff))),
                    end - lengthDiff
                  );
                });
              }
            } else {
              // Tab: Add 2 spaces
              if (start === end) {
                // No selection - insert 2 spaces
                this.customCssDraft = text.substring(0, start) + '  ' + text.substring(end);
                this.$nextTick(() => {
                  textarea.setSelectionRange(start + 2, start + 2);
                });
              } else {
                // Selection - indent all selected lines
                const lineStart = text.lastIndexOf('\n', start - 1) + 1;
                const lineEnd = text.indexOf('\n', end);
                const endPos = lineEnd === -1 ? text.length : lineEnd;
                
                const selectedLines = text.substring(lineStart, endPos);
                const indentedLines = selectedLines.split('\n').map(line => '  ' + line).join('\n');
                
                this.customCssDraft = text.substring(0, lineStart) + indentedLines + text.substring(endPos);
                
                this.$nextTick(() => {
                  const addedSpaces = indentedLines.length - selectedLines.length;
                  textarea.setSelectionRange(
                    start + (start === lineStart ? 2 : 0),
                    end + addedSpaces
                  );
                });
              }
            }
            
            // Apply the CSS after modification
            this.applyCustomCssFromTextarea(false);
          }
        },
        
        keywordSlug(kw) {
          try { return String(kw||'').trim().toLowerCase().replace(/\s+/g,'-').replace(/[^a-z0-9_-]/g,'-'); } catch { return ''; }
        },
        keywordClass(kw) {
          const slug = this.keywordSlug(kw);
          return slug ? `mb-keyword-kw-${slug}` : 'mb-keyword-kw';
        },
        ensureCustomStyleEl() {
          let el = document.getElementById('user-custom-css');
          if (!el) {
            el = document.createElement('style');
            el.id = 'user-custom-css';
            document.head.appendChild(el);
          }
          return el;
        },
        applyCustomCss(css) {
          const el = this.ensureCustomStyleEl();
          el.textContent = css || '';
        },
        openCssSidebar() {
          // Initialize Visual CSS Rules if not already loaded
          if (!this.visualCssRules || this.visualCssRules.length === 0) {
            this.loadVisualCssRules();
          }

          // Load custom rule sets
          this.loadCustomRuleSets();

          // Initialize available selectors
          this.initializeAvailableSelectors();

          // Check for legacy CSS migration
          this.checkAndMigrateLegacyCss();

          this.cssSidebarVisible = true;
          // Add class to body for layout adjustment
          document.body.classList.add('css-sidebar-open');
          // Use saved width if available, otherwise default
          const savedWidth = localStorage.getItem('cssSidebarWidth');
          if (savedWidth) {
            this.cssSidebarWidth = parseInt(savedWidth, 10);
          }
          document.body.style.marginRight = this.cssSidebarWidth + 'px';
        },

        closeCssSidebar() {
          this.cssSidebarVisible = false;
          // Remove class from body to restore layout
          document.body.classList.remove('css-sidebar-open');
          document.body.style.marginRight = '';
        },

        // Visual CSS Editor Methods
        initializeAvailableSelectors() {
          this.visualCssAvailableSelectors = [
            { value: 'body', label: 'Body (Entire Page)', supportsGroup: false, supportsLink: false },
            { value: '.mb-app', label: 'Application Container', supportsGroup: false, supportsLink: false },
            { value: '.mb-titlebar', label: 'Title Bar', supportsGroup: false, supportsLink: false },
            { value: '.mb-toolbar', label: 'Toolbar', supportsGroup: false, supportsLink: false },
            { value: '.mb-toolbar__search', label: 'Search Bar', supportsGroup: false, supportsLink: false },
            { value: '.mb-keywords-cloud', label: 'Keywords Cloud', supportsGroup: false, supportsLink: false },
            { value: '.mb-groups-container', label: 'Groups Container', supportsGroup: false, supportsLink: false },
            { value: '.mb-group', label: 'Group', supportsGroup: true, supportsLink: false },
            { value: '.mb-group__header', label: 'Group Header', supportsGroup: true, supportsLink: false },
            { value: '.mb-group__name', label: 'Group Name', supportsGroup: true, supportsLink: false },
            { value: '.mb-group__actions', label: 'Group Actions', supportsGroup: true, supportsLink: false },
            { value: '.mb-links-container', label: 'Links Container', supportsGroup: true, supportsLink: false },
            { value: '.mb-link', label: 'Link', supportsGroup: true, supportsLink: true },
            { value: '.mb-link__url', label: 'Link URL', supportsGroup: true, supportsLink: true },
            { value: '.mb-link__icon', label: 'Link Icon', supportsGroup: true, supportsLink: true },
            { value: '.mb-link__actions', label: 'Link Actions', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover', label: 'Link Popover Container', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__title', label: 'Link Popover Title', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__url', label: 'Link Popover URL', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__meta', label: 'Link Popover Metadata', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__row', label: 'Link Popover Row', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__label', label: 'Link Popover Label', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__value', label: 'Link Popover Value', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__value--muted', label: 'Link Popover Relative Text', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__keywords', label: 'Link Popover Keywords', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__badge', label: 'Link Popover Keyword Badge', supportsGroup: true, supportsLink: true },
            { value: '.link-detail-popover__favicon', label: 'Link Popover Favicon', supportsGroup: true, supportsLink: true }
          ];
        },

        loadVisualCssRules() {
          // Load tokens
          try {
            const tok = localStorage.getItem('designTokens');
            const parsed = tok ? JSON.parse(tok) : [];
            // Normalize tokens after loading to ensure consistent format (strip any leading dashes)
            this.designTokens = Array.isArray(parsed)
              ? parsed.map(t => ({
                  name: this.normalizeTokenName((t?.name || '').toString()),
                  value: (t?.value ?? '').toString()
                }))
              : [];
          } catch (e) { this.designTokens = []; }
          // Load selected template from localStorage
          const storedTemplate = localStorage.getItem('selectedVisualTemplate');
          if (storedTemplate) {
            this.selectedVisualTemplate = storedTemplate;
          }

          // Load rules from localStorage
          const storedRules = localStorage.getItem('visualCssRules');
          if (storedRules) {
            try {
              const parsedRules = JSON.parse(storedRules);

              // Deep clone each rule to ensure independent selector objects
              this.visualCssRules = parsedRules.map(rule => {
                // Create a deep copy of the rule to avoid shared references
                const clonedRule = JSON.parse(JSON.stringify(rule));

                // Convert old format selectors to new format
                if (typeof clonedRule.selector === 'string') {
                  clonedRule.selector = {
                    base: clonedRule.selector,
                    groupId: clonedRule.groupId || null,
                    linkId: clonedRule.linkId || null
                  };
                }
                // Ensure selector is an object
                if (!clonedRule.selector || typeof clonedRule.selector !== 'object') {
                  clonedRule.selector = {
                    base: '',
                    groupId: null,
                    linkId: null
                  };
                }
                return clonedRule;
              });
            } catch (e) {
              console.error('Failed to parse stored visual CSS rules:', e);
              this.visualCssRules = [];
            }
          } else {
            this.visualCssRules = [];
          }

          // Apply the CSS immediately
          this.applyVisualCss();
        },

        checkAndMigrateLegacyCss() {
          // Check if there's legacy custom CSS to migrate
          // Only migrate once - check if migration was already attempted
          if (this.data.options?.visualCssMigrated) {
            return; // Migration already done or skipped
          }

          // Check if we already have visual CSS rules stored
          if (this.data.options?.visualCssRules && this.data.options.visualCssRules.length > 0) {
            // We have visual rules, no need to migrate
            return;
          }

          const legacyCss = this.data.options?.customCss;
          // Only migrate if we have legacy CSS AND no visual rules AND no previous migration
          if (legacyCss && legacyCss.trim() &&
              this.visualCssRules.length === 0 &&
              !legacyCss.includes('/* Template:') && // Don't migrate generated CSS
              !legacyCss.includes('/* User Rules')) {  // Don't migrate generated CSS
            this.showMigrationNotice = true;
            // Auto-migrate simple CSS rules if possible
            this.attemptCssMigration(legacyCss);

            // Mark as migrated to prevent future auto-migration
            if (!this.data.options) {
              this.data.options = {};
            }
            this.data.options.visualCssMigrated = true;
            this.saveData();
          }
        },

        attemptCssMigration(cssText) {
          // Simple migration: Convert CSS text to visual rules
          // This is a basic implementation - can be enhanced
          const migrationRule = {
            id: Date.now(),
            enabled: true,
            selector: {
              base: 'body',
              groupId: null,
              linkId: null,
              keywordSlug: null
            },
            groupId: null,
            linkId: null,
            properties: {
              custom: cssText
            },
            important: {},
            customCss: cssText
          };

          this.visualCssRules.push(migrationRule);
          this.saveVisualCss();
        },

        addNewCssRule() {
          const ruleCount = this.visualCssRules.length + 1;
          const newRule = {
            id: Date.now(),
            name: `${this.getTranslation('css.visual.rule') || 'Regel'} ${ruleCount}`,
            enabled: true,
            selector: {
              base: '',
              groupId: null,
              linkId: null
            },
            groupId: null,
            linkId: null,
            properties: {},
            important: {},
            customCss: ''
          };

          this.visualCssRules.push(newRule);

          // Load template properties for this rule if a template is selected
          if (this.selectedVisualTemplate && newRule.selector.base) {
            this.loadTemplatePropertiesForRule(newRule);
          }

          this.saveVisualCss();
        },

        toggleCssRule(rule) {
          rule.enabled = !rule.enabled;
          this.saveVisualCss();
        },

        moveCssRuleUp(index) {
          if (index <= 0) return;
          const [rule] = this.visualCssRules.splice(index, 1);
          this.visualCssRules.splice(index - 1, 0, rule);
          this.saveVisualCss();
        },

        moveCssRuleDown(index) {
          if (index < 0 || index >= this.visualCssRules.length - 1) return;
          const [rule] = this.visualCssRules.splice(index, 1);
          this.visualCssRules.splice(index + 1, 0, rule);
          this.saveVisualCss();
        },

        duplicateCssRule(rule) {
          // Create a deep copy to avoid shared references
          const duplicate = JSON.parse(JSON.stringify(rule));
          duplicate.id = Date.now();
          duplicate.name = (rule.name || this.getTranslation('css.visual.rule') || 'Regel') + ' ' + (this.getTranslation('css.visual.copy') || 'Kopie');

          const index = this.visualCssRules.indexOf(rule);
          this.visualCssRules.splice(index + 1, 0, duplicate);
          this.saveVisualCss();
        },

        deleteCssRule(rule) {
          const index = this.visualCssRules.indexOf(rule);
          if (index > -1) {
            this.visualCssRules.splice(index, 1);
            // Remove from collapsed list if present
            const ci = this.collapsedRules.indexOf(rule.id);
            if (ci > -1) this.collapsedRules.splice(ci, 1);
            this.saveCollapsedRules();
            this.saveVisualCss();
          }
        },

        startEditingRuleName(rule) {
          this.editingRuleId = rule.id;
          this.editingRuleName = rule.name || `${this.getTranslation('css.visual.rule') || 'Regel'} ${this.visualCssRules.indexOf(rule) + 1}`;
          this.$nextTick(() => {
            const input = this.$refs.ruleNameInput;
            if (input && Array.isArray(input)) {
              input[0].focus();
              input[0].select();
            } else if (input) {
              input.focus();
              input.select();
            }
          });
        },
        saveRuleName(rule) {
          if (this.editingRuleName && this.editingRuleName.trim()) {
            rule.name = this.editingRuleName.trim();
            this.saveVisualCss();
          }
          this.cancelEditingRuleName();
        },
        cancelEditingRuleName() {
          this.editingRuleId = null;
          this.editingRuleName = '';
        },
        toggleRuleCollapse(rule) {
          const index = this.collapsedRules.indexOf(rule.id);
          if (index > -1) {
            this.collapsedRules.splice(index, 1);
          } else {
            this.collapsedRules.push(rule.id);
          }
          this.saveCollapsedRules();
        },
        isRuleCollapsed(rule) {
          return this.collapsedRules.includes(rule.id);
        },
        expandAllRules() {
          this.collapsedRules = [];
          this.saveCollapsedRules();
        },
        collapseAllRules() {
          this.collapsedRules = this.visualCssRules.map(rule => rule.id);
          this.saveCollapsedRules();
        },
        clearAllCssSettings() {
          // Ask for confirmation
          if (!confirm(this.getTranslation('css.visual.clearAllConfirm') || 'Möchten Sie wirklich ALLE CSS-Einstellungen löschen?\n\nDies entfernt:\n• Alle CSS-Regeln\n• Das ausgewählte Template\n• Alle gespeicherten Regel-Sätze\n\nDiese Aktion kann nicht rückgängig gemacht werden!')) {
            return;
          }

          // Clear all CSS rules
          this.visualCssRules = [];

          // Clear selected template
          this.selectedVisualTemplate = null;

          // Clear selected rule set
          this.selectedRuleSetName = null;

          // Clear all saved rule sets
          this.customRuleSets = {};

          // Clear from localStorage
          localStorage.removeItem('visualCssRules');
          localStorage.removeItem('selectedVisualTemplate');
          localStorage.removeItem('customRuleSets');

          // Clear the applied CSS
          this.applyCustomCss('');

          // Save the empty state
          this.saveVisualCss();

          // Show success message
          this.showToast(this.getTranslation('css.visual.clearedAll') || 'Alle CSS-Einstellungen wurden gelöscht', 'success');
        },

        clearRuleProperties(rule) {
          // Clear all properties
          rule.properties = {};

          // Clear custom CSS
          rule.customCss = '';

          // Clear important flags
          rule.important = {};

          // Save the changes
          this.saveVisualCss();

          // Show success message
          this.showToast(this.getTranslation('css.visual.propertiesCleared') || 'Eigenschaften gelöscht', 'success');
        },

        updateRuleSelector(rule) {
          // Reset group and link when selector changes
          const selectorInfo = this.visualCssAvailableSelectors.find(s => s.value === rule.selector);
          if (selectorInfo) {
            if (!selectorInfo.supportsGroup) {
              rule.groupId = null;
              rule.linkId = null;
            }
            if (!selectorInfo.supportsLink) {
              rule.linkId = null;
            }
          }
        },

        updateRuleGroup(rule) {
          // Reset link when group changes
          rule.linkId = null;
        },

        

        removePropertyFromRule(rule, property) {
          this.$delete(rule.properties, property);
        },

        generateCssSelector(rule) {
          // Ensure selector is an object
          const selectorObj = this.getRuleSelector(rule);

          console.log('generateCssSelector - rule:', JSON.stringify(rule));
          console.log('generateCssSelector - selectorObj:', JSON.stringify(selectorObj));
          console.log('generateCssSelector - groupId type:', typeof selectorObj.groupId, 'value:', selectorObj.groupId);

          // Map base selector to actual CSS selector
          const baseSelectorMap = {
            'app': '#app',
            'header': '.mb-titlebar',
            'toolbar': '.mb-toolbar',
            'footer': '.mb-footer',
            'groups-links-container': '.mb-groups-links-container',
            'groups': '.mb-group',
            'group-header': '.mb-group__header',
            'group-title': '.mb-group__title',
            'group-body': '.mb-group__body',  // Group content area
            'links': '.mb-link',
            'link-hover': '.mb-link:hover',
            'link-anchor': '.mb-link__anchor',
            'link-url': '.mb-link__url',
            'link-icon': '.mb-link__icon',
            'link-popover': '.link-detail-popover',
            'link-popover-title': '.link-detail-popover__title',
            'link-popover-url': '.link-detail-popover__url',
            'link-popover-meta': '.link-detail-popover__meta',
            'link-popover-row': '.link-detail-popover__row',
            'link-popover-label': '.link-detail-popover__label',
            'link-popover-value': '.link-detail-popover__value',
            'link-popover-value-muted': '.link-detail-popover__value--muted',
            'link-popover-keywords': '.link-detail-popover__keywords',
            'link-popover-badge': '.link-detail-popover__badge',
            'link-popover-favicon': '.link-detail-popover__favicon',
            // Keyword selectors
            'keywords': '.mb-keyword',  // Keywords in keyword bar
            'keywords-hierarchical': '.keyword-badge',  // All keyword badges (common class)
            'body': 'body'
          };

          let baseSelector = baseSelectorMap[selectorObj.base] || selectorObj.base || '*';
          let fullSelector = baseSelector;

          // Handle different selector types
          if (selectorObj.base === 'keyword-by-name' && selectorObj.keywordSlug) {
            // Use the slug directly since it's already stored
            const slug = selectorObj.keywordSlug;
            // Use the mb-keyword-kw-{slug} class that's already added to keywords
            fullSelector = `.mb-keyword-kw-${slug}`;
          } else if (selectorObj.base && selectorObj.base.startsWith('badges-')) {
            // Special handling for badge selectors
            if (selectorObj.groupId) {
              const group = this.data.groups.find(g =>
                g.id === selectorObj.groupId ||
                g.uuid === selectorObj.groupId ||
                g.id === parseInt(selectorObj.groupId)
              );
              if (group) {
                // For badge selectors, scope to specific group
                fullSelector = `.mb-group[data-uuid="${group.uuid}"] ${baseSelector}`;

                // If link-specific badge and link is selected
                if ((selectorObj.base === 'badges-link' || selectorObj.base === 'badges-link-keywords') && selectorObj.linkId) {
                  const link = group.links.find(l =>
                    l.id === selectorObj.linkId ||
                    l.uuid === selectorObj.linkId ||
                    l.id === parseInt(selectorObj.linkId)
                  );
                  if (link) {
                    const linkUuid = link.uuid || link.id;
                    fullSelector = `.mb-group[data-uuid="${group.uuid}"] .mb-link[data-uuid="${linkUuid}"] ${baseSelector}`;
                  }
                }
              }
            }
          } else if (selectorObj.base === 'keywords-hierarchical') {
            // Hierarchical keyword selector - scopes based on group/link selection
            if (selectorObj.keywordSlug) {
              // Specific keyword selected
              fullSelector = `.mb-keyword-kw-${selectorObj.keywordSlug}`;
            } else {
              // All keywords
              fullSelector = baseSelector;
            }

            // Apply hierarchical scoping
            if (selectorObj.groupId && selectorObj.linkId) {
              // Scope to specific link
              const group = this.data.groups.find(g =>
                g.id === selectorObj.groupId ||
                g.uuid === selectorObj.groupId ||
                g.id === parseInt(selectorObj.groupId)
              );
              if (group) {
                const link = group.links.find(l =>
                  l.id === selectorObj.linkId ||
                  l.uuid === selectorObj.linkId ||
                  l.id === parseInt(selectorObj.linkId)
                );
                if (link) {
                  const linkUuid = link.uuid || link.id;
                  fullSelector = `.mb-group[data-uuid="${group.uuid}"] .mb-link[data-uuid="${linkUuid}"] ${fullSelector}`;
                }
              }
            } else if (selectorObj.groupId) {
              // Scope to specific group
              const group = this.data.groups.find(g =>
                g.id === selectorObj.groupId ||
                g.uuid === selectorObj.groupId ||
                g.id === parseInt(selectorObj.groupId)
              );
              if (group) {
                fullSelector = `.mb-group[data-uuid="${group.uuid}"] ${fullSelector}`;
              }
            }
          } else if (selectorObj.base === 'keywords-in-group') {
            // Keywords within a specific group
            if (selectorObj.keywordSlug) {
              // Specific keyword in group
              fullSelector = `.mb-keyword-kw-${selectorObj.keywordSlug}`;
              if (selectorObj.groupId) {
                const group = this.data.groups.find(g =>
                  g.id === selectorObj.groupId ||
                  g.uuid === selectorObj.groupId ||
                  g.id === parseInt(selectorObj.groupId)
                );
                if (group) {
                  fullSelector = `.mb-group[data-uuid="${group.uuid}"] ${fullSelector}`;
                }
              }
            } else if (selectorObj.groupId) {
              // All keywords in group
              const group = this.data.groups.find(g =>
                g.id === selectorObj.groupId ||
                g.uuid === selectorObj.groupId ||
                g.id === parseInt(selectorObj.groupId)
              );
              if (group) {
                fullSelector = `.mb-group[data-uuid="${group.uuid}"] ${baseSelector}`;
              }
            } else {
              // All keywords in all groups
              fullSelector = baseSelector;
            }
          } else if (selectorObj.base === 'keywords-in-link') {
            // Keywords within a specific link
            if (selectorObj.keywordSlug) {
              // Specific keyword in link
              fullSelector = `.mb-keyword-kw-${selectorObj.keywordSlug}`;
              if (selectorObj.groupId && selectorObj.linkId) {
                const group = this.data.groups.find(g =>
                  g.id === selectorObj.groupId ||
                  g.uuid === selectorObj.groupId ||
                  g.id === parseInt(selectorObj.groupId)
                );
                if (group) {
                  const link = group.links.find(l =>
                    l.id === selectorObj.linkId ||
                    l.uuid === selectorObj.linkId ||
                    l.id === parseInt(selectorObj.linkId)
                  );
                  if (link) {
                    const linkUuid = link.uuid || link.id;
                    fullSelector = `.mb-group[data-uuid="${group.uuid}"] .mb-link[data-uuid="${linkUuid}"] ${fullSelector}`;
                  }
                }
              }
            } else if (selectorObj.groupId && selectorObj.linkId) {
              // All keywords in specific link
              const group = this.data.groups.find(g =>
                g.id === selectorObj.groupId ||
                g.uuid === selectorObj.groupId ||
                g.id === parseInt(selectorObj.groupId)
              );
              if (group) {
                const link = group.links.find(l =>
                  l.id === selectorObj.linkId ||
                  l.uuid === selectorObj.linkId ||
                  l.id === parseInt(selectorObj.linkId)
                );
                if (link) {
                  const linkUuid = link.uuid || link.id;
                  fullSelector = `.mb-group[data-uuid="${group.uuid}"] .mb-link[data-uuid="${linkUuid}"] ${baseSelector}`;
                }
              }
            }
          } else if (selectorObj.groupId && selectorObj.groupId !== null && selectorObj.groupId !== 'null') {
            // Regular group-specific selector
            const group = this.data.groups.find(g =>
              g.id === selectorObj.groupId ||
              g.uuid === selectorObj.groupId ||
              g.id === parseInt(selectorObj.groupId)
            );

            if (group) {
              const groupUuid = group.uuid;

              // If this rule targets the group element itself, don't append a descendant
              if (baseSelector === '.mb-group') {
                fullSelector = `.mb-group[data-uuid="${groupUuid}"]`;
              } else {
                fullSelector = `.mb-group[data-uuid="${groupUuid}"] ${baseSelector}`;
              }

              // Link-specific targeting
              if (selectorObj.linkId && selectorObj.linkId !== null && selectorObj.linkId !== 'null') {
                const link = group.links.find(l =>
                  l.id === selectorObj.linkId ||
                  l.uuid === selectorObj.linkId ||
                  l.id === parseInt(selectorObj.linkId)
                );
                if (link) {
                  const linkUuid = link.uuid || link.id;
                  const linkBase = `.mb-group[data-uuid="${groupUuid}"] .mb-link[data-uuid="${linkUuid}"]`;
                  if (baseSelector === '.mb-link') {
                    // Target the link element itself
                    fullSelector = linkBase;
                  } else if (baseSelector === '.mb-link:hover') {
                    // Hover state of the link element itself
                    fullSelector = `${linkBase}:hover`;
                  } else {
                    // Target child within the link (anchor/url/icon/etc.)
                    fullSelector = `${linkBase} ${baseSelector}`;
                  }
                }
              }
            }
          }

          return fullSelector;
        },

        generateFullCss() {
          let css = '';

          // Inject design tokens as CSS variables on :root
          if (this.designTokens && this.designTokens.length > 0) {
            css += ':root{\n';
            for (const t of this.designTokens) {
              if (!t || !t.name) continue;
              const name = this.normalizeTokenName(String(t.name));
              const value = (t.value ?? '').toString().trim();
              if (!name || !value) continue;
              css += `  --${name}: ${value};\n`;
            }
            css += '}\n\n';
          }

          // First, generate CSS from the selected template (base layer)
          if (this.selectedVisualTemplate) {
            const templateRules = this.getCurrentTemplate();
            css += '/* Template: ' + this.selectedVisualTemplate + ' */\n';

            for (const rule of templateRules) {
              if (!rule.enabled || !rule.selector) continue;

              const selector = this.generateCssSelector(rule);
              const properties = [];

              for (const [prop, value] of Object.entries(rule.properties)) {
                if (value) {
                  properties.push(`  ${prop}: ${value};`);
                }
              }

              if (properties.length > 0) {
                css += `${selector} {\n${properties.join('\n')}\n}\n`;
              }
            }
          }

          // Then, generate CSS from user rules (override layer)
          if (this.visualCssRules.length > 0) {
            css += '\n/* User Rules (Override Template) */\n';

            for (const rule of this.visualCssRules) {
              if (!rule.enabled || !rule.selector) continue;
              const selObj = this.getRuleSelector(rule);
              // Skip rules without a selected element ("-- Element wählen --")
              if (!selObj.base) continue;

              const selector = this.generateCssSelector(rule);
              const properties = [];

              for (const [prop, value] of Object.entries(rule.properties)) {
                if (!value) continue;
                if (rule.disabled && rule.disabled[prop]) continue;
                if (prop === 'custom') {
                  // Treat as inline properties inside this selector (one per line)
                  const customLines = String(value).split('\n').filter(line => line.trim());
                  for (const line of customLines) {
                    if (line.includes(':')) {
                      properties.push(`  ${line.trim()}`);
                    }
                  }
                } else {
                  // Add !important if enabled for this property
                  const important = rule.important && rule.important[prop] ? ' !important' : '';
                  properties.push(`  ${prop}: ${value}${important};`);
                }
              }

          // Add custom CSS properties if present (legacy support)
          if (rule.customCss) {
            const customLines = rule.customCss.split('\n').filter(line => line.trim());
            for (const line of customLines) {
              if (line.includes(':')) {
                properties.push(`  ${line.trim()}`);
              }
            }
          }

              if (properties.length > 0) {
                css += `${selector} {\n${properties.join('\n')}\n}\n`;
              }
            }
          }

          return css;
        },

        saveVisualCss() {
          console.log('Saving Visual CSS Rules:', JSON.stringify(this.visualCssRules));
          console.log('Selected Template:', this.selectedVisualTemplate);

          // Save rules to localStorage
          localStorage.setItem('visualCssRules', JSON.stringify(this.visualCssRules));

          // Save selected template
          if (this.selectedVisualTemplate) {
            localStorage.setItem('selectedVisualTemplate', this.selectedVisualTemplate);
          }

          // Generate and apply CSS live
          this.applyVisualCss();
        },

        applyVisualCss() {
          const css = this.generateFullCss();
          this.applyCustomCss(css);

          // Also save to data.options for persistence
          if (!this.data.options) {
            this.data.options = {};
          }
          this.data.options.visualCssRules = this.visualCssRules;
          this.data.options.customCss = css; // Keep for backwards compatibility
          this.saveData();
        },

        // Persist/restore Design Tokens collapsed state
        toggleDesignTokensCollapse() {
          this.designTokensCollapsed = !this.designTokensCollapsed;
          this.saveDesignTokensCollapsed();
        },
        saveDesignTokensCollapsed() {
          try { localStorage.setItem('designTokensCollapsed', this.designTokensCollapsed ? '1' : '0'); } catch {}
        },
        loadDesignTokensCollapsed() {
          try {
            const v = localStorage.getItem('designTokensCollapsed');
            this.designTokensCollapsed = v === '1';
          } catch { this.designTokensCollapsed = false; }
        },

        // Persist/restore collapsed state of rule cards
        saveCollapsedRules() {
          try {
            localStorage.setItem('visualCssCollapsedRules', JSON.stringify(this.collapsedRules || []));
          } catch (e) { /* ignore */ }
        },
        loadCollapsedRules() {
          try {
            const stored = localStorage.getItem('visualCssCollapsedRules');
            const arr = stored ? JSON.parse(stored) : [];
            if (Array.isArray(arr)) this.collapsedRules = arr;
          } catch (e) { this.collapsedRules = []; }
        },

        copyCssToClipboard() {
          const css = this.generateFullCss();
          navigator.clipboard.writeText(css).then(() => {
            alert('CSS wurde in die Zwischenablage kopiert!');
          }).catch(err => {
            console.error('Failed to copy CSS:', err);
            alert('Fehler beim Kopieren des CSS');
          });
        },

        // Element Picker
        startElementPicker(rule) {
          if (this.elementPickerActive && this.currentPickerRule && this.currentPickerRule.id === rule.id) {
            return this.stopElementPicker();
          }
          this.currentPickerRule = rule;
          this.elementPickerActive = true;
          document.addEventListener('mouseover', this.onPickerMouseOver, true);
          document.addEventListener('mouseout', this.onPickerMouseOut, true);
          document.addEventListener('click', this.onPickerClick, true);
          this.showToast(this.getTranslation('css.visual.pickerActive') || 'Element-Picker aktiv: Klicke ein Element im Inhalt', 'info');
        },
        stopElementPicker() {
          this.elementPickerActive = false;
          this.currentPickerRule = null;
          document.removeEventListener('mouseover', this.onPickerMouseOver, true);
          document.removeEventListener('mouseout', this.onPickerMouseOut, true);
          document.removeEventListener('click', this.onPickerClick, true);
          this.clearPickerHighlight();
        },
        onPickerMouseOver(e) {
          if (!this.elementPickerActive) return;
          const t = e.target;
          if (t.closest('.mb-css-sidebar')) return; // ignore sidebar
          this.highlightElement(t);
        },
        onPickerMouseOut(e) {
          if (!this.elementPickerActive) return;
          // optional: keep highlight on current element
        },
        onPickerClick(e) {
          if (!this.elementPickerActive) return;
          const t = e.target;
          if (t.closest('.mb-css-sidebar')) return;
          e.preventDefault();
          e.stopPropagation();
          try {
            const base = this.detectBaseForElement(t);
            const pickedRule = this.currentPickerRule;
            if (base && pickedRule) {
              // Update base
              // Pass a flag to avoid auto-adding template properties when picking
              const evt = { target: { value: base }, fromPicker: true };
              this.updateRuleBase(pickedRule, evt);
              // Ensure dropdown reflects pick
              this.$nextTick(() => {
                if (!pickedRule) return;
                const refKey = 'baseSelector-' + pickedRule.id;
                const el = this.$refs[refKey];
                if (el) {
                  if (Array.isArray(el) && el[0]) el[0].value = base;
                  else el.value = base;
                }
              });
              // Optionally detect group/link IDs
              const groupEl = t.closest('.mb-group');
              if (groupEl && groupEl.dataset && groupEl.dataset.uuid) {
                const gevt = { target: { value: groupEl.dataset.uuid } };
                this.updateRuleGroupId(pickedRule, gevt);
              }
              const linkEl = t.closest('.mb-link');
              if (linkEl && linkEl.dataset && linkEl.dataset.uuid) {
                const levt = { target: { value: linkEl.dataset.uuid } };
                this.updateRuleLinkId(pickedRule, levt);
              }
              this.showToast((this.getTranslation('css.visual.picked') || 'Ausgewählt') + ': ' + base, 'success');
            }
          } finally {
            this.stopElementPicker();
          }
        },
        highlightElement(el) {
          this.clearPickerHighlight();
          this.lastHighlightedEl = el;
          this.lastHighlightedOutline = el.style.outline;
          el.style.outline = '2px solid #0d6efd';
          el.style.outlineOffset = '2px';
        },
        clearPickerHighlight() {
          if (this.lastHighlightedEl) {
            this.lastHighlightedEl.style.outline = this.lastHighlightedOutline || '';
            this.lastHighlightedEl.style.outlineOffset = '';
            this.lastHighlightedEl = null;
            this.lastHighlightedOutline = null;
          }
        },
        detectBaseForElement(el) {
          // Check most specific targets first; body last
          const candidates = [
            { base: 'link-anchor', sel: '.mb-link__anchor' },
            { base: 'link-url', sel: '.mb-link__url' },
            { base: 'link-icon', sel: '.mb-link__icon' },
            { base: 'links', sel: '.mb-link' },
            { base: 'group-title', sel: '.mb-group__title' },
            { base: 'group-header', sel: '.mb-group__header' },
            { base: 'group-body', sel: '.mb-group__body' },
            { base: 'groups', sel: '.mb-group' },
            { base: 'toolbar', sel: '.mb-toolbar' },
            { base: 'header', sel: '.mb-titlebar' },
            { base: 'footer', sel: '.mb-footer' },
            { base: 'app', sel: '#app' },
            { base: 'keywords', sel: '.mb-keyword' },
            { base: 'body', sel: 'body' }
          ];
          for (const c of candidates) {
            if (el.closest(c.sel)) return c.base;
          }
          return '';
        },

        

        exportVisualCssRules() {
          const dataStr = JSON.stringify(this.visualCssRules, null, 2);
          const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

          const exportName = 'visual-css-rules-' + new Date().toISOString().slice(0, 10) + '.json';

          const linkElement = document.createElement('a');
          linkElement.setAttribute('href', dataUri);
          linkElement.setAttribute('download', exportName);
          linkElement.click();
        },

        importVisualCssRules(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const rules = JSON.parse(e.target.result);
              if (Array.isArray(rules)) {
                this.visualCssRules = rules;
                this.saveVisualCss();
                alert('CSS rules imported successfully!');
              } else {
                alert('Invalid rules file format');
              }
            } catch (err) {
              alert('Failed to import rules: ' + err.message);
            }
          };
          reader.readAsText(file);
        },

        // Helper methods for Visual CSS Editor
        canSelectGroup(rule) {
          // Get the selector object
          const selector = this.getRuleSelector(rule);

          // Can select group if base selector supports groups
          const groupSupportingSelectors = [
            'groups', 'group-header', 'group-title', 'group-body',
            'links', 'link-hover', 'link-anchor', 'link-url', 'link-icon',
            'link-popover', 'link-popover-title', 'link-popover-url', 'link-popover-meta',
            'link-popover-row', 'link-popover-label', 'link-popover-value', 'link-popover-value-muted',
            'link-popover-keywords', 'link-popover-badge', 'link-popover-favicon',
            'badges-group', 'badges-group-linkcount', 'badges-group-keywords',
            'badges-link', 'badges-link-keywords',
            'keywords-hierarchical'  // New hierarchical keyword selector
            // keyword-by-name removed - no group selection needed
          ];

          // Don't show group selector for global selectors
          const canSelect = groupSupportingSelectors.includes(selector.base);

          console.log('canSelectGroup:', {
            base: selector.base,
            canSelect: canSelect,
            supportingSelectors: groupSupportingSelectors
          });

          return canSelect;
        },

        canSelectLink(rule) {
          // Get the selector object
          const selector = this.getRuleSelector(rule);

          // Can select link if:
          // 1. A group is selected AND the base selector supports link selection
          const linkSupportingSelectors = [
            'links', 'link-hover', 'link-anchor', 'link-url', 'link-icon',
            'link-popover', 'link-popover-title', 'link-popover-url', 'link-popover-meta',
            'link-popover-row', 'link-popover-label', 'link-popover-value', 'link-popover-value-muted',
            'link-popover-keywords', 'link-popover-badge', 'link-popover-favicon',
            'badges-link', 'badges-link-keywords',
            'keywords-hierarchical'  // Can optionally select link for more specific targeting
          ];

          return selector.groupId && linkSupportingSelectors.includes(selector.base);
        },

        getLinksForRule(rule) {
          const selector = this.getRuleSelector(rule);
          if (!selector.groupId) return [];

          // Find group by id or uuid
          const group = this.data.groups.find(g =>
            g.id === selector.groupId ||
            g.uuid === selector.groupId
          );

          return group ? group.links.filter(l => !l.deleted) : [];
        },

        getSelectorInfo(selectorValue) {
          return this.visualCssAvailableSelectors.find(s => s.value === selectorValue) || {};
        },

        formatPropertyName(property) {
          // Convert CSS property names to readable format
          const propertyMap = {
            'custom': 'Custom CSS',
            'background': 'Background',
            'background-color': 'Background Color',
            'color': 'Text Color',
            'font-size': 'Font Size',
            'font-weight': 'Font Weight',
            'border': 'Border',
            'border-color': 'Border Color',
            'border-radius': 'Border Radius',
            'padding': 'Padding',
            'margin': 'Margin',
            'display': 'Display',
            'opacity': 'Opacity',
            'text-decoration': 'Text Decoration',
            'text-transform': 'Text Transform',
            'box-shadow': 'Box Shadow',
            'width': 'Width',
            'height': 'Height'
          };
          return propertyMap[property] || property.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        },

        isColorProperty(property) {
          // Only treat explicit color properties as color inputs
          // Examples: color, background-color, border-top-color, outline-color
          if (!property) return false;
          return property === 'color' || property.endsWith('color');
        },

        validateProperty(rule, property) {
          // Validate CSS property value and persist
          const value = rule.properties[property];
          if (!value || value.trim() === '') {
            delete rule.properties[property];
            this.saveVisualCss();
            return;
          }
          // Trigger re-render to apply is-invalid class; do not auto-remove invalid entries
          this.$forceUpdate();
          this.saveVisualCss();
        },

        // Tokens
        addDesignToken() {
          this.designTokens.push({ name: 'token', value: '#3b82f6' });
          this.saveDesignTokens();
        },
        removeDesignToken(idx) {
          this.designTokens.splice(idx, 1);
          this.saveDesignTokens();
        },
        saveDesignTokens() {
          // Normalize all tokens before saving (store without leading --)
          this.designTokens = (this.designTokens || []).map(t => {
            const name = this.normalizeTokenName(t?.name || '');
            const value = (t?.value ?? '').toString();
            return { name, value };
          });
          localStorage.setItem('designTokens', JSON.stringify(this.designTokens));
          // Apply immediately so token changes are reflected live
          this.applyVisualCss();
        },
        normalizeTokenName(raw) {
          const s = (raw || '').toString().trim().toLowerCase();
          // Remove any leading dashes users might paste
          const noPrefix = s.replace(/^[-]+/, '');
          // Allow only a-z, 0-9, '-', '_'
          const cleaned = noPrefix.replace(/[^a-z0-9_-]/g, '');
          if (!cleaned) return 'token';
          return cleaned;
        },
        onTokenNameInput(token, event) {
          const sanitized = this.normalizeTokenName(event.target.value);
          event.target.value = sanitized; // reflect immediately in input
          token.name = sanitized;
          this.saveDesignTokens();
        },
        onTokenValueInput(token, event) {
          token.value = (event.target.value || '').toString();
          this.saveDesignTokens();
        },
        applyTokenToProperty(rule, prop, tokenName) {
          if (!tokenName) return;
          const name = this.normalizeTokenName(tokenName);
          this.$set(rule.properties, prop, `var(--${name})`);
          this.saveVisualCss();
        },

        removeProperty(rule, property) {
          // Remove a CSS property from a rule
          delete rule.properties[property];
          // Also remove the important flag for this property
          if (rule.important && rule.important[property]) {
            delete rule.important[property];
          }
          // Also remove disabled state for this property
          if (rule.disabled && rule.disabled[property]) {
            delete rule.disabled[property];
          }
          this.saveVisualCss();
        },

        // Presets
        applyPresetToRule(rule, event) {
          const pid = event.target.value;
          if (!pid) return;
          const preset = this.cssPresets.find(p => p.id === pid);
          if (!preset) return;
          if (!rule.properties) this.$set(rule, 'properties', {});
          Object.entries(preset.properties).forEach(([k, v]) => {
            this.$set(rule.properties, k, v);
          });
          // reset select
          event.target.value = '';
          this.saveVisualCss();
          this.showToast((this.getTranslation('css.visual.presetApplied') || 'Preset angewendet') + ': ' + preset.name, 'success');
        },

        isPropertyInRule(rule, property) {
          return rule.properties && rule.properties[property] !== undefined;
        },

        addPropertyToRule(rule, event) {
          // Add a new CSS property to a rule
          const property = event.target.value;
          if (!property) return;

          // Check if property already exists
          if (rule.properties && rule.properties.hasOwnProperty(property)) {
            // Property already exists, show warning and reset dropdown
            this.showToast(this.getTranslation('css.visual.propertyAlreadyExists') || `Die Eigenschaft "${property}" existiert bereits in dieser Regel`, 'warning');
            event.target.value = '';
            return;
          }

          // Initialize important object if not exists
          if (!rule.important) {
            rule.important = {};
          }

          // Do not set default values; start empty for all properties
          rule.properties[property] = '';

          // Do not pre-set !important; user opts in manually

          event.target.value = '';
          this.saveVisualCss();
        },

        getValidHexColor(value) {
          // Return a safe hex color for the color picker without mutating rule state
          const v = (value || '').trim();
          const hex6 = /^#([0-9a-fA-F]{6})$/;
          if (hex6.test(v)) return v;
          // Accept 3-digit hex by expanding
          const hex3 = /^#([0-9a-fA-F]{3})$/;
          if (hex3.test(v)) {
            const m = v.substring(1);
            return '#' + m[0]+m[0] + m[1]+m[1] + m[2]+m[2];
          }
          // Fallback swatch color; does not change actual property value
          return '#000000';
        },

        onColorPickerChange(rule, property, event) {
          const val = event.target.value;
          this.$set(rule.properties, property, val);
          this.saveVisualCss();
        },

        getPropertyImportant(rule, property) {
          // Check if a property is marked as important
          if (!rule.important) {
            rule.important = {};
          }
          return rule.important[property] || false;
        },

        togglePropertyImportant(rule, property) {
          // Toggle the important flag for a property
          if (!rule.important) {
            rule.important = {};
          }
          rule.important[property] = !rule.important[property];
          this.saveVisualCss();
        },

        // ===== CSS Validation Helpers =====
        stripImportant(v) {
          return (v || '').toString().replace(/\s*!important\s*$/i, '').trim();
        },
        hasVarFunction(v) {
          return /var\(\s*--[a-z0-9_-]+\s*\)/i.test(v || '');
        },
        extractVarNames(v) {
          const out = []; const re = /var\(\s*(--[a-z0-9_-]+)\s*\)/ig; let m;
          const s = (v || '').toString();
          while ((m = re.exec(s)) !== null) out.push(m[1]);
          return out;
        },
        tokenExists(name) {
          const n = (name || '').replace(/^--+/, '').toLowerCase();
          return (this.designTokens || []).some(t => (t?.name || '').toLowerCase() === n);
        },
        cssSupports(prop, value) {
          try { if (window.CSS && CSS.supports) return CSS.supports(prop, value); } catch {}
          // Fallback test element
          try {
            const el = document.createElement('div');
            el.style[prop] = value;
            return !!el.style[prop];
          } catch { return false; }
        },
        isPropertyValid(rule, prop) {
          try {
            const raw = (rule?.properties?.[prop] || '').toString();
            if (!raw.trim()) return true; // empty is handled elsewhere
            const v = this.stripImportant(raw);
            // If var() used, ensure referenced tokens exist (all of them)
            if (this.hasVarFunction(v)) {
              const vars = this.extractVarNames(v);
              if (vars.length && !vars.every(n => this.tokenExists(n))) return false;
            }
            return this.cssSupports(prop, v);
          } catch { return true; }
        },
        isTokenValueValid(value) {
          const v = (value || '').toString().trim();
          if (!v) return false;
          // Accept common contexts: background (very permissive) or color
          if (this.cssSupports('background', v)) return true;
          if (this.cssSupports('color', v)) return true;
          // As a fallback, width can validate length/percentage values
          if (this.cssSupports('width', v)) return true;
          return false;
        },
        getPropertyValidationHint(rule, prop) {
          try {
            const raw = (rule?.properties?.[prop] || '').toString();
            const v = this.stripImportant(raw);
            if (this.hasVarFunction(v)) {
              const vars = this.extractVarNames(v);
              const missing = (vars || []).filter(n => !this.tokenExists(n));
              if (missing.length) {
                const list = missing.join(', ');
                return (this.getTranslation('css.visual.missingTokens') || 'Fehlende Tokens') + ': ' + list;
              }
            }
            return this.getTranslation('css.visual.invalidCssValue') || 'Ungültiger CSS-Wert';
          } catch { return this.getTranslation('css.visual.invalidCssValue') || 'Ungültiger CSS-Wert'; }
        },
        getTokenValidationHint(value) {
          // Provide a helpful generic hint for token values
          return this.getTranslation('css.visual.invalidTokenValue') || 'Ungültiger Token-Wert (z. B. #rrggbb, rgb(), linear-gradient(), var(--name))';
        },

        // Rule search helper: match by name and any property key/value
        matchesRuleSearch(rule) {
          const q = (this.rulesFilterQuery || '').toString().trim().toLowerCase();
          if (!q) return true;
          // Name
          if ((rule.name || '').toString().toLowerCase().includes(q)) return true;
          // Properties (keys and values)
          try {
            const props = rule.properties || {};
            for (const [k, v] of Object.entries(props)) {
              if ((k || '').toString().toLowerCase().includes(q)) return true;
              if ((v || '').toString().toLowerCase().includes(q)) return true;
            }
          } catch {}
          // Custom CSS field (legacy)
          if ((rule.customCss || '').toString().toLowerCase().includes(q)) return true;
          return false;
        },

        isPropertyDisabled(rule, property) {
          if (!rule.disabled) return false;
          return !!rule.disabled[property];
        },
        togglePropertyDisabled(rule, property) {
          if (!rule.disabled) {
            // Use Vue.set to keep reactivity if available
            this.$set ? this.$set(rule, 'disabled', {}) : (rule.disabled = {});
          }
          const current = !!rule.disabled[property];
          this.$set ? this.$set(rule.disabled, property, !current) : (rule.disabled[property] = !current);
          this.saveVisualCss();
        },

        getRuleSelector(rule) {
          // Ensure rule.selector is always an object
          if (!rule.selector || typeof rule.selector === 'string') {
            // Create a new selector object for this rule
            rule.selector = {
              base: typeof rule.selector === 'string' ? rule.selector : '',
              groupId: rule.groupId || null,
              linkId: rule.linkId || null,
              keywordSlug: null
            };
          }
          // Ensure the selector has all required properties
          if (!rule.selector.hasOwnProperty('keywordSlug')) {
            rule.selector.keywordSlug = null;
          }
          return rule.selector;
        },

        updateRuleBase(rule, event) {
          const baseValue = event.target.value;
          // Ensure selector is an object and create a new one to avoid shared references
          if (!rule.selector || typeof rule.selector === 'string') {
            rule.selector = {
              base: '',
              groupId: null,
              linkId: null,
              keywordSlug: null
            };
          }
          const oldBase = rule.selector.base;
          const previousGroupId = rule.selector.groupId;
          const previousLinkId = rule.selector.linkId;
          const previousKeywordSlug = rule.selector.keywordSlug;

          // Update the base value
          rule.selector.base = baseValue;

          // Decide whether to keep or reset dependent selections based on new base
          const groupSupportingSelectors = [
            'groups', 'group-header', 'group-title', 'group-body',
            'links', 'link-hover', 'link-anchor', 'link-url', 'link-icon',
            'badges-group', 'badges-group-linkcount', 'badges-group-keywords',
            'badges-link', 'badges-link-keywords',
            'keywords-hierarchical'
          ];
          const linkSupportingSelectors = [
            'links', 'link-hover', 'link-anchor', 'link-url', 'link-icon',
            'badges-link', 'badges-link-keywords',
            'keywords-hierarchical'
          ];
          const keywordSupportingSelectors = [
            'keyword-by-name', 'keywords-hierarchical'
          ];

          const keepGroup = groupSupportingSelectors.includes(baseValue);
          const keepLink = linkSupportingSelectors.includes(baseValue);
          const keepKeyword = keywordSupportingSelectors.includes(baseValue);

          // Apply keeping rules
          rule.selector.groupId = keepGroup ? previousGroupId : null;
          // Link only meaningful if base supports link AND we still have a group
          rule.selector.linkId = (keepLink && (keepGroup ? previousGroupId : null)) ? previousLinkId : null;
          rule.selector.keywordSlug = keepKeyword ? previousKeywordSlug : null;

          // Keep legacy fields in sync
          rule.groupId = rule.selector.groupId;
          rule.linkId = rule.selector.linkId;

          // Do NOT clear user properties on base change.
          // We keep user-entered properties and merge template defaults below if selected.

          // Do not auto-add any properties upon selector changes

          this.saveVisualCss();
        },

        onBaseSelectorChange(rule) {
          // Ensure selector is an object
          this.getRuleSelector(rule);

          // Reset dependent selections when base changes
          rule.selector.groupId = null;
          rule.selector.linkId = null;
          rule.groupId = null;
          rule.linkId = null;

          // Do not auto-add any properties upon selector changes

          this.saveVisualCss();
        },

        loadTemplatePropertiesForRule(rule) {
          // Get template rules
          const templateRules = this.getCurrentTemplate();
          const selector = this.getRuleSelector(rule);

          // Get the actual CSS selector for this base
          const baseSelectorMap = {
            'app': '.mb-app',
            'header': '.mb-titlebar',
            'toolbar': '.mb-toolbar',
            'footer': '.mb-footer',
            'groups-links-container': '.mb-groups-links-container',
            'groups': '.mb-group',
            'group-header': '.mb-group__header',
            'group-title': '.mb-group__title',
            'group-body': '.mb-group__body',
            'links': '.mb-link',
            'link-hover': '.mb-link:hover',
            'link-anchor': '.mb-link__anchor',
            'link-url': '.mb-link__url',
            'link-icon': '.mb-link__icon',
            'link-popover': '.link-detail-popover',
            'link-popover-title': '.link-detail-popover__title',
            'link-popover-url': '.link-detail-popover__url',
            'link-popover-meta': '.link-detail-popover__meta',
            'link-popover-row': '.link-detail-popover__row',
            'link-popover-label': '.link-detail-popover__label',
            'link-popover-value': '.link-detail-popover__value',
            'link-popover-value-muted': '.link-detail-popover__value--muted',
            'link-popover-keywords': '.link-detail-popover__keywords',
            'link-popover-badge': '.link-detail-popover__badge',
            'link-popover-favicon': '.link-detail-popover__favicon',
            'keywords': '.mb-keyword',
            'keywords-hierarchical': '.keyword-badge',
            'keyword-by-name': '.mb-keyword',
            'body': 'body',
            // Additional mappings for better template matching
            'titlebar': '.mb-titlebar',
            'titlebar-title': '.mb-titlebar__title',
            'btn': '.btn',
            'btn-primary': '.btn-primary',
            'btn-secondary': '.btn-secondary',
            'btn-success': '.btn-success',
            'btn-danger': '.btn-danger',
            'form-control': '.form-control',
            'form-select': '.form-select',
            'modal': '.modal-content',
            'modal-header': '.modal-header',
            'modal-footer': '.modal-footer'
          };

          const targetSelector = baseSelectorMap[selector.base] || selector.base;

          // Collect all matching CSS properties from template
          const aggregatedProperties = {};

          // Search through all template rules for matching selectors
          for (const tRule of templateRules) {
            let matches = false;

            // Check if template rule selector matches our target
            if (tRule.selector === targetSelector) {
              matches = true;
            } else if (tRule.selector === selector.base) {
              matches = true;
            } else if (tRule.selector === `.${selector.base}`) {
              matches = true;
            } else if (targetSelector && tRule.selector) {
              // Check various matching patterns
              const normalizedTarget = targetSelector.replace('#', '').replace('.', '');
              const normalizedTemplate = tRule.selector.replace('#', '').replace('.', '');

              // Direct match after normalization
              if (normalizedTemplate === normalizedTarget) {
                matches = true;
              }
              // Check if template selector contains our target (for nested selectors)
              else if (tRule.selector.includes(targetSelector)) {
                matches = true;
              }
              // Check for class/id variations
              else if (tRule.selector === `.${normalizedTarget}` ||
                       tRule.selector === `#${normalizedTarget}`) {
                matches = true;
              }
            }

            // Special case for hierarchical selectors
            if (!matches && targetSelector) {
              // Check if this is a parent/child relationship
              // E.g., .mb-group should also get properties from body if it's a child
              if (tRule.selector === 'body' || tRule.selector === '#app') {
                // These are parent containers, inherit some properties
                const inheritableProps = ['font-family', 'font-size', 'color', 'line-height'];
                for (const prop of inheritableProps) {
                  if (tRule.properties && tRule.properties[prop]) {
                    aggregatedProperties[prop] = tRule.properties[prop];
                  }
                }
              }
            }

            if (matches && tRule.properties) {
              // Aggregate all properties from matching rules
              // Later rules override earlier ones
              for (const [prop, value] of Object.entries(tRule.properties)) {
                aggregatedProperties[prop] = value;
              }
            }
          }

          // Merge aggregated template properties into the rule
          // If the rule already has user properties, keep them and only add missing ones
          if (Object.keys(aggregatedProperties).length > 0) {
            console.log('Loading template properties for', selector.base, ':', aggregatedProperties);

            if (!rule.properties || Object.keys(rule.properties).length === 0) {
              // No user props yet: take the template defaults fully
              rule.properties = {};
              for (const [prop, value] of Object.entries(aggregatedProperties)) {
                rule.properties[prop] = value;
              }
            } else {
              // Already has user props: only add missing keys from template
              for (const [prop, value] of Object.entries(aggregatedProperties)) {
                if (!(prop in rule.properties)) {
                  rule.properties[prop] = value;
                }
              }
            }
          }
        },

        updateRuleGroupId(rule, event) {
          const rawValue = event.target.value;
          let groupId = null;

          if (rawValue && rawValue !== 'null' && rawValue !== '') {
            // Check if it's a UUID (contains dashes) or a numeric ID
            if (rawValue.includes('-')) {
              // It's a UUID, keep as string
              groupId = rawValue;
            } else if (!isNaN(rawValue)) {
              // It's a numeric ID
              groupId = parseInt(rawValue);
            } else {
              // Keep as is
              groupId = rawValue;
            }
          }

          console.log('updateRuleGroupId - Raw value:', rawValue, 'Type:', typeof rawValue, 'Parsed groupId:', groupId, 'Type after parse:', typeof groupId);

          // Ensure selector is an object
          const selector = this.getRuleSelector(rule);

          // Update the selector
          selector.groupId = groupId;
          selector.linkId = null; // Reset link when group changes

          // Also update root level for backward compatibility
          rule.groupId = groupId;
          rule.linkId = null;

          console.log('Group updated:', {
            ruleId: rule.id,
            groupId: groupId,
            selector: selector,
            fullRule: JSON.stringify(rule)
          });

          this.saveVisualCss();
        },

        updateRuleLinkId(rule, event) {
          const rawValue = event.target.value;
          let linkId = null;

          if (rawValue && rawValue !== 'null' && rawValue !== '') {
            // Check if it's a UUID (contains dashes) or a numeric ID
            if (rawValue.includes('-')) {
              // It's a UUID, keep as string
              linkId = rawValue;
            } else if (!isNaN(rawValue)) {
              // It's a numeric ID
              linkId = parseInt(rawValue);
            } else {
              // Keep as is
              linkId = rawValue;
            }
          }

          // Ensure selector is an object
          const selector = this.getRuleSelector(rule);

          // Update the selector
          selector.linkId = linkId;

          // Also update root level for backward compatibility
          rule.linkId = linkId;

          this.saveVisualCss();
        },

        updateRuleKeywordSlug(rule, event) {
          const keywordSlug = event.target.value;

          // Ensure selector is an object
          const selector = this.getRuleSelector(rule);

          // Update the selector with keyword slug
          selector.keywordSlug = keywordSlug;

          this.saveVisualCss();
        },

        getAllUniqueKeywords() {
          // Get all unique keywords from groups and links
          const set = new Set();
          (this.data.groups || []).forEach(g => {
            if (g.deleted) return;

            // Add group keywords
            if (g.keywords) {
              this.parseKeywords(g.keywords).forEach(k => set.add(k));
            }

            // Add link keywords
            (g.links || []).forEach(l => {
              if (!l.deleted && l.keywords) {
                this.parseKeywords(l.keywords).forEach(k => set.add(k));
              }
            });
          });

          // Return sorted array
          return Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        },

        getKeywordsForRule(rule) {
          const selector = this.getRuleSelector(rule);

          console.log('getKeywordsForRule - selector:', JSON.stringify(selector));

          // For keyword-by-name, return all keywords
          if (selector.base === 'keyword-by-name') {
            return this.getAllUniqueKeywords();
          }

          // For hierarchical keywords, filter based on selected group/link
          if (selector.base === 'keywords-hierarchical') {
            // If a specific link is selected, return only that link's keywords
            if (selector.groupId && selector.linkId) {
              const group = this.data.groups.find(g =>
                !g.deleted && (
                  g.id === selector.groupId ||
                  g.uuid === selector.groupId ||
                  g.id === parseInt(selector.groupId)
                )
              );

              if (group) {
                const link = group.links.find(l =>
                  !l.deleted && (
                    l.id === selector.linkId ||
                    l.uuid === selector.linkId ||
                    l.id === parseInt(selector.linkId)
                  )
                );

                if (link && link.keywords) {
                  console.log('getKeywordsForRule - Returning keywords for specific link:', link.text);
                  return this.parseKeywords(link.keywords).sort((a, b) =>
                    a.toLowerCase().localeCompare(b.toLowerCase())
                  );
                }
              }
              return [];
            }

            // If only a group is selected, return all keywords from group AND its links
            if (selector.groupId) {
              const group = this.data.groups.find(g =>
                !g.deleted && (
                  g.id === selector.groupId ||
                  g.uuid === selector.groupId ||
                  g.id === parseInt(selector.groupId)
                )
              );

              if (group) {
                const set = new Set();

                // Add group's own keywords
                if (group.keywords) {
                  console.log('getKeywordsForRule - Adding group keywords:', group.keywords);
                  this.parseKeywords(group.keywords).forEach(k => set.add(k));
                }

                // Add keywords from all links in this group
                (group.links || []).forEach(l => {
                  if (!l.deleted && l.keywords) {
                    console.log('getKeywordsForRule - Adding link keywords:', l.text, l.keywords);
                    this.parseKeywords(l.keywords).forEach(k => set.add(k));
                  }
                });

                const result = Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
                console.log('getKeywordsForRule - Total keywords for group:', result);
                return result;
              }
              return [];
            }

            // No group or link selected - return all keywords
            return this.getAllUniqueKeywords();
          }

          // For keywords-in-group, return keywords that appear in group badges
          if (selector.base === 'keywords-in-group') {
            if (selector.groupId) {
              const group = this.data.groups.find(g =>
                !g.deleted && (
                  g.id === selector.groupId ||
                  g.uuid === selector.groupId ||
                  g.id === parseInt(selector.groupId)
                )
              );

              if (group) {
                // For a specific group, return both group keywords AND all link keywords
                // because both appear as badges in the group header
                const set = new Set();

                // Add group's own keywords
                if (group.keywords) {
                  this.parseKeywords(group.keywords).forEach(k => set.add(k));
                }

                // Also add keywords from all links in this group
                // because they also appear as badges in the group
                (group.links || []).forEach(l => {
                  if (!l.deleted && l.keywords) {
                    this.parseKeywords(l.keywords).forEach(k => set.add(k));
                  }
                });

                return Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
              }
              return []; // No keywords in this group
            }
            // No group selected - return all group keywords (not link keywords)
            const set = new Set();
            (this.data.groups || []).forEach(g => {
              if (!g.deleted && g.keywords) {
                this.parseKeywords(g.keywords).forEach(k => set.add(k));
              }
            });
            return Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
          }

          // For keywords-in-link, return keywords from links
          if (selector.base === 'keywords-in-link') {
            if (selector.groupId && selector.linkId) {
              // Specific link selected - return only that link's keywords
              const group = this.data.groups.find(g =>
                !g.deleted && (
                  g.id === selector.groupId ||
                  g.uuid === selector.groupId ||
                  g.id === parseInt(selector.groupId)
                )
              );

              if (group) {
                const link = group.links.find(l =>
                  !l.deleted && (
                    l.id === selector.linkId ||
                    l.uuid === selector.linkId ||
                    l.id === parseInt(selector.linkId)
                  )
                );

                if (link && link.keywords) {
                  // Return ONLY this link's keywords
                  return this.parseKeywords(link.keywords).sort((a, b) =>
                    a.toLowerCase().localeCompare(b.toLowerCase())
                  );
                }
              }
              return []; // No keywords in this link
            } else if (selector.groupId) {
              // Group selected but no link - return all keywords from all links in this group
              const group = this.data.groups.find(g =>
                !g.deleted && (
                  g.id === selector.groupId ||
                  g.uuid === selector.groupId ||
                  g.id === parseInt(selector.groupId)
                )
              );

              console.log('getKeywordsForRule - Looking for group:', selector.groupId);
              console.log('getKeywordsForRule - Found group:', group ? group.name : 'NOT FOUND');

              if (group) {
                console.log('getKeywordsForRule - Group has keywords:', group.keywords);
                console.log('getKeywordsForRule - Group has', (group.links || []).length, 'links');

                const set = new Set();
                (group.links || []).forEach(l => {
                  console.log('getKeywordsForRule - Checking link:', l.text, 'deleted:', l.deleted, 'keywords:', l.keywords);
                  if (!l.deleted && l.keywords) {
                    const keywords = this.parseKeywords(l.keywords);
                    console.log('getKeywordsForRule - Parsed link keywords:', l.text, keywords);
                    keywords.forEach(k => set.add(k));
                  }
                });
                const result = Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
                console.log('getKeywordsForRule - Final keywords for links in group:', result);
                return result;
              }
              return [];
            }

            // No group or link selected - return all link keywords from all groups
            const set = new Set();
            (this.data.groups || []).forEach(g => {
              if (!g.deleted) {
                (g.links || []).forEach(l => {
                  if (!l.deleted && l.keywords) {
                    this.parseKeywords(l.keywords).forEach(k => set.add(k));
                  }
                });
              }
            });
            return Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
          }

          // Default: return empty array
          return [];
        },

        onGroupChange(rule) {
          // Deprecated - use updateRuleGroupId instead
          this.updateRuleGroupId(rule, { target: { value: rule.selector.groupId } });
        },

        getCurrentTemplate() {
          // Get the currently selected template definition
          const templates = {
            'dark-mode': [
              // ===== WICHTIGER HINWEIS =====
              // Dieses Template enthält ALLE CSS-Regeln aus dem alten Dark Mode Template
              // Viele Selektoren sind nicht im Dropdown verfügbar, funktionieren aber trotzdem

              // Body & Main Container
              {
                id: Date.now() + 1,
                enabled: true,
                selector: 'body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1a1a1a',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 2,
                enabled: true,
                selector: '.mb-app',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1a1a1a'
                }
              },
              // Title Bar
              {
                id: Date.now() + 3,
                enabled: true,
                selector: '.mb-titlebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #2c2c2c 0%, #1f1f1f 100%)',
                  'border-bottom': '1px solid #444'
                }
              },
              {
                id: Date.now() + 4,
                enabled: true,
                selector: '.mb-titlebar__title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f0f0f0',
                  'text-shadow': '2px 2px 4px rgba(0, 0, 0, 0.5)'
                }
              },
              // Toolbar
              {
                id: Date.now() + 5,
                enabled: true,
                selector: '.mb-toolbar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-bottom': '1px solid #333'
                }
              },
              {
                id: Date.now() + 5_1,
                enabled: true,
                selector: '.mb-toolbar .btn',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '4px 8px',
                  'font-size': '13px'
                }
              },
              // Groups
              {
                id: Date.now() + 6,
                enabled: true,
                selector: '.mb-group',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'margin-bottom': '8px',
                  'border-radius': '8px'
                }
              },
              {
                id: Date.now() + 6_1,
                enabled: true,
                selector: '.mb-group__body',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-left-radius': '0',
                  'border-top-right-radius': '0',
                  'border-bottom-left-radius': '8px',
                  'border-bottom-right-radius': '8px'
                }
              },
              {
                id: Date.now() + 7,
                enabled: true,
                selector: '.mb-group__header',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #2f2f2f 0%, #252525 100%)',
                  'border-bottom': '1px solid #3a3a3a'
                }
              },
              {
                id: Date.now() + 8,
                enabled: true,
                selector: '.mb-group__title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f0f0f0'
                }
              },
              // Links
              {
                id: Date.now() + 9,
                enabled: true,
                selector: '.mb-link',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'transparent'
                }
              },
              {
                id: Date.now() + 10,
                enabled: true,
                selector: '.mb-link__url',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#6cb2ff'
                }
              },
              {
                id: Date.now() + 10_1,
                enabled: true,
                selector: '.link-detail-popover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(15, 23, 42, 0.94)',
                  'color': '#e2e8f0',
                  'border': '1px solid rgba(148, 163, 184, 0.25)',
                  'box-shadow': '0 24px 60px rgba(15, 23, 42, 0.45)',
                  'backdrop-filter': 'blur(12px)'
                }
              },
              {
                id: Date.now() + 10_2,
                enabled: true,
                selector: '.link-detail-popover__badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(59, 130, 246, 0.25)',
                  'color': '#bfdbfe'
                }
              },
              {
                id: Date.now() + 10_3,
                enabled: true,
                selector: '.link-detail-popover__favicon',
                groupId: null,
                linkId: null,
                properties: {
                  'box-shadow': '0 3px 8px rgba(15, 23, 42, 0.45)'
                }
              },
              {
                id: Date.now() + 10_4,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'border': '1px solid #444',
                  'box-shadow': '0 12px 24px rgba(0, 0, 0, 0.45)',
                  'border-radius': '12px',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 10_5,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item .form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0',
                  'border-color': '#444',
                  'box-shadow': 'inset 0 1px 2px rgba(0, 0, 0, 0.35)'
                }
              },
              {
                id: Date.now() + 10_6,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item .form-control:disabled',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'rgba(42, 42, 42, 0.6)',
                  'color': 'rgba(224, 224, 224, 0.55)',
                  'border-color': '#3a3a3a'
                }
              },
              {
                id: Date.now() + 10_7,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item .form-text',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#b0b0b0'
                }
              },
              {
                id: Date.now() + 10_8,
                enabled: true,
                selector: '.modal-content .form-label',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 10_9,
                enabled: true,
                selector: '.modal-content .form-check-label',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 10_10,
                enabled: true,
                selector: '.modal-content .text-muted',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ca3af'
                }
              },
              {
                id: Date.now() + 10_11,
                enabled: true,
                selector: '.modal-content .table',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0',
                  'background-color': 'transparent',
                  'border-color': '#3a3a3a'
                }
              },
              {
                id: Date.now() + 10_12,
                enabled: true,
                selector: '.modal-content .table thead th',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f0f0f0',
                  'border-color': '#3a3a3a',
                  'background-color': 'rgba(42, 42, 42, 0.8)'
                }
              },
              {
                id: Date.now() + 10_13,
                enabled: true,
                selector: '.modal-content .table tbody td',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#d4d4d4',
                  'border-color': '#3a3a3a',
                  'background-color': 'rgba(35, 35, 35, 0.6)'
                }
              },
              {
                id: Date.now() + 10_14,
                enabled: true,
                selector: '.modal-content .table tbody tr:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'rgba(58, 58, 58, 0.7)'
                }
              },
              // Keywords
              {
                id: Date.now() + 11,
                enabled: true,
                selector: '.keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a5f7d',
                  'color': '#e0e0e0',
                  'border': '1px solid #4a7f9d'
                }
              },
              // Buttons
              {
                id: Date.now() + 12,
                enabled: true,
                selector: '.btn-primary',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a9eff',
                  'border-color': '#3a8eef',
                  'color': '#fff'
                }
              },
              {
                id: Date.now() + 13,
                enabled: true,
                selector: '.btn-secondary',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#555',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              // Forms
              {
                id: Date.now() + 14,
                enabled: true,
                selector: '.form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 15,
                enabled: true,
                selector: '.form-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              // Modals
              {
                id: Date.now() + 16,
                enabled: true,
                selector: '.modal-content',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0',
                  'border': '1px solid #444'
                }
              },
              {
                id: Date.now() + 17,
                enabled: true,
                selector: '.modal-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-bottom': '1px solid #444'
                }
              },
              {
                id: Date.now() + 18,
                enabled: true,
                selector: '.modal-footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-top': '1px solid #444'
                }
              },
              // Duplicates dialog (ensure consistent dark styling)
              {
                id: Date.now() + 18_1,
                enabled: true,
                selector: '#duplicatesModal .card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 18_2,
                enabled: true,
                selector: '#duplicatesModal .card-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'border-bottom': '1px solid #3a3a3a'
                }
              },
              {
                id: Date.now() + 18_3,
                enabled: true,
                selector: '#duplicatesModal .list-group-item',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'color': '#e0e0e0',
                  'border-color': '#333'
                }
              },
              {
                id: Date.now() + 18_4,
                enabled: true,
                selector: '#duplicatesModal .badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a',
                  'color': '#e0e0e0',
                  'border': '1px solid #444'
                }
              },
              // Zusätzliche wichtige Dark Mode Regeln
              {
                id: Date.now() + 19,
                enabled: true,
                selector: '.groupContainer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'margin-bottom': '8px',
                  'border-radius': '8px'
                }
              },
              {
                id: Date.now() + 20,
                enabled: true,
                selector: '.groupContainerHeader',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #2f2f2f 0%, #252525 100%)',
                  'border-bottom': '1px solid #3a3a3a'
                }
              },
              {
                id: Date.now() + 21,
                enabled: true,
                selector: '.linkContainer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'transparent',
                  'border-bottom': '1px solid #333'
                }
              },
              {
                id: Date.now() + 22,
                enabled: true,
                selector: '.linkContainer:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333'
                }
              },
              {
                id: Date.now() + 23,
                enabled: true,
                selector: '.linkText a',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#6cb2ff'
                }
              },
              {
                id: Date.now() + 24,
                enabled: true,
                selector: '.linkText a:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9cc9ff',
                  'text-decoration': 'none'
                }
              },
              {
                id: Date.now() + 25,
                enabled: true,
                selector: '.mb-css-sidebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-left': '1px solid #444'
                }
              },
              {
                id: Date.now() + 26,
                enabled: true,
                selector: '.alert-info',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e3a5f',
                  'color': '#9cc9ff',
                  'border-color': '#2e4a6f'
                }
              },
              {
                id: Date.now() + 27,
                enabled: true,
                selector: '::-webkit-scrollbar',
                groupId: null,
                linkId: null,
                properties: {
                  'width': '12px',
                  'height': '12px'
                }
              },
              {
                id: Date.now() + 28,
                enabled: true,
                selector: '::-webkit-scrollbar-track',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#1a1a1a'
                }
              },
              {
                id: Date.now() + 29,
                enabled: true,
                selector: '::-webkit-scrollbar-thumb',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#444',
                  'border-radius': '6px'
                }
              },
              {
                id: Date.now() + 30,
                enabled: true,
                selector: '::-webkit-scrollbar-thumb:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#555'
                }
              },
              // Große CSS-Blöcke als Custom CSS
              {
                id: Date.now() + 31,
                enabled: true,
                selector: '.mb-group-info-section',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#232323',
                  'border': '1px solid #3a3a3a',
                  'border-radius': '4px'
                },
                customCss: `/* Weitere Dark Mode Styles für Info-Bereich */
.mb-group-info-header {
  background-color: #2a2a2a;
  color: #e0e0e0;
}
.mb-group-info-header:hover {
  background-color: #333;
}
.mb-group-info-label,
.group-info-section .text-info {
  color: #6cb2ff;
}
.mb-group-info-content {
  background-color: #1f1f1f;
  color: #e0e0e0;
  border: 1px solid #3a3a3a;
}`
              },
              // Kontextmenüs und Submenüs - mit !important für höhere Spezifität
              {
                id: Date.now() + 32,
                enabled: true,
                selector: '.context-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important',
                  'box-shadow': '0 4px 12px rgba(0, 0, 0, 0.5) !important'
                }
              },
              {
                id: Date.now() + 321,
                enabled: true,
                selector: '.mb-context-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important',
                  'box-shadow': '0 4px 12px rgba(0, 0, 0, 0.5) !important'
                }
              },
              {
                id: Date.now() + 3211,
                enabled: true,
                selector: '.context-menu ul',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': 'none !important'
                }
              },
              {
                id: Date.now() + 3212,
                enabled: true,
                selector: '.mb-context-menu ul',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': 'none !important'
                }
              },
              {
                id: Date.now() + 322,
                enabled: true,
                selector: '.context-menu ul li',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'background-color': 'transparent !important'
                }
              },
              {
                id: Date.now() + 323,
                enabled: true,
                selector: '.mb-context-menu li',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'background-color': 'transparent !important'
                }
              },
              {
                id: Date.now() + 324,
                enabled: true,
                selector: '.context-menu ul li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 325,
                enabled: true,
                selector: '.mb-context-menu li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 3251,
                enabled: true,
                selector: '.context-menu li.disabled',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#666666 !important',
                  'opacity': '0.5 !important'
                }
              },
              {
                id: Date.now() + 3252,
                enabled: true,
                selector: '.mb-context-menu li.disabled',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#666666 !important',
                  'opacity': '0.5 !important'
                }
              },
              {
                id: Date.now() + 326,
                enabled: true,
                selector: '.context-menu .separator',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-color': '#444 !important'
                }
              },
              {
                id: Date.now() + 3261,
                enabled: true,
                selector: '.mb-context-menu-separator',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top': '1px solid #444 !important'
                }
              },
              {
                id: Date.now() + 327,
                enabled: true,
                selector: '.context-submenu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important',
                  'box-shadow': '0 2px 8px rgba(0, 0, 0, 0.4) !important'
                }
              },
              {
                id: Date.now() + 328,
                enabled: true,
                selector: '.mb-context-submenu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important',
                  'box-shadow': '0 2px 8px rgba(0, 0, 0, 0.4) !important'
                }
              },
              {
                id: Date.now() + 329,
                enabled: true,
                selector: '.context-submenu li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 330,
                enabled: true,
                selector: '.mb-context-submenu li:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 3301,
                enabled: true,
                selector: '.context-menu.context-menu-visible',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important'
                }
              },
              {
                id: Date.now() + 3302,
                enabled: true,
                selector: '.mb-context-menu.context-menu-visible',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important'
                }
              },
              {
                id: Date.now() + 3303,
                enabled: true,
                selector: '.context-menu .submenu',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'background-color': 'transparent !important'
                }
              },
              {
                id: Date.now() + 3304,
                enabled: true,
                selector: '.context-menu .submenu:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              // Toolbar Buttons
              {
                id: Date.now() + 33,
                enabled: true,
                selector: '.mb-toolbar .btn',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 331,
                enabled: true,
                selector: '.mb-toolbar .btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#444 !important',
                  'color': '#ffffff !important',
                  'border-color': '#555 !important',
                  'box-shadow': 'none !important'
                }
              },
              {
                id: Date.now() + 332,
                enabled: true,
                selector: '.mb-toolbar .btn:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important',
                  'border-color': '#555 !important',
                  'box-shadow': '0 0 0 0.2rem rgba(255, 255, 255, 0.1) !important'
                }
              },
              {
                id: Date.now() + 333,
                enabled: true,
                selector: '.mb-toolbar .btn:active',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'color': '#ffffff !important',
                  'border-color': '#444 !important'
                }
              },
              {
                id: Date.now() + 334,
                enabled: true,
                selector: '.btn-toolbar .btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#444 !important',
                  'color': '#ffffff !important',
                  'border-color': '#555 !important',
                  'box-shadow': 'none !important'
                }
              },
              {
                id: Date.now() + 335,
                enabled: true,
                selector: '.mb-tools .btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#444 !important',
                  'color': '#ffffff !important',
                  'border-color': '#555 !important',
                  'box-shadow': 'none !important'
                }
              },
              {
                id: Date.now() + 336,
                enabled: true,
                selector: '.mb-toolbar .btn-outline-secondary:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#444 !important',
                  'color': '#ffffff !important',
                  'border-color': '#555 !important'
                }
              },
              {
                id: Date.now() + 337,
                enabled: true,
                selector: '.mb-toolbar .btn-outline-primary:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a5f7d !important',
                  'color': '#ffffff !important',
                  'border-color': '#4a7f9d !important'
                }
              },
              {
                id: Date.now() + 338,
                enabled: true,
                selector: '.mb-toolbar .btn-success:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2d5a2d !important',
                  'color': '#ffffff !important',
                  'border-color': '#3d6a3d !important',
                  'box-shadow': 'none !important'
                }
              },
              {
                id: Date.now() + 339,
                enabled: true,
                selector: '.mb-toolbar .btn-danger:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#5a2d2d !important',
                  'color': '#ffffff !important',
                  'border-color': '#6a3d3d !important',
                  'box-shadow': 'none !important',
                  'opacity': '1 !important'
                }
              },
              // Keywords Bar
              {
                id: Date.now() + 34,
                enabled: true,
                selector: '.mb-keyword-bar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-top': '1px solid #333',
                  'border-bottom': '1px solid #333',
                  'padding': '8px 12px'
                }
              },
              {
                id: Date.now() + 341,
                enabled: true,
                selector: '.mb-keyword-label',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0',
                  'border': '1px solid #3a3a3a',
                  'border-right': 'none',
                  'padding': '6px 12px',
                  'font-weight': '600',
                  'font-size': '12px',
                  'letter-spacing': '0.5px'
                }
              },
              {
                id: Date.now() + 342,
                enabled: true,
                selector: '.mb-keyword-label:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333',
                  'border-color': '#4a9eff',
                  'border-right': 'none'
                }
              },
              {
                id: Date.now() + 343,
                enabled: true,
                selector: '.mb-keywords-cloud',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'padding': '12px',
                  'border-radius': '8px',
                  'margin': '8px 0'
                }
              },
              {
                id: Date.now() + 344,
                enabled: true,
                selector: '.keyword-container',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'border': '1px solid #3a3a3a',
                  'border-left': 'none',
                  'border-radius': '0 8px 8px 0'
                }
              },
              {
                id: Date.now() + 345,
                enabled: true,
                selector: '.mb-keyword-bar .keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a5f7d',
                  'color': '#e0e0e0',
                  'border': '1px solid #4a7f9d',
                  'margin': '2px'
                }
              },
              {
                id: Date.now() + 346,
                enabled: true,
                selector: '.mb-keyword-bar .keyword-badge:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a7f9d',
                  'transform': 'scale(1.05)'
                }
              },
              // Footer
              {
                id: Date.now() + 35,
                enabled: true,
                selector: 'footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1f1f1f',
                  'color': '#e0e0e0',
                  'border-top': '1px solid #444'
                },
                customCss: `footer a {
  color: #6cb2ff !important;
}
footer a:hover {
  color: #9cc9ff !important;
}`
              },
              // Global Options Dialog
              {
                id: Date.now() + 36,
                enabled: true,
                selector: '#optionsModal .modal-content',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 361,
                enabled: true,
                selector: '#optionsModal .modal-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-bottom': '1px solid #444'
                }
              },
              {
                id: Date.now() + 362,
                enabled: true,
                selector: '#optionsModal .modal-footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-top': '1px solid #444'
                }
              },
              {
                id: Date.now() + 363,
                enabled: true,
                selector: '#optionsModal .nav-tabs',
                groupId: null,
                linkId: null,
                properties: {
                  'border-bottom': '1px solid #444'
                }
              },
              {
                id: Date.now() + 364,
                enabled: true,
                selector: '#optionsModal .nav-link',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ca3af',
                  'background-color': 'transparent',
                  'border-color': 'transparent'
                }
              },
              {
                id: Date.now() + 365,
                enabled: true,
                selector: '#optionsModal .nav-link:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 366,
                enabled: true,
                selector: '#optionsModal .nav-link.active',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0',
                  'background-color': '#333',
                  'border-color': '#444 #444 #333'
                }
              },
              {
                id: Date.now() + 367,
                enabled: true,
                selector: '#optionsModal .form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 368,
                enabled: true,
                selector: '#optionsModal .form-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 369,
                enabled: true,
                selector: '#optionsModal .form-check-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 370,
                enabled: true,
                selector: '#optionsModal .form-check-input:checked',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a9eff',
                  'border-color': '#4a9eff'
                }
              },
              {
                id: Date.now() + 371,
                enabled: true,
                selector: '#optionsModal .list-group-item',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 372,
                enabled: true,
                selector: '#optionsModal .card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 373,
                enabled: true,
                selector: '#optionsModal .card-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'border-bottom': '1px solid #444'
                }
              },
              // Edit Dialogs (Group & Link)
              {
                id: Date.now() + 37,
                enabled: true,
                selector: '.mb-edit-modal-body',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 371,
                enabled: true,
                selector: '.mb-edit-modal-title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f0f0f0',
                  'font-size': '1.25rem'
                }
              },
              {
                id: Date.now() + 372,
                enabled: true,
                selector: '.mb-edit-modal-footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-top': '1px solid #444',
                  'padding': '1rem'
                }
              },
              {
                id: Date.now() + 373,
                enabled: true,
                selector: '.mb-edit-filter-container',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#232323',
                  'padding': '0.75rem',
                  'border-radius': '0.25rem',
                  'margin-bottom': '1rem'
                }
              },
              {
                id: Date.now() + 374,
                enabled: true,
                selector: '.mb-edit-filter-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 375,
                enabled: true,
                selector: '.mb-edit-filter-input:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'border-color': '#4a9eff',
                  'box-shadow': '0 0 0 0.2rem rgba(74, 158, 255, 0.25)'
                }
              },
              {
                id: Date.now() + 376,
                enabled: true,
                selector: '.mb-edit-section',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border': '1px solid #3a3a3a',
                  'border-radius': '0.25rem',
                  'margin-bottom': '1rem'
                }
              },
              {
                id: Date.now() + 377,
                enabled: true,
                selector: '.mb-edit-section-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'color': '#f0f0f0',
                  'padding': '0.5rem 0.75rem',
                  'border-bottom': '1px solid #3a3a3a',
                  'font-weight': '500'
                }
              },
              {
                id: Date.now() + 378,
                enabled: true,
                selector: '.mb-edit-section-body',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '0.75rem',
                  'background-color': '#1f1f1f',
                  'border-radius': '0 0 0.25rem 0.25rem'
                }
              },
              {
                id: Date.now() + 379,
                enabled: true,
                selector: '.mb-edit-text-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 380,
                enabled: true,
                selector: '.mb-edit-url-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 381,
                enabled: true,
                selector: '.mb-edit-number-input',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 382,
                enabled: true,
                selector: '.mb-edit-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 383,
                enabled: true,
                selector: '.mb-edit-checkbox',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 384,
                enabled: true,
                selector: '.mb-edit-checkbox:checked',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a9eff',
                  'border-color': '#4a9eff'
                }
              },
              {
                id: Date.now() + 385,
                enabled: true,
                selector: '.mb-edit-save-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a9eff',
                  'border-color': '#3a8eef',
                  'color': '#fff'
                }
              },
              {
                id: Date.now() + 386,
                enabled: true,
                selector: '.mb-edit-save-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a8eef',
                  'border-color': '#2a7edf'
                }
              },
              {
                id: Date.now() + 387,
                enabled: true,
                selector: '.mb-edit-cancel-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#555',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 388,
                enabled: true,
                selector: '.mb-edit-cancel-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#666',
                  'border-color': '#555'
                }
              },
              {
                id: Date.now() + 389,
                enabled: true,
                selector: '.mb-edit-reset-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': 'transparent',
                  'border-color': '#666',
                  'color': '#aaa'
                }
              },
              {
                id: Date.now() + 390,
                enabled: true,
                selector: '.mb-edit-reset-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333',
                  'border-color': '#777',
                  'color': '#e0e0e0'
                }
              },
              // Search Bar Container
              {
                id: Date.now() + 391,
                enabled: true,
                selector: '.mb-toolbar__search',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a',
                  'border-radius': '6px',
                  'padding': '4px'
                }
              },
              {
                id: Date.now() + 392,
                enabled: true,
                selector: '.mb-toolbar__search .form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 393,
                enabled: true,
                selector: '.mb-toolbar__search .form-control:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-color': '#4a9eff',
                  'box-shadow': '0 0 0 0.2rem rgba(74, 158, 255, 0.25)',
                  'color': '#f0f0f0'
                }
              },
              {
                id: Date.now() + 394,
                enabled: true,
                selector: '.mb-toolbar__search .input-group-text',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333',
                  'border-color': '#444',
                  'color': '#9ca3af'
                }
              },
              // Group Title Header Container Hover
              {
                id: Date.now() + 395,
                enabled: true,
                selector: '.groupContainerHeader:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #333 0%, #2a2a2a 100%)',
                  'transition': 'background 0.2s ease'
                }
              },
              {
                id: Date.now() + 396,
                enabled: true,
                selector: '.mb-group__header:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #333 0%, #2a2a2a 100%)',
                  'transition': 'background 0.2s ease'
                }
              },
              // Custom CSS Sidebar Containers
              {
                id: Date.now() + 397,
                enabled: true,
                selector: '.generated-css-section',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border-color': '#444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 398,
                enabled: true,
                selector: '.generated-css-section h6',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#f0f0f0',
                  'border-bottom': '1px solid #333',
                  'padding-bottom': '8px',
                  'margin-bottom': '12px'
                }
              },
              {
                id: Date.now() + 399,
                enabled: true,
                selector: '.generated-css-section .css-output',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#0d0d0d',
                  'color': '#6cb2ff',
                  'border': '1px solid #333',
                  'padding': '12px',
                  'border-radius': '4px',
                  'font-family': 'Monaco, Menlo, Consolas, monospace'
                }
              },
              {
                id: Date.now() + 400,
                enabled: true,
                selector: '.selector-preview',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e',
                  'border': '1px solid #444',
                  'color': '#e0e0e0'
                }
              },
              {
                id: Date.now() + 401,
                enabled: true,
                selector: '.selector-preview code',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#6cb2ff',
                  'background-color': '#0d0d0d',
                  'padding': '4px 8px',
                  'border-radius': '3px',
                  'font-size': '13px'
                }
              },
              {
                id: Date.now() + 402,
                enabled: true,
                selector: '.selector-preview small',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ca3af'
                }
              },
              // Force dark mode for Bootstrap bg-light classes
              {
                id: Date.now() + 403,
                enabled: true,
                selector: '.generated-css-section.bg-light',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e !important',
                  'color': '#e0e0e0 !important'
                }
              },
              {
                id: Date.now() + 404,
                enabled: true,
                selector: '.selector-preview.bg-light',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e !important',
                  'color': '#e0e0e0 !important'
                }
              },
              {
                id: Date.now() + 405,
                enabled: true,
                selector: '.selector-preview .text-muted',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ca3af !important'
                }
              },
              // Keywords Bar and Cloud - More specific selectors
              {
                id: Date.now() + 406,
                enabled: true,
                selector: '.mb-keywords-cloud',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525 !important',
                  'padding': '12px',
                  'border-radius': '8px',
                  'margin': '8px 0'
                }
              },
              {
                id: Date.now() + 407,
                enabled: true,
                selector: '.mb-keywords-cloud .keyword-container',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #3a3a3a',
                  'border-radius': '0 8px 8px 0',
                  'padding': '4px 8px'
                }
              },
              {
                id: Date.now() + 408,
                enabled: true,
                selector: '.mb-keywords-cloud .mb-keyword-label',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333 !important',
                  'color': '#e0e0e0 !important',
                  'border': '1px solid #444',
                  'border-right': 'none'
                }
              },
              {
                id: Date.now() + 409,
                enabled: true,
                selector: '.mb-keywords-cloud .keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a5f7d !important',
                  'color': '#e0e0e0 !important',
                  'border': '1px solid #4a7f9d'
                }
              },
              {
                id: Date.now() + 410,
                enabled: true,
                selector: '.mb-keywords-cloud .keyword-badge:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a7f9d !important',
                  'color': '#fff !important',
                  'transform': 'scale(1.05)'
                }
              },
              // CSS Sidebar itself
              {
                id: Date.now() + 411,
                enabled: true,
                selector: '.mb-css-sidebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1a1a1a !important',
                  'color': '#e0e0e0',
                  'border-left': '2px solid #444'
                }
              },
              {
                id: Date.now() + 412,
                enabled: true,
                selector: '.mb-css-sidebar .css-rule-card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#252525',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 413,
                enabled: true,
                selector: '.mb-css-sidebar .form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e !important',
                  'color': '#e0e0e0 !important',
                  'border-color': '#444 !important'
                }
              },
              {
                id: Date.now() + 414,
                enabled: true,
                selector: '.mb-css-sidebar .form-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#1e1e1e !important',
                  'color': '#e0e0e0 !important',
                  'border-color': '#444 !important'
                }
              },
              {
                id: Date.now() + 415,
                enabled: true,
                selector: '.mb-css-sidebar .btn-outline-secondary',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ca3af',
                  'border-color': '#444'
                }
              },
              {
                id: Date.now() + 416,
                enabled: true,
                selector: '.mb-css-sidebar .btn-outline-secondary:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#333',
                  'color': '#e0e0e0',
                  'border-color': '#555'
                }
              },
              // Action Buttons - Make them white/light
              {
                id: Date.now() + 417,
                enabled: true,
                selector: '.mb-css-sidebar-close',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'background-color': 'transparent !important',
                  'opacity': '0.8'
                }
              },
              {
                id: Date.now() + 418,
                enabled: true,
                selector: '.mb-css-sidebar-close:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important',
                  'opacity': '1',
                  'transform': 'scale(1.1)'
                }
              },
              {
                id: Date.now() + 419,
                enabled: true,
                selector: '.mb-group-menu-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'fill': '#e0e0e0 !important',
                  'opacity': '0.7'
                }
              },
              {
                id: Date.now() + 420,
                enabled: true,
                selector: '.mb-group-menu-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important',
                  'fill': '#ffffff !important',
                  'opacity': '1',
                  'transform': 'scale(1.1)'
                }
              },
              {
                id: Date.now() + 421,
                enabled: true,
                selector: '.mb-link-menu-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'fill': '#e0e0e0 !important',
                  'opacity': '0.7'
                }
              },
              {
                id: Date.now() + 422,
                enabled: true,
                selector: '.mb-link-menu-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important',
                  'fill': '#ffffff !important',
                  'opacity': '1',
                  'transform': 'scale(1.1)'
                }
              },
              {
                id: Date.now() + 423,
                enabled: true,
                selector: '.mb-group-add-link-btn',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'fill': '#e0e0e0 !important',
                  'opacity': '0.7'
                }
              },
              {
                id: Date.now() + 424,
                enabled: true,
                selector: '.mb-group-add-link-btn:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#4a9eff !important',
                  'fill': '#4a9eff !important',
                  'opacity': '1',
                  'transform': 'scale(1.1)'
                }
              },
              // Other action icons
              {
                id: Date.now() + 425,
                enabled: true,
                selector: '.actionIcon',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#d0d0d0 !important',
                  'fill': '#d0d0d0 !important'
                }
              },
              {
                id: Date.now() + 426,
                enabled: true,
                selector: '.actionIcon:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important',
                  'fill': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 427,
                enabled: true,
                selector: '.actionIconLink',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#c0c0c0 !important',
                  'fill': '#c0c0c0 !important'
                }
              },
              {
                id: Date.now() + 428,
                enabled: true,
                selector: '.actionIconLink:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important',
                  'fill': '#ffffff !important'
                }
              },
              // Close button (X) in modals
              {
                id: Date.now() + 429,
                enabled: true,
                selector: '.btn-close',
                groupId: null,
                linkId: null,
                properties: {
                  'filter': 'invert(1) grayscale(100%) brightness(200%)',
                  'opacity': '0.8'
                }
              },
              {
                id: Date.now() + 430,
                enabled: true,
                selector: '.btn-close:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'opacity': '1'
                }
              },
              // Dropdown Menus and Submenus (Bootstrap overrides)
              {
                id: Date.now() + 431,
                enabled: true,
                selector: '.dropdown-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important',
                  'box-shadow': '0 4px 12px rgba(0, 0, 0, 0.5) !important'
                }
              },
              {
                id: Date.now() + 432,
                enabled: true,
                selector: '.dropdown-item',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important',
                  'background-color': 'transparent !important'
                }
              },
              {
                id: Date.now() + 433,
                enabled: true,
                selector: '.dropdown-item:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 434,
                enabled: true,
                selector: '.dropdown-item:focus',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important',
                  'outline': 'none !important'
                }
              },
              {
                id: Date.now() + 435,
                enabled: true,
                selector: '.dropdown-item:active',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#4a4a4a !important',
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 436,
                enabled: true,
                selector: '.dropdown-divider',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-color': '#444 !important'
                }
              },
              {
                id: Date.now() + 437,
                enabled: true,
                selector: '.dropdown-submenu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important'
                }
              },
              {
                id: Date.now() + 438,
                enabled: true,
                selector: '.dropdown-submenu .dropdown-item',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important'
                }
              },
              {
                id: Date.now() + 439,
                enabled: true,
                selector: '.dropdown-submenu .dropdown-item:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important',
                  'color': '#ffffff !important'
                }
              },
              // Snapshots dropdown specific
              {
                id: Date.now() + 440,
                enabled: true,
                selector: '.mb-snapshots-menu',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#2a2a2a !important',
                  'border': '1px solid #444 !important'
                }
              },
              {
                id: Date.now() + 441,
                enabled: true,
                selector: '.mb-snapshots-menu .dropdown-item',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important'
                }
              },
              {
                id: Date.now() + 442,
                enabled: true,
                selector: '.mb-snapshots-menu .dropdown-item:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#3a3a3a !important'
                }
              },
              // Context menu submenu arrows
              {
                id: Date.now() + 443,
                enabled: true,
                selector: '.context-menu .submenu::after',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#9ca3af !important'
                }
              },
              {
                id: Date.now() + 444,
                enabled: true,
                selector: '.context-menu .submenu:hover::after',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important'
                }
              },
              // Bootstrap dropdown toggle
              {
                id: Date.now() + 445,
                enabled: true,
                selector: '.dropdown-toggle',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#e0e0e0 !important'
                }
              },
              {
                id: Date.now() + 446,
                enabled: true,
                selector: '.dropdown-toggle:hover',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#ffffff !important'
                }
              },
              {
                id: Date.now() + 447,
                enabled: true,
                selector: '.dropdown-toggle::after',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-color': '#e0e0e0 !important'
                }
              }
            ],
            'minimal': [
              // Groups kompakt
              {
                id: Date.now() + 1,
                enabled: true,
                selector: '.mb-group',
                groupId: null,
                linkId: null,
                properties: {
                  'margin-bottom': '4px',
                  'border-radius': '8px',
                  'border': '1px solid #e0e0e0'
                }
              },
              {
                id: Date.now() + 1_1,
                enabled: true,
                selector: '.mb-group__body',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-left-radius': '0',
                  'border-top-right-radius': '0',
                  'border-bottom-left-radius': '8px',
                  'border-bottom-right-radius': '8px'
                }
              },
              {
                id: Date.now() + 2,
                enabled: true,
                selector: '.mb-group__header',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '6px 10px',
                  'background': '#f8f9fa'
                }
              },
              // Links kompakt
              {
                id: Date.now() + 3,
                enabled: true,
                selector: '.mb-link',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '4px 10px'
                }
              },
              {
                id: Date.now() + 3_1,
                enabled: true,
                selector: '.link-detail-popover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#ffffff',
                  'color': '#212529',
                  'border': '1px solid #dee2e6',
                  'box-shadow': '0 18px 40px rgba(33, 37, 41, 0.08)'
                }
              },
              {
                id: Date.now() + 3_2,
                enabled: true,
                selector: '.link-detail-popover__badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background': '#e9ecef',
                  'color': '#495057'
                }
              },
              {
                id: Date.now() + 3_3,
                enabled: true,
                selector: '.link-detail-popover__favicon',
                groupId: null,
                linkId: null,
                properties: {
                  'box-shadow': '0 2px 6px rgba(0, 0, 0, 0.08)'
                }
              },
              {
                id: Date.now() + 3_4,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'border': '1px solid #d3d9df',
                  'border-radius': '8px',
                  'box-shadow': '0 6px 14px rgba(0, 0, 0, 0.08)',
                  'color': '#212529'
                }
              },
              {
                id: Date.now() + 3_5,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item .form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f8f9fa',
                  'color': '#212529',
                  'border-color': '#c8ced4',
                  'box-shadow': 'inset 0 1px 2px rgba(0, 0, 0, 0.05)'
                }
              },
              {
                id: Date.now() + 3_6,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item .form-control:disabled',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f1f3f5',
                  'color': 'rgba(33, 37, 41, 0.55)',
                  'border-color': '#d9dfe5'
                }
              },
              {
                id: Date.now() + 3_7,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item .form-text',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#6c757d'
                }
              },
              // Toolbar kompakt
              {
                id: Date.now() + 4,
                enabled: true,
                selector: '.mb-toolbar',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '8px'
                }
              },
              {
                id: Date.now() + 5,
                enabled: true,
                selector: '.mb-toolbar .btn',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '4px 8px',
                  'font-size': '13px'
                }
              },
              // Keywords klein
              {
                id: Date.now() + 6,
                enabled: true,
                selector: '.keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '4px 8px',
                  'font-size': '12px',
                  'background-color': '#e9ecef',
                  'color': '#212529',
                  'border': '1px solid #dee2e6'
                }
              },
              // Footer kompakt
              {
                id: Date.now() + 7,
                enabled: true,
                selector: 'footer',
                groupId: null,
                linkId: null,
                properties: {
                  'padding': '8px',
                  'font-size': '12px'
                }
              },
              // Duplicates dialog (ensure readable light styling)
              {
                id: Date.now() + 8,
                enabled: true,
                selector: '#duplicatesModal .card',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'border': '1px solid #e0e0e0'
                }
              },
              {
                id: Date.now() + 9,
                enabled: true,
                selector: '#duplicatesModal .card-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#f8f9fa',
                  'border-bottom': '1px solid #e9ecef'
                }
              },
              {
                id: Date.now() + 10,
                enabled: true,
                selector: '#duplicatesModal .list-group-item',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#ffffff',
                  'color': '#212529',
                  'border-color': '#e9ecef'
                }
              },
              {
                id: Date.now() + 11,
                enabled: true,
                selector: '#duplicatesModal .badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background-color': '#e9ecef',
                  'color': '#212529',
                  'border': '1px solid #dee2e6'
                }
              }
            ],
            'colorful': [
              // Body mit Gradient Background
              {
                id: Date.now() + 1,
                enabled: true,
                selector: 'body',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(120deg, #a1c4fd 0%, #c2e9fb 100%)',
                  'min-height': '100vh',
                  'position': 'relative'
                }
              },
              {
                id: Date.now() + 2,
                enabled: true,
                selector: '.mb-app',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'transparent'
                }
              },
              // Title Bar mit Glaseffekt
              {
                id: Date.now() + 3,
                enabled: true,
                selector: '.mb-titlebar',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(255, 255, 255, 0.95) 100%)',
                  'backdrop-filter': 'blur(20px) saturate(180%)',
                  'border-bottom': 'none',
                  'box-shadow': '0 8px 32px rgba(31, 38, 135, 0.15)'
                }
              },
              {
                id: Date.now() + 4,
                enabled: true,
                selector: '.mb-titlebar__title',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f64f59 100%)',
                  '-webkit-background-clip': 'text',
                  '-webkit-text-fill-color': 'transparent',
                  'background-clip': 'text',
                  'font-weight': '700',
                  'letter-spacing': '-0.5px'
                }
              },
              // Groups mit Glaseffekt
              {
                id: Date.now() + 5,
                enabled: true,
                selector: '.mb-group',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.9)',
                  'backdrop-filter': 'blur(10px) saturate(150%)',
                  'border': '1px solid rgba(255, 255, 255, 0.8)',
                  'box-shadow': '0 4px 24px rgba(31, 38, 135, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08)',
                  'margin-bottom': '16px',
                  'border-radius': '16px',
                  'overflow': 'hidden',
                  'transition': 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
                }
              },
              {
                id: Date.now() + 5_1,
                enabled: true,
                selector: '.mb-group__body',
                groupId: null,
                linkId: null,
                properties: {
                  'border-top-left-radius': '0',
                  'border-top-right-radius': '0',
                  'border-bottom-left-radius': '16px',
                  'border-bottom-right-radius': '16px'
                }
              },
              {
                id: Date.now() + 6,
                enabled: true,
                selector: '.mb-group__header',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(161, 196, 253, 0.2) 0%, rgba(194, 233, 251, 0.2) 100%)',
                  'border-bottom': '1px solid rgba(255, 255, 255, 0.6)',
                  'padding': '12px 16px'
                }
              },
              {
                id: Date.now() + 7,
                enabled: true,
                selector: '.mb-group__title',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#2d3561',
                  'font-weight': '600',
                  'font-size': '16px'
                }
              },
              // Links
              {
                id: Date.now() + 8,
                enabled: true,
                selector: '.mb-link',
                groupId: null,
                linkId: null,
                properties: {
                  'transition': 'all 0.2s ease',
                  'padding': '8px 16px'
                }
              },
              {
                id: Date.now() + 9,
                enabled: true,
                selector: '.mb-link__url',
                groupId: null,
                linkId: null,
                properties: {
                  'color': '#5e72e4',
                  'font-weight': '500',
                  'text-decoration': 'none',
                  'transition': 'all 0.2s ease'
                }
              },
              {
                id: Date.now() + 9_1,
                enabled: true,
                selector: '.link-detail-popover',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.95)',
                  'color': '#1f2933',
                  'border': '1px solid rgba(255, 255, 255, 0.6)',
                  'box-shadow': '0 28px 60px rgba(58, 66, 125, 0.25)',
                  'backdrop-filter': 'blur(16px) saturate(160%)'
                }
              },
              {
                id: Date.now() + 9_2,
                enabled: true,
                selector: '.link-detail-popover__badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(102, 126, 234, 0.25)',
                  'color': '#3d3a7a'
                }
              },
              {
                id: Date.now() + 9_3,
                enabled: true,
                selector: '.link-detail-popover__favicon',
                groupId: null,
                linkId: null,
                properties: {
                  'box-shadow': '0 4px 12px rgba(95, 111, 255, 0.35)'
                }
              },
              {
                id: Date.now() + 9_4,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.95)',
                  'border': '1px solid rgba(255, 255, 255, 0.75)',
                  'box-shadow': '0 18px 44px rgba(102, 126, 234, 0.2)',
                  'border-radius': '16px',
                  'color': '#2d3561'
                }
              },
              {
                id: Date.now() + 9_5,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item .form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.92)',
                  'color': '#2d3561',
                  'border': '1px solid rgba(102, 126, 234, 0.3)',
                  'box-shadow': 'inset 0 1px 2px rgba(102, 126, 234, 0.15)'
                }
              },
              {
                id: Date.now() + 9_6,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item .form-control:disabled',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.7)',
                  'color': 'rgba(45, 53, 97, 0.55)',
                  'border': '1px solid rgba(102, 126, 234, 0.25)'
                }
              },
              {
                id: Date.now() + 9_7,
                enabled: true,
                selector: '.link-shorteners-list .link-shorteners-item .form-text',
                groupId: null,
                linkId: null,
                properties: {
                  'color': 'rgba(45, 53, 97, 0.7)'
                }
              },
              // Keywords mit Gradient
              {
                id: Date.now() + 10,
                enabled: true,
                selector: '.keyword-badge',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  'color': 'white',
                  'border': 'none',
                  'padding': '4px 10px',
                  'border-radius': '20px',
                  'font-size': '11px',
                  'font-weight': '600',
                  'letter-spacing': '0.3px',
                  'transition': 'all 0.2s ease'
                }
              },
              // Buttons mit Gradient
              {
                id: Date.now() + 11,
                enabled: true,
                selector: '.btn',
                groupId: null,
                linkId: null,
                properties: {
                  'border-radius': '8px',
                  'font-weight': '500',
                  'transition': 'all 0.2s ease',
                  'text-transform': 'none',
                  'letter-spacing': '0.2px'
                }
              },
              {
                id: Date.now() + 12,
                enabled: true,
                selector: '.btn-primary',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  'border': 'none',
                  'color': 'white',
                  'box-shadow': '0 4px 12px rgba(102, 126, 234, 0.25)'
                }
              },
              {
                id: Date.now() + 13,
                enabled: true,
                selector: '.btn-success',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
                  'border': 'none',
                  'color': 'white'
                }
              },
              {
                id: Date.now() + 14,
                enabled: true,
                selector: '.btn-danger',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, #eb3349 0%, #f45c43 100%)',
                  'border': 'none',
                  'color': 'white'
                }
              },
              // Toolbar
              {
                id: Date.now() + 15,
                enabled: true,
                selector: '.mb-toolbar',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(255, 255, 255, 0.95) 100%)',
                  'backdrop-filter': 'blur(20px) saturate(150%)',
                  'border-bottom': '1px solid rgba(255, 255, 255, 0.8)',
                  'box-shadow': '0 2px 8px rgba(0, 0, 0, 0.04)',
                  'padding': '12px'
                }
              },
              // Forms
              {
                id: Date.now() + 16,
                enabled: true,
                selector: '.form-control',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.9)',
                  'border': '1px solid rgba(102, 126, 234, 0.2)',
                  'border-radius': '8px',
                  'color': '#2d3561',
                  'transition': 'all 0.2s ease'
                }
              },
              {
                id: Date.now() + 17,
                enabled: true,
                selector: '.form-select',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.9)',
                  'border': '1px solid rgba(102, 126, 234, 0.2)',
                  'border-radius': '8px',
                  'color': '#2d3561',
                  'transition': 'all 0.2s ease'
                }
              },
              // Modals
              {
                id: Date.now() + 18,
                enabled: true,
                selector: '.modal-content',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(255, 255, 255, 0.98)',
                  'backdrop-filter': 'blur(20px)',
                  'border': 'none',
                  'border-radius': '16px',
                  'box-shadow': '0 20px 60px rgba(0, 0, 0, 0.15)'
                }
              },
              {
                id: Date.now() + 19,
                enabled: true,
                selector: '.modal-header',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%)',
                  'border-bottom': '1px solid rgba(102, 126, 234, 0.1)',
                  'border-radius': '16px 16px 0 0'
                }
              },
              {
                id: Date.now() + 20,
                enabled: true,
                selector: '.modal-footer',
                groupId: null,
                linkId: null,
                properties: {
                  'background': 'rgba(0, 0, 0, 0.02)',
                  'border-top': '1px solid rgba(102, 126, 234, 0.1)',
                  'border-radius': '0 0 16px 16px'
                }
              }
            ],
          };

          return templates[this.selectedVisualTemplate] || [];
        },

        loadVisualTemplate() {
          // Just change the template, don't modify any rules
          // Template serves as base layer, user rules stay intact
          if (this.selectedVisualTemplate) {
            // Save template selection
            localStorage.setItem('selectedVisualTemplate', this.selectedVisualTemplate);
          }
          // Apply CSS with new template as base layer
          this.applyVisualCss();
        },

        // Toast Notification Helper
        showToast(message, type = 'success') {
          // Use global toast function
          if (window.showAppToast) {
            window.showAppToast(message, type);
          }
        },

        // Rule Set Management Methods
        saveRuleSet() {
          const name = prompt(this.getTranslation('css.visual.ruleSetName') || 'Name für Regel-Satz:');
          if (!name) return;

          // Save current rules to custom sets (without template)
          this.customRuleSets[name] = {
            name: name,
            rules: JSON.parse(JSON.stringify(this.visualCssRules)),
            createdAt: Date.now()
          };

          // Save to localStorage
          localStorage.setItem('customRuleSets', JSON.stringify(this.customRuleSets));

          // Reset selection to the saved set
          this.selectedRuleSetName = name;

          this.showToast(this.getTranslation('css.visual.ruleSetSaved') || 'Regel-Satz gespeichert!', 'success');
        },

        loadRuleSet(name) {
          if (!this.customRuleSets[name]) return;

          const ruleSet = this.customRuleSets[name];

          // Load the rules (template stays as it was)
          this.visualCssRules = JSON.parse(JSON.stringify(ruleSet.rules));

          // Save and apply
          this.saveVisualCss();

          this.showToast(this.getTranslation('css.visual.ruleSetLoaded') || 'Regel-Satz geladen', 'success');
        },

        deleteRuleSet(name) {
          if (!this.customRuleSets[name]) return;

          if (!confirm(this.getTranslation('css.visual.deleteRuleSetConfirm') || 'Möchten Sie den Regel-Satz "' + name + '" wirklich löschen?')) {
            return;
          }

          delete this.customRuleSets[name];

          // Clear selection
          if (this.selectedRuleSetName === name) {
            this.selectedRuleSetName = null;
          }

          // Save to localStorage
          localStorage.setItem('customRuleSets', JSON.stringify(this.customRuleSets));

          this.showToast(this.getTranslation('css.visual.ruleSetDeleted') || 'Regel-Satz gelöscht', 'success');
        },

        loadCustomRuleSets() {
          // Load saved rule sets from localStorage
          const saved = localStorage.getItem('customRuleSets');
          if (saved) {
            try {
              this.customRuleSets = JSON.parse(saved);
            } catch (e) {
              console.error('Failed to load custom rule sets:', e);
              this.customRuleSets = {};
            }
          }
        },

        // CSS Sidebar resize methods
        startCssSidebarWidthResize(e) {
          this.isCssSidebarWidthResizing = true;
          const startX = e.pageX;
          const startWidth = this.cssSidebarWidth;

          const doResize = (moveEvent) => {
            const diff = startX - moveEvent.pageX;
            const newWidth = Math.max(300, Math.min(800, startWidth + diff));
            this.cssSidebarWidth = newWidth;
            // Update body margin when resizing
            if (document.body.classList.contains('css-sidebar-open')) {
              document.body.style.marginRight = newWidth + 'px';
            }
          };

          const stopResize = () => {
            this.isCssSidebarWidthResizing = false;
            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopResize);
            // Save the width to localStorage
            localStorage.setItem('cssSidebarWidth', this.cssSidebarWidth);
          };

          document.addEventListener('mousemove', doResize);
          document.addEventListener('mouseup', stopResize);
        },
        
        openFeatureSidebar() {
          this.featureSidebarVisible = true;
        },
        
        saveCssTemplate() {
          if (!this.newTemplateName.trim()) return;
          
          // Initialize templates array if needed
          if (!this.data.options) this.$set(this.data, 'options', {});
          if (!this.data.options.cssTemplates) this.$set(this.data.options, 'cssTemplates', []);
          
          // Generate unique ID
          const templateId = 'tpl_' + Date.now();
          
          // Create new template
          const newTemplate = {
            id: templateId,
            name: this.newTemplateName.trim(),
            css: this.customCssDraft || '',
            createdAt: new Date().toISOString()
          };
          
          // Check if template with same name exists
          const existingIndex = this.data.options.cssTemplates.findIndex(t => t.name === newTemplate.name);
          if (existingIndex >= 0) {
            // Replace existing template
            const confirmMsg = this.getTranslation('css.templates.overwriteConfirm', [newTemplate.name])
              .replace('{0}', newTemplate.name);
            if (confirm(confirmMsg)) {
              this.$set(this.data.options.cssTemplates, existingIndex, newTemplate);
            } else {
              return;
            }
          } else {
            // Add new template
            this.data.options.cssTemplates.push(newTemplate);
          }
          
          // Update local list
          this.cssTemplates = [...this.data.options.cssTemplates];
          
          // Save to storage
          this.saveData();
          
          // Reset dialog
          this.showSaveTemplateDialog = false;
          this.newTemplateName = '';
          
          // Select the new template
          this.selectedTemplateId = templateId;
          
          // Show success notification
          // Template saved
          console.log('CSS Template saved:', newTemplate.name);
        },
        
        loadCssTemplate() {
          if (!this.selectedTemplateId) {
            // Clear selection
            this.customCssDraft = '';
            this.applyCustomCss('');
            return;
          }
          
          // Find selected template
          const template = this.cssTemplates.find(t => t.id === this.selectedTemplateId);
          if (template) {
            this.customCssDraft = template.css;
            this.applyCustomCss(template.css);
            
            // Log template loading
            console.log('CSS Template loaded:', template.name);
          }
        },
        
        // CSS Sidebar resize methods
        startCssSidebarResize(event) {
          this.isCssSidebarResizing = true;
          this.cssSidebarStartY = event.clientY;
          this.cssSidebarStartHeight = this.cssSidebarTopHeight;
          
          // Add event listeners
          document.addEventListener('mousemove', this.handleCssSidebarResize);
          document.addEventListener('mouseup', this.endCssSidebarResize);
          
          // Prevent text selection during resize
          event.preventDefault();
        },
        
        handleCssSidebarResize(event) {
          if (!this.isCssSidebarResizing) return;
          
          const deltaY = event.clientY - this.cssSidebarStartY;
          const newHeight = this.cssSidebarStartHeight + deltaY;
          
          // Get the container height
          const containerHeight = window.innerHeight - 60; // Subtract header height
          
          // Limit the height between min and max
          const minHeight = 100;
          const maxHeight = containerHeight - 200; // Leave at least 200px for bottom section
          
          this.cssSidebarTopHeight = Math.min(Math.max(newHeight, minHeight), maxHeight);
        },
        
        endCssSidebarResize() {
          this.isCssSidebarResizing = false;
          
          // Remove event listeners
          document.removeEventListener('mousemove', this.handleCssSidebarResize);
          document.removeEventListener('mouseup', this.endCssSidebarResize);
          
          // Save the height to localStorage
          localStorage.setItem('cssSidebarTopHeight', this.cssSidebarTopHeight.toString());
        },
        
        // CSS Sidebar Width Resize Methods
        startCssSidebarWidthResize(event) {
          this.isCssSidebarWidthResizing = true;
          this.cssSidebarStartX = event.clientX;
          this.cssSidebarStartWidth = this.cssSidebarWidth;
          
          // Add event listeners
          document.addEventListener('mousemove', this.handleCssSidebarWidthResize);
          document.addEventListener('mouseup', this.endCssSidebarWidthResize);
          
          // Prevent text selection during resize
          event.preventDefault();
        },
        
        handleCssSidebarWidthResize(event) {
          if (!this.isCssSidebarWidthResizing) return;

          const deltaX = this.cssSidebarStartX - event.clientX; // Negative because we're resizing from the left edge
          const newWidth = this.cssSidebarStartWidth + deltaX;

          // Constrain width between 300px and 80% of window width
          const minWidth = 300;
          const maxWidth = window.innerWidth * 0.8;

          this.cssSidebarWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);

          // Update body margin when resizing
          if (document.body.classList.contains('css-sidebar-open')) {
            document.body.style.marginRight = this.cssSidebarWidth + 'px';
          }
        },
        
        endCssSidebarWidthResize() {
          this.isCssSidebarWidthResizing = false;
          
          // Remove event listeners
          document.removeEventListener('mousemove', this.handleCssSidebarWidthResize);
          document.removeEventListener('mouseup', this.endCssSidebarWidthResize);
          
          // Save the width to localStorage
          localStorage.setItem('cssSidebarWidth', this.cssSidebarWidth.toString());
        },
        applyCustomCssFromTextarea(reset) {
          if (reset) {
            this.customCssDraft = '';
          }
          this.applyCustomCss(this.customCssDraft || '');
          // Force re-render of keywords to apply new gradient colors
          this.$forceUpdate();
        },
        saveCustomCss() {
          if (!this.data.options) this.$set(this.data, 'options', {});
          this.$set(this.data.options, 'customCss', this.customCssDraft || '');
          this.saveData();
          // Don't close sidebar - user may want to continue editing
        },
        revertCustomCss() {
          this.customCssDraft = this.data.options?.customCss || '';
          this.applyCustomCss(this.customCssDraft);
          // Don't close sidebar - user may want to continue editing
        },
        appendHook(sel) {
          try {
            const snippet = `${sel} {\n  \n}\n`;
            this.customCssDraft = (this.customCssDraft && this.customCssDraft.trim().length)
              ? (this.customCssDraft.replace(/\s*$/, '') + "\n\n" + snippet)
              : snippet;
            this.applyCustomCssFromTextarea(false);
          } catch (e) { debugLog('warn', 'appendHook failed', e); }
        },

        // Insert CSS Hooks for quick styling
        insertCssHooks(hookType) {
          let hooks = '';
          let selectors = [];

          switch(hookType) {
            case 'sidebar':
              selectors = [
                '.mb-css-sidebar',
                '.css-sidebar-resize-handle',
                '.mb-css-sidebar-header',
                '.mb-css-sidebar-title',
                '.sidebar-split-container',
                '.sidebar-top-section',
                '.mb-css-sidebar-help-content',
                '.sidebar-divider',
                '.sidebar-bottom-section',
                '.editor-header',
                '.mb-css-editor'
              ];
              hooks = `/* CSS Sidebar Styling */\n`;
              break;
            case 'groups':
              selectors = [
                '.groupContainer',
                '.groupContainerHeader',
                '.groupTitle',
                '.groupLinkCount',
                '.mb-group-info-section'
              ];
              hooks = `/* Group Styling */\n`;
              break;
            case 'links':
              selectors = [
                '.linkContainer',
                '.linkContainerListItem',
                '.linkText',
                '.linkText a',
                '.link-favicon'
              ];
              hooks = `/* Link Styling */\n`;
              break;
            case 'toolbar':
              selectors = [
                '.mb-toolbar',
                '.btn-toolbar',
                '.mb-toolbar__search',
                '.mb-toolbar__search input'
              ];
              hooks = `/* Toolbar Styling */\n`;
              break;
            case 'menus':
              selectors = [
                '.mb-context-menu',
                '.mb-context-menu ul',
                '.mb-context-menu ul li',
                '.mb-context-menu-separator',
                '.mb-context-submenu',
                '.mb-context-submenu-item',
                '.mb-context-submenu::after'
              ];
              hooks = `/* Context Menus Styling */\n`;
              break;
            case 'feature-sidebar':
              selectors = [
                '.mb-feature-sidebar',
                '.mb-feature-sidebar-header',
                '.mb-feature-sidebar-title',
                '.mb-feature-sidebar-content',
                '.feature-section',
                '.feature-card'
              ];
              hooks = `/* Feature Sidebar Styling */\n`;
              break;
            case 'all':
              return this.insertCssHooks('sidebar') + '\n' +
                     this.insertCssHooks('groups') + '\n' +
                     this.insertCssHooks('links') + '\n' +
                     this.insertCssHooks('toolbar') + '\n' +
                     this.insertCssHooks('menus') + '\n' +
                     this.insertCssHooks('feature-sidebar');
          }

          // Generate CSS rules with placeholders
          selectors.forEach(sel => {
            hooks += `${sel} {\n  /* Add your styles here */\n}\n\n`;
          });

          return hooks;
        },

        // Quick insert CSS hooks via button
        quickInsertCssHooks(hookType) {
          const hooks = this.insertCssHooks(hookType);
          if (hooks) {
            // Insert at cursor or append to end
            const textarea = this.$refs.cssTextarea;
            if (textarea) {
              const start = textarea.selectionStart;
              const end = textarea.selectionEnd;
              const text = this.customCssDraft || '';

              // Insert hooks at cursor position
              this.customCssDraft = text.substring(0, start) + hooks + text.substring(end);

              // Apply the CSS
              this.applyCustomCssFromTextarea(false);

              // Restore cursor position after Vue updates the textarea
              this.$nextTick(() => {
                textarea.focus();
                const newPosition = start + hooks.length;
                textarea.setSelectionRange(newPosition, newPosition);
              });
            } else {
              // Fallback: append to end
              this.customCssDraft = (this.customCssDraft || '') + '\n\n' + hooks;
              this.applyCustomCssFromTextarea(false);
            }
          }
        },
        
        insertCssSelector(event) {
          const selector = event.target.value;
          if (!selector) return;
          
          // Clean up selector for placeholders
          let cleanSelector = selector;
          if (selector.includes('...')) {
            // Replace placeholders with example values or prompt user
            if (selector.includes('uuid-...')) {
              cleanSelector = selector.replace('...', 'YOUR-UUID-HERE');
            } else if (selector.includes("data-keyword='...'")) {
              cleanSelector = selector.replace('...', 'your-keyword');
            } else if (selector.includes("data-group-uuid='...'")) {
              cleanSelector = selector.replace('...', 'YOUR-GROUP-UUID');
            } else if (selector.includes("data-link-uuid='...'")) {
              cleanSelector = selector.replace('...', 'YOUR-LINK-UUID');
            } else if (selector.includes("data-link-count='5'")) {
              // This one is already specific, no change needed
            } else if (selector.includes('mb-keyword-kw-...')) {
              cleanSelector = selector.replace('...', 'your-keyword');
            }
          }
          
          // Check if selector already exists in the CSS
          const currentCss = this.customCssDraft || '';
          const textarea = this.$refs.cssTextarea;
          
          // Create regex to find the selector (escape special characters)
          const escapedSelector = cleanSelector.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const selectorRegex = new RegExp(`^\\s*${escapedSelector}\\s*\\{`, 'gm');
          const existingMatch = selectorRegex.exec(currentCss);
          
          if (existingMatch) {
            // Selector already exists - jump to it
            if (textarea) {
              // Find the line number and position
              const position = existingMatch.index;
              
              // Set cursor position to the existing selector
              textarea.selectionStart = position;
              textarea.selectionEnd = position + existingMatch[0].length;
              textarea.focus();
              
              // Scroll to make it visible
              const lineHeight = parseInt(window.getComputedStyle(textarea).lineHeight);
              const lines = currentCss.substring(0, position).split('\n').length - 1;
              textarea.scrollTop = lines * lineHeight - (textarea.clientHeight / 2);
              
              // Sync the highlighted container
              this.syncScroll();
              
              // Selector already exists
              console.log(this.getTranslation('css.selectorExists') || 'CSS selector already exists! Jumped to line.');
            }
            
            // Reset dropdown
            event.target.value = '';
            return;
          }
          
          // Always add comments for complex selectors
          let snippet;
          const parts = cleanSelector.match(/(\.[a-zA-Z-]+|\[[^\]]+\])/g);
          
          // Always add comments for better readability
          if (parts && parts.length >= 1) {
            // Create a commented version for readability
            let comments = '/* ';
            const commentParts = [];
            
            parts.forEach((part, i) => {
              if (part.includes('data-group-uuid')) {
                // Extract UUID and find group name
                const uuidMatch = part.match(/data-group-uuid=['"]([^'"]+)['"]/);
                if (uuidMatch) {
                  const uuid = uuidMatch[1];
                  const group = this.data.groups?.find(g => g.uuid === uuid);
                  const groupName = group ? group.name : 'Unknown';
                  commentParts.push(`Group: ${groupName}`);
                }
              } else if (part.includes('data-link-uuid')) {
                // Extract UUID and find link name
                const uuidMatch = part.match(/data-link-uuid=['"]([^'"]+)['"]/);
                if (uuidMatch) {
                  const uuid = uuidMatch[1];
                  let linkName = 'Unknown';
                  // Search through all groups for the link
                  if (this.data.groups) {
                    for (const group of this.data.groups) {
                      const link = group.links?.find(l => l.uuid === uuid);
                      if (link) {
                        linkName = link.text || link.url;
                        break;
                      }
                    }
                  }
                  commentParts.push(`Link: ${linkName.substring(0, 25)}${linkName.length > 25 ? '...' : ''}`);
                }
              } else if (part.includes('data-keyword')) {
                const keywordMatch = part.match(/data-keyword=['"]([^'"]+)['"]/);
                if (keywordMatch) {
                  commentParts.push(`Keyword: ${keywordMatch[1]}`);
                }
              } else if (part.includes('data-link-count')) {
                const countMatch = part.match(/data-link-count=['"]([^'"]+)['"]/);
                if (countMatch) {
                  commentParts.push(`Count: ${countMatch[1]}`);
                }
              }
            });
            
            if (commentParts.length > 0) {
              comments += commentParts.join(' → ') + ' */\n';
              snippet = `${comments}${cleanSelector} {\n  \n}\n`;
            } else {
              snippet = `${cleanSelector} {\n  \n}\n`;
            }
          } else {
            snippet = `${cleanSelector} {\n  \n}\n`;
          }
          
          // Add to CSS draft
          if (this.$refs.cssTextarea) {
            const textarea = this.$refs.cssTextarea;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = this.customCssDraft || '';
            
            // If cursor is at a position, insert there
            if (start !== undefined && end !== undefined) {
              this.customCssDraft = text.substring(0, start) + snippet + text.substring(end);
              // Set cursor position inside the new rule
              this.$nextTick(() => {
                const newPos = start + cleanSelector.length + 3; // Position after " {\n  "
                textarea.selectionStart = newPos;
                textarea.selectionEnd = newPos;
                textarea.focus();
              });
            } else {
              // Otherwise append at the end
              this.customCssDraft = (text && text.trim().length)
                ? (text.replace(/\s*$/, '') + "\n\n" + snippet)
                : snippet;
            }
          } else {
            // Fallback if textarea ref not available
            this.customCssDraft = (this.customCssDraft && this.customCssDraft.trim().length)
              ? (this.customCssDraft.replace(/\s*$/, '') + "\n\n" + snippet)
              : snippet;
          }
          
          // Apply the CSS
          this.applyCustomCssFromTextarea(false);
          
          // Reset dropdown
          event.target.value = '';
        },
        
        // Insert selected color at cursor position in CSS editor
        insertColorAtCursor() {
          try {
            const textarea = this.$refs.cssTextarea;
            if (!textarea || !this.selectedColor) return;
            
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = this.customCssDraft || '';
            
            // Insert color at cursor position or replace selection
            const before = text.substring(0, start);
            const after = text.substring(end);
            
            // Format the color value
            const colorValue = this.selectedColor;
            
            // Update the text
            this.customCssDraft = before + colorValue + after;
            
            // Apply the CSS
            this.applyCustomCssFromTextarea(false);
            
            // Restore cursor position after Vue updates the textarea
            this.$nextTick(() => {
              textarea.focus();
              const newPosition = start + colorValue.length;
              textarea.setSelectionRange(newPosition, newPosition);
            });
          } catch (e) {
            console.warn('Error inserting color:', e);
          }
        },
        
        // Handle CSS input and trigger highlighting
        onCssInput() {
          this.applyCustomCssFromTextarea(false);
          // Force Vue to update the highlighted display
          this.$forceUpdate();
        },
        
        // Sync scroll position between textarea and highlighted display
        syncScroll() {
          try {
            const textarea = this.$refs.cssTextarea;
            const highlightedContainer = this.$refs.highlightedContainer;
            if (textarea && highlightedContainer) {
              // Move the pre element inside the container using transform
              const pre = highlightedContainer.querySelector('.mb-css-highlighted-pre');
              if (pre) {
                pre.style.transform = `translate(${-textarea.scrollLeft}px, ${-textarea.scrollTop}px)`;
              }
            }
          } catch (e) {
            // Ignore scroll sync errors
          }
        },
        // Reuse share dialog for owner transfer
        openOwnerTransferDialog(group) {
          const g = group || this.contextGroup;
          if (!g || !this.isOwnerOfGroup(g)) { alert(this.getTranslation('error.onlyOwner')); return; }
          // Prepare share dialog in a special mode 'owner-transfer'
          this.shareDialog = {
            visible: true,
            mode: 'owner-transfer',
            group: g,
            selectedContacts: {},
          };
          // Refresh online status for all contacts so availability is accurate in dialog
          this.checkAllContactsStatus && this.checkAllContactsStatus();
          // Show modal
          const el = document.getElementById('shareModal');
          if (el) bootstrap.Modal.getOrCreateInstance(el).show();
        },
        
        async broadcastIdentityMigration(oldUuid, newUuid) {
          try {
            if (!oldUuid || !newUuid) return;
            const from = { oldUuid, newUuid, name: this.data.identity?.name||'' };
            const env = { v:1, type:'identity-migrate', ts:Date.now(), from, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
            // To contacts (pairwise)
            for (const c of (this.data.contacts||[])) {
              try { await sharing.sendToContact(c.uuid, env); } catch {}
            }
            // To groups
            for (const g of (this.data.groups||[])) {
              if (g.shared && g.groupTopic && g.groupKey) {
                try { await sharing.sendToGroup(g, Object.assign({ groupId: g.groupId }, env)); } catch {}
              }
            }
          } catch(e) { try { console.warn('identity migrate broadcast failed', e); } catch {} }
        },
        
        async transferOwnership(group, newOwnerUuid) {
          try {
            if (!this.isOwnerOfGroup(group)) { alert(this.getTranslation('error.onlyOwner')); return; }
            const from = { uuid: this.data.identity?.uuid, name:this.data.identity?.name||'' };
            const env = { v:1, type:'owner-transfer', ts:Date.now(), from, groupId: group.groupId, newOwnerUuid, msgId:(Math.random().toString(36).slice(2)+Date.now()) };
            await sharing.sendToGroup(group, env);
            // NOTE: Do not apply locally yet; wait for new owner's acceptance and roster broadcast
          } catch(e) { try { console.warn('owner transfer failed', e); } catch {} }
        },
        // --- Conflict Resolution UI Methods ---
        showConflictResolutionNotification(message, duration = 5000) {
          this.conflictNotificationText = message;
          this.showConflictNotification = true;
          
          // Clear any existing timeout
          if (this.conflictNotificationTimeout) {
            clearTimeout(this.conflictNotificationTimeout);
          }
          
          // Auto-hide after duration
          this.conflictNotificationTimeout = setTimeout(() => {
            this.showConflictNotification = false;
            this.conflictNotificationText = '';
          }, duration);
        },
        
        // Role-based access helpers for sync settings
        isOwnerOfAnyGroup() {
          // Check if user is owner of at least one shared group
          return (this.data.groups || []).some(g => 
            g.shared && this.isOwnerOfGroup(g)
          );
        },
        
        isMemberOfAnyGroup() {
          // Check if user is member (not owner) of at least one shared group
          return (this.data.groups || []).some(g => 
            g.shared && !this.isOwnerOfGroup(g)
          );
        },
        
        isFieldAccessible(field) {
          // Check if field should be accessible based on role scope
          if (!field.roleScope || field.roleScope === 'all') {
            return true;
          }
          
          if (field.roleScope === 'owner') {
            return this.isOwnerOfAnyGroup();
          }
          
          if (field.roleScope === 'member') {
            return this.isMemberOfAnyGroup();
          }
          
          return true;
        },
        
        getRoleScopeBadgeText(roleScope) {
          switch(roleScope) {
            case 'all':
              return this.getTranslation('sync.role.all') || 'All';
            case 'owner':
              return this.getTranslation('sync.role.owner') || 'Owner';
            case 'member':
              return this.getTranslation('sync.role.member') || 'Member';
            default:
              return '';
          }
        },
        
        checkAndShowConflictNotifications() {
          // Check notification level setting
          const notificationLevel = this.data.options?.sync?.conflictNotificationLevel || 'minimal';
          
          // Don't show any notifications if set to silent
          if (notificationLevel === 'silent') {
            return;
          }
          
          // Check all groups for recent conflict resolutions
          for (const group of this.data.groups || []) {
            if (group.conflictNotifications?.length > 0) {
              const recentConflicts = group.conflictNotifications.filter(
                n => n.timestamp > Date.now() - 10000 // Last 10 seconds
              );
              
              if (recentConflicts.length > 0) {
                const latestConflict = recentConflicts[recentConflicts.length - 1];
                
                // For 'minimal' level, only show important conflicts
                if (notificationLevel === 'minimal') {
                  // Skip minor conflicts
                  if (latestConflict.operation === 'link-edit' && latestConflict.winner === 'local') {
                    continue; // User's own edits winning is not important
                  }
                }
                
                let message = '';
                
                switch (latestConflict.operation) {
                  case 'link-edit':
                    message = this.getTranslation('sync.conflict.linkEdit') || 
                             `Link edit conflict resolved (${latestConflict.winner} version kept)`;
                    break;
                  case 'link-add':
                    message = this.getTranslation('sync.conflict.linkAdd') || 
                             `Duplicate link prevented`;
                    break;
                  case 'link-delete':
                    message = this.getTranslation('sync.conflict.linkDelete') || 
                             `Link deletion conflict resolved`;
                    break;
                  default:
                    message = this.getTranslation('sync.conflict.generic') || 
                             `Sync conflict automatically resolved`;
                }
                
                this.showConflictResolutionNotification(message);
                
                // Mark as shown
                latestConflict.shown = true;
              }
            }
          }
        },
        
        // --- Event-Log Migration Helpers (Prepared for Future) ---
        migrateGroupToEventLog(group) {
          // Skip if already migrated
          if (group.eventLog) {
            debugLog('log', '[MIGRATION] Group already has event log', group.groupId);
            return false;
          }
          
          // Ensure group has a groupId (needed for event-log)
          if (!group.groupId) {
            // Use existing UUID or generate a new one
            group.groupId = group.uuid || this.generateUUID();
            if (!group.uuid) {
              group.uuid = group.groupId;
            }
          }
          
          // Ensure we have an identity UUID for event-log
          if (!this.data.identity?.uuid) {
            if (!this.data.identity) {
              this.$set(this.data, 'identity', { 
                uuid: this.generateUUID(),
                name: '', 
                pubKey: '', 
                privKey: '' 
              });
            } else {
              this.$set(this.data.identity, 'uuid', this.generateUUID());
            }
          }
          
          const author = this.data.identity.uuid;
          
          // Create initial snapshot event
          const migrationEvent = {
            eventId: 'migration-' + (group.uuid || this.generateUUID()),
            parentId: null,
            timestamp: Date.now(),
            author: author,
            vectorClock: { [author]: 1 },
            operation: {
              type: 'snapshot',
              data: {
                links: JSON.parse(JSON.stringify(group.links || [])),
                members: JSON.parse(JSON.stringify(group.members || [])),
                version: group.version || 0,
                name: group.name || '',
                color: group.color || '',
                keywords: group.keywords || '',
                emoji: group.emoji || '',
                favicon: group.favicon || '',
                faviconSource: group.faviconSource || null,
                faviconRuleId: group.faviconRuleId || null,
                infoHtml: group.infoHtml || ''
              }
            }
          };
          
          // Initialize event log with migration event
          this.$set(group, 'eventLog', [migrationEvent]);
          this.$set(group, 'headEventId', migrationEvent.eventId);
          this.$set(group, 'vectorClock', { [author]: 1 });
          this.$set(group, 'snapshot', migrationEvent.operation.data);

          debugLog('log', '[MIGRATION] Migrated group to event-log system', {
            groupId: group.groupId,
            eventId: migrationEvent.eventId
          });
          
          return true;
        },
        
        // Enable event-log sync for a group (opt-in, owner only)
        enableEventLogSync(group) {
          if (!group.shared) {
            debugLog('warn', '[EVENT-LOG] Cannot enable event-log sync for non-shared group');
            return false;
          }
          
          // Only owner can enable event-log
          if (!this.isOwnerOfGroup(group)) {
            debugLog('warn', '[EVENT-LOG] Only owner can enable event-log sync');
            alert(this.getTranslation('error.eventlog.ownerOnly') || 'Only the owner can enable event-log for this group');
            return false;
          }
          
          // Migrate if needed
          if (!group.eventLog) {
            this.migrateGroupToEventLog(group);
          }
          
          // Mark as event-log enabled
          this.$set(group, 'useEventLog', true);
          
          debugLog('log', '[EVENT-LOG] Enabled event-log sync for group', group.groupId);
          this.saveData();
          
          // IMPORTANT: Notify all members about event-log activation
          if (sharing && group.shared && group.groupTopic) {
            try {
              const activationMessage = {
                v: 1,
                type: 'event-log-activation',
                ts: Date.now(),
                from: { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' },
                groupId: group.groupId,
                useEventLog: true,
                // Send complete event-log data
                eventLog: group.eventLog || [],
                snapshot: group.snapshot || null,
                headEventId: group.headEventId || null,
                vectorClock: group.vectorClock || {},
                migrationSnapshot: {
                  eventId: group.eventLog[0].eventId,
                  timestamp: group.eventLog[0].timestamp,
                  data: group.eventLog[0].operation.data
                },
                msgId: (Math.random().toString(36).slice(2) + Date.now())
              };
              
              debugLog('log', '[EVENT-LOG] Notifying members about event-log activation');
              sharing.sendToGroup(group, activationMessage);
            } catch (e) {
              debugLog('error', '[EVENT-LOG] Failed to notify members:', e);
            }
          }
          
          return true;
        },
        
        // Create event for operations (prepared for future use)
        createSyncEvent(group, operation) {
          if (!group.useEventLog) return null;
          
          const vectorClock = group.vectorClock || {};
          const myId = this.data.identity?.uuid || 'unknown';
          vectorClock[myId] = (vectorClock[myId] || 0) + 1;
          
          const event = {
            eventId: this.generateUUID(),
            parentId: group.headEventId || null,
            timestamp: Date.now(),
            author: myId,
            vectorClock: { ...vectorClock },
            operation: operation
          };
          
          return event;
        },
        
        // Helper method to send sync event to group members
        async sendSyncEventToMembers(group, event) {
          // Don't check useEventLog here - that's already done in createAndApplyEvent
          if (!group.groupTopic || !group.groupKey) {
            debugLog('warn', '[SYNC] Missing groupTopic or groupKey, cannot send sync');
            return;
          }
          if (typeof sharing === 'undefined' || !sharing) {
            debugLog('error', '[SYNC] Sharing module not available');
            return;
          }
          
          const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
          const syncEvent = {
            v: 1,
            type: 'sync-event',
            ts: Date.now(),
            from,
            groupId: group.groupId,
            event: event,
            // Don't include full eventLog and snapshot in every sync - too large
            // These are sent separately in group-update messages
            msgId: (Math.random().toString(36).slice(2) + Date.now())
          };
          
          debugLog('log', '[SYNC] Sending sync event to group members:', {
            groupId: group.groupId,
            eventType: event.operation?.type,
            eventId: event.eventId,
            hasGroupTopic: !!group.groupTopic,
            hasGroupKey: !!group.groupKey
          });
          
          try {
            await sharing.sendToGroup(group, syncEvent);
            debugLog('log', '[SYNC] Successfully sent sync event');
          } catch (error) {
            debugLog('error', '[SYNC] Error sending sync event:', error);
          }
        },
        
        // Helper method to create and apply event with sync
        createAndApplyEvent(group, operation, skipSync = false) {
          debugLog('log', '[EVENT-LOG] createAndApplyEvent called:', {
            groupName: group.name,
            groupId: group.groupId,
            useEventLog: group.useEventLog,
            hasEventLogManager: !!this.eventLogManager,
            operationType: operation.type,
            isShared: group.shared
          });
          
          if (!group.useEventLog || !this.eventLogManager) {
            debugLog('warn', '[EVENT-LOG] Cannot create event:', {
              useEventLog: group.useEventLog,
              hasEventLogManager: !!this.eventLogManager
            });
            return null;
          }
          
          const event = this.createSyncEvent(group, operation);
          if (!event) {
            debugLog('warn', '[EVENT-LOG] createSyncEvent returned null');
            return null;
          }
          
          debugLog('log', '[EVENT-LOG] Event created:', event);
          
          // Apply locally
          const added = this.eventLogManager.addEvent(event, group);
          if (!added) {
            debugLog('warn', '[EVENT-LOG] Failed to add event:', event);
            return null;
          }
          
          debugLog('log', '[EVENT-LOG] Created and applied event:', {
            type: operation.type,
            eventId: event.eventId,
            eventCount: group.eventLog?.length || 0,
            groupId: group.groupId,
            isShared: group.shared
          });
          
          // Send to members if group is shared
          if (!skipSync && group.shared && group.groupTopic) {
            this.sendSyncEventToMembers(group, event);
          }
          
          return event;
        },
        
        // --- Dark Mode ---
        toggleDarkMode() {
          this.isDarkMode = !this.isDarkMode;
          this.applyDarkMode();
          localStorage.setItem('darkMode', this.isDarkMode ? 'true' : 'false');
        },
        
        applyDarkMode() {
          if (this.isDarkMode) {
            document.documentElement.setAttribute('data-theme', 'dark');
          } else {
            document.documentElement.removeAttribute('data-theme');
          }
        },
        
        initDarkMode() {
          const savedDarkMode = localStorage.getItem('darkMode');
          if (savedDarkMode === 'true') {
            this.isDarkMode = true;
            this.applyDarkMode();
          }
        },
        
        // --- Color Customization ---
        initCustomColors() {
          // Apply colors from data.options.colors if available
          if (this.data.options?.colors) {
            this.applyCustomColors();
          } 
          // Fallback to old customColors for backward compatibility
          else if (this.data.options?.customColors) {
            this.customColors = Object.assign({}, this.data.options.customColors);
            this.applyCustomColors();
          } 
          // Fallback to localStorage for backward compatibility
          else {
            const savedColors = localStorage.getItem('customColors');
            if (savedColors) {
              try {
                this.customColors = JSON.parse(savedColors);
                this.applyCustomColors();
              } catch (e) {
                debugLog('error', 'Failed to load custom colors:', e);
              }
            }
          }
        },
        
        applyCustomColors() {
          debugLog('log', 'applyCustomColors called');
          const root = document.documentElement;
          
          // Generic approach: iterate through optionsDesign to find all color fields with cssVar
          Object.keys(this.optionsDesign).forEach(sectionKey => {
            const section = this.optionsDesign[sectionKey];
            if (section.fields) {
              Object.keys(section.fields).forEach(fieldKey => {
                const field = section.fields[fieldKey];
                
                // Check if this field has a CSS variable mapping
                if (field.cssVar && field.optionPath) {
                  // Get the value from data.options using the optionPath
                  const pathParts = field.optionPath.split('.');
                  let value = this.data.options;
                  for (const part of pathParts) {
                    value = value?.[part];
                  }
                  
                  // Parse JSON and generate full CSS if needed
                  let cssProperties = {};
                  
                  if (value && typeof value === 'string') {
                    try {
                      const jsonData = JSON.parse(value);
                      
                      // Generate CSS properties from JSON
                      if (jsonData.backgroundColor) {
                        cssProperties['background-color'] = jsonData.backgroundColor;
                      }
                      if (jsonData.color) {
                        cssProperties['color'] = jsonData.color;
                      }
                      if (jsonData.opacity && jsonData.opacity < 100) {
                        cssProperties['opacity'] = (jsonData.opacity / 100).toFixed(2);
                      }
                      if (jsonData.fontFamily) {
                        cssProperties['font-family'] = jsonData.fontFamily;
                      }
                      if (jsonData.fontSize && jsonData.fontSize !== '') {
                        cssProperties['font-size'] = jsonData.fontSize + (jsonData.fontSizeUnit || 'px');
                      }
                      if (jsonData.fontWeight) {
                        cssProperties['font-weight'] = jsonData.fontWeight;
                      }
                      if (jsonData.borderStyle && jsonData.borderStyle !== 'none') {
                        cssProperties['border-style'] = jsonData.borderStyle;
                        if (jsonData.borderWidth) {
                          cssProperties['border-width'] = jsonData.borderWidth + 'px';
                        }
                        if (jsonData.borderColor) {
                          cssProperties['border-color'] = jsonData.borderColor;
                        }
                      }
                      if (jsonData.borderRadius) {
                        cssProperties['border-radius'] = jsonData.borderRadius + 'px';
                      }
                      if (jsonData.padding) {
                        cssProperties['padding'] = jsonData.padding + 'px';
                      }
                      if (jsonData.margin) {
                        cssProperties['margin'] = jsonData.margin + 'px';
                      }
                      
                      // Store all properties as CSS variables with a prefix
                      const varPrefix = field.cssVar || `--custom-${fieldKey}`;
                      
                      // Set individual CSS variables for each property
                      Object.keys(cssProperties).forEach(prop => {
                        const varName = `${varPrefix}-${prop.replace(/-/g, '_')}`;
                        root.style.setProperty(varName, cssProperties[prop]);
                        debugLog('log', `Setting CSS var ${varName} to ${cssProperties[prop]}`);
                      });
                      
                      // Also set the main variable with the primary color for backward compatibility
                      if (field.cssVar && jsonData.backgroundColor) {
                        root.style.setProperty(field.cssVar, jsonData.backgroundColor);
                        debugLog('log', `Setting main CSS var ${field.cssVar} to ${jsonData.backgroundColor}`);
                      }
                      
                    } catch (e) {
                      // Not JSON, use as simple value
                      if (value && value.trim() !== '') {
                        root.style.setProperty(field.cssVar, value);
                        debugLog('log', `Setting CSS var ${field.cssVar} to ${value}`);
                      }
                    }
                  } else if (field.default) {
                    // Use default value if no custom value is set
                    root.style.setProperty(field.cssVar, field.default);
                  } else {
                    // Remove the CSS variable if no value and no default
                    root.style.removeProperty(field.cssVar);
                  }
                }
              });
            }
          });
          
          // Also check group and link designs for CSS variables
          if (this.groupDesign) {
            this.applyDesignColors(this.groupDesign, 'groups');
          }
          if (this.linkDesign) {
            this.applyDesignColors(this.linkDesign, 'links');
          }
        },
        
        applyDesignColors(design, optionPrefix) {
          const root = document.documentElement;
          Object.keys(design).forEach(sectionKey => {
            const section = design[sectionKey];
            if (section.fields) {
              Object.keys(section.fields).forEach(fieldKey => {
                const field = section.fields[fieldKey];
                if (field.cssVar && field.optionPath) {
                  const pathParts = field.optionPath.split('.');
                  let value = this.data.options;
                  for (const part of pathParts) {
                    value = value?.[part];
                  }
                  if (value && value.trim() !== '') {
                    root.style.setProperty(field.cssVar, value);
                  } else if (field.default) {
                    root.style.setProperty(field.cssVar, field.default);
                  } else {
                    root.style.removeProperty(field.cssVar);
                  }
                }
              });
            }
          });
        },
        
        resetColor(colorType) {
          const defaults = {
            background: '#fafbfc',
            toolbar: '#ffffff',
            titleBar: '#f8f9fa',
            titleText: '#1a1a1a',
            keywordContainer: '#f0f0f0'
          };
          
          if (defaults[colorType]) {
            // Reset to default value (website colors always have defaults)
            this.customColors[colorType] = defaults[colorType];
            this.applyCustomColors();
          } else {
            // Remove the color entirely (for group/link colors without defaults)
            this.customColors[colorType] = '';
            this.applyCustomColors();
          }
        },
        
        resetAllColors() {
          this.customColors = {
            background: '#fafbfc',
            toolbar: '#ffffff',
            titleBar: '#f8f9fa',
            titleText: '#1a1a1a',
            keywordContainer: '#f0f0f0'
          };
          this.applyCustomColors();
        },
        
        // --- Ownership helper ---
        isOwnerOfGroup(group) {
          try {
            if (!group) return false;
            const my = this.data?.identity?.uuid;
            if (!my) return false;
            if (group.ownerUuid && group.ownerUuid === my) return true;
            const members = Array.isArray(group.members) ? group.members : [];
            return members.some(m => m.role === 'owner' && m.uuid === my);
          } catch { return false; }
        },
        // Check if NTFY URL is configured
        hasNtfyUrl() {
          return this.data.options?.sharing?.ntfyServerUrl && this.data.options.sharing.ntfyServerUrl.trim();
        },
        // --- Permission helpers ---
        normalizeUrl(u) {
          try {
            if (!u) return '';
            const url = new URL(u, 'http://example.invalid');
            if (!url.protocol || (url.protocol !== 'http:' && url.protocol !== 'https:')) return (u||'').trim();
            let host = (url.hostname || '').toLowerCase();
            let proto = url.protocol.toLowerCase();
            let port = url.port;
            if ((proto === 'http:' && port === '80') || (proto === 'https:' && port === '443')) port = '';
            // drop tracking params
            try {
              ['utm_source','utm_medium','utm_campaign','utm_term','utm_content'].forEach(k=>url.searchParams.delete(k));
            } catch {}
            let path = url.pathname || '/';
            // remove trailing slash except root
            if (path.length > 1 && path.endsWith('/')) path = path.slice(0, -1);
            const qs = url.search || '';
            // ignore hash for normalization
            return `${proto}//${host}${port?(':'+port):''}${path}${qs}`;
          } catch { return (u||'').trim(); }
        },
        urlsEqual(a, b) { return this.normalizeUrl(a) === this.normalizeUrl(b); },
        getMyMemberEntry(group) {
          try {
            const my = this.data?.identity?.uuid; if (!my) return null;
            const members = Array.isArray(group?.members) ? group.members : [];
            return members.find(m => m.uuid === my) || null;
          } catch { return null; }
        },
        canAdd(group) {
          if (!group?.shared) return true; // local groups unrestricted
          if (this.isOwnerOfGroup(group)) return true;
          const me = this.getMyMemberEntry(group);
          // Safer default: deny unless explicitly granted by owner
          return !!(me && me.canAdd === true);
        },
        canEdit(group) {
          if (!group?.shared) return true;
          if (this.isOwnerOfGroup(group)) return true;
          const me = this.getMyMemberEntry(group);
          return !!(me && me.canEdit === true);
        },
        canDelete(group) {
          if (!group?.shared) return true;
          if (this.isOwnerOfGroup(group)) return true;
          const me = this.getMyMemberEntry(group);
          return !!(me && me.canDelete === true);
        },
        toggleMemberPerm(m, field) {
          const g = this.editGroup; if (!g) return;
          if (!this.isOwnerOfGroup(g)) return;
          if (!['canAdd','canEdit','canDelete'].includes(field)) return;
          const cur = !!m[field];
          this.$set(m, field, !cur);
          this.saveData();
          // Propagate roster immediately
          try {
            if (g.shared && g.groupTopic && g.groupKey) {
              const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
              sharing.sendToGroup(g, { v:1, type:'group-roster', ts:Date.now(), from, groupId: g.groupId, members: g.members||[] });
            }
          } catch {}
        },
        // --- Sharing: identity & contacts ---
        async generateIdentity() { await sharing.ensureIdentity(); alert('Identity ready'); },
        showMyContactQr() {
          try {
            const card = sharing.getContactCard();
            const url = 'data:application/json,' + encodeURIComponent(JSON.stringify(card));
            this.qrCodeUrl = JSON.stringify(card);
            const qrCodeDiv = document.getElementById('qrCodeDiv');
            if (qrCodeDiv) { qrCodeDiv.innerHTML = ''; new QRCode(qrCodeDiv, { text: JSON.stringify(card), width: 256, height: 256 }); }
            const modalElement = document.getElementById('qrCodeModal');
            if (modalElement) new bootstrap.Modal(modalElement).show();
          } catch (e) { alert('QR error'); }
        },
        async addContactFromCardPaste() {
          const txt = prompt('Paste contact card JSON');
          if (!txt) return;
          try { const card = JSON.parse(txt); await sharing.addContactFromCard(card); alert('Contact added'); } catch { alert('Invalid contact card'); }
        },
        openQuickConnectDialog() {
          this.contactsDialog.visible = true;
          this.contactsDialog.tab = 'quickconnect';
          this.qcDialog.mode = 'receive';  // Default to receive mode
          this.qcDialog.status = [];
          this.qcDialog.progress = 'idle';
          this.qcDialog.code = '';
          // Hook status updates
          sharing.setStatusHandler((evt) => {
            if (!this.qcDialog.visible) return;
            if (evt.phase === 'waiting') { this.qcAddStatus(`Waiting for offer on topic ${evt.topic}`); this.qcDialog.progress = 'waiting'; this.qcDialog.code = sharing.qcCode; }
            if (evt.phase === 'offer_sent') { this.qcAddStatus(`Offer sent on topic ${evt.topic}`); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'offer_received') { this.qcAddStatus('Offer received'); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'answer_sent') { this.qcAddStatus('Answer sent'); }
            if (evt.phase === 'final_sent') { this.qcAddStatus('Final sent (your card)'); this.qcDialog.progress = 'done'; this.qcAutoClose(); }
            if (evt.phase === 'final_received') { this.qcAddStatus('Final received (peer card)'); this.qcDialog.progress = 'done'; this.qcAutoClose(); }
            if (evt.phase === 'stopped') { this.qcAddStatus('Stopped'); this.qcDialog.progress = 'idle'; }
          });
        },
        qcAutoClose() { 
          setTimeout(()=>{ 
            try { 
              const modalElement=document.getElementById('contactsModal'); 
              if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).hide(); 
            } catch{} 
            this.contactsDialog.visible=false; 
          }, 800); 
        },
        openContactsDialog() {
          this.contactsDialog.visible = true;
          this.contactsDialog.tab = 'contacts';  // Default to contacts tab
          
          // Check online status for all contacts when dialog opens
          this.checkAllContactsStatus();
          
          const modalElement = document.getElementById('contactsModal');
          if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).show();
        },
        closeContactsDialog() {
          this.contactsDialog.visible = false;
          // Stop and reset Quick-Connect completely
          if (this.qcDialog.code || this.qcDialog.active) {
            this.qcCancel();
          }
          // Ensure complete reset
          this.qcDialog.code = '';
          this.qcDialog.active = false;
          this.qcDialog.progress = 'idle';
        },
        confirmRemoveContact(c) {
          if (!c) return;
          
          const warnings = [];
          
          // Check if contact is owner of shared groups
          const ownerGroups = (this.data.groups || []).filter(g => 
            g.shared && g.ownerUuid === c.uuid
          );
          if (ownerGroups.length > 0) {
            warnings.push(`${this.getTranslation('dialog.contacts.removeWarningOwner') || 'This contact owns'} ${ownerGroups.length} ${this.getTranslation('dialog.contacts.removeWarningGroups') || 'shared group(s) that will be deleted'}`);
          }
          
          // Check if contact is member of our shared groups
          const memberGroups = (this.data.groups || []).filter(g => 
            g.shared && g.ownerUuid === this.data.identity?.uuid && 
            g.members?.some(m => m.uuid === c.uuid)
          );
          if (memberGroups.length > 0) {
            warnings.push(`${this.getTranslation('dialog.contacts.removeWarningMember') || 'This contact is member of'} ${memberGroups.length} ${this.getTranslation('dialog.contacts.removeWarningYourGroups') || 'of your shared group(s)'}`);
          }
          
          let message = `${this.getTranslation('dialog.contacts.removeConfirm') || 'Remove contact'} "${c.name || c.uuid}"?`;
          if (warnings.length > 0) {
            message += '\n\n⚠️ ' + warnings.join('\n⚠️ ');
          }
          message += `\n\n${this.getTranslation('dialog.contacts.removeNote') || 'This contact will no longer be able to send you messages.'}`;
          
          if (confirm(message)) {
            this.removeContact(c);
          }
        },
        
        async removeContact(c) {
          if (!c) return;
          
          // 1. Remove member from all shared groups where we are owner
          const ownedGroups = (this.data.groups || []).filter(g => 
            g.shared && g.ownerUuid === this.data.identity?.uuid && 
            g.members?.some(m => m.uuid === c.uuid)
          );
          
          for (const group of ownedGroups) {
            debugLog('log', '[CONTACT] Removing member from owned group:', group.name);
            await this.removeMemberFromGroup(group, { uuid: c.uuid });
          }
          
          // 2. Remove shared groups where contact is owner
          const groupsToRemove = (this.data.groups || []).filter(g => 
            g.shared && g.ownerUuid === c.uuid
          );
          
          for (const group of groupsToRemove) {
            debugLog('log', '[CONTACT] Removing group where contact is owner:', group.name);
            // Unsubscribe from group topic
            try { 
              if (group.groupTopic) {
                sharing.ntfy.unsubscribe(group.groupTopic);
              }
            } catch {}
            // Remove group from local data
            const gIdx = this.data.groups.findIndex(g => g.uuid === group.uuid);
            if (gIdx >= 0) {
              this.data.groups.splice(gIdx, 1);
            }
          }
          
          // 3. Remove contact from list
          const idx = (this.data.contacts || []).findIndex(x => x.uuid === c.uuid);
          if (idx >= 0) this.data.contacts.splice(idx, 1);
          
          // 4. Unsubscribe from pairwise channel
          try { sharing.unsubscribePairwise && sharing.unsubscribePairwise(c); } catch {}
          
          // 5. Add to blocked list to prevent future messages
          if (!this.data.blockedContacts) this.$set(this.data, 'blockedContacts', []);
          if (!this.data.blockedContacts.includes(c.uuid)) {
            this.data.blockedContacts.push(c.uuid);
          }
          
          this.saveData();
          this.$forceUpdate();
        },
        openMembersModal(group) {
          if (!group.prefs) this.$set(group, 'prefs', { inbound: { perMember: {} } });
          if (!group.prefs.inbound) this.$set(group.prefs, 'inbound', { perMember: {} });
          if (!group.prefs.inbound.perMember) this.$set(group.prefs.inbound, 'perMember', {});
          this.editGroup = group;
          const modalElement = document.getElementById('membersModal');
          if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).show();
          this.hideMenus();
        },
        confirmRemoveMember(member) {
          const memberName = member.name || member.uuid;
          if (confirm(`Are you sure you want to remove "${memberName}" from this group?`)) {
            this.removeMemberFromGroup(member);
          }
        },
        
        // Show notification when member was removed while offline
        showRemovedFromGroupNotification(groupName, ownerName, groupId, removedAt) {
          this.removedGroupInfo = {
            groupName: groupName || 'Unknown Group',
            ownerName: ownerName || 'Unknown Owner',
            removedAt: removedAt || new Date(),
            groupId: groupId
          };
          
          // Show the modal
          const modal = new bootstrap.Modal(document.getElementById('removedFromGroupModal'));
          modal.show();
        },
        
        // Handle acknowledgment of removal
        acknowledgeGroupRemoval() {
          const groupId = this.removedGroupInfo.groupId;
          if (groupId) {
            // Remove the group from local storage
            const groupIndex = this.data.groups.findIndex(g => g.uuid === groupId);
            if (groupIndex !== -1) {
              this.data.groups.splice(groupIndex, 1);
              this.saveData();
              debugLog('log', '[SYNC] Removed group after member removal notification:', groupId);
            }
          }
          
          // Clear the info
          this.removedGroupInfo = {
            groupName: '',
            ownerName: '',
            removedAt: null,
            groupId: null
          };
        },
        toggleMemberInbound(m) {
          if (!this.editGroup?.prefs?.inbound?.perMember) return;
          const cur = this.editGroup.prefs.inbound.perMember[m.uuid] || 'unset';
          const next = cur==='allow' ? 'deny' : 'allow';
          this.$set(this.editGroup.prefs.inbound.perMember, m.uuid, next);
          this.saveData();
        },
        async removeMemberFromGroup(groupOrMember, memberParam) {
          // Handle two different call signatures:
          // 1. From members dialog: removeMemberFromGroup(member) - uses this.editGroup
          // 2. From removeContact: removeMemberFromGroup(group, member)
          let g, m;
          if (memberParam) {
            // Called with (group, member)
            g = groupOrMember;
            m = memberParam;
          } else {
            // Called with (member) - use editGroup
            g = this.editGroup;
            m = groupOrMember;
          }
          
          if (!g) return;
          if (!this.isOwnerOfGroup(g)) { 
            // Only show alert if called from UI (no memberParam)
            if (!memberParam) alert('Only the owner can remove members.'); 
            return; 
          }
          
          // Update local roster
          g.members = (g.members||[]).filter(x=>x.uuid!==m.uuid);
          
          // Check if group should no longer be shared
          // Unshare if: no members left, only owner remains, or no members with role 'member'
          const noMembers = !g.members || g.members.length === 0;
          const onlyOwnerRemains = g.members.length === 1 && g.members[0].role === 'owner';
          const noRegularMembers = g.members.length > 0 && !g.members.some(x => x.role === 'member');
          
          if (noMembers || onlyOwnerRemains || noRegularMembers) {
            debugLog('log', '[SHARE] Group no longer shared:', g.name, 
              noMembers ? '(no members)' : onlyOwnerRemains ? '(only owner remains)' : '(no regular members)');
            // Unshare the group
            g.shared = false;
            // Optionally clear sharing-related properties
            // Keep groupId, groupKey, groupTopic for potential re-sharing
            // But unsubscribe from the topic
            try {
              if (g.groupTopic && window.sharing) {
                window.sharing.ntfy.unsubscribe(g.groupTopic);
              }
            } catch (e) {
              debugLog('warn', '[SHARE] Failed to unsubscribe from topic:', e);
            }
          }
          
          this.saveData();
          
          try {
            // Notify removed member 1:1
            // For shared groups, we must use groupId (never fallback to local id)
            if (!g.groupId) {
              debugLog('error', '[REMOVE_MEMBER] No groupId for shared group:', g.name);
              return;
            }
            const env = { v:1, type:'group-member-removed', ts:Date.now(), from:{ uuid:this.data.identity?.uuid, name:this.data.identity?.name||'' }, groupId: g.groupId };
            await sharing.sendToContact(m.uuid, env);
          } catch (e) {
            debugLog('error', '[REMOVE_MEMBER] Failed to notify member:', e);
          }
          
          try {
            // Broadcast updated roster to remaining group
            await sharing.sendToGroup(g, { v:1, type:'group-roster', ts:Date.now(), from:{ uuid:this.data.identity?.uuid, name:this.data.identity?.name||'' }, groupId: g.groupId, members: g.members||[] });
          } catch {}
        },
        // Contact online status methods
        async checkContactOnlineStatus(contactUuid) {
          // Check if contact is online by attempting a ping
          try {
            // Store checking status
            this.$set(this.contactOnlineStatus, contactUuid, {
              online: false,
              checking: true,
              lastCheck: Date.now()
            });
            
            // Try to ping the contact
            const pingSuccess = await this.pingContact(contactUuid);
            
            // Update status
            this.$set(this.contactOnlineStatus, contactUuid, {
              online: pingSuccess,
              checking: false,
              lastCheck: Date.now()
            });
            
            return pingSuccess;
          } catch (e) {
            this.$set(this.contactOnlineStatus, contactUuid, {
              online: false,
              checking: false,
              lastCheck: Date.now()
            });
            return false;
          }
        },
        
        async pingContact(contactUuid) {
          // Proper ping/pong mechanism to check if contact is truly online
          try {
            const contact = (this.data.contacts || []).find(c => c.uuid === contactUuid);
            if (!contact) return false;
            
            // Check if contact has valid channel info
            if (!contact.kChannelB64 || !contact.topic) {
              return false;
            }
            
            // Generate unique ping ID
            const pingId = Math.random().toString(36).slice(2) + Date.now();
            
            // Create ping message
            const pingMessage = {
              type: 'ping',
              pingId: pingId,
              from: this.data.identity?.uuid,
              timestamp: Date.now()
            };
            
            // Create promise that will be resolved when pong is received
            const pongPromise = new Promise((resolve, reject) => {
              // Store resolver for the pong handler to use
              this.pendingPings[pingId] = { resolve, reject };
              
              // Set timeout for pong response
              const timeoutId = setTimeout(() => {
                if (this.pendingPings[pingId]) {
                  delete this.pendingPings[pingId];
                  resolve(false); // Timeout = offline
                }
              }, 3000); // 3 second timeout
              
              this.pendingPings[pingId].timeout = timeoutId;
            });
            
            // Send ping message
            try {
              await sharing.sendToContact(contactUuid, pingMessage);
              debugLog('log', '[PING/PONG] Sent ping to:', contactUuid, 'with ID:', pingId);
            } catch (e) {
              // Failed to send ping
              if (this.pendingPings[pingId]) {
                clearTimeout(this.pendingPings[pingId].timeout);
                delete this.pendingPings[pingId];
              }
              return false;
            }
            
            // Wait for pong response
            const result = await pongPromise;
            
            // Clean up timeout if still exists
            if (this.pendingPings[pingId]) {
              clearTimeout(this.pendingPings[pingId].timeout);
              delete this.pendingPings[pingId];
            }
            
            return result === true;
          } catch (e) {
            debugLog('error', '[PING/PONG] Failed to ping contact:', e);
            return false;
          }
        },
        
        isContactOnline(contactUuid) {
          const status = this.contactOnlineStatus[contactUuid];
          if (!status) {
            // Check status if not cached
            this.checkContactOnlineStatus(contactUuid);
            return false; // Assume offline until checked
          }
          
          // Re-check if status is older than the configured timeout
          const timeoutMs = (this.data.options?.sharing?.contactOnlineTimeoutSeconds || CONSTS.CONTACT_ONLINE_TIMEOUT_SEC) * 1000;
          if (Date.now() - status.lastCheck > timeoutMs) {
            this.checkContactOnlineStatus(contactUuid);
          }
          
          return status.online;
        },
        
        // Check online status for all contacts
        async checkAllContactsStatus() {
          if (!this.data.contacts || this.data.contacts.length === 0) return;
          
          // Check all contacts in parallel
          const checkPromises = this.data.contacts.map(contact => 
            this.checkContactOnlineStatus(contact.uuid)
          );
          
          try {
            await Promise.all(checkPromises);
            debugLog('log', 'Checked status for all contacts');
          } catch (e) {
            debugLog('error', 'Failed to check some contact statuses:', e);
          }
        },
        
        getContactStatusClass(contactUuid) {
          const status = this.contactOnlineStatus[contactUuid];
          if (!status) return 'online-indicator checking';
          if (status.checking) return 'online-indicator checking';
          return status.online ? 'online-indicator online' : 'online-indicator offline';
        },
        
        getContactStatusText(contactUuid) {
          const status = this.contactOnlineStatus[contactUuid];
          if (!status || status.checking) return this.getTranslation('dialog.contacts.checking') || 'checking...';
          // Now shows true online status via ping/pong mechanism
          return status.online ? 
            (this.getTranslation('dialog.contacts.online') || 'online') : 
            (this.getTranslation('dialog.contacts.offline') || 'offline');
        },
        
        getContactStatusTextClass(contactUuid) {
          const status = this.contactOnlineStatus[contactUuid];
          if (!status || status.checking) return 'contact-status-text';
          return status.online ? 'contact-status-text online' : 'contact-status-text offline';
        },
        
        // Format date for display using moment.js
        formatDate(dateValue) {
          if (!dateValue) return '';
          
          try {
            // Create moment object and validate
            const m = moment(dateValue);
            if (!m.isValid()) {
              return '';
            }
            
            // Use localized format (LLL = Month name, day, year, time)
            // In German: "15. Januar 2024 14:30"
            return m.format('LLL');
          } catch (e) {
            console.error('Error formatting date:', e);
            return '';
          }
        },
        
        // Format time for messages using moment.js
        formatMessageTime(timeValue) {
          if (!timeValue) return '';
          
          try {
            const m = moment(timeValue);
            if (!m.isValid()) {
              return '';
            }
            
            // Use time format (HH:mm:ss)
            return m.format('LTS');
          } catch (e) {
            console.error('Error formatting message time:', e);
            return '';
          }
        },
        
        async sendTestToContact(c) {
          // Check if contact is online first
          if (!this.isContactOnline(c.uuid)) {
            alert(this.getTranslation('dialog.contacts.cannotSendOffline') || 'Cannot send to offline contact');
            return;
          }
          
          try {
            const env = { v:1, type:'share', from:{ uuid:this.data.identity?.uuid, name:this.data.identity?.name||'' }, ts:Date.now(), note: this.getTranslation('quick.test.note'), selection:{ groups:[], links:[] }, mode:'merge', schemaVersion:1 };
            await sharing.sendToContact(c.uuid, env);
            // Removed alert - success already visible in UI
          } catch (e) { alert(this.getTranslation('quick.test.failed')); }
        },
        qcAddStatus(msg) { (this.qcDialog.status || (this.qcDialog.status=[])).push({ t: Date.now(), m: msg }); this.$nextTick(() => {
          const box = document.getElementById('qcStatusBox'); if (box) box.scrollTop = box.scrollHeight; });
        },
        async qcStartReceive() {
          // Setup status handler first
          this.setupQcStatusHandler();
          const ttl = this.data.options?.sharing?.quickCodeTtlSec || CONSTS.QUICK_CODE_TTL_SEC;
          const alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789';
          let code = '';
          for (let i = 0; i < 6; i++) code += alphabet[Math.floor(Math.random() * alphabet.length)];
          this.qcDialog.code = code;
          this.qcAddStatus(`Code: ${code} (valid ~${ttl}s)`);
          try { await sharing.quickCodeReceiveStart(code); } catch (e) { this.qcAddStatus('Error starting receive'); }
        },
        async qcStartSend() {
          // Setup status handler first
          this.setupQcStatusHandler();
          const code = (this.qcDialog.code || '').trim().toLowerCase();
          if (!code || code.length !== 6) { alert('Enter a 6-character code'); return; }
          try { await sharing.quickCodeSendOffer(code); this.qcAddStatus('Offer sent; waiting for answer'); }
          catch { this.qcAddStatus('Quick-Connect failed'); }
        },
        setupQcStatusHandler() {
          sharing.setStatusHandler((evt) => {
            if (evt.phase === 'waiting') { this.qcAddStatus(`Waiting for offer on topic ${evt.topic}`); this.qcDialog.progress = 'waiting'; this.qcDialog.code = sharing.qcCode; }
            if (evt.phase === 'offer_sent') { this.qcAddStatus(`Offer sent on topic ${evt.topic}`); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'offer_received') { this.qcAddStatus('Offer received from peer; generating answer'); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'answer_sent') { this.qcAddStatus('Answer sent; generating contact'); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'answer_received') { this.qcAddStatus('Answer received; generating contact'); this.qcDialog.progress = 'exchanging'; }
            if (evt.phase === 'final_sent') { this.qcAddStatus('Final sent (contact card)'); this.qcDialog.progress = 'done'; this.qcAutoClose(); }
            if (evt.phase === 'final_received') { this.qcAddStatus('Final received (peer card)'); this.qcDialog.progress = 'done'; this.qcAutoClose(); }
            if (evt.phase === 'stopped') { this.qcAddStatus('Stopped'); this.qcDialog.progress = 'idle'; }
          });
        },
        qcCancel() { 
          try { sharing.quickCodeStop(); } catch {} 
          this.qcAddStatus('Canceled'); 
          this.qcDialog.progress = 'idle'; 
          this.qcDialog.code = ''; // Reset the code input field
          this.qcDialog.active = false; // Reset active state
        },
        // --- Invitation Dialog ---
        showInvitationDialog(type, env) {
          this.invitationDialog.type = type;
          this.invitationDialog.env = env;
          this.invitationDialog.fromName = env.from?.name || env.from?.uuid || 'Unknown';
          
          if (type === 'group') {
            this.invitationDialog.groupName = env.groupName || 'Shared Group';
            this.invitationDialog.linkCount = (env.selection?.links || []).length;
            this.invitationDialog.preview = [];
          } else if (type === 'link') {
            // Check if it's a group share or just links
            if (env.selection?.groups?.length > 0) {
              // It's actually a group share via Share Group button
              const group = env.selection.groups[0];
              this.invitationDialog.groupName = group.name || 'Shared Group';
              this.invitationDialog.linkCount = (group.links || []).length;
              this.invitationDialog.preview = (group.links || []).slice(0, 10).map(l => ({
                text: l.text || l.url,
                url: l.url
              }));
            } else {
              // It's just shared links
              this.invitationDialog.groupName = '';
              this.invitationDialog.linkCount = 0;
              this.invitationDialog.preview = (env.selection?.links || []).slice(0, 10).map(l => ({
                text: l.text || l.url,
                url: l.url
              }));
            }
          }
          
          this.invitationDialog.visible = true;
          this.$nextTick(() => {
            const el = document.getElementById('invitationModal');
            if (el) new bootstrap.Modal(el).show();
          });
        },
        
        async acceptInvitation() {
          try {
            const env = this.invitationDialog.env;
            debugLog('log', '[INVITE] Accepting invitation, type:', this.invitationDialog.type, 'env:', env);
            if (!env) {
              debugLog('log', '[INVITE] No envelope found');
              return;
            }
            
            if (this.invitationDialog.type === 'group') {
              // Mark as processed to prevent duplicates
              if (env.msgId && this.processedMsgIds) this.processedMsgIds.add(env.msgId);
              
              // Accept group invite: create or update shared group and subscribe
              debugLog('log', '[INVITE] Processing invitation with event-log data:', {
                hasEventLog: !!env.eventLog,
                eventLogCount: env.eventLog?.length || 0,
                hasSnapshot: !!env.snapshot,
                useEventLog: env.useEventLog
              });
              let g = (this.data.groups||[]).find(x=>x.groupId===env.groupId);
              if (!g) {
                // Create a completely new group object with deep copy to avoid reference issues
                g = JSON.parse(JSON.stringify({ 
                  uuid: this.generateUUID(),
                  name: env.groupName||'Shared Group', 
                  color:'', 
                  opacity:100, 
                  keywords:'', 
                  column: Math.max(0, ...(this.getGroupColumns()||[0])), 
                  index:(this.data.groups||[]).length, 
                  collapsed:false, 
                  shared:true, 
                  groupId: env.groupId, 
                  groupTopic: env.groupTopic, 
                  groupKey: env.groupKey,
                  // Include event-log data from invitation
                  useEventLog: env.useEventLog || false,
                  eventLog: env.eventLog || [],
                  snapshot: env.snapshot || null,
                  headEventId: env.headEventId || null,
                  vectorClock: env.vectorClock || {}
                }));
                // Ensure links is a new array
                g.links = [];
                if (!Array.isArray(this.data.groups)) this.$set(this.data, 'groups', []);
                // Use Vue's reactive method to add the group
                const newIndex = this.data.groups.length;
                this.$set(this.data.groups, newIndex, g);
              } else {
                // Group already exists (possibly re-adding after removal)
                this.$set(g, 'shared', true); 
                this.$set(g,'groupId', env.groupId); 
                this.$set(g,'groupTopic', env.groupTopic); 
                this.$set(g,'groupKey', env.groupKey);
                // Update event-log data from invitation if provided
                if (env.useEventLog) {
                  this.$set(g, 'useEventLog', true);
                  this.$set(g, 'eventLog', env.eventLog || []);
                  this.$set(g, 'snapshot', env.snapshot || null);
                  this.$set(g, 'headEventId', env.headEventId || null);
                  this.$set(g, 'vectorClock', env.vectorClock || {});
                }
                // Ensure links array is reactive
                if (!Array.isArray(g.links)) {
                  this.$set(g, 'links', []);
                }
              }
              
              // Enable event-log for shared groups if not already provided in invitation
              if (!g.eventLog && !env.useEventLog) {
                debugLog('log', '[EVENT-LOG] Enabling event-log for newly shared group:', g.name);
                this.migrateGroupToEventLog(g);
                this.$set(g, 'useEventLog', true);
              }
              
              // Apply roster if provided
              if (Array.isArray(env.members)) {
                const contacts = Array.isArray(this.data.contacts) ? this.data.contacts : [];
                const mapped = env.members.map(m=>{
                  const mm = Object.assign({}, m);
                  if (!mm.name || mm.name===mm.uuid) {
                    if (env.groupOwnerUuid && mm.uuid===env.groupOwnerUuid && env.from?.name) mm.name = env.from.name;
                    if ((!mm.name || mm.name===mm.uuid)) {
                      const c = contacts.find(x=>x.uuid===mm.uuid);
                      if (c && c.name) mm.name = c.name;
                    }
                  }
                  // Preserve permissions
                  mm.canAdd = m.canAdd;
                  mm.canEdit = m.canEdit;
                  mm.canDelete = m.canDelete;
                  return mm;
                });
                this.$set(g, 'members', mapped);
              }
              
              // Apply color and opacity
              if (typeof env.groupColor === 'string') this.$set(g, 'color', env.groupColor);
              if (typeof env.groupOpacity === 'number') this.$set(g, 'opacity', Math.max(0, Math.min(100, env.groupOpacity)));
              if (typeof env.groupOwnerUuid === 'string' && env.groupOwnerUuid) this.$set(g, 'ownerUuid', env.groupOwnerUuid);
              
              // Import initial links with reactive properties
              if (!Array.isArray(g.links)) {
                this.$set(g, 'links', []);
              }
              g.links = []; // Clear existing links
              if (env.selection && Array.isArray(env.selection.links)) {
                env.selection.links.forEach((l,i)=>{
                  const col = (typeof l.column==='number') ? l.column : 0;
                  const idx = (typeof l.index === 'number') ? l.index : i;
                  const newLink = { 
                    uuid: l.uuid || this.generateUUID(),
                    text: l.text || l.url, 
                    url: l.url, 
                    keywords: l.keywords || '', 
                    emoji: l.emoji || '',
                    column: col, 
                    index: idx, 
                    editing: false, 
                    isMouseOver: false 
                  };
                  // Ensure reactive properties
                  this.$set(newLink, 'editing', false);
                  this.$set(newLink, 'isMouseOver', false);
                  g.links.push(newLink);
                });
              }
              
              // Ensure reactive UI properties
              if (g.isMouseOver===undefined) this.$set(g,'isMouseOver',false);
              if (g.editing===undefined) this.$set(g,'editing',false);
              
              // Default inbound prefs
              if (!g.prefs) this.$set(g,'prefs',{ inbound: { perMember: {} } });
              if (!g.prefs.inbound) this.$set(g.prefs,'inbound',{ perMember: {} });
              if (!g.prefs.inbound.perMember) this.$set(g.prefs.inbound,'perMember',{});
              
              this.saveData();
              
              // Subscribe to group - skip initial update request since we already have the data from the invite
              debugLog('log', '[INVITE] Accepted group invitation:', g.name, g.groupId);
              
              // If group was previously removed and re-added, we need to force re-subscription
              if (sharing.groupSubs && sharing.groupSubs.has(g.groupTopic)) {
                debugLog('log', '[INVITE] Group was already subscribed, forcing re-subscription');
                // Remove old subscription from map
                sharing.groupSubs.delete(g.groupTopic);
                // Unsubscribe from NTFY (in case subscription still exists)
                try {
                  sharing.ntfy.unsubscribe(g.groupTopic);
                } catch (e) {
                  debugLog('log', '[INVITE] Could not unsubscribe old subscription:', e);
                }
              }
              
              // Subscribe and request update immediately so owner sends full state
              sharing.applyConfig();
              sharing.subscribeGroup(g, false); // false = send update request automatically
              
              // Force update UI
              try { this.$forceUpdate(); } catch {}
              
              // After subscription is established, request an update to sync with latest state
              // This ensures we get any changes that happened while the invitation was pending
              setTimeout(() => {
                try {
                  const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
                  debugLog('log', '[INVITE] Sending delayed update request after invitation acceptance');
                  sharing.sendToGroup(g, { 
                    v: 1, 
                    type: 'group-update-request', 
                    ts: Date.now(), 
                    from, 
                    groupId: g.groupId, 
                    msgId: (Math.random().toString(36).slice(2) + Date.now()) 
                  });
                } catch(e) {
                  debugLog('warn', '[INVITE] Failed to send update request after invitation acceptance', e);
                }
              }, 500); // Shorter delay; subscribeGroup already requested update
              
            } else if (this.invitationDialog.type === 'link') {
              // Accept shared links or groups
              debugLog('log', '[INVITE] Processing shared links/groups');
              
              // Debug: Check state before applying share envelope
              debugLog('log', '[INVITE] Groups before applyShareEnvelope:', this.data.groups.map(g => ({
                name: g.name,
                uuid: g.uuid,
                linksCount: g.links?.length,
                firstLink: g.links?.[0]?.text
              })));
              
              await this.applyShareEnvelope(env);
              
              // Debug: Check state after applying share envelope
              debugLog('log', '[INVITE] Groups after applyShareEnvelope:', this.data.groups.map(g => ({
                name: g.name,
                uuid: g.uuid,
                linksCount: g.links?.length,
                firstLink: g.links?.[0]?.text
              })));
              
              // Extra debug: Check if links arrays are actually different objects
              if (this.data.groups.length >= 2) {
                const group1 = this.data.groups[0];
                const group2 = this.data.groups[1];
                debugLog('log', '[DEBUG] Group 1 links === Group 2 links?', group1.links === group2.links);
                debugLog('log', '[DEBUG] Group 1:', { name: group1.name, uuid: group1.uuid, links: group1.links });
                debugLog('log', '[DEBUG] Group 2:', { name: group2.name, uuid: group2.uuid, links: group2.links });
                
                // Check actual link content
                debugLog('log', '[DEBUG] Group 1 first link text:', group1.links[0]?.text);
                debugLog('log', '[DEBUG] Group 2 first link text:', group2.links[0]?.text);
                
                // Force check after a delay to see if something changes
                setTimeout(() => {
                  debugLog('log', '[DEBUG DELAYED] After 2 seconds:');
                  debugLog('log', '[DEBUG DELAYED] Group 1:', { 
                    name: this.data.groups[0].name, 
                    linksCount: this.data.groups[0].links.length,
                    firstLink: this.data.groups[0].links[0]?.text 
                  });
                  debugLog('log', '[DEBUG DELAYED] Group 2:', { 
                    name: this.data.groups[1].name, 
                    linksCount: this.data.groups[1].links.length,
                    firstLink: this.data.groups[1].links[0]?.text 
                  });
                }, 2000);
              }
            }
            
            // Close the dialog
            this.closeInvitationDialog();
            debugLog('log', '[INVITE] Invitation accepted successfully');
            
          } catch (e) { 
            debugLog('error', 'Failed to accept invitation:', e);
            alert('Failed to accept invitation');
          }
        },
        
        rejectInvitation() {
          debugLog('log', '[INVITE] Rejected invitation');
          // Mark as processed to prevent showing dialog again
          const env = this.invitationDialog.env;
          if (env && env.msgId && this.processedMsgIds) {
            this.processedMsgIds.add(env.msgId);
          }
          this.closeInvitationDialog();
        },
        
        closeInvitationDialog() {
          this.invitationDialog.visible = false;
          this.invitationDialog.env = null;
          const el = document.getElementById('invitationModal');
          if (el) {
            const modal = bootstrap.Modal.getInstance(el);
            if (modal) modal.hide();
          }
        },
        
        // Apply shared envelope (for link and group sharing)
        async applyShareEnvelope(env) {
          debugLog('log', '[SHARE] Applying share envelope:', env);
          const sel = env.selection || {};
          if (env.msgId && this.processedMsgIds && this.processedMsgIds.has(env.msgId)) {
            debugLog('log', '[SHARE] Skipping duplicate msgId:', env.msgId);
            return;
          }
          if (env.msgId && this.processedMsgIds) this.processedMsgIds.add(env.msgId);
          
          // Handle shared groups
          if (Array.isArray(sel.groups) && sel.groups.length) {
            debugLog('log', '[SHARE] Processing shared groups:', sel.groups.length);
            sel.groups.forEach(sharedGroup => {
              // IMPORTANT: For sent groups (not shared), always generate a new UUID
              // to prevent collision with existing groups
              // Only shared groups (with groupId) should maintain the same UUID across members
              const isSharedGroup = sharedGroup.shared && sharedGroup.groupId;
              debugLog('log', '[SHARE] Processing group:', sharedGroup.name, 'isShared:', isSharedGroup, 'originalUUID:', sharedGroup.uuid);
              let newGroupUUID = isSharedGroup ? (sharedGroup.uuid || this.generateUUID()) : this.generateUUID();
              debugLog('log', '[SHARE] New group UUID:', newGroupUUID, 'for group:', sharedGroup.name);
              
              // Check if a group with this UUID already exists
              const existingGroup = this.data.groups?.find(g => g.uuid === newGroupUUID);
              if (existingGroup) {
                debugLog('error', '[SHARE] CRITICAL: Group with UUID already exists!', newGroupUUID, existingGroup.name);
                // Force generate a new UUID if collision detected
                newGroupUUID = this.generateUUID();
                debugLog('log', '[SHARE] Generated new UUID to avoid collision:', newGroupUUID);
              }
              
              // Debug: Log all existing groups before adding
              debugLog('log', '[SHARE] Existing groups before add:', this.data.groups?.map(g => ({ 
                name: g.name, 
                uuid: g.uuid,
                column: g.column,
                index: g.index
              })));
              // Create a completely new group object to avoid any reference issues
              const g = JSON.parse(JSON.stringify({
                uuid: newGroupUUID,
                name: sharedGroup.name || `Shared from ${env.from?.name || env.from?.uuid || 'unknown'}`,
                color: sharedGroup.color || '',
                opacity: typeof sharedGroup.opacity === 'number' ? sharedGroup.opacity : 100,
                keywords: sharedGroup.keywords || '',
                column: Math.max(0, ...(this.getGroupColumns() || [0])),
                index: (this.data.groups || []).length,
                collapsed: false,
                links: [],
                // Include event-log data if available
                useEventLog: sharedGroup.useEventLog || false,
                eventLog: sharedGroup.eventLog || [],
                snapshot: sharedGroup.snapshot || null,
                headEventId: sharedGroup.headEventId || null,
                vectorClock: sharedGroup.vectorClock || {}
              }));
              
              // Add links from the shared group
              if (Array.isArray(sharedGroup.links)) {
                sharedGroup.links.forEach((l, i) => {
                  // For sent groups, generate new UUIDs for links too
                  // Only shared groups should maintain the same link UUIDs
                  // Create a completely new object to avoid any reference issues
                  const newLink = JSON.parse(JSON.stringify({
                    uuid: isSharedGroup ? (l.uuid || this.generateUUID()) : this.generateUUID(),
                    text: l.text || l.url,
                    url: l.url,
                    keywords: l.keywords || '',
                    column: typeof l.column === 'number' ? l.column : 0,
                    index: typeof l.index === 'number' ? l.index : i,
                    editing: false,
                    isMouseOver: false
                  }));
                  g.links.push(newLink);
                });
              }
              
              // Ensure reactive UI properties for group
              g.isMouseOver = false;
              g.editing = false;
              
              debugLog('log', '[SHARE] Adding group:', g.name, 'with', g.links.length, 'links', 'UUID:', g.uuid);
              if (!Array.isArray(this.data.groups)) this.$set(this.data, 'groups', []);
              // Use Vue's reactive method to add the group
              const newIndex = this.data.groups.length;
              this.$set(this.data.groups, newIndex, g);
              
              // Debug: Log all groups after adding
              debugLog('log', '[SHARE] Groups after add:', this.data.groups.map(grp => ({ 
                name: grp.name, 
                uuid: grp.uuid, 
                column: grp.column,
                index: grp.index,
                linksCount: grp.links?.length,
                firstLink: grp.links?.[0]?.text 
              })));
            });
          }
          
          // Handle shared links (create new group for them)
          else if (Array.isArray(sel.links) && sel.links.length) {
            debugLog('log', '[SHARE] Processing shared links:', sel.links.length);
            const name = `Shared from ${env.from?.name || env.from?.uuid || 'unknown'} ${moment(env.ts || Date.now()).format('LLL')}`;
            const g = { 
              uuid: this.generateUUID(),
              name, 
              color: '', 
              opacity: 100, 
              keywords: '', 
              column: Math.max(0, ...(this.getGroupColumns() || [0])), 
              index: (this.data.groups || []).length, 
              collapsed: false, 
              links: [],
              isMouseOver: false,
              editing: false
            };
            sel.links.forEach((l, i) => g.links.push({ 
              uuid: this.generateUUID(), // Always generate new UUID for sent links
              text: l.text || l.url, 
              url: l.url, 
              keywords: l.keywords || '', 
              column: 0, 
              index: i,
              editing: false,
              isMouseOver: false
            }));
            debugLog('log', '[SHARE] Adding group:', g.name, 'with', g.links.length, 'links', 'UUID:', g.uuid);
            if (!Array.isArray(this.data.groups)) this.$set(this.data, 'groups', []);
            // Use Vue's reactive method to add the group
            const newIndex = this.data.groups.length;
            this.$set(this.data.groups, newIndex, g);
          } else {
            debugLog('log', '[SHARE] No groups or links to process');
          }
          
          // Final debug: Check if groups are still correct after everything
          debugLog('log', '[SHARE] Final check - all groups:', this.data.groups.map(grp => ({ 
            name: grp.name, 
            uuid: grp.uuid, 
            groupId: grp.groupId,
            shared: grp.shared,
            linksCount: grp.links?.length,
            firstLink: grp.links?.[0]?.text 
          })));
          
          // Debug before saveData
          debugLog('log', '[SHARE] Before saveData - groups:', this.data.groups.map(g => ({
            name: g.name,
            uuid: g.uuid,
            linksCount: g.links?.length,
            firstLink: g.links?.[0]?.text
          })));
          
          this.saveData();
          
          // Debug after saveData
          debugLog('log', '[SHARE] After saveData - groups:', this.data.groups.map(g => ({
            name: g.name,
            uuid: g.uuid,
            linksCount: g.links?.length,
            firstLink: g.links?.[0]?.text
          })));
          
          // Debug before forceUpdate
          debugLog('log', '[SHARE] Before $forceUpdate - groups:', this.data.groups.length);
          
          // CRITICAL FIX: Force Vue to completely re-render by replacing the array
          // This ensures no cached computed properties or stale references persist
          const newGroupsArray = JSON.parse(JSON.stringify(this.data.groups));
          this.$set(this.data, 'groups', newGroupsArray);
          
          // Also force update all Vue internals
          this.$nextTick(() => {
            try { 
              this.$forceUpdate(); 
              
              // Debug after forceUpdate
              debugLog('log', '[SHARE] After $forceUpdate - groups:', this.data.groups.map(grp => ({ 
                name: grp.name, 
                uuid: grp.uuid,
                linksCount: grp.links?.length
              })));
              
              // Final verification after Vue's next tick
              this.$nextTick(() => {
                debugLog('log', '[SHARE] Final verification after next tick:');
                this.data.groups.forEach((g, idx) => {
                  debugLog('log', `  Group ${idx}: ${g.name} (UUID: ${g.uuid}) - Links: ${g.links?.length}, First: ${g.links?.[0]?.text}`);
                });
              });
            } catch(e) {
              debugLog('error', '[SHARE] $forceUpdate failed:', e);
            }
          });
        },
        // ---------- Saved Searches ----------
        async saveCurrentSearch() {
          const q = (this.filterText || '').trim();
          if (!q) { alert(this.getTranslation('savedSearches.empty')); return; }
          const name = prompt(this.getTranslation('savedSearches.promptName'), q);
          if (!name) return;
          const id = this.generateUUID(); // Use UUID for saved searches
          const entry = { id, name: name.trim(), query: q };
          this.savedSearches.push(entry);
          if (!Array.isArray(this.data.savedSearches)) this.$set(this.data, 'savedSearches', []);
          this.data.savedSearches.push(entry);
          if (typeof this.saveDataImmediate === 'function') await this.saveDataImmediate(); else this.saveData();
          this.selectedSavedSearch = id;
        },
        applySavedSearch() {
          const id = this.selectedSavedSearch;
          const s = (this.savedSearches || []).find(x => x.id == id);
          if (s) this.filterText = s.query;
        },
        async deleteSavedSearch() {
          const id = this.selectedSavedSearch;
          if (!id) return;
          if (!confirm(this.getTranslation('savedSearches.delete.confirm'))) return;
          const idx = (this.data.savedSearches || []).findIndex(x => x.id == id);
          if (idx >= 0) this.data.savedSearches.splice(idx, 1);
          const idx2 = (this.savedSearches || []).findIndex(x => x.id == id);
          if (idx2 >= 0) this.savedSearches.splice(idx2, 1);
          this.selectedSavedSearch = '';
          if (typeof this.saveDataImmediate === 'function') await this.saveDataImmediate(); else this.saveData();
        },

        // ---------- History / Undo-Redo ----------
        undo() {
          if (!this.historyPast.length) return;
          const current = this.getSavableData();
          const snapshot = this.historyPast.pop();
          this.historyFuture.push(current);
          this._applySnapshot(snapshot);
        },
        redo() {
          if (!this.historyFuture.length) return;
          const current = this.getSavableData();
          const snapshot = this.historyFuture.pop();
          this.historyPast.push(current);
          this._applySnapshot(snapshot);
        },
        async _applySnapshot(snap) {
          if (!snap) return;
          this.historyLock = true;
          try {
            const merged = Object.assign({}, JSON.parse(JSON.stringify(initialData)), snap);
            this.data.options = merged.options || this.data.options;
            this.data.groups = Array.isArray(merged.groups) ? merged.groups : [];
            this.data.savedSearches = Array.isArray(merged.savedSearches) ? merged.savedSearches : [];
            this.fixOptions();
            (this.data.groups || []).forEach(g => {
              if (g.column === undefined || g.column === null) this.$set(g, 'column', 0);
              this.$set(g, 'editing', false);
              this.$set(g, 'isMouseOver', false);
              if (g.collapsed === undefined) this.$set(g, 'collapsed', false);
              this.$set(g, 'searchCollapsed', true);
              this.$set(g, 'newLinkText', '');
              this.$set(g, 'newLinkUrl', '');
              if (!Array.isArray(g.links)) this.$set(g, 'links', []);
              (g.links || []).forEach(l => {
                if (l.column === undefined || l.column === null) this.$set(l, 'column', 0);
                this.$set(l, 'editing', false);
                this.$set(l, 'isMouseOver', false);
              });
              this.getLinkColumns(g.links).forEach(col => this.reindexArr(g.links.filter(l => l.column === col)));
            });
            this.getGroupColumns().forEach(col => this.reindexArr(this.data.groups.filter(g => g.column === col)));
            this.savedSearches = Array.isArray(this.data.savedSearches) ? [...this.data.savedSearches] : [];
            if (typeof this.saveDataImmediate === 'function') await this.saveDataImmediate(); else this.saveData();
          } finally {
            this.historyLock = false;
          }
        },

        // ---------- Bookmarklet ----------
        handleBookmarkletAdd() {
          const p = new URLSearchParams(location.search);
          const url = p.get('add');
          if (!url) return;
          const title = p.get('title') || url;
          const g = (this.data.groups && this.data.groups[0]) || null;
          if (!g) return;
          this.openAddLinkDialog(g);
          this.$nextTick(() => {
            if (this.editLink) {
              this.editLink.url = url;
              this.editLink.text = title;
            }
          });
        },
        showBookmarkletHelp() {
          const hrefNoQuery = (location.href || '').replace(/[?#].*$/, '');
          let base = '';
          if (location.protocol === 'file:') {
            // Use file:/// path when opened from file
            base = hrefNoQuery;
          } else if (location.origin && location.origin !== 'null') {
            base = (location.origin + location.pathname).replace(/[?#].*$/, '');
          } else {
            // Fallback: use full href without query/hash
            base = hrefNoQuery;
          }
          base = base.replace(/[?#].*$/, '');
          // Clipboard-based bookmarklet: copy URL+title to clipboard (fallback prompt on failure)
          const js = "javascript:(async()=>{try{const d={url:location.href,title:document.title};await navigator.clipboard.writeText(JSON.stringify(d));alert('Copied URL + title to clipboard');}catch(e){prompt('Copy URL manually:',location.href)}})()";
          this.bookmarkletHref = js;
          const modalElement = document.getElementById('bookmarkletModal');
          if (!modalElement) return;
          const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
          modalInstance && modalInstance.show();
        },
        openPasteModal() {
          this.pasteContent = '';
          this.pasteHint = '';
          this.parsedLinks = null;
          this.detectedFormat = '';
          this.importGroupTitle = '';
          this.isFullExport = false;
          this.fullExportData = null;
          this.importCollapsedGroups = {}; // Reset collapsed state
          const modalElement = document.getElementById('pasteClipboardModal');
          if (!modalElement) return;
          const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
          modalInstance && modalInstance.show();
        },
        async readFromClipboard() {
          try {
            const txt = (await navigator.clipboard.readText()) || '';
            if (!txt.trim()) { this.pasteHint = this.getTranslation('clipboard.empty'); return; }
            this.pasteContent = txt.trim();
            this.pasteHint = this.getTranslation('clipboard.readOk');
            this.parsePastedContent();
          } catch (e) {
            debugLog('warn', 'Clipboard read failed', e);
            this.pasteHint = this.getTranslation('clipboard.noPermission');
          }
        },
        
        handleFileUpload(event) {
          const file = event.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = (e) => {
            this.pasteContent = e.target.result;
            this.parsePastedContent();
          };
          reader.readAsText(file);
        },
        
        async fetchBrowserBookmarks() {
          this.fetchingBrowserBookmarks = true;
          this.browserBookmarksInfo = '';

          try {
            const bookmarksData = await MB.Extension.getBookmarks();
            debugLog('log', 'Received browser bookmarks:', bookmarksData);

            // Handle the response structure
            let bookmarksRoot;
            if (bookmarksData.success && bookmarksData.bookmarks) {
              bookmarksRoot = bookmarksData.bookmarks;
              // Show stats if available
              if (bookmarksData.stats) {
                debugLog('log', `Extension reports: ${bookmarksData.stats.links} links in ${bookmarksData.stats.folders} folders`);
              }
            } else if (bookmarksData) {
              bookmarksRoot = bookmarksData;
            } else {
              throw new Error('No bookmarks data received from extension');
            }

            debugLog('log', 'Processing bookmark structure:', bookmarksRoot);

            // Convert bookmarks to our format for the textarea
            const links = [];
            let folderCount = 0;
            let linkCount = 0;

            const extractLinks = (node, path = '') => {
              if (!node) return;

              // Handle the flattened structure where groups have both links AND children

              // First, process any links directly in this node
              if (node.links && Array.isArray(node.links) && node.links.length > 0) {
                // Use the node's path if available, otherwise use the title
                const groupPath = node.path || node.title || 'Folder';

                node.links.forEach(link => {
                  if (link.url) {
                    links.push({
                      text: link.text || link.title || link.url,
                      url: link.url,
                      path: groupPath  // Use the full path from the node
                    });
                    linkCount++;
                  }
                });
              }

              // Then process children (which are groups in the flattened structure)
              if (node.children && Array.isArray(node.children)) {
                node.children.forEach(child => {
                  folderCount++;
                  // Recursively process each child group
                  extractLinks(child, '');
                });
              }

              // Handle single link node (backwards compatibility)
              if (node.url && !node.links && !node.children) {
                links.push({
                  text: node.text || node.title || node.url,
                  url: node.url,
                  path: path
                });
                linkCount++;
              }
            };

            // Extract all links
            if (Array.isArray(bookmarksRoot)) {
              bookmarksRoot.forEach(node => extractLinks(node));
            } else {
              extractLinks(bookmarksRoot);
            }

            // Format as tab-separated for the textarea
            if (links.length > 0) {
              const formattedLinks = links.map(link => {
                // Include path info as comment if available
                const prefix = link.path ? `[${link.path}] ` : '';
                return `${prefix}${link.text}\t${link.url}`;
              }).join('\n');

              this.pasteContent = formattedLinks;
              this.parsePastedContent();

              // Show info about what was found
              this.browserBookmarksInfo = `Found ${linkCount} bookmarks in ${folderCount} folders`;
            } else {
              this.browserBookmarksInfo = 'No bookmarks found in browser';
            }

          } catch (error) {
            debugLog('error', 'Failed to fetch browser bookmarks:', error);
            this.browserBookmarksInfo = `Error: ${error.message}`;
          } finally {
            this.fetchingBrowserBookmarks = false;
          }
        },

        async fetchFromUrl() {
          if (!this.importUrl) return;

          this.fetchingUrl = true;
          this.urlFetchError = '';

          try {
            // Check if extension is available for secure fetching
            if (this.extensionAvailable) {
              debugLog('log', 'Using extension to fetch URL for import:', this.importUrl);

              // Request full HTML content and extracted links
              const metadata = await MB.Extension.fetchMetadata(this.importUrl, {
                includeHtml: true
              });

              // Check if this is a JSON endpoint or HTML page
              if (this.importUrl.endsWith('.json')) {
                // Try to parse the HTML as JSON (some servers return JSON with HTML content-type)
                try {
                  const jsonData = JSON.parse(metadata.html);
                  this.pasteContent = JSON.stringify(jsonData, null, 2);
                } catch {
                  // Not valid JSON, put the full HTML in the textarea for parsing
                  this.pasteContent = metadata.html;
                }
              } else {
                // HTML page - put the FULL HTML CONTENT in the textarea
                // The parsePastedContent function will extract links from it
                if (metadata.html) {
                  debugLog('log', `Got HTML content (${metadata.html.length} chars), letting parsePastedContent extract links`);
                  this.pasteContent = metadata.html;
                } else if (metadata.links && metadata.links.length > 0) {
                  // Fallback if no HTML but we have extracted links
                  debugLog('log', `No HTML but found ${metadata.links.length} pre-extracted links`);
                  const linkList = metadata.links.map(link => `${link.text || link.url}\t${link.url}`).join('\n');
                  this.pasteContent = linkList;
                } else {
                  // No content at all, create single link to the page
                  debugLog('warn', 'No HTML content or links found, creating single link');
                  this.pasteContent = `${metadata.title || this.importUrl}\t${this.importUrl}`;
                }
              }
              this.parsePastedContent();
            } else {
              // Extension not available - try direct fetch (will likely fail due to CORS)
              const response = await fetch(this.importUrl);

              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }

              const contentType = response.headers.get('content-type');
              let content = '';

              if (contentType && contentType.includes('application/json')) {
                const data = await response.json();
                content = JSON.stringify(data, null, 2);
              } else {
                content = await response.text();
              }

              this.pasteContent = content;
              this.parsePastedContent();
            }

          } catch (error) {
            debugLog('error', 'Failed to fetch from URL:', error);

            // Provide helpful error messages
            if (!this.extensionAvailable) {
              this.urlFetchError = this.getTranslation('import.extensionRequired') ||
                'Browser extension required for fetching URLs. Please install the MyBookmarks extension or use file upload.';
            } else if (error.message.includes('Extension needs enhancement')) {
              this.urlFetchError = error.message;
            } else if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
              this.urlFetchError = this.getTranslation('import.corsError') ||
                'Cannot fetch due to CORS policy. Try using the browser extension or download the file locally.';
            } else {
              this.urlFetchError = this.getTranslation('import.fetchError') ||
                `Failed to fetch: ${error.message}`;
            }
          } finally {
            this.fetchingUrl = false;
          }
        },
        
        parsePastedContent() {
          const txt = (this.pasteContent || '').trim();
          if (!txt) {
            this.parsedLinks = null;
            this.detectedFormat = '';
            this.isFullExport = false;
            return;
          }

          // Try to detect and parse format
          let links = [];
          this.isFullExport = false;
          this.parsedGroups = null; // Reset parsed groups

          // 1. First check if it's HTML content (most flexible parser)
          const hasHtmlTags = /<[a-z][\s\S]*>/i.test(txt);
          const hasLinks = /<a\s+[^>]*href[\s]*=/i.test(txt);
          const isLikelyHtml = hasHtmlTags || txt.includes('<!DOCTYPE') || txt.includes('<html');

          if (isLikelyHtml && hasLinks) {
            try {
              const htmlParser = new HTMLBookmarkParser({
                minLinksForGroup: 2,
                extractMetadata: true,
                extractKeywords: true,
                inferGroupNames: true
              });

              const parsedGroups = htmlParser.parse(txt);

              if (parsedGroups && parsedGroups.length > 0) {
                // Successfully parsed with groups
                let totalLinks = 0;
                parsedGroups.forEach(group => {
                  if (group.links && group.links.length > 0) {
                    totalLinks += group.links.length;
                    group.links.forEach(link => {
                      links.push({
                        text: link.text || link.url || 'Link',
                        url: link.url,
                        keywords: link.keywords || '',
                        groupName: group.name || 'Imported',
                        selected: true
                      });
                    });
                  }
                });

                if (totalLinks > 0) {
                  // Found links with groups
                  this.detectedFormat = parsedGroups.length > 1 ?
                    `HTML (${parsedGroups.length} groups, ${totalLinks} links)` :
                    `HTML (${totalLinks} links)`;
                  this.parsedGroups = parsedGroups;
                  console.log(`[Import] HTMLBookmarkParser found ${parsedGroups.length} groups with ${totalLinks} links`);
                }
              }
            } catch (e) {
              console.error('[Import] HTMLBookmarkParser failed:', e);
              // Will fall through to other parsers
            }
          }

          // 2. If no HTML links found, try JSON (more structured)
          if (links.length === 0) {
            try {
            const data = JSON.parse(txt);
            if (Array.isArray(data)) {
              // JSON Array
              this.detectedFormat = 'JSON Array';
              links = data.map(item => ({
                url: item.url || item.href || item.link || '',
                text: item.text || item.title || item.name || '',
                keywords: item.keywords || item.tags || '',
                selected: true
              })).filter(l => l.url);
            } else if (data && typeof data === 'object') {
              // Single JSON Object
              this.detectedFormat = 'JSON Object';
              if (data.url || data.href || data.link) {
                links = [{
                  url: data.url || data.href || data.link,
                  text: data.text || data.title || data.name || '',
                  keywords: data.keywords || data.tags || '',
                  selected: true
                }];
              } else if (data.groups && Array.isArray(data.groups)) {
                // Check if it's a full export with settings
                if (data.options || data.identity || data.contacts || data.snapshots) {
                  this.detectedFormat = 'Full Bookmarks Export (with Settings)';
                  this.isFullExport = true;
                  this.fullExportData = data;
                } else {
                  this.detectedFormat = 'Bookmarks Export (Groups only)';
                }
                
                data.groups.forEach(group => {
                  if (group.links && Array.isArray(group.links)) {
                    group.links.forEach(link => {
                      if (!link.deleted) {
                        links.push({
                          url: link.url || '',
                          text: link.text || '',
                          keywords: link.keywords || '',
                          groupName: group.name,
                          selected: true
                        });
                      }
                    });
                  }
                });
              }
            }
          } catch (e) {
            // Not JSON, try other formats
          }
          
          // Try CSV if no JSON found
          if (links.length === 0 && txt.includes(',')) {
            const lines = txt.split('\n').filter(line => line.trim());
            const hasHeader = lines[0] && (lines[0].toLowerCase().includes('url') || lines[0].toLowerCase().includes('title'));
            const startIdx = hasHeader ? 1 : 0;
            
            for (let i = startIdx; i < lines.length; i++) {
              const parts = lines[i].split(',').map(p => p.trim().replace(/^["']|["']$/g, ''));
              if (parts.length >= 1) {
                const url = parts.find(p => /^https?:\/\//i.test(p)) || parts[0];
                if (url && /^https?:\/\//i.test(url)) {
                  this.detectedFormat = 'CSV';
                  links.push({
                    url: url,
                    text: parts.find(p => p !== url) || '',
                    keywords: '',
                    selected: true
                  });
                }
              }
            }
          }
          }
          
          // Try tab-separated format (text\turl per line)
          if (links.length === 0) {
            const lines = txt.split('\n').filter(line => line.trim());
            const tabSeparatedLinks = [];

            for (const line of lines) {
              if (line.includes('\t')) {
                const parts = line.split('\t');
                if (parts.length >= 2) {
                  const url = parts[parts.length - 1].trim(); // Last part is URL
                  let text = parts.slice(0, -1).join('\t').trim(); // Everything else is text

                  // Extract folder path from text if present [Folder / Subfolder] Title or [Folder > Subfolder] Title
                  let groupName = '';
                  const pathMatch = text.match(/^\[([^\]]+)\]\s*(.*)$/);
                  if (pathMatch) {
                    const path = pathMatch[1];
                    text = pathMatch[2] || text;
                    // Use the full path as group name for hierarchical display
                    // Support both ' / ' and ' > ' as separators
                    groupName = path.trim();
                  }

                  // Validate URL
                  if (url && (url.startsWith('http://') || url.startsWith('https://') || url.includes('.'))) {
                    tabSeparatedLinks.push({
                      url: MB.Utils.ensureProtocol(url),
                      text: text || url,
                      keywords: '',
                      groupName: groupName,
                      selected: true
                    });
                  }
                }
              }
            }

            if (tabSeparatedLinks.length > 0) {
              this.detectedFormat = 'Tab-separated (text → URL)';
              links = tabSeparatedLinks;
              debugLog('log', `Parsed ${links.length} links from tab-separated format`);
            }
          }

          // Try plain URLs as last resort
          if (links.length === 0) {
            const urlRegex = /https?:\/\/[^\s]+/gi;
            const matches = txt.match(urlRegex);
            if (matches && matches.length > 0) {
              this.detectedFormat = 'Plain URLs';
              links = matches.map(url => ({
                url: url,
                text: '',
                keywords: '',
                selected: true
              }));
            }
          }
          
          this.parsedLinks = links.length > 0 ? links : null;
          if (!this.parsedLinks) {
            this.detectedFormat = '';
            this.pasteHint = this.getTranslation('clipboard.noLinksFound') || 'No valid links found';
          } else {
            this.pasteHint = '';
          }
        },
        
        selectAllLinks() {
          if (this.parsedLinks) {
            this.parsedLinks.forEach(link => { link.selected = true; });
          }
        },
        
        deselectAllLinks() {
          if (this.parsedLinks) {
            this.parsedLinks.forEach(link => { link.selected = false; });
          }
        },
        
        getImportGroups() {
          if (!this.parsedLinks) return [];
          const groups = new Set();
          this.parsedLinks.forEach(link => {
            if (link.groupName) {
              groups.add(link.groupName);
            }
          });
          return Array.from(groups).sort();
        },

        getUniqueGroupNames() {
          if (!this.parsedLinks) return [];
          const groups = new Set();
          // Add empty string first for ungrouped links
          groups.add('');
          this.parsedLinks.forEach(link => {
            if (link.groupName) {
              groups.add(link.groupName);
            }
          });
          // Sort with empty string first, then alphabetically
          return Array.from(groups).sort((a, b) => {
            if (a === '') return -1;
            if (b === '') return 1;
            return a.localeCompare(b);
          });
        },

        getLinksForGroup(groupName) {
          if (!this.parsedLinks) return [];
          return this.parsedLinks.filter(link => (link.groupName || '') === groupName);
        },

        resetImportDialog() {
          // Clear all import-related data to free up memory
          // This is especially important for large link collections
          this.pasteContent = '';
          this.parsedLinks = null;
          this.parsedGroups = null;
          this.detectedFormat = '';
          this.isFullExport = false;
          this.fullExportData = null;
          this.pasteHint = '';
          this.importUrl = '';
          this.fetchingUrl = false;
          this.fetchMessage = '';
          this.browserBookmarks = null;
          this.selectedBookmarkFolders = [];
          this.importGroupTitle = '';

          // Clear file input if exists
          if (this.$refs.fileInput) {
            this.$refs.fileInput.value = '';
          }

          debugLog('log', '[Import] Dialog reset - memory cleared');
        },

        isGroupSelected(groupName) {
          const links = this.getLinksForGroup(groupName);
          if (links.length === 0) return false;
          return links.every(link => link.selected);
        },

        toggleGroupSelection(groupName) {
          const links = this.getLinksForGroup(groupName);
          if (links.length === 0) return;

          const allSelected = links.every(link => link.selected);
          links.forEach(link => {
            link.selected = !allSelected;
          });
        },

        isImportGroupCollapsed(groupName) {
          return this.importCollapsedGroups[groupName] || false;
        },

        toggleImportGroupCollapse(groupName) {
          this.$set(this.importCollapsedGroups, groupName, !this.importCollapsedGroups[groupName]);
        },

        getGroupDisplayName(groupName) {
          // For browser bookmarks, show only the last part of the path as the main title
          if (groupName && groupName.includes(' / ')) {
            const parts = groupName.split(' / ');
            return parts[parts.length - 1];
          }
          return groupName || 'Unsorted';
        },

        getGroupFullPath(groupName) {
          // Show the full path only if it's a multi-level path (from browser bookmarks)
          if (groupName && groupName.includes(' / ')) {
            return groupName;
          }
          return ''; // Don't show path for single-level groups
        },
        
        getDefaultImportGroupTitle() {
          const now = new Date();
          const dateStr = moment(now).format('L'); // Localized date format
          const timeStr = moment(now).format('LT'); // Localized time format
          return `${this.getTranslation('import.defaultGroupTitle') || 'Import'} ${dateStr} ${timeStr}`;
        },
        
        confirmPasteAdd() {
          // Handle full export with settings - treat as database restore
          if (this.isFullExport && this.fullExportData) {
            const confirmMsg = this.getTranslation('import.fullExportConfirm') || 
                             'This will REPLACE your entire database (groups, settings, contacts, etc.).\n\n' +
                             'This is a restore operation - all UUIDs will be preserved.\n\n' +
                             'Continue?';
            
            if (confirm(confirmMsg)) {
              // Full database restore - preserve all UUIDs
              try {
                // Create backup snapshot before restore
                const backup = this.getSavableData();
                if (!this.data.snapshots) this.data.snapshots = [];
                this.data.snapshots.push({
                  timestamp: Date.now(),
                  label: 'Before Full Import Restore',
                  data: backup
                });
                
                // Complete database restore - preserve all UUIDs exactly as they are
                if (this.fullExportData.options) this.data.options = this.fullExportData.options;
                if (this.fullExportData.identity) this.data.identity = this.fullExportData.identity;
                if (this.fullExportData.contacts) this.data.contacts = this.fullExportData.contacts;
                if (this.fullExportData.snapshots) this.data.snapshots = this.fullExportData.snapshots;
                if (this.fullExportData.savedSearches) this.data.savedSearches = this.fullExportData.savedSearches;
                if (this.fullExportData.inbox) this.data.inbox = this.fullExportData.inbox;
                if (this.fullExportData.pendingNcDeletes) this.data.pendingNcDeletes = this.fullExportData.pendingNcDeletes;
                if (this.fullExportData.schemaVersion) this.data.schemaVersion = this.fullExportData.schemaVersion;
                
                // Restore groups with preserved UUIDs
                if (this.fullExportData.groups) {
                  this.data.groups = this.fullExportData.groups.map(g => ({
                    ...g,
                    // Preserve the UUID from the export - this is a restore operation
                    uuid: g.uuid, // Keep original UUID, don't generate new one
                    editing: false,
                    isMouseOver: false,
                    newLinkText: '',
                    newLinkUrl: '',
                    collapsed: this.data.options?.groups?.collapseGroupsOnStart || false,
                    searchCollapsed: true,
                    links: (g.links || []).map(l => ({
                      ...l,
                      // Preserve the UUID from the export - this is a restore operation
                      uuid: l.uuid, // Keep original UUID, don't generate new one
                      editing: false,
                      isMouseOver: false
                    }))
                  }));
                }
                
                // Restore idSequence if present
                if (this.fullExportData.idSequence) {
                  this.data.idSequence = this.fullExportData.idSequence;
                }
                
                this.saveData();
                this.updateSettings();
                
                // Close modal and refresh
                const modalElement = document.getElementById('pasteClipboardModal');
                const modalInstance = modalElement ? bootstrap.Modal.getInstance(modalElement) : null;
                modalInstance && modalInstance.hide();
                // Note: resetImportDialog() will be called automatically by the modal hidden event listener
                this.detectedFormat = '';
                this.isFullExport = false;
                this.fullExportData = null;
                return;
              } catch (error) {
                debugLog('error', 'Database restore failed:', error);
                alert(this.getTranslation('import.fullExportError') || 'Database restore failed. Check console for details.');
                return;
              }
            }
          }
          
          // Normal import - just add selected links
          if (!this.parsedLinks || this.parsedLinks.length === 0) {
            alert(this.getTranslation('clipboard.noLinksFound') || 'No links to import');
            return;
          }
          
          const selectedLinks = this.parsedLinks.filter(l => l.selected);
          if (selectedLinks.length === 0) {
            alert(this.getTranslation('clipboard.noSelection') || 'Please select at least one link');
            return;
          }
          
          // Group links by their groupName if available
          const linksByGroup = {};
          const noGroupLinks = [];
          
          selectedLinks.forEach(link => {
            if (link.groupName) {
              if (!linksByGroup[link.groupName]) {
                linksByGroup[link.groupName] = [];
              }
              linksByGroup[link.groupName].push(link);
            } else {
              noGroupLinks.push(link);
            }
          });
          
          // Process links with groupName - create groups as needed
          Object.entries(linksByGroup).forEach(([groupName, links]) => {
            // Check if group already exists
            let group = this.data.groups.find(g => g.name === groupName);
            
            if (!group) {
              // Create new group
              group = this.getNewGroupTemplate(groupName);
              // Apply default colors from settings
              group.color = this.data.options?.groups?.defaultGroupFormatting || '';
              group.titleFormatting = this.data.options?.groups?.defaultGroupTitleFormatting || '';
              group.linkFormatting = this.data.options?.groups?.defaultGroupLinkFormatting || '';
              
              // Find the column with the fewest groups
              const columns = this.getGroupColumns();
              let targetColumn = 0;
              if (columns.length > 0) {
                const groupsPerColumn = {};
                columns.forEach(col => groupsPerColumn[col] = 0);
                this.data.groups.forEach(g => {
                  if (groupsPerColumn[g.column] !== undefined) {
                    groupsPerColumn[g.column]++;
                  }
                });
                targetColumn = Object.keys(groupsPerColumn).reduce((a, b) => 
                  groupsPerColumn[a] <= groupsPerColumn[b] ? a : b
                );
              }
              group.column = parseInt(targetColumn);
              group.index = this.data.groups.length;
              if (!this.data.groups) this.data.groups = [];
              this.data.groups.push(group);
            }
            
            // Add links to the group
            links.forEach(link => {
              const newLink = {
                uuid: this.generateUUID(),
                url: link.url || '',
                text: link.text || '',
                keywords: link.keywords || '',
                column: 0,
                index: group.links ? group.links.length : 0,
                editing: false,
                isMouseOver: false
              };
              if (!group.links) group.links = [];
              group.links.push(newLink);
            });
          });
          
          // Process links without groupName
          if (noGroupLinks.length > 0) {
            let g = null;
            
            // Use specified title or generate default with date
            const groupTitle = this.importGroupTitle && this.importGroupTitle.trim() 
              ? this.importGroupTitle.trim() 
              : this.getDefaultImportGroupTitle();
            
            // Create new group with title
            const newGroup = this.getNewGroupTemplate(groupTitle);
            // Apply default colors from settings
            newGroup.color = this.data.options?.groups?.defaultGroupFormatting || '';
            newGroup.titleFormatting = this.data.options?.groups?.defaultGroupTitleFormatting || '';
            newGroup.linkFormatting = this.data.options?.groups?.defaultGroupLinkFormatting || '';
            newGroup.badgeFormatting = this.data.options?.groups?.defaultGroupBadgeFormatting || '';
            newGroup.pillFormatting = this.data.options?.groups?.defaultGroupPillFormatting || '';
            newGroup.pillColor = '';
            // Find the column with the fewest groups
            const columns = this.getGroupColumns();
            let targetColumn = 0;
            if (columns.length > 0) {
              const groupsPerColumn = {};
              columns.forEach(col => groupsPerColumn[col] = 0);
              this.data.groups.forEach(group => {
                if (groupsPerColumn[group.column] !== undefined) {
                  groupsPerColumn[group.column]++;
                }
              });
              targetColumn = Object.keys(groupsPerColumn).reduce((a, b) => 
                groupsPerColumn[a] <= groupsPerColumn[b] ? a : b
              );
            }
            newGroup.column = parseInt(targetColumn);
            newGroup.index = this.data.groups.length;
            if (!this.data.groups) this.data.groups = [];
            this.data.groups.push(newGroup);
            g = newGroup;
            
            if (!g) { 
              alert('No group available'); 
              return; 
            }
            
            // Add all no-group links to the selected group
            noGroupLinks.forEach(link => {
              const newLink = {
                uuid: this.generateUUID(),
                url: link.url || '',
                text: link.text || '',
                keywords: link.keywords || '',
                column: 0,
                index: g.links ? g.links.length : 0,
                editing: false,
                isMouseOver: false
              };
              if (!g.links) g.links = [];
              g.links.push(newLink);
            });
          }
          
          this.saveData();
          
          // Close modal
          const modalElement = document.getElementById('pasteClipboardModal');
          const modalInstance = modalElement ? bootstrap.Modal.getInstance(modalElement) : null;
          modalInstance && modalInstance.hide();

          // Note: resetImportDialog() will be called automatically by the modal hidden event listener
        },

        // ---------- Smart Sync for Shared Groups ----------
        
        initSmartSync() {
          // Initialize smart sync for shared groups
          if (!this.data.syncState) {
            this.$set(this.data, 'syncState', {});
          }
          
          debugLog('log', '[SMART-SYNC] Initializing sync for shared groups');
          
          // Check for updates on startup for all shared groups
          // This ensures offline members get updates when they come online
          this.data.groups.forEach(group => {
            if (group.shared && group.groupId) {
              // Schedule sync for all shared groups (both owners and members)
              // Members need updates from when they were offline
              // Owners might need to provide updates to members coming online
              const delay = Math.random() * 10000; // Random delay up to 10 seconds
              debugLog('log', `[SMART-SYNC] Scheduling initial sync for ${group.name} in ${Math.round(delay/1000)}s`);
              this.scheduleGroupSync(group, delay);
            }
          });
        },
        
        scheduleGroupSync(group, delayMs = Math.random() * 5000) {
          // Stagger sync requests to avoid thundering herd
          setTimeout(() => {
            this.requestSmartSync(group);
          }, delayMs);
        },
        
        async requestSmartSync(group) {
          if (!group.shared || !group.groupId) {
            debugLog('log', '[SMART-SYNC] Skipping non-shared group');
            return;
          }
          
          // Ensure syncState exists
          if (!this.data.syncState) {
            this.$set(this.data, 'syncState', {});
          }
          
          const syncStateKey = group.groupId || group.id;
          const syncState = this.data.syncState[syncStateKey] || {};
          const now = Date.now();
          
          // Don't sync too frequently (max once per minute)
          if (syncState.lastSyncAttempt && (now - syncState.lastSyncAttempt) < CONSTS.MINUTE_MS) {
            const remaining = Math.ceil((CONSTS.MINUTE_MS - (now - syncState.lastSyncAttempt)) / 1000);
            debugLog('log', `[SMART-SYNC] Too soon to sync ${group.name}, wait ${remaining}s`);
            return;
          }
          
          // Update sync attempt time
          this.$set(this.data.syncState, syncStateKey, {
            ...syncState,
            lastSyncAttempt: now
          });
          
          // Calculate our version
          const myVersion = group.version || (group.links?.length || 0);
          
          debugLog('log', '[SMART-SYNC] Requesting sync for group', {
            name: group.name,
            groupId: group.groupId,
            myVersion,
            members: group.sharedWith?.length
          });
          
          // Phase 1: Send version check request (lightweight)
          const versionCheckRequest = {
            type: 'sync-version-check',
            groupId: group.groupId,
            myVersion: myVersion,
            requestId: this.generateUUID(),
            from: { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' },
            timestamp: now
          };
          
          // Store request for response matching
          this.pendingSyncRequests = this.pendingSyncRequests || {};
          this.pendingSyncRequests[versionCheckRequest.requestId] = {
            group: group,
            responses: [],
            timeout: setTimeout(() => {
              this.processSyncResponses(versionCheckRequest.requestId);
            }, 3000) // Wait 3 seconds for responses
          };
          
          // Send to all group members via group channel
          if (window.sharing) {
            await window.sharing.sendToGroup(group, versionCheckRequest);
          }
        },
        
        async handleSyncVersionCheck(message, fromMember) {
          // Find group by groupId (shared groups use groupId, not id)
          const group = this.data.groups.find(g => g.groupId === message.groupId);
          if (!group || !group.shared) {
            debugLog('log', '[SMART-SYNC] Group not found or not shared', message.groupId);
            return;
          }
          
          // Calculate version from links count/modification
          const version = group.version || (group.links?.length || 0);
          
          debugLog('log', '[SMART-SYNC] Responding to version check', { 
            groupId: group.groupId, 
            myVersion: version,
            fromMember 
          });
          
          // Respond with our version info
          const response = {
            type: 'sync-version-response',
            requestId: message.requestId,
            groupId: message.groupId,
            myVersion: version,
            memberCount: group.sharedWith?.length || 0,
            uuid: this.data.identity?.uuid,
            from: { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' },
            timestamp: Date.now()
          };
          
          // Send response via group channel (more reliable than direct member channel)
          if (window.sharing) {
            await window.sharing.sendToGroup(group, response);
          }
        },
        
        handleSyncVersionResponse(message) {
          const pending = this.pendingSyncRequests?.[message.requestId];
          if (!pending) return;
          
          pending.responses.push(message);
        },
        
        processSyncResponses(requestId) {
          const pending = this.pendingSyncRequests?.[requestId];
          if (!pending) return;
          
          clearTimeout(pending.timeout);
          delete this.pendingSyncRequests[requestId];
          
          const group = pending.group;
          const responses = pending.responses;
          
          if (responses.length === 0) {
            // No responses - we might be the only one online
            debugLog('log', '[SYNC] No responses for group', group.name);
            return;
          }
          
          // Find the newest version
          const newestVersion = Math.max(
            group.version || 0,
            ...responses.map(r => r.myVersion || 0)
          );
          
          if (newestVersion <= (group.version || 0)) {
            // We already have the newest version
            debugLog('log', '[SYNC] Already have newest version for group', group.name);
            return;
          }
          
          // We need an update - determine who should send it
          const updatedMembers = responses.filter(r => r.myVersion === newestVersion);
          
          // Leader election: Member with newest version and lowest UUID sends
          updatedMembers.sort((a, b) => (a.uuid || '').localeCompare(b.uuid || ''));
          const designatedSender = updatedMembers[0];
          
          // Prepare fallback members (next 2 members with newest version)
          const fallbackMembers = updatedMembers.slice(1, 3).map(m => m.uuid);
          
          // Request full update from designated sender with fallbacks
          this.requestFullUpdate(group, designatedSender.uuid, fallbackMembers);
        },
        
        async requestFullUpdate(group, fromMemberUuid, fallbackMembers = []) {
          const request = {
            type: 'sync-request-full',
            groupId: group.id,
            requestId: this.generateUUID(),
            toMember: fromMemberUuid
          };
          
          // Store fallback info for timeout handling
          this.pendingUpdateRequests = this.pendingUpdateRequests || {};
          this.pendingUpdateRequests[request.requestId] = {
            group: group,
            primaryMember: fromMemberUuid,
            fallbackMembers: fallbackMembers,
            attemptNumber: 1,
            timeout: setTimeout(() => {
              this.handleUpdateTimeout(request.requestId);
            }, 5000) // 5 second timeout for full update
          };
          
          // Send request only to designated sender
          await this.sendToMember(fromMemberUuid, request);
        },
        
        handleUpdateTimeout(requestId) {
          const pending = this.pendingUpdateRequests?.[requestId];
          if (!pending) return;
          
          clearTimeout(pending.timeout);
          
          debugLog('log', '[SYNC] Update timeout for attempt', pending.attemptNumber, 'from', pending.primaryMember);
          
          // Try next fallback member
          if (pending.fallbackMembers.length > 0 && pending.attemptNumber < 3) {
            const nextMember = pending.fallbackMembers.shift();
            debugLog('log', '[SYNC] Trying fallback member', nextMember);
            
            // Update pending request
            pending.primaryMember = nextMember;
            pending.attemptNumber++;
            pending.timeout = setTimeout(() => {
              this.handleUpdateTimeout(requestId);
            }, 5000);
            
            // Send request to next member
            const request = {
              type: 'sync-request-full',
              groupId: pending.group.id,
              requestId: requestId,
              toMember: nextMember
            };
            
            this.sendToMember(nextMember, request);
          } else {
            // All attempts failed - try broadcast as last resort
            debugLog('log', '[SYNC] All targeted attempts failed, trying broadcast');
            delete this.pendingUpdateRequests[requestId];
            
            this.requestBroadcastUpdate(pending.group);
          }
        },
        
        async requestBroadcastUpdate(group) {
          // Last resort: Ask everyone for update
          const request = {
            type: 'sync-request-any',
            groupId: group.id,
            requestId: this.generateUUID(),
            myVersion: group.version || 0,
            timestamp: Date.now()
          };
          
          // Limit responses with a random selection mechanism
          this.pendingBroadcastRequests = this.pendingBroadcastRequests || {};
          this.pendingBroadcastRequests[request.requestId] = {
            group: group,
            responded: false,
            timeout: setTimeout(() => {
              delete this.pendingBroadcastRequests[request.requestId];
            }, 10000) // 10 second timeout
          };
          
          await this.broadcastToGroup(group, request);
        },
        
        async handleSyncRequestAny(message, fromMember) {
          const group = this.data.groups.find(g => g.id === message.groupId);
          if (!group || !group.shared) return;
          
          // Check if the requesting member is still in the group
          const memberStillInGroup = group.members?.some(m => m.uuid === fromMember.uuid);
          if (!memberStillInGroup) {
            // Member was removed - send removal notification
            await this.sendMemberRemovalNotification(group, fromMember);
            return;
          }
          
          // Check if we have a newer version
          if ((group.version || 0) <= message.myVersion) return;
          
          // Implement random backoff to avoid everyone responding
          const responseDelay = Math.random() * 3000; // 0-3 seconds random delay
          
          setTimeout(async () => {
            // Check if request is still pending (not already handled)
            if (!this.pendingBroadcastRequests?.[message.requestId]) return;
            
            // Send update with probability to reduce responses
            const shouldRespond = Math.random() < 0.3; // Only 30% chance to respond
            if (!shouldRespond) return;
            
            const update = {
              type: 'sync-broadcast-update',
              requestId: message.requestId,
              groupId: group.id,
              groupData: {
                version: group.version || Date.now(),
                links: group.links || [],
                name: group.name
              },
              timestamp: Date.now()
            };
            
            await this.sendToMember(fromMember, update);
          }, responseDelay);
        },
        
        handleSyncBroadcastUpdate(message) {
          const pending = this.pendingBroadcastRequests?.[message.requestId];
          if (!pending || pending.responded) return;
          
          // Mark as responded to ignore further updates
          pending.responded = true;
          clearTimeout(pending.timeout);
          delete this.pendingBroadcastRequests[message.requestId];
          
          // Apply the update
          this.handleSyncFullUpdate(message);
        },
        
        async handleSyncRequestFull(message, fromMember) {
          const group = this.data.groups.find(g => g.id === message.groupId);
          if (!group || !group.shared) return;
          
          // Check if the requesting member is still in the group
          const memberStillInGroup = group.members?.some(m => m.uuid === fromMember.uuid);
          if (!memberStillInGroup) {
            // Member was removed - send removal notification
            await this.sendMemberRemovalNotification(group, fromMember);
            return;
          }
          
          // Check if we're the designated sender
          if (message.toMember !== this.data.identity?.uuid) return;
          
          // Send full group update
          const update = {
            type: 'sync-full-update',
            requestId: message.requestId,
            groupId: group.id,
            groupData: {
              version: group.version || Date.now(),
              links: group.links || [],
              name: group.name,
              // Include other group properties as needed
            },
            timestamp: Date.now()
          };
          
          await this.sendToMember(fromMember, update);
        },
        
        handleSyncFullUpdate(message) {
          const group = this.data.groups.find(g => g.id === message.groupId);
          if (!group || !group.shared) return;
          
          // Clear any pending update requests for this group
          if (message.requestId && this.pendingUpdateRequests?.[message.requestId]) {
            clearTimeout(this.pendingUpdateRequests[message.requestId].timeout);
            delete this.pendingUpdateRequests[message.requestId];
          }
          
          // Apply the update if it's newer
          if ((message.groupData.version || 0) > (group.version || 0)) {
            // Merge the update
            group.version = message.groupData.version;
            group.links = message.groupData.links;
            // Update other properties as needed
            
            this.saveData();
            debugLog('log', '[SYNC] Updated group', group.name, 'to version', group.version);
            
            // Update sync state
            this.$set(this.data.syncState, group.id, {
              lastSyncAttempt: Date.now(),
              lastSuccessfulSync: Date.now(),
              version: group.version
            });
          }
        },
        
        async broadcastToGroup(group, message) {
          // Send message to all group members
          if (!group.sharedWith) return;
          
          for (const memberUuid of group.sharedWith) {
            if (memberUuid !== this.data.identity?.uuid) {
              await this.sendToMember(memberUuid, message);
            }
          }
        },
        
        async handleSyncFullRequest(message) {
          const group = this.data.groups.find(g => g.groupId === message.groupId);
          if (!group || !group.shared) {
            debugLog('log', '[SMART-SYNC] Cannot send full update - group not found', message.groupId);
            return;
          }
          
          debugLog('log', '[SMART-SYNC] Sending full update to requester', {
            groupId: group.groupId,
            links: group.links?.length
          });
          
          // Send full group snapshot including event-log and snapshots
          const fullUpdate = {
            type: 'sync-full-update',
            requestId: message.requestId,
            groupId: group.groupId,
            version: group.version || (group.links?.length || 0),
            name: group.name,
            emoji: group.emoji || '',
            color: group.color || '',
            links: (group.links || []).map(l => ({
              uuid: l.uuid || this.generateUUID(),
              text: l.text || '',
              url: l.url || '',
              keywords: l.keywords || '',
              emoji: l.emoji || '',
              column: l.column || 0,
              index: typeof l.index === 'number' ? l.index : 0
            })),
            // Include event-log data if available
            useEventLog: group.useEventLog || false,
            eventLog: group.eventLog || [],
            snapshot: group.snapshot || null,
            headEventId: group.headEventId || null,
            vectorClock: group.vectorClock || {},
            from: { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' },
            timestamp: Date.now()
          };
          
          // Send via group channel for reliability (chunked if large)
          if (window.sharing) {
            const raw = JSON.stringify(fullUpdate);
            if (raw.length > 100000) {
              await window.sharing.sendChunkedGroup(group, 'full-update', fullUpdate);
            } else {
              await window.sharing.sendToGroup(group, fullUpdate);
            }
          }
        },
        
        async handleSyncFullUpdate(message) {
          const group = this.data.groups.find(g => g.groupId === message.groupId);
          if (!group || !group.shared) {
            debugLog('log', '[SMART-SYNC] Cannot apply full update - group not found', message.groupId);
            return;
          }
          
          // Clear pending update request if this matches
          const pending = this.pendingUpdateRequests?.[message.requestId];
          if (pending) {
            clearTimeout(pending.timeout);
            delete this.pendingUpdateRequests[message.requestId];
          }
          
          debugLog('log', '[SMART-SYNC] Applying full update', {
            groupId: group.groupId,
            newVersion: message.version,
            oldVersion: group.version || 0,
            linksCount: message.links?.length
          });
          
          // Update group metadata
          group.version = message.version;
          if (message.name) group.name = message.name;
          if (message.emoji !== undefined) group.emoji = message.emoji || '';
          if (message.color !== undefined) group.color = message.color;
          
          // Apply links update - prevent duplicates
          if (Array.isArray(message.links)) {
            const isOwner = (group.members || []).some(m => m.role === 'owner' && m.uuid === this.data.identity?.uuid);
            
            if (!isOwner) {
              // Members accept the full update
              const existingUuids = new Set();
              const newLinks = [];
              
              for (const link of message.links) {
                // Ensure each link has a UUID
                const linkUuid = link.uuid || this.generateUUID();
                
                // Skip duplicates
                if (existingUuids.has(linkUuid)) {
                  debugLog('log', '[SMART-SYNC] Skipping duplicate link', linkUuid);
                  continue;
                }
                
                existingUuids.add(linkUuid);
                newLinks.push({
                  uuid: linkUuid,
                  text: link.text || '',
                  url: link.url || '',
                  keywords: link.keywords || '',
                  emoji: link.emoji || '',
                  column: link.column || 0,
                  index: typeof link.index === 'number' ? link.index : 0,
                  editing: false,
                  isMouseOver: false
                });
              }
              
              // Replace links array completely to avoid duplicates
              this.$set(group, 'links', newLinks);
              debugLog('log', '[SMART-SYNC] Replaced links array', { count: newLinks.length });
            }
          }
          
          // Apply event-log data if available - BUT DON'T OVERWRITE OWNER'S DATA
          if (message.useEventLog && message.eventLog) {
            const isOwner = (group.members || []).some(m => m.role === 'owner' && m.uuid === this.data.identity?.uuid);
            
            if (isOwner && group.useEventLog && group.eventLog) {
              // OWNER: Merge events, don't overwrite
              debugLog('log', '[SMART-SYNC] Owner merging event-log from full update', {
                currentEventCount: group.eventLog?.length || 0,
                incomingEventCount: message.eventLog?.length || 0
              });
              
              // Find new events that we don't have yet
              const existingEventIds = new Set((group.eventLog || []).map(e => e.eventId));
              const newEvents = (message.eventLog || []).filter(e => !existingEventIds.has(e.eventId));
              
              if (newEvents.length > 0) {
                debugLog('log', '[SMART-SYNC] Owner merging new events', { count: newEvents.length });
                // Merge new events
                if (this.eventLogManager) {
                  newEvents.forEach(event => {
                    this.eventLogManager.applyRemoteEvent(group, event, 'owner-leads');
                  });
                }
              }
              
              // Merge vector clocks
              if (message.vectorClock) {
                const mergedVC = { ...(group.vectorClock || {}) };
                Object.keys(message.vectorClock).forEach(key => {
                  mergedVC[key] = Math.max(mergedVC[key] || 0, message.vectorClock[key] || 0);
                });
                this.$set(group, 'vectorClock', mergedVC);
              }
            } else {
              // MEMBER or OWNER without event-log yet: Accept full event-log
              debugLog('log', '[SMART-SYNC] Applying complete event-log data', {
                isOwner,
                eventLogCount: message.eventLog?.length || 0,
                hasSnapshot: !!message.snapshot
              });
              
              this.$set(group, 'useEventLog', true);
              this.$set(group, 'eventLog', message.eventLog || []);
              this.$set(group, 'snapshot', message.snapshot || null);
              this.$set(group, 'headEventId', message.headEventId || null);
              this.$set(group, 'vectorClock', message.vectorClock || {});
            }
            
            debugLog('log', '[SMART-SYNC] Event-log data processed successfully');
          }
          
          this.saveData();
        },
        
        async handleSyncBroadcastRequest(message) {
          const group = this.data.groups.find(g => g.groupId === message.groupId);
          if (!group || !group.shared) return;
          
          const myVersion = group.version || (group.links?.length || 0);
          
          // Only respond if we have a newer version
          if (myVersion <= message.myVersion) {
            debugLog('log', '[SMART-SYNC] Ignoring broadcast request - no newer version');
            return;
          }
          
          // Use random delay and probability to avoid thundering herd
          const delay = Math.random() * 2000;
          const probability = 1 / Math.max(2, group.sharedWith?.length || 2);
          
          if (Math.random() < probability) {
            setTimeout(async () => {
              debugLog('log', '[SMART-SYNC] Responding to broadcast request with full update');
              await this.handleSyncFullRequest(message);
            }, delay);
          }
        },
        
        async sendMemberRemovalNotification(group, removedMember) {
          // Find the owner of the group
          const owner = group.members?.find(m => m.role === 'owner');
          const ownerName = owner?.name || owner?.uuid || 'Unknown';
          
          const notification = {
            type: 'member-removed-notification',
            groupId: group.id || group.uuid,
            groupName: group.name,
            ownerName: ownerName,
            removedAt: Date.now(),
            message: 'You have been removed from this group'
          };
          
          debugLog('log', '[SYNC] Sending removal notification to:', removedMember.uuid);
          await this.sendToMember(removedMember.uuid, notification);
        },
        
        handleMemberRemovedNotification(message) {
          debugLog('log', '[SYNC] Received removal notification:', message);
          
          // Show the notification dialog
          this.showRemovedFromGroupNotification(
            message.groupName,
            message.ownerName,
            message.groupId,
            message.removedAt
          );
        },
        
        async sendToMember(memberUuid, message) {
          // Send message to a specific group member via their contact channel
          try {
            // Find the contact by UUID
            const contact = (this.data.contacts || []).find(c => c.uuid === memberUuid);
            if (!contact) {
              debugLog('warn', '[SYNC] Cannot send to member - contact not found:', memberUuid);
              return false;
            }
            
            // Use the sharing service to send via the contact's channel
            if (window.sharing && typeof window.sharing.sendToContact === 'function') {
              await window.sharing.sendToContact(memberUuid, message);
              debugLog('log', '[SYNC] Message sent to member', memberUuid, message.type);
              return true;
            } else {
              debugLog('warn', '[SYNC] Sharing service not available');
              return false;
            }
          } catch (error) {
            debugLog('error', '[SYNC] Failed to send to member:', memberUuid, error);
            return false;
          }
        },
        
        // ---------- Sync All Groups ----------
        async syncAllGroups() {
          // Check cooldown
          const now = Date.now();
          if (this.lastSyncAllTime && (now - this.lastSyncAllTime) < CONSTS.MINUTE_MS) {
            const remainingSeconds = Math.ceil((CONSTS.MINUTE_MS - (now - this.lastSyncAllTime)) / 1000);
            alert(`Please wait ${remainingSeconds} seconds before syncing again.`);
            return;
          }
          
          // Start sync process
          this.isSyncingAll = true;
          this.lastSyncAllTime = now;
          
          // Start cooldown countdown
          this.syncAllCooldown = 60;
          const cooldownInterval = setInterval(() => {
            this.syncAllCooldown--;
            if (this.syncAllCooldown <= 0) {
              clearInterval(cooldownInterval);
            }
          }, 1000);
          
          try {
            // Find all shared groups - check for shared flag and groupId
            const sharedGroups = this.data.groups.filter(g => 
              g.shared && g.groupId && g.groupTopic
            );
            
            if (sharedGroups.length === 0) {
              debugLog('log', '[SYNC ALL] No shared groups found', {
                totalGroups: this.data.groups.length,
                groupsWithShared: this.data.groups.filter(g => g.shared).length,
                groupsWithGroupId: this.data.groups.filter(g => g.groupId).length
              });
              alert('No shared groups to sync.');
              this.isSyncingAll = false;
              return;
            }
            
            debugLog('log', `[SYNC ALL] Starting sync for ${sharedGroups.length} shared groups`);
            
            // Send sync requests for all shared groups with staggered timing
            for (let i = 0; i < sharedGroups.length; i++) {
              const group = sharedGroups[i];
              const delay = i * 200; // 200ms between each group to avoid overwhelming the network
              
              setTimeout(async () => {
                debugLog('log', `[SYNC ALL] Requesting sync for group: ${group.name}`);
                await this.requestSmartSync(group);
              }, delay);
            }
            
            // Show success message
            setTimeout(() => {
              this.isSyncingAll = false;
              debugLog('log', `[SYNC ALL] Sync requests sent for ${sharedGroups.length} groups`);
            }, sharedGroups.length * 200 + 1000);
            
          } catch (error) {
            debugLog('error', '[SYNC ALL] Error during sync:', error);
            this.isSyncingAll = false;
            alert('Error during sync. Please check the console for details.');
          }
        },
        
        // ---------- Duplicate Finder ----------

        // ---------- Snapshots ----------
        async saveSnapshot() {
          const name = prompt(this.getTranslation('snapshots.promptName'), new Date().toISOString().slice(0, 19).replace('T', ' '));
          if (!name) return;
          const base = this.getSavableData();
          // avoid nesting snapshots within snapshots
          if (base.snapshots) base.snapshots = [];
          const snap = {
            id: this.generateUUID(), // Use UUID for snapshots too
            name: name.trim(),
            createdAt: Date.now(),
            payload: base,
          };
          if (!Array.isArray(this.data.snapshots)) this.$set(this.data, 'snapshots', []);
          this.data.snapshots.unshift(snap);
          // keep last 20 snapshots
          if (this.data.snapshots.length > 20) this.data.snapshots.length = 20;
          if (typeof this.saveDataImmediate === 'function') await this.saveDataImmediate(); else this.saveData();
        },
        restoreSnapshot(id) {
          const snap = (this.data.snapshots || []).find(s => s.id === id);
          if (!snap) return;
          if (!confirm(this.getTranslation('snapshots.restore.confirm'))) return;
          // push current to history before restore
          this.historyPast.push(this.getSavableData());
          this._applySnapshot(snap.payload);
        },
        async deleteSnapshot(id) {
          if (!confirm(this.getTranslation('snapshots.delete.confirm'))) return;
          const arr = this.data.snapshots || [];
          const idx = arr.findIndex(s => s.id === id);
          if (idx >= 0) {
            arr.splice(idx, 1);
            if (typeof this.saveDataImmediate === 'function') await this.saveDataImmediate(); else this.saveData();
          }
        },
        formatSnapshotLabel(s) {
          const d = new Date(s.createdAt || Date.now());
          const ds = moment(d).format('LLL');
          return `${s.name} (${ds})`;
        },
        findDuplicateMap() {
          const map = {};
          (this.data.groups || []).forEach(g => (g.links || []).forEach(l => {
            if (!l.url) return;
            const key = this.normalizeUrl(l.url);
            if (!map[key]) map[key] = [];
            map[key].push({ group: g, link: l });
          }));
          return Object.fromEntries(Object.entries(map).filter(([, v]) => v.length > 1));
        },
        findAndResolveDuplicates() {
          const dups = this.findDuplicateMap();
          // Store duplicates with selection status
          this.duplicatesFound = {};
          Object.entries(dups).forEach(([url, items]) => {
            this.duplicatesFound[url] = items.map((item, index) => ({
              ...item,
              selected: index > 0 // By default, select all but the first occurrence
            }));
          });
          
          // Open the modal
          const modalElement = document.getElementById('duplicatesModal');
          if (modalElement) {
            const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
            modalInstance.show();
          }
        },
        toggleDuplicateSelection(url, index) {
          if (this.duplicatesFound[url] && this.duplicatesFound[url][index]) {
            this.duplicatesFound[url][index].selected = !this.duplicatesFound[url][index].selected;
          }
        },
        removeDuplicates() {
          let removedCount = 0;
          Object.values(this.duplicatesFound).forEach(list => {
            // Check if at least one item will remain
            const hasUnselected = list.some(item => !item.selected);
            if (!hasUnselected) {
              // If all items are selected, skip the first one to keep at least one
              list[0].selected = false;
            }
            
            list.forEach((item) => {
              if (item.selected) {
                const idx = item.group.links.findIndex(x => 
                  item.link.uuid && x.uuid === item.link.uuid
                );
                if (idx >= 0) {
                  item.group.links.splice(idx, 1);
                  removedCount++;
                }
                this.getLinkColumns(item.group.links).forEach(col => 
                  this.reindexArr(item.group.links.filter(l => l.column === col))
                );
              }
            });
          });
          
          this.saveData();
          
          // Close the modal
          const modalElement = document.getElementById('duplicatesModal');
          if (modalElement) {
            const modalInstance = bootstrap.Modal.getInstance(modalElement);
            if (modalInstance) {
              modalInstance.hide();
            }
          }
          
          // Show success message
          if (removedCount > 0) {
            alert(this.getTranslation('duplicates.deleted').replace('%s', removedCount));
          }
          
          // Clear duplicates data
          this.duplicatesFound = {};
        },
        // General keyboard activation helper
        onKeyActivate(evt, handler) {
          if (evt.key === 'Enter' || evt.key === ' ') {
            evt.preventDefault();
            handler();
          }
        },
        handleGlobalClick(event) {
          // Close context menus when clicking outside of them
          const groupMenu = document.getElementById('groupMenu');
          const linkMenu = document.getElementById('linkMenu');
          const t = event.target;
          if ((groupMenu && groupMenu.contains(t)) || (linkMenu && linkMenu.contains(t))) {
            return; // click inside an open menu -> ignore
          }
          this.hideMenus();
        },
        onClearClick() {
          this.filterText = '';
          if (this.data.options?.groups?.clearClosesAllGroups) {
            this.collapseAllGroups();
          }
        },
        onKeywordClick(kw) {
          this.filterText = kw;
          if (this.data.options?.groups?.keywordClickExpandsAll) {
            this.expandAllGroups();
          }
        },
        isGroupMatched(g, q) {
          const query = (q || this.filterText || '').toLowerCase();
          if (!query) return true;
          return (
            g.name?.toLowerCase().includes(query)
            || (g.keywords && g.keywords.toLowerCase().includes(query))
            || (g.links && g.links.some(l =>
              l.text?.toLowerCase().includes(query)
              || (l.keywords && l.keywords.toLowerCase().includes(query))
              || (l.url && l.url.toLowerCase().includes(query))
            ))
          );
        },
        // Generic CSS parser function - parses JSON from complex colorpicker
        // ONLY applies properties that are actually SET (non-empty) in the JSON
        parseCssValue(value, defaultStyles = {}) {
          if (!value) return defaultStyles;
          
          // Try to parse as JSON from complex colorpicker
          try {
            const jsonData = JSON.parse(value);
            // Start with defaults
            const styles = { ...defaultStyles };
            
            // ONLY apply properties that have actual values (non-empty)
            // Background
            if (jsonData.backgroundColor && jsonData.backgroundColor.trim() !== '') {
              styles.backgroundColor = jsonData.backgroundColor;
            }
            
            // Text Color
            if (jsonData.color && jsonData.color.trim() !== '') {
              styles.color = jsonData.color;
            }
            
            // Opacity (only if not 100%)
            if (jsonData.opacity && jsonData.opacity < 100) {
              styles.opacity = (jsonData.opacity / 100).toFixed(2);
            }
            
            // Font properties
            if (jsonData.fontFamily && jsonData.fontFamily.trim() !== '') {
              styles.fontFamily = jsonData.fontFamily;
            }
            if (jsonData.fontSize && jsonData.fontSize !== '') {
              styles.fontSize = jsonData.fontSize + (jsonData.fontSizeUnit || 'px');
            }
            if (jsonData.fontWeight && jsonData.fontWeight.trim() !== '') {
              styles.fontWeight = jsonData.fontWeight;
            }
            if (jsonData.fontStyle && jsonData.fontStyle.trim() !== '' && jsonData.fontStyle !== 'normal') {
              styles.fontStyle = jsonData.fontStyle;
            }
            if (jsonData.textDecoration && jsonData.textDecoration.trim() !== '' && jsonData.textDecoration !== 'none') {
              styles.textDecoration = jsonData.textDecoration;
            }
            
            // Border properties - only apply if borderStyle is not 'none' or empty
            if (jsonData.borderStyle && jsonData.borderStyle !== '' && jsonData.borderStyle !== 'none') {
              styles.borderStyle = jsonData.borderStyle;
              
              // Only add width and color if border style exists and is not 'none'
              if (jsonData.borderWidth !== '' && jsonData.borderWidth !== undefined) {
                styles.borderWidth = (jsonData.borderWidth || 1) + 'px';
              }
              
              if (jsonData.borderColor && jsonData.borderColor.trim() !== '') {
                styles.borderColor = jsonData.borderColor;
              }
            }
            // If borderStyle is explicitly 'none', don't add any border properties at all
            
            // Border radius (only if > 0)
            if (jsonData.borderRadius && parseFloat(jsonData.borderRadius) > 0) {
              styles.borderRadius = jsonData.borderRadius + 'px';
            }
            
            // Box shadow (only if set)
            if (jsonData.boxShadow && jsonData.boxShadow.trim() !== '') {
              styles.boxShadow = jsonData.boxShadow;
            }
            
            // Spacing
            // Side-specific padding
            const pT = parseFloat(jsonData.paddingTop);
            const pR = parseFloat(jsonData.paddingRight);
            const pB = parseFloat(jsonData.paddingBottom);
            const pL = parseFloat(jsonData.paddingLeft);
            if (!isNaN(pT)) styles.paddingTop = pT + 'px';
            if (!isNaN(pR)) styles.paddingRight = pR + 'px';
            if (!isNaN(pB)) styles.paddingBottom = pB + 'px';
            if (!isNaN(pL)) styles.paddingLeft = pL + 'px';
            // Fallback uniform padding
            if (jsonData.padding !== undefined && jsonData.padding !== '') {
              const pv = parseFloat(jsonData.padding);
              if (!isNaN(pv)) styles.padding = pv + 'px';
            }
            // Side-specific margin
            const mT = parseFloat(jsonData.marginTop);
            const mR = parseFloat(jsonData.marginRight);
            const mB = parseFloat(jsonData.marginBottom);
            const mL = parseFloat(jsonData.marginLeft);
            if (!isNaN(mT)) styles.marginTop = mT + 'px';
            if (!isNaN(mR)) styles.marginRight = mR + 'px';
            if (!isNaN(mB)) styles.marginBottom = mB + 'px';
            if (!isNaN(mL)) styles.marginLeft = mL + 'px';
            // Fallback uniform margin
            if (jsonData.margin !== undefined && jsonData.margin !== '') {
              const mv = parseFloat(jsonData.margin);
              if (!isNaN(mv)) styles.margin = mv + 'px';
            }
            
            return styles;
          } catch (e) {
            // Not JSON - check if it's a CSS string
            if (typeof value === 'string' && value.includes(':') && value.includes(';')) {
              // Parse CSS string
              const styles = { ...defaultStyles };
              const rules = value.split(';').filter(r => r.trim());
              rules.forEach(rule => {
                const [prop, val] = rule.split(':').map(s => s.trim());
                if (prop && val) {
                  // Convert CSS property names to camelCase
                  const camelProp = prop.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
                  styles[camelProp] = val;
                }
              });
              return styles;
            }
            
            // Simple value (e.g., just a color)
            if (typeof value === 'string' && value.trim()) {
              // Assume it's a background color
              return { ...defaultStyles, backgroundColor: value };
            }
            
            return defaultStyles;
          }
        },
        
        // Get primary color from parsed CSS (for calculations like gradients)
        getPrimaryColorFromCss(value, defaultColor = '') {
          if (!value) return defaultColor;
          
          try {
            const jsonData = JSON.parse(value);
            return jsonData.backgroundColor || defaultColor;
          } catch (e) {
            // Check for simple hex color
            if (typeof value === 'string' && value.match(/^#[0-9A-Fa-f]{3,6}$/)) {
              return value;
            }
            // Check for CSS string with background-color
            if (typeof value === 'string' && value.includes('background-color:')) {
              const match = value.match(/background-color:\s*([^;]+)/);
              if (match) return match[1].trim();
            }
            return defaultColor;
          }
        },
        
        // All styling is now handled via CSS variables and classes
        // Style functions have been removed - use CSS classes and variables instead
        
        calculateStorageUsage() {
          try {
            let totalSize = 0;
            
            // Calculate size of the main data object (stored in IndexedDB)
            if (this.data) {
              const dataString = JSON.stringify(this.data);
              // Each character in JavaScript strings is typically 2 bytes (UTF-16)
              // But JSON.stringify creates UTF-8, so we use the actual byte length
              totalSize = new Blob([dataString]).size;
              
              debugLog('log', '[STORAGE] Data size calculation:', {
                groups: this.data.groups?.length || 0,
                totalLinks: this.data.groups?.reduce((sum, g) => sum + (g.links?.length || 0), 0) || 0,
                snapshots: this.data.snapshots?.length || 0,
                contacts: this.data.contacts?.length || 0,
                stringLength: dataString.length,
                byteSize: totalSize
              });
            }
            
            // Also add localStorage items (like preferences, etc.)
            for (let key in localStorage) {
              if (localStorage.hasOwnProperty(key)) {
                const item = localStorage.getItem(key);
                totalSize += new Blob([key + item]).size;
              }
            }
            
            this.storageUsed = totalSize;
          } catch (e) {
            debugLog('error', 'Error calculating storage:', e);
            this.storageUsed = 0;
          }
        },

        // Schedule/clear CardDAV auto-sync timer based on options
        scheduleCardDavAutoSync() {
          try { if (this.carddavTimer) { clearInterval(this.carddavTimer); this.carddavTimer = null; } } catch {}
          const backend = this.data.options?.sync?.backend || '';
          if (!this.extensionAvailable || !backend) return;
          let sec = 0;
          if (backend === 'carddav') sec = Number(this.data.options?.carddav?.syncIntervalSec || 0);
          if (backend === 'nc-bookmarks') sec = Number(this.data.options?.bookmarks?.syncIntervalSec || 0);
          if (!sec || sec <= 0) return;
          this.carddavTimer = setInterval(() => {
            try { this.syncNowGeneric(); } catch (e) { debugLog('warn', '[SYNC] auto-sync error', e); }
          }, sec * 1000);
          debugLog('log', `[SYNC] Auto-sync scheduled every ${sec}s for backend ${backend}`);
        },
        
        formatStorageSize(bytes) {
          if (bytes < 1024) return bytes + ' B';
          if (bytes < 1048576) return (bytes / 1024).toFixed(2) + ' KB';
          if (bytes < 1073741824) return (bytes / 1048576).toFixed(2) + ' MB';
          return (bytes / 1073741824).toFixed(2) + ' GB';
        },
        
        getStorageTooltip() {
          const used = this.formatStorageSize(this.storageUsed);
          return `${used}`;
        },
        getGroupInnerStyle(group) { return null; },
        getGroupKeywordBadgeStyle(group) {
          // Use titleFormatting which is what's actually set for group titles
          const color = group?.titleFormatting || group?.color || '#6c757d';
          return {
            backgroundColor: `${color} !important`,
            color: `${this.getContrastingTextColor(color)} !important`,
            opacity: '1 !important',
            border: 'none !important'
          };
        },
        getLinkKeywordBadgeStyle(link, group) {
          // Priority: link color > group titleColor > group color > default
          let bgColor = '#6c757d'; // default gray
          
          // Check if link has a color set
          if (link && link.color) {
            try {
              const parsed = JSON.parse(link.color);
              // If it's JSON from CSS dialog, extract the background color
              bgColor = parsed.backgroundColor || parsed.color || bgColor;
            } catch (e) {
              // Not JSON, use as-is
              bgColor = link.color;
            }
          } else {
            // Fall back to group's titleFormatting for consistency with keyword overview
            bgColor = group?.titleFormatting || group?.color || bgColor;
          }
          
          return {
            backgroundColor: `${bgColor} !important`,
            color: `${this.getContrastingTextColor(bgColor)} !important`,
            fontSize: '0.65rem',
            padding: '0.15rem 0.4rem',
            marginLeft: '0.2rem',
            opacity: '1 !important',
            border: 'none !important'
          };
        },
        groupKeywordsArray(group) {
          if (!group || !group.keywords) return [];
          return this.parseKeywords(group.keywords);
        },
        // --- Auto-expand collapsed groups on link hover ---
        scheduleExpandGroup(group) {
          if (!group || !group.collapsed) return;
          if (this.dragState !== 'link') return;
          if (!this.data.options?.groups?.hoverExpandEnabled) return;
          if (this.expandHoverTimers[group.uuid]) return;
          const delay = Math.max(0, Number(this.data.options?.groups?.hoverExpandDelayMs) || 0);
          this.expandHoverTimers[group.uuid] = setTimeout(() => {
            try {
              if (this.dragState === 'link' && group.collapsed) {
                // Expand only if still collapsed
                this.toggleGroupCollapse(group);
              }
            } finally {
              this.$delete(this.expandHoverTimers, group.uuid);
            }
          }, delay);
        },
        handleGroupDragEnter(group) {
          if (this.dragState !== 'link') return;
          this.scheduleExpandGroup(group);
        },
        handleGroupDragOver(group) {
          if (this.dragState !== 'link') return;
          this.scheduleExpandGroup(group);
        },
        handleGroupDragLeave(group) {
          const t = this.expandHoverTimers[group?.id];
          if (t) {
            clearTimeout(t);
            this.$delete(this.expandHoverTimers, group.uuid);
          }
        },
        clearExpandHoverTimers() {
          Object.values(this.expandHoverTimers).forEach(t => clearTimeout(t));
          this.expandHoverTimers = {};
        },

        resetAllMouseOverStates() {
          // Reset mouseover state for all groups
          if (this.data.groups) {
            this.data.groups.forEach(group => {
              group.isMouseOver = false;
              // Reset mouseover state for all links in the group
              if (group.links) {
                group.links.forEach(link => {
                  link.isMouseOver = false;
                });
              }
            });
          }
          debugLog('log', 'Reset all mouseover states for groups and links');
        },

        expandAllGroups() {
          (this.data.groups || []).forEach(g => { this.$set(g, 'collapsed', false); });
          this.saveData();
        },
        collapseAllGroups() {
          (this.data.groups || []).forEach(g => { this.$set(g, 'collapsed', true); });
          this.saveData();
        },

        handleDragEnd(evt) {
          debugLog('log', "handleDragEnd called");

          // Reset cursor for dragged element
          if (evt.target) {
            evt.target.style.cursor = 'grab';
          }

          // Always reset mouseover states when drag ends
          this.resetAllMouseOverStates();

          // Check if we even have a drag operation in progress
          if (!this.dropManager.draggedState) {
            debugLog('log', "No drag state found, ignoring dragend (already reset)");
            return;
          }

          // Check if enough time has passed since drag started
          const dragDuration = this.dropManager.dragStartTime ? Date.now() - this.dropManager.dragStartTime : 0;
          debugLog('log', "Drag duration:", dragDuration, "ms");

          // Browser detection
          const userAgent = navigator.userAgent;
          const isEdge = /Edg/.test(userAgent);
          
          // Edge specific: Handle immediate dragend (< 100ms) differently
          if (isEdge && dragDuration < 100) {
            debugLog('log', "Edge: Immediate dragend detected (< 100ms), keeping state for real drag");
            // This is Edge's immediate cancel - keep everything active
            // Clear the start time to allow the next attempt
            this.dropManager.dragStartTime = null;
            // Mark that we're expecting a second attempt
            this.dropManager.edgeDragPending = true;
            // Keep drag state and dropzones visible
            return;
          }
          
          // For Edge with pending drag, check if this is a real drag
          if (isEdge && this.dropManager.edgeDragPending) {
            debugLog('log', "Edge: Real drag completed after pending state");
            this.dropManager.edgeDragPending = false;
          }
          
          // For other short durations, might be a cancel
          if (dragDuration < 200) {
            debugLog('log', `Short drag duration (${dragDuration}ms), likely cancelled`);
          }

          debugLog('log', "Processing legitimate dragend event");
          this.dropManager.reset();
          this.dropManager.edgeDragAttempt = false;
        },
        
        // Universal browser workaround for drag and drop
        prepareForDrag(event, element) {
          if (!element) return;
          
          // Detect browser engine
          const userAgent = navigator.userAgent;
          const isEdge = /Edg/.test(userAgent);
          const isChrome = /Chrome/.test(userAgent) && !isEdge;
          const isFirefox = /Firefox/.test(userAgent);
          const isSafari = /Safari/.test(userAgent) && !isChrome && !isEdge;
          
          if (event.type === 'mouseover') {
            // Always ensure element is draggable on mouseover
            if (element.getAttribute('draggable') !== 'true') {
              element.setAttribute('draggable', 'true');
              debugLog('log', `DnD: Setting draggable=true on mouseover`);
            }
            
            // Browser-specific optimizations
            if (isEdge || isChrome) {
              // Chromium-based browsers need these styles
              element.style.webkitUserDrag = 'element';
              element.style.webkitUserSelect = 'none';
            }
            
            // Universal styles for better drag experience
            element.style.userSelect = 'none';
            element.style.cursor = 'grab';
          } else if (event.type === 'mousedown') {
            // For Edge, we need to ensure draggable is still true
            if (isEdge) {
              // Double-check draggable is set for Edge
              if (element.getAttribute('draggable') !== 'true') {
                element.setAttribute('draggable', 'true');
                debugLog('log', "Edge: Re-ensuring draggable=true on mousedown");
              }
              // Don't change cursor to grabbing for Edge as it might interfere
              debugLog('log', "Edge: Mousedown handled, maintaining grab cursor");
            } else {
              // For non-Edge browsers
              element.style.cursor = 'grabbing';
              debugLog('log', `DnD: Mousedown handled for non-Edge browser`);
            }
          }
        },

        handleDropToNewColumn(evt, targetColumnIndex) {
          debugLog('log', `handleDropToNewColumn called for target column index ${targetColumnIndex}`);

          // Prevent default and stop propagation
          evt.preventDefault();
          evt.stopPropagation();

          // Get the dragged group from dropManager
          const draggedGroup = this.dropManager.oldItem;
          const draggedState = this.dropManager.draggedState;

          debugLog('log', 'Dragged group:', draggedGroup);
          debugLog('log', 'Dragged state:', draggedState);

          if (!draggedGroup || draggedState !== 'group') {
            debugLog('warn', 'No valid group being dragged');
            this.dropManager.reset();
            return;
          }

          const oldColumn = draggedGroup.column;
          const oldIndex = draggedGroup.index;

          // Get all existing columns sorted
          const existingColumns = this.getGroupColumns();
          debugLog('log', 'Existing columns before move:', existingColumns);
          debugLog('log', `Moving group from column ${oldColumn} to dropzone at position ${targetColumnIndex}`);

          // Check if this is the same position (no move needed)
          if (targetColumnIndex !== -1) {
            // The dropzone after column X has targetColumnIndex = X + 1
            // So if we're dropping on the dropzone right after our current column, it's a no-op
            if (oldColumn === targetColumnIndex || oldColumn === targetColumnIndex - 1) {
              // Check if this group is alone in its column
              const groupsInOldColumn = this.data.groups.filter(g => g.column === oldColumn);
              if (groupsInOldColumn.length === 1) {
                debugLog('log', 'Group is alone in its column and dropping in adjacent position - no move needed');
                this.dropManager.reset();
                return;
              }
            }
          }

          let newColumnIndex;

          if (targetColumnIndex === -1) {
            // Drop before first column - all columns shift right
            newColumnIndex = 0;

            // Shift all groups to the right (except the dragged one)
            this.data.groups.forEach(g => {
              if (g.uuid !== draggedGroup.uuid) {
                g.column = (g.column || 0) + 1;
              }
            });
          } else {
            // targetColumnIndex is the position where we want to insert the new column
            // This is the column index AFTER which the dropzone is located

            // The new column should be created at this exact position
            newColumnIndex = targetColumnIndex;

            debugLog('log', `Creating new column at position ${newColumnIndex}`);

            // Shift all groups at or after the target position to the right
            // But not the dragged group itself
            this.data.groups.forEach(g => {
              if (g.uuid !== draggedGroup.uuid && g.column >= newColumnIndex) {
                g.column++;
                debugLog('log', `Shifted group "${g.name}" from column ${g.column - 1} to ${g.column}`);
              }
            });
          }

          // Update indices in the old column (remove the gap)
          const groupsInOldColumn = this.data.groups.filter(g =>
            g.column === oldColumn && g.uuid !== draggedGroup.uuid && g.index > oldIndex
          );
          groupsInOldColumn.forEach(g => {
            g.index--;
          });

          // Move the dragged group to the new column
          draggedGroup.column = newColumnIndex;
          draggedGroup.index = 0; // Place at top of new column

          debugLog('log', `Moved group "${draggedGroup.name}" from column ${oldColumn} to new column ${newColumnIndex}`);

          // Now normalize column indices to remove any gaps
          this.normalizeColumnIndices();

          // Save and reset
          this.saveData();
          this.dropManager.reset();
        },

        normalizeColumnIndices() {
          // Get all unique columns and sort them
          const columns = [...new Set(this.data.groups.map(g => g.column))].sort((a, b) => a - b);

          // Create a mapping from old column index to new normalized index
          const columnMapping = {};
          columns.forEach((col, index) => {
            columnMapping[col] = index;
          });

          // Apply the mapping to all groups
          this.data.groups.forEach(g => {
            const oldCol = g.column;
            const newCol = columnMapping[oldCol];
            if (oldCol !== newCol) {
              debugLog('log', `Normalized column for group "${g.name}": ${oldCol} -> ${newCol}`);
              g.column = newCol;
            }
          });

          debugLog('log', 'Column normalization complete. Final columns:', this.getGroupColumns());
        },

        // Combined handlers removed - using inline handlers instead
        // Edge has issues finding these methods, so we use inline expressions
        reindexArr(arr) { // Now a method of the Vue instance
          if (!arr || arr.length === 0) return;
          // Sort based on the temporary index, then re-assign sequential index
          let tmpArr = arr.sort((a, b) => a.index - b.index);
          tmpArr.forEach((item, index) => {
            item.index = index;
          });
        },

        // Make sure dropManager is initialized with the app instance
        initializeDropManager() {
          this.dropManager = new DropManager(this);
        },

        // --- Database & Data Management ---
        initDatabase() {
          linksDb = new Dexie('data');
          linksDb.version(1).stores({
            links: '++id',
          });
          this.loadData();
        },
        async loadData() {
          try {
            const dataArray = await linksDb.links.toArray();
            const isFresh = (dataArray.length === 0);
            if (dataArray.length > 0) {
              this.dataId = dataArray[0].id;
              const storedData = JSON.parse(dataArray[0].data);
              // Merge gespeicherte Daten auf die Standardstruktur
              this.data = Object.assign({}, JSON.parse(JSON.stringify(initialData)), storedData);
              debugLog('log', "Loaded data:", storedData);
            } else {
              // DB leer -> Initialisiere mit Defaults
              this.data = JSON.parse(JSON.stringify(initialData));
              this.dataId = -1;
              // Optional: Default-Gruppe erstellen, wenn gewünscht
              // const tmpGroup = this.getNewGroupTemplate(this.getTranslation('options.common'));
              // this.data.groups = [tmpGroup];
            }
            // Track if we need to save due to migrations
            let needsSaveForMigration = false;
            // Apply schema migrations and normalization before further processing
            try { if (this.applyMigrations && this.applyMigrations(this.data)) needsSaveForMigration = true; } catch (e) { debugLog('warn','[MIGRATION] applyMigrations failed', e); }

            // 1. Optionsstruktur sicherstellen
            this.fixOptions();
            // Ensure identity exists with a UUID (needed for event-log)
            if (!this.data.identity) {
              this.$set(this.data, 'identity', { 
                uuid: this.generateUUID(), // Always generate a UUID for event-log
                name: '', 
                pubKey: '', 
                privKey: '' 
              });
            } else if (!this.data.identity.uuid) {
              // If identity exists but has no UUID, generate one
              this.$set(this.data.identity, 'uuid', this.generateUUID());
            }

            // Ensure display name: on fresh settings or if not set
            try {
              const currentName = (this.data.options?.common?.identityName || this.data.identity?.name || '').trim();
              if (isFresh || !currentName) {
                const rand = Math.random().toString(36).slice(2, 8); // 6-stellig, [a-z0-9]
                const generated = `mybookmarks_${rand}`;
                if (!this.data.options) this.$set(this.data, 'options', {});
                if (!this.data.options.common) this.$set(this.data.options, 'common', {});
                this.$set(this.data.options.common, 'identityName', generated);
                if (!this.data.identity) this.$set(this, 'identity', {});
                this.$set(this.data.identity, 'name', generated);
                debugLog('log', '[INIT] Generated default identity name:', generated);
                // Persist immediately so subsequent logic sees the identity
                this.saveData();
              }
            } catch {}
            if (!Array.isArray(this.data.contacts)) this.$set(this.data, 'contacts', []);
            if (!Array.isArray(this.data.inbox)) this.$set(this.data, 'inbox', []);
            // Ensure auxiliary arrays exist
            if (!Array.isArray(this.data.savedSearches)) this.$set(this.data, 'savedSearches', []);
            if (!Array.isArray(this.data.snapshots)) this.$set(this.data, 'snapshots', []);

            // Ensure all groups have required IDs and clean up shared status
            (this.data.groups || []).forEach(g => {
              // Ensure every group has a groupId (needed for event-log)
              if (!g.groupId) {
                g.groupId = g.uuid || this.generateUUID();
                if (!g.uuid) {
                  g.uuid = g.groupId;
                }
                debugLog('log', '[INIT] Added groupId to group:', g.name, g.groupId);
              }

              if (g.favicon === undefined) this.$set(g, 'favicon', '');
              if (g.faviconError === undefined) this.$set(g, 'faviconError', false);
              if (g.faviconLoading === undefined) this.$set(g, 'faviconLoading', false);
              if (g.faviconSource === undefined) this.$set(g, 'faviconSource', null);
              if (g.faviconRuleId === undefined) this.$set(g, 'faviconRuleId', null);
              if (g.snapshot && typeof g.snapshot === 'object') {
                if (g.snapshot.favicon === undefined) this.$set(g.snapshot, 'favicon', g.favicon || '');
                if (g.snapshot.faviconSource === undefined) this.$set(g.snapshot, 'faviconSource', g.faviconSource || null);
                if (g.snapshot.faviconRuleId === undefined) this.$set(g.snapshot, 'faviconRuleId', g.faviconRuleId || null);
              }

              // Add progressive loading defaults for existing groups
              if (g.linksExpanded === undefined) {
                g.linksExpanded = false; // Start collapsed for performance
              }
              if (g.initialLinkCount === undefined) {
                // Use global setting or default to 100
                const threshold = this.data.options?.links?.progressiveLoadingThreshold || CONSTS.PROGRESSIVE_LOADING_THRESHOLD;
                g.initialLinkCount = threshold;
              }
              if (g.expandedLinkCount === undefined) {
                g.expandedLinkCount = CONSTS.EXPANDED_LINK_LIMIT; // Show 500 when expanded
              }
              
              // Clean up shared flag for groups without active members
              if (g.shared) {
                const noMembers = !g.members || g.members.length === 0;
                const onlyOwnerRemains = g.members && g.members.length === 1 && g.members[0].role === 'owner';
                const noRegularMembers = g.members && g.members.length > 0 && !g.members.some(x => x.role === 'member');
                if (noMembers || onlyOwnerRemains || noRegularMembers) {
                  debugLog('log', '[CLEANUP] Auto-unshare group without active members:', g.name);
                  g.shared = false;
                  try { if (g.groupTopic && window.sharing) window.sharing.ntfy.unsubscribe(g.groupTopic); } catch (e) { debugLog('warn','[CLEANUP] Unsubscribe failed', e); }
                }
              }
            });

            // 2. Option lesen *nach* dem Fixen
            const forceCollapseAll = this.data.options.groups.collapseGroupsOnStart;
            debugLog('log', "Option collapseGroupsOnStart:", forceCollapseAll);
            
            
            // 3. Gruppen verarbeiten und 'collapsed' Status korrekt setzen
            if (this.data.groups && Array.isArray(this.data.groups)) {
              this.data.groups.forEach(g => {

                // --- NEUE, KORRIGIERTE Logik ---
                if (forceCollapseAll) {
                  // Option ist TRUE -> Alle Gruppen einklappen, gespeicherten Zustand ignorieren
                  this.$set(g, 'collapsed', true);
                  debugLog('log', `Group "${g.name}" (ID: ${g.id}) forced collapsed=true due to option.`);
                } else {
                  // Option ist FALSE -> Gespeicherten Zustand verwenden oder auf ausgeklappt (false) setzen
                  if (g.collapsed === undefined || g.collapsed === null) {
                    // Wenn kein Zustand gespeichert, default ist AUSGEKLAPPT
                    this.$set(g, 'collapsed', false);
                    debugLog('log', `Group "${g.name}" (ID: ${g.id}) 'collapsed' state MISSING, defaulting to expanded (false).`);
                  } else {
                    // Gespeicherten Zustand (true oder false) verwenden
                    debugLog('log', `Group "${g.name}" (ID: ${g.id}) 'collapsed' state loaded from save: ${g.collapsed}`);
                    // Hier ist keine Aktion nötig, der Wert aus storedData wurde bereits übernommen
                    // Nur zur Sicherheit via $set setzen, falls Objekt nicht reaktiv war:
                    this.$set(g, 'collapsed', g.collapsed);
                  }
                }
                // --- Ende NEUE, KORRIGIERTE Logik ---

                // UUID-Migration für Gruppen: Add UUID to existing groups that don't have one
                if (!g.uuid) {
                  this.$set(g, 'uuid', this.generateUUID());
                  needsSaveForMigration = true;
                  debugLog('log', `[MIGRATION] Added UUID to group "${g.name}": ${g.uuid}`);
                }

                // Andere Eigenschaften setzen/prüfen (wie zuvor)
                if (g.column === undefined || g.column === null) this.$set(g, 'column', 0);
                this.$set(g, 'editing', false);
                this.$set(g, 'isMouseOver', false);
                this.$set(g, 'searchCollapsed', true); // Immer für Suche initial einklappen
                this.$set(g, 'newLinkText', '');
                this.$set(g, 'newLinkUrl', '');

                // Links verarbeiten und UUID-Migration
                if (!g.links || !Array.isArray(g.links)) {
                  this.$set(g, 'links', []);
                } else {
                  g.links.forEach(l => {
                    // UUID-Migration: Add UUID to existing links that don't have one
                    if (!l.uuid) {
                      this.$set(l, 'uuid', this.generateUUID());
                      needsSaveForMigration = true;
                      debugLog('log', `[MIGRATION] Added UUID to link "${l.text}" in group "${g.name}"`);
                    }
                    
                    if (l.column === undefined || l.column === null) this.$set(l, 'column', 0);
                    this.$set(l, 'editing', false);
                    this.$set(l, 'isMouseOver', false);
                  });
                  
                  // Links-Spalten innerhalb der Gruppe neu indizieren
                  this.getLinkColumns(g.links).forEach(col => this.reindexArr(g.links.filter(l => l.column === col)));
                }
              });

              // Gruppen-Spalten neu indizieren
              this.getGroupColumns().forEach(col => {
                this.reindexArr(this.data.groups.filter(g => g.column === col));
              });
            } else {
              this.$set(this.data, 'groups', []);
            }

            if (this.ensureAllTimestamps()) {
              needsSaveForMigration = true;
            }

            // Initialdaten speichern, wenn DB leer war oder Migration durchgeführt wurde
            if (this.dataId === -1 || needsSaveForMigration) {
              if (needsSaveForMigration) {
                debugLog('log', "[MIGRATION] Saving data after UUID migration - this is critical for sync!");
                // Force immediate save to ensure UUIDs are persisted before any sharing operations
                await this.saveDataImmediate();
              } else {
                debugLog('log', "Saving initial data structure.");
                this.saveData();
              }
            }

            // 4. UI-Einstellungen anwenden
            this.updateSettings();
            
            // Apply custom CSS if it exists
            if (this.data.options?.customCss) {
              this.applyCustomCss(this.data.options.customCss);
            }

            // Ensure identity now that data is loaded, then subscribe pairwise
            try {
              if (sharing) {
                sharing.applyConfig();
                await sharing.ensureIdentity();
                for (const c of (this.data.contacts || [])) {
                  try { await sharing.derivePairwiseFor(c.uuid); } catch {}
                }
                // subscribe shared groups
                for (const g of (this.data.groups || [])) {
                  try { 
                    if (g.shared && g.groupTopic && g.groupKey) {
                      debugLog('log', '[INIT] Subscribing to shared group from loadData:', g.name, g.groupId);
                      sharing.subscribeGroup(g, false); // false = send update request
                    }
                  } catch(e) {
                    debugLog('warn', '[INIT] Failed to subscribe group:', g.name, e);
                  }
                }
                // Ensure owner membership on non-shared groups
                try {
                  const myUuid = this.data.identity?.uuid || '';
                  const myName = this.data.identity?.name || '';
                  (this.data.groups||[]).forEach(g => {
                    if (!g.shared) {
                      if (!Array.isArray(g.members) || !g.members.length) {
                        this.$set(g, 'members', [ { uuid: myUuid, name: myName, role: 'owner' } ]);
                      } else if (!g.members.some(m => m.uuid === myUuid && m.role === 'owner')) {
                        g.members = g.members.filter(m => m.uuid !== myUuid);
                        g.members.unshift({ uuid: myUuid, name: myName, role: 'owner' });
                      }
                    }
                  });
                  this.saveData();
                } catch (error) {
                debugLog('error', '[Sharing] Error processing message headers:', error);
              }
                // Owner-initiated sync on open
                for (const g of (this.data.groups || [])) {
                  try { await sharing.sendOwnerSync(g); } catch {}
                }
              }
            } catch {}

            // 5. Vue rendern lassen (Template Binding kümmert sich um 'show' Klasse)
            this.$nextTick(() => {
              debugLog('log', "Vue data processed. Template binding should set initial collapse state based on final group.collapsed values.");
              // Stelle sicher, dass setInitialCollapseStates HIER NICHT aufgerufen wird, wenn du Template Binding nutzt.
              // Initialize saved searches and history baseline
              this.savedSearches = Array.isArray(this.data.savedSearches) ? [...this.data.savedSearches] : [];
              try { this.lastSavedJson = JSON.stringify(this.getSavableData()); } catch { }
            });

          } catch (e) {
            debugLog('error', "Error loading data:", e);
            // Fallback
            this.data = JSON.parse(JSON.stringify(initialData));
            this.fixOptions();
            this.dataId = -1;
            if (!Array.isArray(this.data.savedSearches)) this.$set(this.data, 'savedSearches', []);
            if (!Array.isArray(this.data.snapshots)) this.$set(this.data, 'snapshots', []);
            this.updateSettings();
            this.$nextTick(() => {
              debugLog('log', "Vue data processed after error/fallback.");
              // Stelle sicher, dass setInitialCollapseStates HIER NICHT aufgerufen wird.
              this.savedSearches = Array.isArray(this.data.savedSearches) ? [...this.data.savedSearches] : [];
              
              // Apply custom CSS if it exists
              if (this.data.options?.customCss) {
                this.applyCustomCss(this.data.options.customCss);
              }
              
              try { this.lastSavedJson = JSON.stringify(this.getSavableData()); } catch { }
            });
          }
        }, // Ende loadData
        getSavableData() {
          // Create a deep copy to avoid modifying the original data structure
          const dataToSave = JSON.parse(JSON.stringify({
            groups: this.data.groups,
            options: this.data.options,
            identity: this.data.identity,
            contacts: this.data.contacts,
            inbox: this.data.inbox,
            savedSearches: this.data.savedSearches || [],
            snapshots: this.data.snapshots || [],
            pendingNcDeletes: this.data.pendingNcDeletes || []
          }));

          // Remove transient UI properties
          dataToSave.groups.forEach(group => {
            delete group.editing;
            delete group.isMouseOver;
            delete group.newLinkText;
            delete group.newLinkUrl;
            delete group.searchCollapsed; // Don't save search-specific collapse state
            group.links.forEach(link => {
              delete link.editing;
              delete link.isMouseOver;
            });
          });

          return dataToSave;
        },
        // saveData defined later (debounced); keep single source of truth
        resetData() {
          if (!confirm(this.getTranslation('eraseDatabase') + ' ' + this.getTranslation('Are you sure?'))) return;
          Dexie.delete('data').then(() => {
            location.reload();
          }).catch(err => {
            debugLog('error', "Error deleting database:", err);
            alert("Could not delete the database. Please clear site data manually.");
          });
        },
        resetDataFromOptions() {
          // Show warning message first
          const warning = this.getTranslation('eraseDatabase.warning') || 'Warning! This will permanently delete ALL your bookmarks, groups, and settings. This action cannot be undone!';
          const confirmMsg = this.getTranslation('eraseDatabase.confirm') || 'Are you absolutely sure you want to delete everything?';
          
          if (!confirm(warning)) return;
          if (!confirm(confirmMsg)) return;
          
          // Close the modal first
          const modalElement = document.getElementById('optionsModal');
          if (modalElement) {
            const modalInstance = bootstrap.Modal.getInstance(modalElement);
            if (modalInstance) {
              modalInstance.hide();
            }
          }
          
          // Delete the database
          Dexie.delete('data').then(() => {
            location.reload();
          }).catch(err => {
            debugLog('error', "Error deleting database:", err);
            alert("Could not delete the database. Please clear site data manually.");
          });
        },
        // Reset all Nextcloud/Sync bindings on groups and links
        resetSyncBindingsFromOptions() {
          try {
            const msg = (this.getTranslation('sync.resetBindings.confirm') || 'This will remove all Nextcloud sync bindings (folder and bookmark IDs) from all groups and links. Your bookmarks stay, but re-sync will recreate mappings. Continue?');
            if (!confirm(msg)) return;
            let groupsCleared = 0, linksCleared = 0;
            for (const g of (this.data.groups||[])) {
              if (g.ncBookmarks) { try { this.$delete(g, 'ncBookmarks'); } catch { delete g.ncBookmarks; } groupsCleared++; }
              for (const l of (g.links||[])) {
                if (l && l.ncBookmarks) { try { this.$delete(l, 'ncBookmarks'); } catch { delete l.ncBookmarks; } linksCleared++; }
              }
            }
            // Clear cached folder hashes
            try {
              if (this.data.options && this.data.options.bookmarks) {
                this.$set(this.data.options.bookmarks, 'folderHashes', {});
              }
            } catch {}
            this.saveData();
            this.showToast((this.getTranslation('sync.resetBindings.done') || 'Sync bindings cleared') + ` (groups: ${groupsCleared}, links: ${linksCleared})`, 'success');
          } catch (e) {
            debugLog('error', '[SYNC] reset bindings failed', e);
            this.showToast((this.getTranslation('sync.resetBindings.failed') || 'Failed to clear sync bindings') + ': ' + (e?.message||String(e)), 'error');
          }
        },
        parseNetscapeHtml(html) {
          const doc = new DOMParser().parseFromString(html, 'text/html');
          const result = [];
          const walkDL = (dl, currentGroupName) => {
            const groupLinks = [];
            const groups = [];
            const nodes = Array.from(dl.children || []);
            for (let i = 0; i < nodes.length; i++) {
              const el = nodes[i];
              if (el.tagName === 'DT') {
                const a = el.querySelector('a');
                const h3 = el.querySelector('h3');
                if (a) {
                  groupLinks.push({
                    text: a.textContent || (a.getAttribute('href') || 'Link'),
                    url: a.getAttribute('href') || null,
                    keywords: '',
                  });
                } else if (h3) {
                  const name = h3.textContent || 'Folder';
                  // Next sibling DL contains its children
                  let next = el.nextElementSibling;
                  while (next && next.tagName !== 'DL') next = next.nextElementSibling;
                  if (next && next.tagName === 'DL') {
                    const sub = walkDL(next, name);
                    groups.push(...sub);
                    // skip handled DL in loop
                  } else {
                    groups.push({ name, links: [] });
                  }
                }
              }
            }
            if (currentGroupName) {
              groups.unshift({ name: currentGroupName, links: groupLinks });
            } else if (groupLinks.length) {
              groups.unshift({ name: 'Imported', links: groupLinks });
            }
            return groups;
          };
          const topDL = doc.querySelector('dl');
          const groups = topDL ? walkDL(topDL, null) : [];
          return groups.map(g => ({ name: g.name, links: g.links || [] }));
        },
        exportAndDownload() {
          // Prepare export selection data
          this.exportSelection = this.data.groups.map(group => ({
            name: group.name,
            selected: true,
            original: group,
            links: (group.links || []).filter(l => !l.deleted).map(link => ({
              text: link.text,
              url: link.url,
              keywords: Array.isArray(link.keywords) ? link.keywords.join(';') : (link.keywords || ''),
              selected: true,
              original: link
            }))
          }));
          
          // Open export dialog
          const modalElement = document.getElementById('exportModal');
          if (!modalElement) return;
          const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
          modalInstance && modalInstance.show();
        },
        
        onExportGroupChange(groupIndex) {
          const group = this.exportSelection[groupIndex];
          if (group.selected) {
            // Select all links in the group
            group.links.forEach(link => { link.selected = true; });
          }
        },
        
        onExportLinkChange(groupIndex) {
          const group = this.exportSelection[groupIndex];
          // Update group selection based on links
          const anySelected = group.links.some(l => l.selected);
          const allSelected = group.links.length > 0 && group.links.every(l => l.selected);
          group.selected = allSelected;
        },
        
        selectAllExportGroups() {
          this.exportSelection.forEach(group => {
            group.selected = true;
            group.links.forEach(link => { link.selected = true; });
          });
        },
        
        deselectAllExportGroups() {
          this.exportSelection.forEach(group => {
            group.selected = false;
            group.links.forEach(link => { link.selected = false; });
          });
        },
        
        hasExportSelection() {
          return this.exportSelection.some(g => g.links.some(l => l.selected));
        },
        
        getExportSelectionCount() {
          let count = 0;
          this.exportSelection.forEach(g => {
            count += g.links.filter(l => l.selected).length;
          });
          return count;
        },
        getFullJsonPreview() {
          try {
            return JSON.stringify(this.getSavableData(), null, 2);
          } catch { return '{}'; }
        },
        getSettingsJsonPreview() {
          try {
            return JSON.stringify({ options: this.data.options || {} }, null, 2);
          } catch { return '{}'; }
        },
        
        confirmExport() {
          const selectedGroups = [];
          if (this.exportFormat !== 'json') {
            this.exportSelection.forEach(group => {
              const selectedLinks = group.links.filter(l => l.selected);
              if (selectedLinks.length > 0) {
                selectedGroups.push({
                  ...group.original,
                  links: selectedLinks.map(l => l.original)
                });
              }
            });
            if (selectedGroups.length === 0) {
              alert('No links selected for export');
              return;
            }
          }
          
          let content = '';
          let filename = '';
          let mimeType = '';
          const dateStr = new Date().toISOString().slice(0, 10);
          
          switch (this.exportFormat) {
            case 'json':
              // JSON (Full) exports the complete application data
              content = JSON.stringify(this.getSavableData(), null, 2);
              filename = `bookmarks-export-${dateStr}.json`;
              mimeType = 'application/json;charset=utf-8';
              break;
              
            case 'json-array':
              // JSON Array of links only
              const allLinks = [];
              selectedGroups.forEach(g => {
                g.links.forEach(l => {
                  allLinks.push({
                    url: l.url,
                    text: l.text,
                    keywords: Array.isArray(l.keywords) ? l.keywords.join(';') : (l.keywords || '')
                  });
                });
              });
              content = JSON.stringify(allLinks, null, 2);
              filename = `bookmarks-links-${dateStr}.json`;
              mimeType = 'application/json;charset=utf-8';
              break;
              
            case 'csv':
              // CSV export
              let csv = 'Title,URL,Keywords\n';
              selectedGroups.forEach(g => {
                g.links.forEach(l => {
                  const title = (l.text || '').replace(/"/g, '""');
                  const url = (l.url || '').replace(/"/g, '""');
                  const keywords = (l.keywords || '').replace(/"/g, '""');
                  csv += `"${title}","${url}","${keywords}"\n`;
                });
              });
              content = csv;
              filename = `bookmarks-${dateStr}.csv`;
              mimeType = 'text/csv;charset=utf-8';
              break;
              
            case 'html':
              // HTML Bookmarks format
              let html = '<!DOCTYPE NETSCAPE-Bookmark-file-1>\n';
              html += '<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">\n';
              html += '<TITLE>Bookmarks</TITLE>\n';
              html += '<H1>Bookmarks</H1>\n';
              html += '<DL><p>\n';
              selectedGroups.forEach(g => {
                html += `    <DT><H3>${this.escapeHtml(g.name || 'Untitled')}</H3>\n`;
                html += '    <DL><p>\n';
                g.links.forEach(l => {
                  const tags = (l.keywords || '');
                  html += `        <DT><A HREF="${this.escapeHtml(l.url || '')}"`;
                  if (tags) html += ` TAGS="${this.escapeHtml(tags)}"`;
                  html += `>${this.escapeHtml(l.text || l.url || '')}</A>\n`;
                });
                html += '    </DL><p>\n';
              });
              html += '</DL><p>\n';
              content = html;
              filename = `bookmarks-${dateStr}.html`;
              mimeType = 'text/html;charset=utf-8';
              break;
          }
          
          // Download file
          try {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Close modal
            const modalElement = document.getElementById('exportModal');
            const modalInstance = modalElement ? bootstrap.Modal.getInstance(modalElement) : null;
            modalInstance && modalInstance.hide();
          } catch (error) {
            debugLog('error', "Export failed:", error);
            alert("Export failed. See console for details.");
          }
        },
        
        escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        },
        // Generate UUID for links to ensure unique identification across all members
        generateUUID() {
          try {
            // Prefer native crypto.randomUUID
            if (crypto && crypto.randomUUID) {
              return crypto.randomUUID();
            }
            // Fallback to crypto.getRandomValues with proper UUID v4 format
            if (crypto && crypto.getRandomValues) {
              const bytes = new Uint8Array(16);
              crypto.getRandomValues(bytes);
              // Set version (4) and variant bits according to UUID v4 spec
              bytes[6] = (bytes[6] & 0x0f) | 0x40; // Version 4
              bytes[8] = (bytes[8] & 0x3f) | 0x80; // Variant 10
              // Format as UUID string
              const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
              return `${hex.substr(0,8)}-${hex.substr(8,4)}-${hex.substr(12,4)}-${hex.substr(16,4)}-${hex.substr(20,12)}`;
            }
            // Fallback to URL.createObjectURL (still better than timestamp)
            return URL.createObjectURL(new Blob()).split('/').pop();
          } catch (error) {
            debugLog('error', '[UUID] Failed to generate secure UUID:', error);
            // Last resort with better entropy
            const timestamp = Date.now().toString(36);
            const random1 = Math.random().toString(36).substr(2, 9);
            const random2 = Math.random().toString(36).substr(2, 9);
            const random3 = performance.now().toString(36).substr(2, 5);
            return `${timestamp}-${random1}-${random2}-${random3}`;
          }
        },
        // --- Options & Settings ---
        fixOptions() { // Ensures options structure exists with defaults
          const defaultOptions = initialData.options;
          this.data.options = this.data.options || {};
          this.data.options.common = Object.assign({}, defaultOptions.common, this.data.options.common);
          this.data.options.groups = Object.assign({}, defaultOptions.groups, this.data.options.groups);
          this.data.options.links = Object.assign({}, defaultOptions.links || {}, this.data.options.links || {});
          if (typeof this.data.options.links.defaultUrlPrefix !== 'string') {
            this.$set(this.data.options.links, 'defaultUrlPrefix', CONSTS.DEFAULT_URL_PREFIX);
          } else {
            this.data.options.links.defaultUrlPrefix = this.data.options.links.defaultUrlPrefix.trim();
          }
          if (!Array.isArray(this.data.options.links.faviconRules)) {
            this.$set(this.data.options.links, 'faviconRules', getDefaultFaviconRules());
          }
          if (!this.data.options.linkShorteners || typeof this.data.options.linkShorteners !== 'object') {
            this.$set(this.data.options, 'linkShorteners', JSON.parse(JSON.stringify(defaultOptions.linkShorteners)));
          }
          const shortenerOptions = this.data.options.linkShorteners;
          if (!Array.isArray(shortenerOptions.enabledServices)) {
            this.$set(shortenerOptions, 'enabledServices', []);
          }
          if (!shortenerOptions.accounts || typeof shortenerOptions.accounts !== 'object') {
            this.$set(shortenerOptions, 'accounts', {});
          }
          if (!this.data.options.proxy || typeof this.data.options.proxy !== 'object') {
            this.$set(this.data.options, 'proxy', JSON.parse(JSON.stringify(defaultOptions.proxy)));
          }
          if (typeof this.data.options.proxy.enabled !== 'boolean') {
            this.$set(this.data.options.proxy, 'enabled', false);
          }
          if (typeof this.data.options.proxy.baseUrl !== 'string') {
            this.$set(this.data.options.proxy, 'baseUrl', '');
          }
          if (typeof this.data.options.proxy.apiKey !== 'string') {
            this.$set(this.data.options.proxy, 'apiKey', '');
          }
          if (typeof this.data.options.proxy.extraHeaders !== 'string') {
            this.$set(this.data.options.proxy, 'extraHeaders', '');
          }
          // Ensure Nextcloud Bookmarks block exists and preserves saved values (including rootFolderId)
          this.data.options.bookmarks = Object.assign({}, defaultOptions.bookmarks || { serverUrl:'', username:'', password:'', rootFolderId:0, syncIntervalSec:0, folderHashes:{} }, this.data.options.bookmarks || {});
          this.data.options.sharing = Object.assign({}, defaultOptions.sharing || {}, this.data.options.sharing || {});
          this.data.options.colors = Object.assign({}, defaultOptions.colors || {}, this.data.options.colors || {});
          
          // Event-Log defaults - use initialData defaults
          this.data.options.eventlog = Object.assign({}, defaultOptions.eventlog || {
            snapshotInterval: CONSTS.EVENT_LOG_SNAPSHOT_INTERVAL,
            maxEvents: CONSTS.EVENT_LOG_MAX_EVENTS * 2, // Double for main setting
            syncStrategy: 'owner-leads'
          }, this.data.options.eventlog || {});
          
          // Sync defaults - sensible defaults for good user experience
          this.data.options.sync = Object.assign({}, {
            // Good defaults for all users
            conflictNotificationLevel: 'minimal', // Show important conflicts only
            autoSyncInterval: '600', // 10 minutes - good balance
            offlineMode: 'optimistic', // Better UX for most users
            // Owner defaults
            conflictResolution: 'last-write-wins', // Fair default
            memberRateLimit: 30, // 30 changes per minute is reasonable
            validationLevel: 'moderate', // Balance between security and flexibility
            // Member defaults
            localCacheStrategy: 'full', // Keep everything for offline access
            errorHandling: 'retry' // Auto-retry is user-friendly
          }, this.data.options.sync || {});

          // Performance defaults
          this.data.options.performance = Object.assign({}, defaultOptions.performance || {
            virtualizeLinks: false,
            initialLimit: 200,
            pageSize: 200
          }, this.data.options.performance || {});
          // Custom CSS default
          if (typeof this.data.options.customCss !== 'string') this.$set(this.data.options, 'customCss', '');
        },
        // Migrations/Normalization to keep schema compatible
        applyMigrations(data) {
          let migrated = false;
          try {
            if (!data.schemaVersion) { data.schemaVersion = 1; migrated = true; }
            // Example migration scaffolding for future versions
            // if (data.schemaVersion < 2) { /* transform ... */ data.schemaVersion = 2; migrated = true; }
            // Ensure structural fields exist
            if (!Array.isArray(data.groups)) { data.groups = []; migrated = true; }
            if (!data.options) { data.options = JSON.parse(JSON.stringify(initialData.options)); migrated = true; }
            // Ensure performance block exists
            if (!data.options.performance) { data.options.performance = JSON.parse(JSON.stringify(initialData.options.performance)); migrated = true; }
          } catch (e) {
            debugLog('warn', '[MIGRATION] failed to normalize data', e);
          }
          return migrated;
        },
        updateSettings() { // Applies settings to the UI
          this.fixOptions(); // Ensure options are valid before using them
          this.title = this.data.options.common.pageTitle || initialData.options.common.pageTitle;
          document.title = this.title; // Update browser tab title
          
          // Custom colors are now handled via CSS variables

          // Initialize collapse state based on options ONLY if not already set
          this.data.groups.forEach(g => {
            if (g.collapsed === undefined) { // Check if the property exists
              this.$set(g, 'collapsed', this.data.options.groups.collapseGroupsOnStart);
            }
            // Always reset searchCollapsed state
            this.$set(g, 'searchCollapsed', true);
            // Ensure keywords property exists
            if (g.keywords === undefined) this.$set(g, 'keywords', '');
            // Ensure opacity property exists (use global default if available)
          });
          // Populate missing faviconUrl for existing links when option is enabled
          // Removed - no fallback favicon URL needed anymore
        },
        // Generic Edit Dialog Methods
        openGenericEditDialog(type, data, design, title, saveCallback) {
          console.log('openGenericEditDialog called with type:', type);
          debugLog('log', 'openGenericEditDialog called with type:', type);
          this.genericEditConfig = {
            title: title,
            type: type,
            design: design,
            saveCallback: saveCallback
          };
          
          // Deep clone the data for editing
          this.genericEditData = JSON.parse(JSON.stringify(data));
          this.genericFilterText = '';
          this.genericExpandedSections = {};
          
          debugLog('log', 'Looking for modal element: genericEditModal');
          console.log('Looking for modal element: genericEditModal');
          // Open the modal
          const modalElement = document.getElementById('genericEditModal');
          console.log('Modal element:', modalElement);
          if (modalElement) {
            debugLog('log', 'Modal element found, creating instance');
            console.log('Modal element found, creating Bootstrap instance');
            try {
              const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
              console.log('Modal instance:', modalInstance);
              modalInstance.show();
              
              // Ensure focus is set when modal is shown
              modalElement.addEventListener('shown.bs.modal', () => {
                // Prefer explicit autofocus fields, then URL inputs, else first focusable
                const auto = modalElement.querySelector('[data-autofocus="true"]');
                if (auto) { auto.focus(); return; }
                const urlInput = modalElement.querySelector('input[type="url"]');
                if (urlInput) { urlInput.focus(); return; }
                const firstFocusable = modalElement.querySelector('input:not([readonly]), button:not([disabled]), select, textarea');
                if (firstFocusable) { firstFocusable.focus(); }
              }, { once: true });
              
              debugLog('log', 'Modal show called');
              console.log('Modal show() called successfully');
            } catch (error) {
              console.error('Error creating/showing modal:', error);
              debugLog('error', 'Error creating/showing modal:', error);
            }
          } else {
            debugLog('error', 'Modal element genericEditModal not found!');
            console.error('Modal element genericEditModal not found in DOM!');
          }
        },
        
        getDisplayValueForCssField(sectionKey, fieldKey, field) {
          const value = this.getGenericFieldValue(sectionKey, fieldKey);
          if (!value) return '';
          
          try {
            const jsonData = JSON.parse(value);
            // Show a summary of all set properties
            const parts = [];
            if (jsonData.backgroundColor) parts.push(`bg: ${jsonData.backgroundColor}`);
            if (jsonData.color) parts.push(`text: ${jsonData.color}`);
            if (jsonData.border) parts.push(`border: ${jsonData.border}`);
            if (jsonData.fontSize) parts.push(`size: ${jsonData.fontSize}`);
            if (jsonData.fontWeight && jsonData.fontWeight !== 'normal') parts.push(`weight: ${jsonData.fontWeight}`);
            if (jsonData.fontStyle && jsonData.fontStyle !== 'normal') parts.push(jsonData.fontStyle);
            if (jsonData.textDecoration && jsonData.textDecoration !== 'none') parts.push(jsonData.textDecoration);
            if (jsonData.boxShadow) {
              // Shorten shadow description for display
              const shadow = jsonData.boxShadow;
              if (shadow.length > 20) {
                // For long shadows, show abbreviated version
                const shortShadow = shadow.substring(0, 20) + '...';
                parts.push(`shadow: ${shortShadow}`);
              } else {
                parts.push(`shadow: ${shadow}`);
              }
            }
            if (jsonData.opacity && jsonData.opacity < 100) parts.push(`opacity: ${jsonData.opacity}%`);
            if (jsonData.fontFamily) parts.push(`font: ${jsonData.fontFamily}`);
            if (jsonData.borderStyle && jsonData.borderStyle !== 'none') {
              parts.push(`border-style: ${jsonData.borderStyle}`);
            }
            if (jsonData.borderRadius && jsonData.borderRadius > 0) parts.push(`radius: ${jsonData.borderRadius}px`);
            if (jsonData.padding && jsonData.padding > 0) parts.push(`padding: ${jsonData.padding}px`);
            if (jsonData.margin && jsonData.margin > 0) parts.push(`margin: ${jsonData.margin}px`);
            
            // If nothing is set, show placeholder
            if (parts.length === 0) {
              return 'No custom styles';
            }
            
            // Return summary (truncate if too long)
            const summary = parts.join(', ');
            if (summary.length > 60) {
              return summary.substring(0, 57) + '...';
            }
            return summary;
          } catch (e) {
            // Not JSON - could be hex color or CSS string
            if (!value) return '';
            
            // Check if it's a simple hex color
            if (value.match(/^#[0-9A-Fa-f]{3,6}$/)) {
              return `color: ${value}`;
            }
            
            // Check if it's a CSS string with multiple properties
            if (value.includes(':') && value.includes(';')) {
              // Parse CSS string and show summary
              const props = value.split(';').filter(p => p.trim());
              const parts = [];
              props.forEach(prop => {
                const [key, val] = prop.split(':').map(s => s.trim());
                if (key && val) {
                  if (key.includes('background')) parts.push(`bg: ${val}`);
                  else if (key.includes('color')) parts.push(`text: ${val}`);
                  else if (key.includes('border')) parts.push(`border: ${val}`);
                  else if (key.includes('font-size')) parts.push(`size: ${val}`);
                  else if (key.includes('font-weight')) parts.push(`weight: ${val}`);
                  else if (key.includes('shadow')) parts.push('shadow');
                  else parts.push(`${key}: ${val}`);
                }
              });
              const summary = parts.join(', ');
              return summary.length > 60 ? summary.substring(0, 57) + '...' : summary;
            }
            
            // Return as is if we can't parse it
            return value.length > 60 ? value.substring(0, 57) + '...' : value;
          }
        },
        
        getGenericFieldValue(sectionKey, fieldKey) {
          if (this.genericEditConfig.type === 'options') {
            // For options, navigate the nested structure
            const pathParts = this.genericEditConfig.design[sectionKey].fields[fieldKey].optionPath?.split('.');
            if (pathParts) {
              let value = this.genericEditData;
              for (const part of pathParts) {
                value = value?.[part];
              }
              // Ensure select binding types match option keys
              const optPath = this.genericEditConfig.design[sectionKey].fields[fieldKey].optionPath || '';
              if (optPath === 'bookmarks.rootFolderId') return String(value ?? '0');
              return value;
            }
          }
          // For groups and links, direct access
          return this.genericEditData?.[fieldKey];
        },
        
        setGenericFieldValue(sectionKey, fieldKey, value) {
          if (this.genericEditConfig.type === 'options') {
            // For options, navigate the nested structure
            const pathParts = this.genericEditConfig.design[sectionKey].fields[fieldKey].optionPath?.split('.');
            if (pathParts) {
              let obj = this.genericEditData;
              for (let i = 0; i < pathParts.length - 1; i++) {
                if (!obj[pathParts[i]]) {
                  this.$set(obj, pathParts[i], {});
                }
                obj = obj[pathParts[i]];
              }
              // Cast value for specific options to preserve type
              const optPath = this.genericEditConfig.design[sectionKey].fields[fieldKey].optionPath || '';
              let finalValue = value;
              if (optPath === 'bookmarks.rootFolderId') finalValue = Number(value || 0);
              this.$set(obj, pathParts[pathParts.length - 1], finalValue);
            }

            // If NC-Bookmarks credentials/URL change during Options editing, refresh folder list
            if (sectionKey === 'bookmarks' && (fieldKey === 'serverUrl' || fieldKey === 'username' || fieldKey === 'password')) {
              clearTimeout(this._ncFolderRefreshTimer);
              this._ncFolderRefreshTimer = setTimeout(async () => {
                try {
                  const bk = (this.genericEditData && this.genericEditData.bookmarks) ? this.genericEditData.bookmarks : (this.data.options?.bookmarks || {});
                  const values = await this.fetchNcFolderValues((bk.serverUrl||'').trim(), bk.username||'', bk.password||'');
                  const current = String(bk.rootFolderId || '0');
                  if (!values[current]) values[current] = current === '0' ? 'All folders' : `Folder #${current}`;
                  this.$set(this.optionsDesign.bookmarks.fields.rootFolderId, 'values', values);
                } catch (e) {
                  debugLog('warn', '[NC] Refresh folder select failed', e);
                }
              }, 500);
            }
          } else {
            // For groups and links, direct access
            this.$set(this.genericEditData, fieldKey, value);

            // Auto-fetch title and favicon when URL is changed in link edit dialog
            if (this.genericEditConfig.type === 'link' && fieldKey === 'url' && value) {
              // Clear any existing timeout
              if (this.autoFetchTimeout) {
                clearTimeout(this.autoFetchTimeout);
              }

              // Set a new timeout to fetch after user stops typing
              this.autoFetchTimeout = setTimeout(() => {
                this.autoFetchLinkMetadata(value);
              }, 800); // Wait 800ms after user stops typing
            }
          }
        },

        async autoFetchLinkMetadata(url) {
          // Normalize URL
          url = MB.Utils.ensureProtocol(url);
          if (!MB.Utils.isValidHttpUrl(url)) {
            debugLog('log', 'Not a valid HTTP URL yet:', url);
            return;
          }

          // Additional validation: Check if domain looks complete
          try {
            const urlObj = new URL(url);
            const hostname = urlObj.hostname;

            // Check if hostname has at least a TLD (e.g., "example.com", not just "example")
            if (!hostname.includes('.') || hostname.endsWith('.')) {
              debugLog('log', 'Domain not complete yet:', hostname);
              return;
            }

            // Check for very short domains that are likely incomplete
            const parts = hostname.split('.');
            const tld = parts[parts.length - 1];
            if (tld.length < 2) {
              debugLog('log', 'TLD too short, likely incomplete:', tld);
              return;
            }

            // Don't fetch for localhost or IP addresses during typing
            if (hostname === 'localhost' || /^\d{1,3}(\.\d{1,3}){0,3}$/.test(hostname)) {
              debugLog('log', 'Skipping auto-fetch for localhost/IP:', hostname);
              return;
            }
          } catch (e) {
            debugLog('log', 'URL parsing failed, not ready:', e.message);
            return;
          }

          // Check if extension is available before trying to fetch
          if (!this.extensionAvailable || !window.MyBookmarksExtension) {
            debugLog('warn', 'Auto-fetch requested but extension not available');
            return;
          }

          debugLog('log', 'Auto-fetching metadata for URL:', url);

          // Set loading state for favicon
          this.$set(this.genericEditData, 'faviconLoading', true);

          // Auto-fetch title if enabled and text is empty or same as URL
          if (this.data.options?.links?.autoFetchTitle) {
            const currentText = this.genericEditData.text || '';
            // Also check if text is just "h" or similar single character (from premature fetch)
            if (!currentText || currentText === url || currentText === url.replace(/^https?:\/\//, '') || currentText.length === 1) {
              debugLog('log', 'Fetching title for URL:', url);
              try {
                const title = await this.tryFetchTitle(url);
                if (title && title !== url) {
                  debugLog('log', 'Auto-fetched title:', title);
                  this.$set(this.genericEditData, 'text', title);
                }
              } catch (e) {
                debugLog('warn', 'Title fetch failed:', e);
              }
            }
          }

          // Auto-fetch favicon if enabled
          if (this.data.options?.links?.autoFetchFavicon) {
            debugLog('log', 'Fetching favicon for URL:', url);
            try {
              await this.tryFetchAndSetFavicon(this.genericEditData, url);
            } catch (e) {
              debugLog('warn', 'Favicon fetch failed:', e);
            }
          }

          // Clear loading state
          this.$set(this.genericEditData, 'faviconLoading', false);
        },
        
        getFilteredGenericSettings() {
          if (!this.genericFilterText) {
            return this.genericEditConfig.design;
          }
          
          const filter = this.genericFilterText.toLowerCase();
          const filtered = {};
          
          for (const [sectionKey, section] of Object.entries(this.genericEditConfig.design)) {
            const sectionLabel = this.getTranslation(section.translateKey) || sectionKey;
            
            // Check if section matches
            if (sectionLabel.toLowerCase().includes(filter)) {
              filtered[sectionKey] = section;
              continue;
            }
            
            // Check if any field matches
            const matchingFields = {};
            for (const [fieldKey, field] of Object.entries(section.fields)) {
              const fieldLabel = this.getTranslation(field.translateKey) || fieldKey;
              const helpText = this.getTranslation(field.helpText) || '';
              
              let matches = fieldLabel.toLowerCase().includes(filter) || 
                  helpText.toLowerCase().includes(filter);

              if (!matches && field.type === 'linkShorteners') {
                matches = (this.linkShortenerServices || []).some(service => {
                  const name = (service.name || '').toLowerCase();
                  const summary = (this.getServiceText(service, 'summary') || '').toLowerCase();
                  const audience = (this.getServiceText(service, 'audience') || '').toLowerCase();
                  return name.includes(filter) || summary.includes(filter) || audience.includes(filter);
                });
              }

              if (matches) {
                matchingFields[fieldKey] = field;
              }
            }
            
            if (Object.keys(matchingFields).length > 0) {
              filtered[sectionKey] = {
                ...section,
                fields: matchingFields
              };
            }
          }
          
          return filtered;
        },
        
        isGenericSectionExpanded(sectionKey) {
          // Auto-expand if filtering
          if (this.genericFilterText) return true;
          return this.genericExpandedSections[sectionKey] !== false;
        },
        
        toggleGenericSection(sectionKey) {
          this.$set(this.genericExpandedSections, sectionKey, !this.isGenericSectionExpanded(sectionKey));
        },
        
        saveGenericEditDialog() {
          const type = this.genericEditConfig?.type;
          if (type === 'group') {
            const name = (this.genericEditData?.name || '').trim();
            if (!name) {
              this.showToast(this.getTranslation('group.name.required') || 'Group name is required', 'warning');
              return;
            }
            this.$set(this.genericEditData, 'name', name);
          } else if (type === 'link') {
            const text = (this.genericEditData?.text || '').trim();
            if (!text) {
              this.showToast(this.getTranslation('link.text.required') || 'Link text is required', 'warning');
              return;
            }
            this.$set(this.genericEditData, 'text', text);
          }

          if (this.genericEditConfig.saveCallback) {
            this.genericEditConfig.saveCallback(this.genericEditData);
          }
          
          // Close the modal
          const modalElement = document.getElementById('genericEditModal');
          if (modalElement) {
            const modalInstance = bootstrap.Modal.getInstance(modalElement);
            if (modalInstance) {
              modalInstance.hide();
            }
          }
        },
        
        handleGenericAction(sectionKey, fieldKey) {
          try {
            if (sectionKey === 'bookmarks' && fieldKey === 'resetBindings') {
              this.resetSyncBindingsFromOptions();
              return;
            } else if (sectionKey === 'bookmarks' && fieldKey === 'testConnection') {
              // Run generic connection test (uses selected backend adapter)
              this.testConnectionGeneric();
              return;
            } else if (sectionKey === 'links' && fieldKey === 'faviconRulesManage') {
              this.openFaviconRulesModal();
              return;
            }
            debugLog('warn', '[OPTIONS] Unknown action', { sectionKey, fieldKey });
          } catch (e) {
            debugLog('error', '[OPTIONS] handleGenericAction failed', { sectionKey, fieldKey, error: e });
          }
        },
        openFaviconRulesModal() {
          // Ensure structure exists
          if (!this.data.options) this.$set(this, 'data', { options: {} });
          if (!this.data.options.links) this.$set(this.data.options, 'links', {});
          if (!Array.isArray(this.data.options.links.faviconRules)) this.$set(this.data.options.links, 'faviconRules', []);
          this.faviconRulesWorking = JSON.parse(JSON.stringify(this.data.options.links.faviconRules));
          this.faviconRulesWorking.forEach((rule, idx) => {
            if (rule.comment === undefined) {
              this.$set(this.faviconRulesWorking[idx], 'comment', '');
            }
          });
          this.faviconRulesTestUrl = '';
          const modalEl = document.getElementById('faviconRulesModal');
          if (modalEl && !modalEl.dataset.refreshListenerAttached) {
            modalEl.addEventListener('hidden.bs.modal', () => {
              try {
                this.onFaviconRulesClosed();
              } catch (err) {
                debugLog('warn', '[FaviconRules] hidden handler failed', err);
              }
            });
            modalEl.dataset.refreshListenerAttached = '1';
          }
          const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
          modal && modal.show();
        },
        addFaviconRule() {
          const rule = {
            id: Date.now(),
            enabled: true,
            patternType: 'domain',
            pattern: '',
            iconDataUrl: '',
            comment: '',
            createdAt: Date.now()
          };
          this.faviconRulesWorking.push(rule);
        },
        restoreDefaultFaviconRules() {
          if (!Array.isArray(this.faviconRulesWorking)) {
            this.$set(this, 'faviconRulesWorking', []);
          }
          const defaults = getDefaultFaviconRules();
          const existingKeys = new Set(
            (this.faviconRulesWorking || []).map(rule => `${(rule.patternType || 'domain')}__${(rule.pattern || '').trim().toLowerCase()}`)
          );
          let added = 0;
          defaults.forEach((rule, idx) => {
            const key = `${rule.patternType || 'domain'}__${(rule.pattern || '').trim().toLowerCase()}`;
            if (!existingKeys.has(key)) {
              const newRule = Object.assign({}, rule, { createdAt: Date.now() + idx });
              this.faviconRulesWorking.push(newRule);
              existingKeys.add(key);
              added++;
            }
          });
          if (added) {
            this.showToast(this.getTranslation('favicon.rules.defaultsRestored') || 'Default favicon rules restored', 'success');
          } else {
            this.showToast(this.getTranslation('favicon.rules.defaultsAlreadyPresent') || 'All default favicon rules are already present', 'info');
          }
        },
        exportFaviconRules() {
          try {
            const data = JSON.stringify(this.faviconRulesWorking || [], null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = url;
            a.download = `favicon-rules-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          } catch (error) {
            debugLog('error', '[FaviconRules] export failed', error);
            this.showToast(this.getTranslation('favicon.rules.exportError') || 'Failed to export favicon rules', 'error');
          }
        },
        onImportFaviconRules(event) {
          const input = event?.target;
          const file = input?.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const text = typeof reader.result === 'string' ? reader.result : '';
              const parsed = JSON.parse(text);
              if (!Array.isArray(parsed)) {
                throw new Error('Invalid format');
              }

              if (!Array.isArray(this.faviconRulesWorking)) {
                this.$set(this, 'faviconRulesWorking', []);
              }

              const validTypes = ['domain', 'prefix', 'regex'];
              const existingKeys = new Set(
                (this.faviconRulesWorking || []).map(rule => `${(rule.patternType || 'domain')}__${(rule.pattern || '').trim().toLowerCase()}`)
              );
              let added = 0;
              parsed.forEach((rule, idx) => {
                if (!rule || typeof rule !== 'object') return;
                const pattern = (rule.pattern || '').toString().trim();
                if (!pattern) return;
                const typeRaw = (rule.patternType || 'domain').toString().toLowerCase();
                const patternType = validTypes.includes(typeRaw) ? typeRaw : 'domain';
                const key = `${patternType}__${pattern.toLowerCase()}`;
                if (existingKeys.has(key)) return;

                const normalized = {
                  id: rule.id || (Date.now() + idx + Math.floor(Math.random() * 1000)),
                  enabled: rule.enabled !== false,
                  patternType,
                  pattern,
                  iconDataUrl: typeof rule.iconDataUrl === 'string' ? rule.iconDataUrl : '',
                  comment: typeof rule.comment === 'string' ? rule.comment : '',
                  createdAt: Number(rule.createdAt) || Date.now() + idx
                };

                this.faviconRulesWorking.push(normalized);
                existingKeys.add(key);
                added++;
              });

              if (added) {
                const messageTemplate = this.getTranslation('favicon.rules.importSuccess') || 'Imported {count} favicon rules';
                this.showToast(messageTemplate.replace('{count}', added), 'success');
              } else {
                this.showToast(this.getTranslation('favicon.rules.importNothing') || 'No new favicon rules to import', 'info');
              }
            } catch (error) {
              debugLog('error', '[FaviconRules] import failed', error);
              this.showToast(this.getTranslation('favicon.rules.importError') || 'Failed to import favicon rules', 'error');
            } finally {
              try { input.value = ''; } catch {}
            }
          };
          reader.onerror = () => {
            debugLog('error', '[FaviconRules] import read error');
            this.showToast(this.getTranslation('favicon.rules.importError') || 'Failed to import favicon rules', 'error');
            try { input.value = ''; } catch {}
          };
          reader.readAsText(file);
        },
        openFaviconRuleFile(idx) {
          // When using ref inside v-for, Vue returns an array of elements
          const r = this.$refs && this.$refs.frFile;
          if (Array.isArray(r)) {
            const el = r[idx];
            if (el && typeof el.click === 'function') el.click();
          } else if (r && typeof r.click === 'function') {
            r.click();
          }
        },
        deleteFaviconRule(idx) {
          this.faviconRulesWorking.splice(idx, 1);
        },
        async autoFetchRuleIcon(rule) {
          try {
            if (!rule || !rule.pattern) return;
            let sampleUrl = '';
            const raw = (rule.pattern || '').trim();
            if (rule.patternType === 'domain') {
              // Strip any protocol, slashes and wildcard prefixes, keep only hostname
              let host = raw.replace(/^https?:\/\//i, '').replace(/^\/{2}/, '');
              host = host.replace(/^\*\.?/, '');
              host = host.replace(/\/.*$/, '');
              if (!host) return;
              sampleUrl = `https://${host}`;
            } else if (rule.patternType === 'prefix') {
              sampleUrl = MB.Utils.ensureProtocol(raw);
            } else {
              // regex: use test URL if provided, else fallback
              sampleUrl = this.faviconRulesTestUrl ? MB.Utils.ensureProtocol(this.faviconRulesTestUrl) : 'https://example.com';
            }
            if (!this.extensionAvailable || !window.MyBookmarksExtension) {
              this.showToast(this.getTranslation('favicon.rules.needsExtension') || 'Extension required to auto-fetch icons', 'warning');
              return;
            }
            const md = await window.MyBookmarksExtension.fetchMetadata(sampleUrl, {});
            if (md && md.favicon) {
              rule.iconDataUrl = md.favicon;
              this.showToast(this.getTranslation('link.favicon.uploaded') || 'Favicon uploaded', 'success');
            } else {
              this.showToast('No favicon found', 'warning');
            }
          } catch (e) {
            this.showToast(e?.message || 'Auto-fetch failed', 'error');
          }
        },
        onFaviconRuleFileSelected(idx, event) {
          const file = event?.target?.files?.[0];
          if (!file) return;
          if (!file.type || !file.type.startsWith('image/')) { this.showToast(this.getTranslation('link.favicon.invalidFile') || 'Please select an image file', 'warning'); event.target.value=''; return; }
          const reader = new FileReader();
          reader.onload = () => {
            const dataUrl = reader.result;
            if (typeof dataUrl === 'string') {
              this.$set(this.faviconRulesWorking[idx], 'iconDataUrl', dataUrl);
              this.showToast(this.getTranslation('link.favicon.uploaded') || 'Favicon uploaded', 'success');
            }
            try { event.target.value=''; } catch{}
          };
          reader.onerror = () => { this.showToast(this.getTranslation('link.favicon.readError') || 'Could not read image file', 'error'); };
          reader.readAsDataURL(file);
        },
        faviconSourceClass(link) {
          const s = (link && link.faviconSource) || '';
          if (s === 'rule') return 'src-rule';
          if (s === 'upload') return 'src-upload';
          if (s === 'extension') return 'src-extension';
          return '';
        },
        faviconSourceTooltip(link) {
          try {
            if (!link || !link.favicon) return '';
            const s = link.faviconSource || '';
            if (s === 'upload') return 'Favicon (upload)';
            if (s === 'extension') return 'Favicon (extension)';
            if (s === 'rule') {
              const rules = this.data.options?.links?.faviconRules || [];
              const r = rules.find(x => x.id === link.faviconRuleId);
              if (r) return `Favicon (rule: ${r.patternType} ${r.pattern})`;
              return 'Favicon (rule)';
            }
            return '';
          } catch { return ''; }
        },
        saveFaviconRules() {
          if (!this.data.options) this.$set(this, 'data', { options: {} });
          if (!this.data.options.links) this.$set(this.data.options, 'links', {});
          this.$set(this.data.options.links, 'faviconRules', JSON.parse(JSON.stringify(this.faviconRulesWorking)));
          this.saveData();
          this.showToast(this.getTranslation('favicon.rules.saved') || 'Favicon rules saved', 'success');
          this.refreshVisibleFavicons();
          // Close the modal after saving
          try {
            const modalEl = document.getElementById('faviconRulesModal');
            const modal = modalEl ? bootstrap.Modal.getInstance(modalEl) : null;
            if (modal) modal.hide();
          } catch {}
        },
        findRuleForUrl(url, rulesOverride = null, rawInput = null) {
          try {
            if (!url && !rawInput) return null;
            const sourceRules = Array.isArray(rulesOverride) ? rulesOverride : (this.data.options?.links?.faviconRules || []);
            const rules = sourceRules.filter(r => r && r.enabled && r.iconDataUrl);
            if (!rules.length) return null;

            const normalizedSource = (url || '').trim();
            const normalizedCandidate = MB.Utils.ensureProtocol(normalizedSource);
            const normalizedLower = normalizedCandidate ? normalizedCandidate.toLowerCase() : '';

            const rawFallbackValue = rawInput != null ? rawInput : null;
            const rawFallback = rawFallbackValue != null ? String(rawFallbackValue) : normalizedSource;
            const rawTrimmed = (rawFallback || '').trim();
            const rawLower = rawTrimmed.toLowerCase();

            const candidateStrings = [];
            const addCandidate = (val) => {
              if (!val || typeof val !== 'string') return;
              const v = val.trim();
              if (!v) return;
              if (!candidateStrings.includes(v)) candidateStrings.push(v);
            };

            addCandidate(normalizedLower);
            addCandidate(normalizedSource.toLowerCase());
            addCandidate(rawLower);
            if (rawLower.includes('\\')) addCandidate(rawLower.replace(/\\+/g, '/'));
            if (normalizedLower.includes('\\')) addCandidate(normalizedLower.replace(/\\+/g, '/'));

            const configuredPrefix = (this.data?.options?.links?.defaultUrlPrefix ?? CONSTS.DEFAULT_URL_PREFIX) || '';
            const prefixStripList = Array.from(new Set([
              typeof configuredPrefix === 'string' ? configuredPrefix.trim().toLowerCase() : '',
              'http://',
              'https://'
            ].filter(Boolean)));
            const existingCandidates = candidateStrings.slice();
            prefixStripList.forEach(pref => {
              existingCandidates.forEach(candidate => {
                if (candidate.startsWith(pref)) {
                  addCandidate(candidate.slice(pref.length));
                }
              });
            });
            candidateStrings.slice().forEach(candidate => {
              if (candidate.startsWith('//')) addCandidate(candidate.slice(2));
            });

            let host = '';
            let parsedUrl = null;
            if (normalizedLower) {
              try {
                parsedUrl = new URL(normalizedLower);
                host = parsedUrl.hostname.toLowerCase();
              } catch {
                parsedUrl = null;
                host = '';
              }
            }
            let best = null; let bestLen = -1;
            for (const r of rules) {
              let patRaw = (r.pattern || '').toString().trim().toLowerCase();
              if (!patRaw) continue;
              if (r.patternType === 'domain') {
                // Normalize: strip scheme, //, wildcard, and path
                let pat = patRaw
                  .replace(/^https?:\/\//, '')
                  .replace(/^\/\//, '')
                  .replace(/^\*\.?/, '')
                  .replace(/\/.*$/, '')
                  .replace(/\.+$/, '');
                if (!pat) continue;
                if (host && (host === pat || host.endsWith('.' + pat))) {
                  const len = pat.length; if (len > bestLen) { best = r; bestLen = len; }
                }
              } else if (r.patternType === 'prefix') {
                const trimSlash = (s) => s.replace(/\/+$/, '');
                const patternVariants = [];
                const addPatternVariant = (val) => {
                  if (!val) return;
                  const v = trimSlash(val.toLowerCase());
                  if (!v) return;
                  if (!patternVariants.includes(v)) patternVariants.push(v);
                };
                addPatternVariant(patRaw);
                addPatternVariant(patRaw.replace(/^[a-z]+:\/\//, ''));
                addPatternVariant(MB.Utils.ensureProtocol(patRaw).toLowerCase());
                const matchedVariant = patternVariants.reduce((bestLocalLen, patt) => {
                  const len = patt.length;
                  if (!len) return bestLocalLen;
                  const found = candidateStrings.some(candidate => {
                    const target = trimSlash(candidate);
                    return target.startsWith(patt);
                  });
                  return found ? Math.max(bestLocalLen, len) : bestLocalLen;
                }, -1);
                if (matchedVariant > bestLen) { best = r; bestLen = matchedVariant; }
              } else if (r.patternType === 'regex') {
                try {
                  // Be forgiving: unescape \/ to / and anchor to start if not provided
                  let rxSrc = patRaw.replace(/\\\//g, '/');
                  if (!/^\^/.test(rxSrc)) rxSrc = '^' + rxSrc;
                  const re = new RegExp(rxSrc, 'i');
                  const matched = candidateStrings.some(candidate => {
                    try { return re.test(candidate); } finally { re.lastIndex = 0; }
                  });
                  if (matched) {
                    const len = rxSrc.length;
                    if (len > bestLen) { best = r; bestLen = len; }
                  }
                } catch {}
              }
            }
            return best;
          } catch { return null; }
        },
        findRuleIconForUrl(url, rulesOverride = null, rawInput = null) {
          const r = this.findRuleForUrl(url, rulesOverride, rawInput);
          return r ? r.iconDataUrl : null;
        },

        getEnabledFaviconRules() {
          const rules = this.data?.options?.links?.faviconRules;
          if (!Array.isArray(rules)) return [];
          return rules.filter(r => r && r.enabled && r.iconDataUrl);
        },

        applyFaviconRulesToLink(link, rulesOverride = null, rawInput = null) {
          try {
            if (!link || !link.url) return false;
            const enabledRules = Array.isArray(rulesOverride) ? rulesOverride : this.getEnabledFaviconRules();
            if (!enabledRules.length) {
              if (link.faviconSource === 'rule' && (link.favicon || link.faviconRuleId)) {
                this.$set(link, 'favicon', null);
                this.$set(link, 'faviconError', false);
                this.$set(link, 'faviconSource', null);
                this.$set(link, 'faviconRuleId', null);
                return true;
              }
              return false;
            }

            const incomingRaw = rawInput != null ? rawInput : (link.rawUrlInput ?? null);
            const normalizedRaw = incomingRaw != null ? String(incomingRaw).trim() : null;
            const rule = this.findRuleForUrl(link.url, enabledRules, normalizedRaw);
            if (rule && rule.iconDataUrl) {
              const ruleIcon = rule.iconDataUrl;
              const ruleId = rule.id ?? null;
              if (link.favicon !== ruleIcon || link.faviconSource !== 'rule' || link.faviconRuleId !== ruleId) {
                this.$set(link, 'favicon', ruleIcon);
                this.$set(link, 'faviconError', false);
                this.$set(link, 'faviconSource', 'rule');
                this.$set(link, 'faviconRuleId', ruleId);
                if (normalizedRaw !== null && link.rawUrlInput !== normalizedRaw) {
                  this.$set(link, 'rawUrlInput', normalizedRaw || '');
                }
                return true;
              }
              return false;
            }

            if (link.faviconSource === 'rule' && (link.favicon || link.faviconRuleId)) {
              this.$set(link, 'favicon', null);
              this.$set(link, 'faviconError', false);
              this.$set(link, 'faviconSource', null);
              this.$set(link, 'faviconRuleId', null);
              if (normalizedRaw !== null && link.rawUrlInput !== normalizedRaw) {
                this.$set(link, 'rawUrlInput', normalizedRaw || '');
              }
              return true;
            }
            return false;
          } catch (err) {
            debugLog('warn', '[FaviconRules] applyFaviconRulesToLink failed', err);
            return false;
          }
        },

        onFaviconRulesClosed() {
          this.refreshVisibleFavicons();
        },

        refreshVisibleFavicons() {
          try {
            const groups = Array.isArray(this.data?.groups) ? this.data.groups : [];
            if (!groups.length) return;

            const enabledRules = this.getEnabledFaviconRules();

            let changed = false;

            groups.forEach(group => {
              if (!group || group.collapsed || group.deleted) return;
              const links = Array.isArray(group.links) ? group.links : [];
              links.forEach(link => {
                if (!link || link.deleted || !link.url) return;
                if (this.applyFaviconRulesToLink(link, enabledRules)) changed = true;
              });
            });

            if (changed) {
              this.saveData();
            }
          } catch (err) {
            debugLog('warn', '[FaviconRules] refreshVisibleFavicons failed', err);
          }
        },

      showOptionsDialog() {
        debugLog('log', 'showOptionsDialog called');
        // Ensure options structure is complete before editing
        this.fixOptions();
        // Remember current identity name to detect changes on save
        this.prevIdentityName = this.data.identity?.name || '';
          
          console.log('this.optionsDesign:', this.optionsDesign);
          console.log('this.data.options:', this.data.options);
          debugLog('log', 'Opening generic dialog with:', {
            type: 'options',
            design: this.optionsDesign,
            title: this.getTranslation('options')
          });
          
        // Prepare dynamic NC folder select values before opening
        try { this.prepareNcFolderSelectInOptions(); } catch {}

        // Use the generic dialog
        this.openGenericEditDialog(
          'options',
          this.data.options,
          this.optionsDesign,
          this.getTranslation('options'),
            (editedData) => {
              // Apply the edited options
              Object.assign(this.data.options, editedData);
              // Normalize and ensure identity name
              try {
                let newIdentityName = this.data.options?.common?.identityName || '';
                // Trim and auto-generate if empty on save
                newIdentityName = (typeof newIdentityName === 'string') ? newIdentityName.trim() : '';
                if (!newIdentityName) {
                  const rand = Math.random().toString(36).slice(2, 8); // 6 chars
                  newIdentityName = `mybookmarks_${rand}`;
                  if (!this.data.options) this.$set(this, 'options', {});
                  if (!this.data.options.common) this.$set(this.data.options, 'common', {});
                  this.$set(this.data.options.common, 'identityName', newIdentityName);
                  debugLog('log', '[OPTIONS] Auto-generated identityName on empty save:', newIdentityName);
                }
                if (!this.data.identity) this.$set(this, 'identity', {});
                this.$set(this.data.identity, 'name', newIdentityName);
              } catch {}
              this.saveData();
              this.applyCustomColors();
              
              // Update page title if changed
              if (this.data.options.common.pageTitle !== this.title) {
                this.title = this.data.options.common.pageTitle;
                document.title = this.title;
              }
              
              // Refresh groups if identity name changed
              if (this.prevIdentityName !== this.data.identity?.name) {
                this.data.groups.forEach(group => {
                  if (group.members) {
                    group.members.forEach(member => {
                      if (member.uuid === this.data.identity?.uuid) {
                        member.name = this.data.identity?.name || '';
                      }
                    });
                  }
                });
              }
            }
          );
        },
        
        // Populate NC-Bookmarks folder select in Options dialog
        async prepareNcFolderSelectInOptions() {
          try {
            const bk = this.data.options?.bookmarks || {};
            const serverUrl = (bk.serverUrl || '').trim();
            const username = bk.username || '';
            const password = bk.password || '';
            const values = await this.fetchNcFolderValues(serverUrl, username, password);
            // Ensure current selection exists
            const current = String(bk.rootFolderId || '0');
            if (!values[current]) values[current] = current === '0' ? 'All folders' : `Folder #${current}`;
            this.$set(this.optionsDesign.bookmarks.fields.rootFolderId, 'values', values);
          } catch (e) {
            debugLog('warn', '[NC] Could not populate folder select:', e);
            // Fallback to only "All folders"
            this.$set(this.optionsDesign.bookmarks.fields.rootFolderId, 'values', { '0': 'All folders' });
          }
        },
        async fetchNcFolderValues(serverUrl, username, password) {
          const map = { '0': 'All folders' };
          if (!serverUrl) return map;
          try {
            await MB.Extension.setDavAuth(serverUrl, username||'', password||'');
            const url = MB.CardDAV.joinUrl(serverUrl, '/index.php/apps/bookmarks/public/rest/v2/folder');
            const auth = MB.CardDAV.buildBasicAuthHeader(username||'', password||'');
            const res = await MB.Extension.davRequest({ method:'GET', url, headers:{ 'Accept':'application/json', 'OCS-APIREQUEST':'true', 'X-Requested-With':'XMLHttpRequest', 'Authorization':auth }, username, password });
            if (!res.ok) return map;
            let parsed=null; try { parsed = JSON.parse(res.bodyText||'[]'); } catch {}
            const list = Array.isArray(parsed) ? parsed : (parsed && Array.isArray(parsed.data) ? parsed.data : []);
            for (const f of list) {
              if (!f || f.id === undefined) continue;
              const id = String(f.id);
              map[id] = f.title ? `${f.title} (#${f.id})` : `Folder #${f.id}`;
            }
          } catch (e) {
            debugLog('warn', '[NC] fetchNcFolderValues failed', e);
          }
          return map;
        },
        
        // --- Generic Options Dialog Methods ---
        getFilteredSettings() {
          // Backend-aware section filtering
          const backend = this.data.options?.sync?.backend || (this.data.options?.carddav?.enabled ? 'carddav' : null);
          const design = {};
          Object.entries(this.optionsDesign).forEach(([key, section]) => {
            // Hide provider-specific sections that don't match backend
            if (key === 'carddav' && backend && backend !== 'carddav') return;
            if (key === 'bookmarks' && backend && backend !== 'nc-bookmarks') return;
            design[key] = section;
          });
          if (!this.settingsFilterText) return design;
          
          const filter = this.settingsFilterText.toLowerCase();
          const filtered = {};
          
          for (const [sectionKey, section] of Object.entries(design)) {
            // Skip if not an object with fields
            if (!section.fields) continue;
            
            const filteredFields = {};
            let sectionMatches = false;
            
            // Check section title
            const sectionTitle = this.getTranslation(section.translateKey) || sectionKey;
            if (sectionTitle.toLowerCase().includes(filter)) {
              sectionMatches = true;
            }
            
            // Check fields
            for (const [fieldKey, field] of Object.entries(section.fields)) {
              const fieldLabel = this.getTranslation(field.translateKey) || fieldKey;
              const fieldHelp = this.getTranslation(field.helpText) || '';
              let matches = fieldLabel.toLowerCase().includes(filter) || fieldHelp.toLowerCase().includes(filter);

              if (!matches && field.type === 'linkShorteners') {
                matches = (this.linkShortenerServices || []).some(service => {
                  const name = (service.name || '').toLowerCase();
                  const summary = (this.getServiceText(service, 'summary') || '').toLowerCase();
                  const audience = (this.getServiceText(service, 'audience') || '').toLowerCase();
                  return name.includes(filter) || summary.includes(filter) || audience.includes(filter);
                });
              }

              if (matches) {
                filteredFields[fieldKey] = field;
                sectionMatches = true;
              }
            }
            
            if (sectionMatches) {
              filtered[sectionKey] = {
                ...section,
                fields: Object.keys(filteredFields).length > 0 ? filteredFields : section.fields
              };
            }
          }
          
          return filtered;
        },
        
        isSectionExpanded(sectionKey) {
          // Auto-expand if filter is active and section has matches
          if (this.settingsFilterText && this.getFilteredSettings()[sectionKey]) {
            return true;
          }
          // Otherwise use stored state (default to false)
          return this.expandedSections[sectionKey] || false;
        },
        
        toggleSection(sectionKey) {
          this.$set(this.expandedSections, sectionKey, !this.expandedSections[sectionKey]);
        },
        
        getFieldComponent(type) {
          // Map field types to component names
          const componentMap = {
            'text': 'text-field',
            'number': 'number-field',
            'checkbox': 'checkbox-field',
            'select': 'select-field',
            'color': 'color-field'
          };
          return componentMap[type] || 'text-field';
        },
        
        
        // --- Group Edit Dialog Methods ---
        isGroupSectionExpanded(sectionKey) {
          // Auto-expand all sections by default
          if (this.expandedGroupSections[sectionKey] === undefined) {
            this.$set(this.expandedGroupSections, sectionKey, true);
          }
          return this.expandedGroupSections[sectionKey];
        },
        toggleGroupSection(sectionKey) {
          this.$set(this.expandedGroupSections, sectionKey, !this.expandedGroupSections[sectionKey]);
        },
        
        // --- Link Edit Dialog Methods ---
        isLinkSectionExpanded(sectionKey) {
          // Auto-expand all sections by default
          if (this.expandedLinkSections[sectionKey] === undefined) {
            this.$set(this.expandedLinkSections, sectionKey, true);
          }
          return this.expandedLinkSections[sectionKey];
        },
        toggleLinkSection(sectionKey) {
          this.$set(this.expandedLinkSections, sectionKey, !this.expandedLinkSections[sectionKey]);
        },
        
        // --- Translation ---
        getTranslation(key, values) {
          const lang = this.data.options?.common?.language || MB.I18n?.defaultLocale || 'en';
          let text = MB.I18n?.get(lang, key) || '';
          if (!text) text = key;
          if (values && Array.isArray(values)) {
            values.forEach(val => {
              text = text.replace('%s', (val !== undefined && val !== null) ? val : '');
            });
          }
          return text;
        },
        // --- Groups ---
        getNewGroupTemplate(name) {
          const groupUuid = this.generateUUID();
          const nowTs = Date.now();
          const newGroup = {
            uuid: groupUuid, // Every group gets a permanent UUID from creation
            groupId: groupUuid, // Use the same UUID as groupId for all groups (needed for event-log)
            name: name,
            emoji: '',
            keywords: '',
            favicon: '',
            faviconError: false,
            faviconLoading: false,
            faviconSource: null,
            faviconRuleId: null,
            links: [],
            index: this.data.groups.length > 0 ? Math.max(...this.data.groups.map(g => g.index)) + 1 : 0,
            column: 0,
            createdAt: nowTs,
            lastModified: nowTs,
            // Transient UI state defaults
            collapsed: this.data.options.groups.collapseGroupsOnStart, // Use option default
            searchCollapsed: true,
            editing: false,
            isMouseOver: false,
            newLinkText: '', // Moved from main data
            newLinkUrl: '',    // Moved from main data
            // Progressive loading state
            linksExpanded: false, // Start with limited links for performance
            // If true, disable colored background and use neutral styling
            shared: false,
            members: [ { uuid: this.data.identity?.uuid || '', name: this.data.identity?.name || '', role: 'owner' } ],
            // Enable event-log by default for all new groups
            useEventLog: true,
            eventLog: [],
            snapshot: null,
            headEventId: null,
            vectorClock: {}
          };
          
          // Create initial snapshot event for the new group
          // Ensure we have an identity UUID for event-log
          if (!this.data.identity?.uuid) {
            if (!this.data.identity) {
              this.$set(this.data, 'identity', { 
                uuid: this.generateUUID(),
                name: '', 
                pubKey: '', 
                privKey: '' 
              });
            } else {
              this.$set(this.data.identity, 'uuid', this.generateUUID());
            }
          }
          
          const author = this.data.identity.uuid;
          const migrationEvent = {
            eventId: 'creation-' + groupUuid,
            parentId: null,
            timestamp: nowTs,
            author: author,
            type: 'snapshot',
            data: {
              groupId: groupUuid,
              name: name,
              emoji: '',
              favicon: '',
              links: [],
              keywords: '',
              members: newGroup.members
            }
          };
          
          newGroup.eventLog = [migrationEvent];
          newGroup.snapshot = migrationEvent.data;
          newGroup.headEventId = migrationEvent.eventId;
          newGroup.vectorClock = { [author]: 1 };
          
          return newGroup;
        },
        addGroup() {
          const newGroup = this.getNewGroupTemplate('New Group'); // Default name
          // apply default colors from settings
          newGroup.color = this.data.options?.groups?.defaultGroupFormatting || '';
          newGroup.titleFormatting = this.data.options?.groups?.defaultGroupTitleFormatting || '';
          newGroup.linkFormatting = this.data.options?.groups?.defaultGroupLinkFormatting || '';
          newGroup.badgeFormatting = this.data.options?.groups?.defaultGroupBadgeFormatting || '';
          newGroup.pillFormatting = this.data.options?.groups?.defaultGroupPillFormatting || '';
          newGroup.pillColor = '';
          // Find the column with the fewest groups or default to 0
          const columns = this.getGroupColumns();
          let targetColumn = 0;
          if (columns.length > 0) {
            const counts = columns.map(col => this.data.groups.filter(g => g.column === col).length);
            const minCount = Math.min(...counts);
            targetColumn = columns[counts.indexOf(minCount)];
          }
          newGroup.column = targetColumn;
          newGroup.index = this.getMaxIndexForColumn(this.data.groups, targetColumn) + 1; // Add to end of target column
          this.data.groups.push(newGroup);
          // No need to reindex all if adding to end
          // reindexArr(this.data.groups.filter(g => g.column === newGroup.column));
          this.saveData();
        },
        // --- Sharing: context actions ---
        // Preserve original confirmShare to allow extension
        // _originalConfirmShare removed; extend confirmShare in-place
        async shareGroup(group) {
          try {
            this.openShareDialog('group', group);
          } catch (e) { debugLog('error', e); alert('Send failed'); }
        },
        async shareLink(link) {
          try {
            this.openShareDialog('link', link);
          } catch (e) { debugLog('error', e); alert('Send failed'); }
        },
        openShareDialog(mode, payload) {
          this.shareDialog.visible = true;
          this.shareDialog.mode = mode;
          this.shareDialog.payload = payload;
          this.shareDialog.selectedContacts = {};
          
          // Check online status for all contacts when dialog opens
          this.checkAllContactsStatus();
          
          const modalElement = document.getElementById('shareModal');
          if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).show();
          this.hideMenus();
        },
        async confirmShare() {
          if (this.shareDialog?.mode === 'owner-transfer') {
            const selected = Object.entries(this.shareDialog.selectedContacts||{}).filter(([,v])=>!!v).map(([k])=>k);
            if (selected.length !== 1) { alert(this.getTranslation('dialog.transfer.select')||'Select new owner:'); return; }
            const g = this.shareDialog.group;
            if (!g) return;
            await this.transferOwnership(g, selected[0]);
            this.shareDialog.visible=false; const modalElement = document.getElementById('shareModal'); if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).hide();
            return;
          }
          const selectedContacts = Object.entries(this.shareDialog.selectedContacts).filter(([,v])=>!!v).map(([k])=>k);
          if (selectedContacts.length===0) { alert('Select at least one contact'); return; }
          const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
          const base = { v:1, ts: Date.now(), from, schemaVersion:1, msgId: (Math.random().toString(36).slice(2)+Date.now()) };
          if (this.shareDialog.mode==='link') {
            const l = this.shareDialog.payload;
            const selection = { groups: [], links: [{ 
              uuid:l.uuid, 
              text:l.text, 
              url:l.url, 
              keywords:l.keywords 
            }] };
            // to contacts
            for (const uuid of selectedContacts) {
              await sharing.sendToContact(uuid, Object.assign({}, base, { type:'share', mode:'merge', selection }));
            }
          } else if (this.shareDialog.mode==='group') {
            const g0 = this.shareDialog.payload;
            const gPayload = { 
              uuid:g0.uuid, 
              name:g0.name, 
              color:g0.color, 
              opacity:g0.opacity, 
              keywords:g0.keywords, 
              favicon:g0.favicon || '',
              faviconSource:g0.faviconSource || null,
              links:(g0.links||[]).map(l=>({
                uuid:l.uuid,
                text:l.text,
                url:l.url,
                keywords:l.keywords,
                column:(typeof l.column==='number'?l.column:0),
                index:(typeof l.index==='number'?l.index:0)
              })),
              // Include event-log data if available
              useEventLog: g0.useEventLog || false,
              eventLog: g0.eventLog || [],
              snapshot: g0.snapshot || null,
              headEventId: g0.headEventId || null,
              vectorClock: g0.vectorClock || {}
            };
            const selection = { groups:[gPayload], links:[] };
            for (const uuid of selectedContacts) {
              await sharing.sendToContact(uuid, Object.assign({}, base, { type:'share', mode:'merge', selection }));
            }
          } else if (this.shareDialog.mode==='invite-group') {
            const g = this.shareDialog.payload;
            // ensure group is shared and has topic/key
            await sharing.inviteContactToGroup(g, selectedContacts[0] || '');
            for (let i=1;i<selectedContacts.length;i++) {
              await sharing.inviteContactToGroup(g, selectedContacts[i]);
            }
          }
          this.shareDialog.visible=false; const modalElement = document.getElementById('shareModal'); if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).hide();
          // Removed alert - modal will close to indicate success
        },
        inviteMembers(group) {
          // For non-shared groups, allow current user to initiate sharing (becomes owner)
          if (group?.shared && !this.isOwnerOfGroup(group)) { alert(this.getTranslation('error.onlyOwner')); return; }
          // reuse share dialog to pick contacts; on confirm, send invites
          this.shareDialog.visible = true;
          this.shareDialog.mode = 'invite-group';
          this.shareDialog.payload = group;
          this.shareDialog.selectedContacts = {};

          // Check online status for all contacts when dialog opens
          this.checkAllContactsStatus();

          const modalElement = document.getElementById('shareModal');
          if (modalElement) bootstrap.Modal.getOrCreateInstance(modalElement).show();
          this.hideMenus();
        },
        duplicateGroup(group) {
          if (!group) return;
          const copy = {
            uuid: this.generateUUID(), // Generate new UUID for the duplicated group
            name: `${group.name} (Kopie)`,
            keywords: group.keywords || '',
            links: [],
            index: (this.data.groups && this.data.groups.length ? Math.max(...this.data.groups.map(g=>g.index)) + 1 : 0),
            column: group.column || 0,
            collapsed: !!group.collapsed,
            searchCollapsed: true,
            editing: false,
            isMouseOver: false,
            newLinkText: '',
            newLinkUrl: '',
            color: group.color || '',
            titleFormatting: group.titleFormatting || '',
            linkFormatting: group.linkFormatting || '',
            badgeFormatting: group.badgeFormatting || '',
            pillFormatting: group.pillFormatting || '',
            favicon: group.favicon || '',
            faviconError: false,
            faviconLoading: false,
            faviconSource: group.faviconSource || null,
            faviconRuleId: group.faviconRuleId || null,
            shared: false,
            members: [ { uuid: this.data.identity?.uuid || '', name: this.data.identity?.name || '', role: 'owner' } ]
          };
          const nowTs = Date.now();
          copy.createdAt = nowTs;
          copy.lastModified = nowTs;
          (group.links||[]).forEach((l, idx)=>{
            const linkCreated = this.normalizeTimestampValue(l.createdAt) ?? nowTs;
            const linkModified = this.normalizeTimestampValue(l.lastModified) ?? linkCreated;
            copy.links.push({ 
              uuid: this.generateUUID(), // New UUID for duplicated link
              text: l.text||l.url, 
              url: l.url, 
              keywords: l.keywords||'', 
              color: l.color || '',
              column: 0, 
              index: idx, 
              editing:false, 
              isMouseOver:false,
              createdAt: linkCreated,
              lastModified: linkModified
            });
          });
          if (!Array.isArray(this.data.groups)) this.$set(this.data, 'groups', []);
          this.data.groups.push(copy);
          this.touchGroup(copy, nowTs);
          this.saveData();
          this.hideMenus();
        },
        async delGroup(group) {
          const needConfirm = !!this.data?.options?.common?.confirmDeleteGroup;
          if (needConfirm) {
            const msg = this.getTranslation('confirm.deleteGroup', [group?.name || '']);
            if (!confirm(msg)) return;
          }
          const oldColumn = group.column; // Spalte merken
          const index = this.data.groups.findIndex(g => g.uuid === group.uuid);
          const isOwner = (group.members||[]).some(m=>m.role==='owner' && m.uuid===this.data.identity?.uuid);
          // If this is a shared group and we are NOT the owner, notify owner that we left; owner's group stays intact
          if (group.shared && !isOwner) {
            try {
              const owner = (group.members||[]).find(m=>m.role==='owner') || (group.members||[]).find(m=>m.uuid!==this.data.identity?.uuid);
              if (owner) {
                const env = { v:1, type:'group-member-left', ts:Date.now(), from:{ uuid:this.data.identity?.uuid, name:this.data.identity?.name||'' }, groupId: group.groupId, memberUuid: this.data.identity?.uuid };
                await sharing.sendToContact(owner.uuid, env);
              }
            } catch {}
            try { sharing.ntfy.unsubscribe(group.groupTopic); } catch {}
          }
          if (index > -1) {
            this.data.groups.splice(index, 1);
            this.reindexArr(this.data.groups.filter(g => g.column === oldColumn)); // Alte Spalte neu indizieren
            this.normalizeColumnNumbers(); // <-- HIER AUFRUFEN
            this.saveData(); // Speichern nach Normalisierung und Reindexierung
          }
          this.hideMenus();
        },
        getGroupColumns() {
          if (!this.data.groups || this.data.groups.length === 0) return [0]; // Default to one column if empty
          const columns = [...new Set(this.data.groups.map(g => g.column))];
          return columns.sort((a, b) => a - b);
        },
        getMaxIndexForColumn(arr, column) {
          const itemsInColumn = arr.filter(item => item.column === column);
          return itemsInColumn.length > 0 ? Math.max(...itemsInColumn.map(item => item.index)) : -1;
        },
        getGroupsByColumn(colIndex) {
          // Immer nach column filtern, Suchtext-Filter bleibt erhalten
          return this.data.groups
            .filter(g =>
              g.column === colIndex &&
              (
                !this.filterText ||
                g.name?.toLowerCase().includes(this.filterText.toLowerCase()) ||
                // If the group has the keyword, show the entire group
                (g.keywords && g.keywords.toLowerCase().includes(this.filterText.toLowerCase())) ||
                // Or if any link has the keyword or matches the search
                (g.links && g.links.some(l =>
                  l.text?.toLowerCase().includes(this.filterText.toLowerCase()) ||
                  (l.keywords && l.keywords.toLowerCase().includes(this.filterText.toLowerCase())) ||
                  (l.url && l.url.toLowerCase().includes(this.filterText.toLowerCase()))
                ))
              )
            )
            .sort((a, b) => a.index - b.index);
        },
        // Innerhalb von methods: { ... } der Vue-Instanz 'app'
        normalizeColumnNumbers() {
          const groups = this.data.groups;
          if (!groups || groups.length === 0) return; // Nichts zu tun, wenn keine Gruppen da sind

          const currentColumns = this.getGroupColumns(); // Holt sortierte, eindeutige Spalten, z.B. [0, 2, 3]
          if (currentColumns.length === 0) return; // Sollte nicht passieren, aber sicher ist sicher

          let expectedCol = 0;
          let changed = false;
          const columnMapping = {}; // Objekt zum Speichern der Zuordnung: alteSpalte -> neueSpalte

          // 1. Mapping erstellen
          for (const currentCol of currentColumns) {
            if (currentCol !== expectedCol) {
              // Lücke oder erster Eintrag ist nicht 0 (sollte nicht sein, aber zur Sicherheit)
              columnMapping[currentCol] = expectedCol; // Weise die erwartete Nummer zu
            } else {
              columnMapping[currentCol] = currentCol; // Keine Änderung für diese Spalte
            }
            expectedCol++; // Erhöhe die erwartete Nummer für die nächste Iteration
          }

          // 2. Mapping auf alle Gruppen anwenden
          groups.forEach(group => {
            const oldCol = group.column;
            if (columnMapping[oldCol] !== undefined && columnMapping[oldCol] !== oldCol) {
              // Nur ändern, wenn eine neue Zuordnung existiert und sie anders ist
              this.$set(group, 'column', columnMapping[oldCol]);
              changed = true;
            }
          });

          if (changed) {
            debugLog('log', "Columns normalized. New mapping:", columnMapping);
            this.$forceUpdate(); // Erzwinge UI-Update nach Spaltenänderung
            // Wichtig: saveData() wird in der aufrufenden Funktion (moveGroup/delGroup/onDrop) gemacht!
          }
        },
        toggleGroupCollapse(group) {
          // 1. Toggle den Vue-Datenzustand (für Icon etc.)
          this.$set(group, 'collapsed', !group.collapsed);

          // Load favicons when expanding the group (lazy loading)
          if (!group.collapsed && this.extensionAvailable && this.data.options?.links?.autoFetchFavicon) {
            this.loadFaviconsForGroup(group);
          }

          // 2. Hole das Bootstrap Collapse Element
          const elementId = 'collapseGroup-' + group.uuid;
          const collapseElement = document.getElementById(elementId);

          if (collapseElement) {
            // 3. Hole oder erstelle die Bootstrap Instanz
            let bsCollapseInstance = bootstrap.Collapse.getInstance(collapseElement);
            if (!bsCollapseInstance) {
              bsCollapseInstance = new bootstrap.Collapse(collapseElement, { toggle: false });
            }
            // 4. Trigger Bootstrap's Toggle-Funktion
            bsCollapseInstance.toggle();

            // 5. Speichere den neuen Zustand (optional, je nachdem ob du den manuellen Toggle speichern willst)
            // Das Speichern hier kann dazu führen, dass beim nächsten Laden der Zustand korrekt ist,
            // überschreibt aber ggf. die "collapseGroupsOnStart"-Option für diese eine Gruppe.
            this.saveData();

          } else {
            debugLog('warn', "Could not find collapse element to toggle:", elementId);
          }
        },

        async loadFaviconsForGroup(group, linksOverride = null) {
          const targetLinks = Array.isArray(linksOverride) ? linksOverride : (group.links || []);
          if (!targetLinks.length) return;

          debugLog('log', `Loading favicons for group: ${group.name}`, { overrideCount: linksOverride ? targetLinks.length : undefined });

          // Track which links already have favicons
          const linksToFetch = targetLinks.filter(link => {
            const fav = link && link.favicon ? String(link.favicon) : '';
            const isBase64 = fav.startsWith('data:');
            return link.url && !isBase64 && !link.faviconLoading;
          });

          if (linksToFetch.length === 0) {
            debugLog('log', 'All links already have favicons');
            return;
          }

          // Mark links as loading to prevent duplicate fetches
          linksToFetch.forEach(link => {
            this.$set(link, 'faviconLoading', true);
          });

          // Fetch favicons in batches
          const batchSize = 5;
          for (let i = 0; i < linksToFetch.length; i += batchSize) {
            const batch = linksToFetch.slice(i, i + batchSize);

            // Fetch metadata for each link in the batch
            const fetchPromises = batch.map(async (link) => {
              try {
                await this.tryFetchAndSetFavicon(link, link.url, link.rawUrlInput ?? null);
              } catch (error) {
                debugLog('warn', `Failed to fetch favicon for ${link.url}:`, error);
              } finally {
                this.$set(link, 'faviconLoading', false);
              }
            });

            // Wait for batch to complete before continuing
            await Promise.all(fetchPromises);

            // Small delay between batches to avoid overwhelming the extension
            if (i + batchSize < linksToFetch.length) {
              await new Promise(resolve => setTimeout(resolve, 100));
            }
          }

          // Save data after all favicons are loaded
          this.saveData();
          debugLog('log', `Finished loading favicons for group: ${group.name}`);
        },
        // --- Links ---
        getNewLinkTemplate(group) {
          const rawInput = (group.newLinkUrl || '').trim();
          // Basic URL normalization using configured default prefix
          let url = MB.Utils.ensureProtocol(rawInput);
          const nowTs = Date.now();

          return {
            uuid: this.generateUUID(), // UUID is the only identifier
            text: group.newLinkText.trim() || url || '', // Links can have empty text
            url: url || '', // Empty string instead of null for consistency
            rawUrlInput: rawInput || '',
            keywords: '', // Add keywords field
            emoji: '', // Add emoji field for custom icons
            index: group.links.length > 0 ? Math.max(...group.links.map(link => link.index)) + 1 : 0,
            column: 0, // Default to first column within the group
            // Timestamps for conflict resolution
            createdAt: nowTs,
            lastModified: nowTs,
            // Transient UI state defaults
            editing: false,
            isMouseOver: false,
          };
        },
        async addLink(group) {
          debugLog('log', '[addLink] Function called for group:', {
            groupName: group.name,
            groupId: group.groupId,
            useEventLog: group.useEventLog,
            hasEventLog: !!group.eventLog,
            isShared: group.shared
          });
          
          if (!this.canAdd(group)) { alert(this.getTranslation('error.perm.add')); return; }
          if (!group.newLinkText.trim() && !group.newLinkUrl.trim()) return; // Require at least text or URL
          const rawNewLinkInput = group.newLinkUrl;
          const newLink = this.getNewLinkTemplate(group);
          debugLog('log', '[DEBUG] Created new link:', { 
            uuid: newLink.uuid, 
            text: newLink.text, 
            url: newLink.url, 
            hasUrl: !!newLink.url && newLink.url !== '',
            urlLength: newLink.url ? newLink.url.length : 0
          });
          
          group.links.push(newLink);
          const newLinkTimestamp = this.touchLink(newLink, newLink.createdAt);
          this.touchGroup(group, newLinkTimestamp);
          group.newLinkText = '';
          group.newLinkUrl = '';

          const rawInputTrimmed = typeof rawNewLinkInput === 'string' ? rawNewLinkInput.trim() : rawNewLinkInput;
          if (rawInputTrimmed !== undefined && rawInputTrimmed !== null) {
            this.$set(newLink, 'rawUrlInput', rawInputTrimmed || '');
          }

          if (newLink.url) {
            try {
              if (!this.applyFaviconRulesToLink(newLink, null, rawInputTrimmed)) {
                await this.tryFetchAndSetFavicon(newLink, newLink.url, rawInputTrimmed);
              }
            } catch (err) {
              debugLog('warn', '[addLink] Failed to apply favicon for new link', { error: err, url: newLink.url });
            }
          }

          if (!group.collapsed && this.data.options?.links?.autoFetchFavicon) {
            this.loadFaviconsForGroup(group, [newLink]);
          }

          // Update version for sync tracking
          if (group.shared) {
            group.version = (group.version || 0) + 1;
            debugLog('log', '[SYNC] Updated group version after adding link', { groupId: group.groupId, version: group.version });
          }
          
          // EVENT-LOG: Create and send event for link addition (for ALL groups with event-log)
          debugLog('log', '[LINK-ADD] Checking event-log for group:', {
            groupName: group.name,
            groupId: group.groupId,
            useEventLog: group.useEventLog,
            hasEventLog: !!group.eventLog,
            isShared: group.shared
          });
          
          if (group.useEventLog) {
            debugLog('log', '[LINK-ADD] Creating event-log entry for link addition');
            this.createAndApplyEvent(group, {
              type: 'link-add',
              linkId: newLink.uuid,
              data: {
                uuid: newLink.uuid,  // Include UUID in data for consistency
                text: newLink.text || '',
                url: newLink.url || '',
                rawUrlInput: newLink.rawUrlInput || '',
                keywords: newLink.keywords || '',
                emoji: newLink.emoji || '',
                column: newLink.column || 0,
                index: newLink.index || 0,
                createdAt: newLink.createdAt || newLinkTimestamp,
                lastModified: newLink.lastModified || newLinkTimestamp
              }
            });
          } else {
            debugLog('warn', '[LINK-ADD] Event-log is disabled for this group');
          }
          
          this.saveData();
          // Broadcast to shared group (legacy for backward compatibility)
          try {
            if (group.shared && group.groupTopic && group.groupKey && !group.useEventLog) {
              const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
              // Ensure empty strings for text and url if not provided
              const linkToShare = { 
                uuid: newLink.uuid, 
                text: newLink.text || '', 
                url: newLink.url || '', 
                rawUrlInput: newLink.rawUrlInput || '',
                keywords: newLink.keywords || '', 
                emoji: newLink.emoji || '',
                column: newLink.column || 0, 
                index: newLink.index || 0,
                createdAt: newLink.createdAt || newLinkTimestamp,
                lastModified: newLink.lastModified || newLinkTimestamp 
              };
              debugLog('log', '[SYNC] Broadcasting new link', { 
                uuid: linkToShare.uuid, 
                text: linkToShare.text, 
                url: linkToShare.url,
                hasUrl: !!linkToShare.url && linkToShare.url !== '',
                urlLength: linkToShare.url ? linkToShare.url.length : 0,
                rawEnvelope: JSON.stringify(linkToShare)
              });
              const env = { v:1, type:'share-links', ts:Date.now(), from, groupId: group.groupId, selection:{ groups:[], links:[linkToShare] }, mode:'merge', msgId:(Math.random().toString(36).slice(2)+Date.now()) };
              await sharing.sendToGroup(group, env);
            }
          } catch {}
        },
        // Accept external link drops (from browser address bar or page links) or fall back to internal reordering
        async handleLinkDrop(evt, group, targetIndex, targetColumn) {
          // Try external data first
          const ext = this.extractUrlAndTitle(evt.dataTransfer);
          if (ext && ext.url && /^https?:\/\//i.test(ext.url)) {
            if (!this.canAdd(group)) { alert(this.getTranslation('error.perm.add')); return; }
            const url = ext.url.trim();
            const title = (ext.title || '').trim();
            const nowTs = Date.now();
            const newLink = {
              uuid: this.generateUUID(), // UUID is the only identifier
              text: title || url,
              url,
              rawUrlInput: url,
              keywords: '',
              column: targetColumn,
              index: 0,
              editing: false,
              isMouseOver: false,
              createdAt: nowTs,
              lastModified: nowTs,
            };
            if (!Array.isArray(group.links)) this.$set(group, 'links', []);
            group.links.push(newLink);
            // Reindex target column with new link inserted at requested position
            const colLinks = group.links.filter(l => l.column === targetColumn).sort((a, b) => a.index - b.index);
            const before = colLinks.slice(0, Math.max(0, Math.min(targetIndex, colLinks.length)));
            const after = colLinks.slice(Math.max(0, Math.min(targetIndex, colLinks.length)));
            const ordered = [...before, newLink, ...after.filter(l => l !== newLink)];
            ordered.forEach((l, i) => l.index = i);
            const newLinkTs = this.touchLink(newLink, nowTs);
            this.touchGroup(group, newLinkTs);
            // Metadata helpers
            if (this.data.options?.links?.autoFetchFavicon) {
              this.tryFetchAndSetFavicon(newLink, url, url);
            }
            if (this.data.options?.links?.autoFetchTitle && (!title || title === url)) {
              // best effort, non-blocking
              this.tryFetchTitle(url).then(tt => { if (tt) newLink.text = tt; this.saveData(); }).catch(() => { });
            }
            // EVENT-LOG: Create event for external link drop (for ALL groups with event-log)
            if (group.useEventLog) {
              this.createAndApplyEvent(group, {
                type: 'link-add',
                linkId: newLink.uuid,
                data: {
                  uuid: newLink.uuid,
                  text: newLink.text || '',
                  url: newLink.url || '',
                  rawUrlInput: newLink.rawUrlInput || '',
                  keywords: newLink.keywords || '',
                  column: newLink.column || 0,
                  index: newLink.index || 0,
                  createdAt: newLink.createdAt || newLinkTs,
                  lastModified: newLink.lastModified || newLinkTs
                }
              });
            }
            
            this.saveData();
            // Broadcast to shared group (legacy only)
            try {
              if (group.shared && group.groupTopic && group.groupKey && !group.useEventLog) {
                const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                // Ensure all fields are strings, not null/undefined
                const linkToShare = { 
                  uuid: newLink.uuid, 
                  text: newLink.text || '', 
                  url: newLink.url || '', 
                  rawUrlInput: newLink.rawUrlInput || '',
                  keywords: newLink.keywords || '', 
                  emoji: newLink.emoji || '',
                  column: newLink.column || 0, 
                  index: newLink.index || 0,
                  createdAt: newLink.createdAt || newLinkTs,
                  lastModified: newLink.lastModified || newLinkTs 
                };
                debugLog('log', '[SYNC] Broadcasting dropped link', { uuid: linkToShare.uuid, hasUrl: !!linkToShare.url, text: linkToShare.text });
                const env = { v:1, type:'share-links', ts:Date.now(), from, groupId: group.groupId, selection:{ groups:[], links:[linkToShare] }, mode:'merge', msgId:(Math.random().toString(36).slice(2)+Date.now()) };
                await sharing.sendToGroup(group, env);
              }
            } catch {}
            return;
          }
          // No external URL -> if we're dragging an internal link, delegate to DropManager
          if (this.dragState === 'link' && this.dropManager && this.dropManager.oldItem) {
            this.dropManager.onDrop(evt, group.links, null, targetIndex, targetColumn, 'link');
            const nowTs = Date.now();
            const draggedLink = this.dropManager.oldItem;
            const linkTs = draggedLink ? this.touchLink(draggedLink, nowTs) : nowTs;
            const sourceGroup = this.dropManager.oldArr ? this.data.groups.find(g => g.links === this.dropManager.oldArr) : null;
            this.touchGroup(group, linkTs);
            if (sourceGroup && sourceGroup !== group) this.touchGroup(sourceGroup, nowTs);
            this.saveData();
          }
        },

        handleLinkDropToNewColumn(evt, group, targetColumnIndex) {
          debugLog('log', `handleLinkDropToNewColumn called for group ${group.name}, target column index ${targetColumnIndex}`);

          // Prevent default and stop propagation
          evt.preventDefault();
          evt.stopPropagation();

          // Get the dragged link from dropManager
          const draggedLink = this.dropManager.oldItem;
          const draggedState = this.dropManager.draggedState;
          const sourceGroup = this.dropManager.oldArr ? this.data.groups.find(g => g.links === this.dropManager.oldArr) : null;

          debugLog('log', 'Dragged link:', draggedLink);
          debugLog('log', 'Dragged state:', draggedState);
          debugLog('log', 'Source group:', sourceGroup);
          debugLog('log', 'Target group:', group);

          if (!draggedLink || draggedState !== 'link') {
            debugLog('warn', 'No valid link being dragged');
            this.dropManager.reset();
            return;
          }

          const moveTimestamp = Date.now();
          let linkMoveTimestamp = moveTimestamp;

          const oldColumn = draggedLink.column || 0;
          const oldIndex = draggedLink.index || 0;

          // Check if this is a cross-group move
          const isCrossGroup = sourceGroup && sourceGroup !== group;

          if (isCrossGroup) {
            debugLog('log', 'Cross-group move detected');

            // Check permissions BEFORE making any changes
            if (!this.canDelete(sourceGroup)) {
              alert(this.getTranslation('error.perm.delete') || 'You do not have permission to remove links from this group');
              this.dropManager.reset();
              return;
            }

            if (!this.canAdd(group)) {
              alert(this.getTranslation('error.perm.add') || 'You do not have permission to add links to this group');
              this.dropManager.reset();
              return;
            }

            // Remove link from source group (only after permission check)
            const linkIndex = sourceGroup.links.findIndex(l => l.uuid === draggedLink.uuid);
            if (linkIndex !== -1) {
              sourceGroup.links.splice(linkIndex, 1);

              // Update indices in the old column of source group
              const remainingLinksInOldColumn = sourceGroup.links.filter(l =>
                (l.column || 0) === oldColumn && (l.index || 0) > oldIndex
              );
              remainingLinksInOldColumn.forEach(l => {
                l.index = (l.index || 0) - 1;
              });

              this.touchGroup(sourceGroup, moveTimestamp);
            }

            // Add link to target group
            if (!Array.isArray(group.links)) {
              this.$set(group, 'links', []);
            }
            group.links.push(draggedLink);
            this.touchGroup(group, moveTimestamp);
          }

          // Get all existing link columns in target group
          const existingColumns = this.getLinkColumns(group.links);
          debugLog('log', 'Existing link columns before move:', existingColumns);
          debugLog('log', `Moving link from column ${oldColumn} to dropzone at position ${targetColumnIndex}`);

          // For same-group moves, check if this link is alone in its column
          if (!isCrossGroup) {
            const linksInOldColumn = group.links.filter(l => (l.column || 0) === oldColumn);
            const isAloneInColumn = linksInOldColumn.length === 1;

            // Check if this is effectively no move
            if (isAloneInColumn) {
              if ((targetColumnIndex === -1 && oldColumn === 0) ||
                  (targetColumnIndex !== -1 && targetColumnIndex === oldColumn) ||
                  (targetColumnIndex !== -1 && targetColumnIndex - 1 === oldColumn)) {
                debugLog('log', 'Link is alone in column and target position is same - no move needed');
                this.dropManager.reset();
                return;
              }
            }
          }

          let newColumnIndex;

          if (targetColumnIndex === -1) {
            // Drop before first column - all columns shift right
            newColumnIndex = 0;

            // Shift all links to the right (except the dragged one)
            group.links.forEach(l => {
              if (l.uuid !== draggedLink.uuid) {
                l.column = (l.column || 0) + 1;
              }
            });
          } else {
            // targetColumnIndex is the position where we want to insert the new column
            // This is the column index AFTER which the dropzone is located

            // The new column should be created at this exact position
            newColumnIndex = targetColumnIndex;

            debugLog('log', `Creating new link column at position ${newColumnIndex}`);

            // Shift all links at or after the target position to the right
            // But not the dragged link itself
            group.links.forEach(l => {
              if (l.uuid !== draggedLink.uuid && (l.column || 0) >= newColumnIndex) {
                l.column = (l.column || 0) + 1;
                debugLog('log', `Shifted link "${l.text}" from column ${l.column - 1} to ${l.column}`);
              }
            });
          }

          // Update indices in the old column (remove the gap) - only for same-group moves
          if (!isCrossGroup) {
            const remainingLinksInOldColumn = group.links.filter(l =>
              (l.column || 0) === oldColumn && l.uuid !== draggedLink.uuid && (l.index || 0) > oldIndex
            );
            remainingLinksInOldColumn.forEach(l => {
              l.index = (l.index || 0) - 1;
            });
          }

          // Move the dragged link to the new column
          draggedLink.column = newColumnIndex;
          draggedLink.index = 0; // Place at top of new column
          linkMoveTimestamp = this.touchLink(draggedLink, moveTimestamp);
          if (!isCrossGroup) {
            this.touchGroup(group, moveTimestamp);
          }

          debugLog('log', `Moved link "${draggedLink.text}" from column ${oldColumn} to new column ${newColumnIndex}`);

          // Now normalize link column indices to remove any gaps
          this.normalizeLinkColumnIndices(group);

          // Also normalize source group if it was a cross-group move
          if (isCrossGroup && sourceGroup) {
            this.normalizeLinkColumnIndices(sourceGroup);

            // Handle sync for cross-group moves
            // Send DELETE event/message to source group if it's shared
            if (sourceGroup.shared) {
              if (sourceGroup.useEventLog && this.eventLogManager) {
                // Create link-delete event for source group
                this.createAndApplyEvent(sourceGroup, {
                  type: 'link-delete',
                  linkId: draggedLink.uuid,
                  data: {
                    deletedLink: {
                      uuid: draggedLink.uuid,
                      text: draggedLink.text,
                      url: draggedLink.url,
                      column: oldColumn,
                      index: oldIndex
                    }
                  }
                });
                debugLog('log', '[DND EVENT-LOG] Created link-delete event for source group:', sourceGroup.name);
              } else if (sourceGroup.groupTopic && sourceGroup.groupKey) {
                // Legacy sync for source group
                try {
                  const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
                  const deleteEnv = {
                    v: 1,
                    type: 'link-delete',
                    ts: Date.now(),
                    from,
                    groupId: sourceGroup.groupId,
                    link: { uuid: draggedLink.uuid, url: draggedLink.url || null },
                    version: sourceGroup.version || CONSTS.VERSION_FALLBACK,
                    msgId: (Math.random().toString(36).slice(2) + Date.now())
                  };
                  debugLog('log', '[DRAG] Sending link-delete to source shared group:', sourceGroup.name, draggedLink.uuid);
                  if (typeof sharing !== 'undefined' && sharing) {
                    sharing.sendToGroup(sourceGroup, deleteEnv);
                  }
                } catch (error) {
                  debugLog('error', '[DRAG] Error sending link-delete:', error);
                }
              }
            }

            // Send ADD event/message to target group if it's shared
            if (group.shared) {
              if (group.useEventLog && this.eventLogManager) {
                // Create link-add event for target group
                this.createAndApplyEvent(group, {
                  type: 'link-add',
                  linkId: draggedLink.uuid,
                  data: {
                    uuid: draggedLink.uuid,
                    text: draggedLink.text || '',
                    url: draggedLink.url || '',
                    rawUrlInput: draggedLink.rawUrlInput || '',
                    keywords: draggedLink.keywords || '',
                    column: draggedLink.column || 0,
                    index: draggedLink.index || 0,
                    createdAt: draggedLink.createdAt || linkMoveTimestamp,
                    lastModified: draggedLink.lastModified || linkMoveTimestamp
                  }
                });
                debugLog('log', '[DND EVENT-LOG] Created link-add event for target group:', group.name);
              } else if (group.groupTopic && group.groupKey) {
                // Legacy sync for target group
                try {
                  const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
                  const linkData = {
                    uuid: draggedLink.uuid,
                    text: draggedLink.text || draggedLink.url,
                    url: draggedLink.url,
                    rawUrlInput: draggedLink.rawUrlInput || '',
                    keywords: draggedLink.keywords || '',
                    column: draggedLink.column || 0,
                    index: draggedLink.index || 0,
                    createdAt: draggedLink.createdAt || linkMoveTimestamp,
                    lastModified: draggedLink.lastModified || linkMoveTimestamp
                  };
                  const addEnv = {
                    v: 1,
                    type: 'share-links',
                    ts: Date.now(),
                    from,
                    groupId: group.groupId,
                    selection: { groups: [], links: [linkData] },
                    mode: 'merge',
                    msgId: (Math.random().toString(36).slice(2) + Date.now())
                  };
                  debugLog('log', '[DRAG] Sending share-links to target shared group:', group.name, linkData);
                  if (typeof sharing !== 'undefined' && sharing) {
                    sharing.sendToGroup(group, addEnv);
                  }
                } catch (error) {
                  debugLog('error', '[DRAG] Error sending share-links:', error);
                }
              }
            }
          } else if (group.shared && !isCrossGroup) {
            // Within same group movement - send position update for shared groups
            if (group.useEventLog && this.eventLogManager) {
              // For event-log groups, create a link-update event
              this.createAndApplyEvent(group, {
                type: 'link-update',
                linkId: draggedLink.uuid,
                data: {
                  uuid: draggedLink.uuid,
                  text: draggedLink.text || '',
                  url: draggedLink.url || '',
                  keywords: draggedLink.keywords || '',
                  column: draggedLink.column || 0,
                  index: draggedLink.index || 0,
                  lastModified: draggedLink.lastModified || linkMoveTimestamp
                }
              });
              debugLog('log', '[DND EVENT-LOG] Created link-update event for position change:', group.name);
            } else if (group.groupTopic && group.groupKey) {
              // Legacy sync - send position update
              try {
                const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name || '' };
                const linkData = {
                  uuid: draggedLink.uuid,
                  text: draggedLink.text || draggedLink.url,
                  url: draggedLink.url,
                  keywords: draggedLink.keywords || '',
                  column: draggedLink.column || 0,
                  index: draggedLink.index || 0,
                  lastModified: draggedLink.lastModified || linkMoveTimestamp
                };
                const env = {
                  v: 1,
                  type: 'share-links',
                  ts: Date.now(),
                  from,
                  groupId: group.groupId,
                  selection: { groups: [], links: [linkData] },
                  mode: 'merge',
                  msgId: (Math.random().toString(36).slice(2) + Date.now())
                };
                debugLog('log', '[DRAG] Sending share-links update within same group:', linkData);
                if (typeof sharing !== 'undefined' && sharing) {
                  sharing.sendToGroup(group, env);
                }
              } catch (error) {
                debugLog('error', '[DRAG] Error sending share-links update:', error);
              }
            }
          }

          // Save and reset
          this.touchGroup(group, moveTimestamp);
          if (isCrossGroup && sourceGroup) {
            this.touchGroup(sourceGroup, moveTimestamp);
          }
          this.saveData();
          this.dropManager.reset();
        },

        normalizeLinkColumnIndices(group) {
          // Get all unique columns and sort them
          const columns = [...new Set(group.links.map(l => l.column || 0))].sort((a, b) => a - b);

          // Create mapping from old to new column indices
          const columnMapping = {};
          columns.forEach((col, index) => {
            columnMapping[col] = index;
          });

          // Update all links with new column indices
          group.links.forEach(l => {
            const oldCol = l.column || 0;
            const newCol = columnMapping[oldCol];
            if (oldCol !== newCol) {
              l.column = newCol;
              debugLog('log', `Normalized link "${l.text}" from column ${oldCol} to ${newCol}`);
            }
          });
        },

        extractUrlAndTitle(dt) {
          if (!dt) return { url: '', title: '' };
          const safeGet = (t) => { try { return dt.getData(t) || ''; } catch { return ''; } };
          // 1) text/uri-list
          const uriListRaw = safeGet('text/uri-list');
          if (uriListRaw) {
            const lines = uriListRaw.split('\n').map(s => s.trim()).filter(s => s && !s.startsWith('#'));
            if (lines.length && /^https?:\/\//i.test(lines[0])) return { url: lines[0], title: '' };
          }
          // 2) Firefox: text/x-moz-url => "URL\nTitel"
          const moz = safeGet('text/x-moz-url');
          if (moz) {
            const [url, title] = moz.split('\n');
            if (url && /^https?:\/\//i.test(url)) return { url, title: title || '' };
          }
          // 3) text/html: <a href="..">Titel</a>
          const html = safeGet('text/html');
          if (html) {
            try {
              const doc = new DOMParser().parseFromString(html, 'text/html');
              const a = doc.querySelector('a[href]');
              const href = a?.getAttribute('href') || '';
              const title = (a?.textContent || '').trim();
              if (/^https?:\/\//i.test(href)) return { url: href, title };
            } catch { }
          }
          // 4) text/plain
          const plain = safeGet('text/plain').trim();
          if (/^https?:\/\//i.test(plain)) return { url: plain, title: '' };
          return { url: '', title: '' };
        },
        async deleteLink(link) {
          const needConfirm = !!this.data?.options?.common?.confirmDeleteLink;
          if (needConfirm) {
            const msg = this.getTranslation('confirm.deleteLink');
            if (!confirm(msg)) return;
          }
          const group = this.data.groups.find(g => g.links.some(l => 
            link.uuid && l.uuid === link.uuid
          ));
          if (group) {
            if (!this.canDelete(group)) { alert(this.getTranslation('error.perm.delete')); return; }
            const linkIndex = group.links.findIndex(l => 
              link.uuid && l.uuid === link.uuid
            );
            if (linkIndex > -1) {
              const nowTs = Date.now();
              const removed = group.links.splice(linkIndex, 1)[0];
              // Queue deletion to Nextcloud if this link was synced
              try {
                const nid = removed?.ncBookmarks?.id;
                const fid = removed?.ncBookmarks?.folderId;
                if (nid) {
                  if (!Array.isArray(this.data.pendingNcDeletes)) this.$set(this.data, 'pendingNcDeletes', []);
                  this.data.pendingNcDeletes.push({ id: nid, folderId: fid||null, url: removed.url||'', ts: Date.now() });
                  debugLog('log', '[NC SYNC] Queued NC deletion', { id: nid, folderId: fid });
                }
              } catch {}

              // Update version for sync tracking (only for shared groups)
              if (group.shared) {
                group.version = (group.version || 0) + 1;
                debugLog('log', '[SYNC] Updated group version after deleting link', { groupId: group.groupId, version: group.version });
              }

              // Event-log integration for delete (for ALL groups with event-log)
              if (group.useEventLog) {
                this.createAndApplyEvent(group, {
                  type: 'link-delete',
                  linkId: removed.uuid,
                  data: {
                    deletedLink: {
                      uuid: removed.uuid,
                      text: removed.text,
                      url: removed.url,
                      column: removed.column,
                      index: removed.index
                    }
                  }
                });
              }
              this.reindexArr(group.links.filter(l => l.column === link.column)); // Reindex affected column
              this.touchGroup(group, nowTs);
              this.saveData();
              // Propagate delete to group members (legacy sync)
              try {
                if (group.shared && group.groupTopic && group.groupKey) {
                  const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                  const env = { 
                    v:1, 
                    type:'link-delete', 
                    ts:Date.now(), 
                    from, 
                    groupId: group.groupId, 
                    link:{ uuid: removed.uuid, url: removed.url||null }, 
                    version: group.version || 0,  // Include version for delete operations
                    msgId:(Math.random().toString(36).slice(2)+Date.now()) 
                  };
                  await sharing.sendToGroup(group, env);
                }
              } catch (error) {
                debugLog('error', '[Sharing] Error processing message headers:', error);
              }
            }
          }
          this.hideMenus();
        },
        getLinkColumns(links) {
          if (!links || links.length === 0) return [0];
          const columns = [...new Set(links.map(l => l.column))];
          return columns.sort((a, b) => a - b);
        },
        getLinksByColumn(links, colIndex) {
          // First, find the group that contains these links
          const group = this.data.groups.find(g => g.links === links);
          const rawFilter = (this.filterText || '').trim();
          // Tokenize search text
          const tokens = rawFilter ? rawFilter.toLowerCase().split(/\s+/).filter(Boolean) : [];
          // If any token matches group keywords, show all links
          const groupHasKeyword = group && tokens.length && this.parseKeywords(group.keywords || '')
            .map(k => k.toLowerCase()).some(kw => tokens.some(t => kw.includes(t)));
          
          let result = links
            .filter(l =>
              l.column === colIndex &&
              (tokens.length === 0 || groupHasKeyword || (function(){
                const text = (l.text || '').toLowerCase();
                const url = (l.url || '').toLowerCase();
                const kws = (Array.isArray(l.keywords) ? l.keywords : (typeof l.keywords === 'string' ? l.keywords.split(/[,;]+/) : []))
                  .map(s => String(s).trim().toLowerCase()).join(' ');
                return tokens.every(t => text.includes(t) || url.includes(t) || kws.includes(t));
              })())
            )
            .sort((a, b) => a.index - b.index); // Sort by index

          // Progressive loading: limit display if not expanded
          if (group && !this.filterText) {
            const threshold = this.data.options?.links?.progressiveLoadingThreshold || 100;
            const expandedLimit = CONSTS.EXPANDED_LINK_LIMIT;

            if (!group.linksExpanded && result.length > threshold) {
              // Show limited links when not expanded
              const columnCount = this.getLinkColumns(links).length || 1;
              const perColumnLimit = Math.ceil(threshold / columnCount);
              result = result.slice(0, perColumnLimit);
            } else if (group.linksExpanded && result.length > expandedLimit) {
              // Even when expanded, limit to expandedLimit for performance
              const columnCount = this.getLinkColumns(links).length || 1;
              const perColumnLimit = Math.ceil(expandedLimit / columnCount);
              result = result.slice(0, perColumnLimit);
            }
          }

          // Optional simple virtualization by limit to reduce DOM on huge lists
          try {
            const perf = this.data?.options?.performance || {};
            if (perf.virtualizeLinks) {
              const init = Number(perf.initialLimit || 200);
              const groupKey = group?.uuid || 'default';
              if (!this._visibleLimits) this._visibleLimits = {};
              if (!this._visibleLimits[groupKey]) this._visibleLimits[groupKey] = init;
              result = result.slice(0, this._visibleLimits[groupKey]);
            }
          } catch {}

          return result;
        },
        // --- Sorting helpers for links ---
        _getLocaleCollator() {
          try {
            const lang = (this.data?.options?.common?.language || navigator.language || 'en').toString();
            return new Intl.Collator(lang, { numeric: true, sensitivity: 'base' });
          } catch { return new Intl.Collator('en', { numeric: true, sensitivity: 'base' }); }
        },
        _normalizeLinkSortKey(link, { ignoreArticles = true } = {}) {
          const raw = (link?.text || link?.url || '').toString().trim().toLowerCase();
          if (!ignoreArticles) return raw;
          const lang = (this.data?.options?.common?.language || 'en').toString().toLowerCase();
          // Minimal article lists (customize as needed)
          const articles = {
            en: ['the ', 'a ', 'an '],
            de: ['der ', 'die ', 'das ', 'ein ', 'eine ']
          };
          const list = articles[lang] || [];
          const match = list.find(p => raw.startsWith(p));
          return match ? raw.slice(match.length) : raw;
        },
        _compareLinks(a, b, collator, { direction = 'asc', ignoreArticles = true } = {}) {
          const ka = this._normalizeLinkSortKey(a, { ignoreArticles });
          const kb = this._normalizeLinkSortKey(b, { ignoreArticles });
          const c = collator.compare(ka, kb) || collator.compare(a.url||'', b.url||'');
          return direction === 'desc' ? -c : c;
        },
        // Sort links in a group by text (or URL as fallback)
        // strategy:
        //  - 'within-columns' (default): sort each column independently
        //  - 'preserve-counts': global sort, then slice back into current column counts (keeps visual balance)
        //  - 'rebalance-columns': global sort, then distribute as evenly as possible across columns
        sortGroupLinksByText(group, { strategy = 'within-columns', direction = 'asc', ignoreArticles = true } = {}) {
          if (!group || !Array.isArray(group.links) || group.links.length === 0) return;
          const collator = this._getLocaleCollator();
          const columns = this.getLinkColumns(group.links);
          const byCol = (col) => group.links.filter(l => l.column === col);
          if (strategy === 'within-columns') {
            columns.forEach(col => {
              const list = byCol(col).sort((a, b) => this._compareLinks(a, b, collator, { direction, ignoreArticles }));
              list.forEach((l, idx) => { l.index = idx; });
            });
            this.saveData();
            return;
          }
          // Global sort for the remaining strategies
          const all = [...group.links].sort((a, b) => this._compareLinks(a, b, collator, { direction, ignoreArticles }));
          let counts = [];
          if (strategy === 'preserve-counts') {
            counts = columns.map(col => byCol(col).length);
          } else if (strategy === 'rebalance-columns') {
            const total = all.length;
            const base = Math.floor(total / columns.length);
            const extra = total % columns.length;
            counts = columns.map((_, i) => base + (i < extra ? 1 : 0));
          }
          // Assign back according to counts
          let pos = 0;
          columns.forEach((col, ci) => {
            const take = counts[ci] || 0;
            const slice = all.slice(pos, pos + take);
            pos += take;
            slice.forEach((l, idx) => { l.column = col; l.index = idx; });
          });
          this.saveData();
        },
        // Helper methods for progressive loading
        shouldShowExpandButton(group) {
          if (!group || !group.links || this.filterText) return false;

          const totalLinks = group.links.length;
          const initialLimit = this.data.options?.links?.progressiveLoadingThreshold || CONSTS.PROGRESSIVE_LOADING_THRESHOLD;

          return totalLinks > initialLimit;
        },
        toggleGroupExpansion(group) {
          if (!group) return;
          group.linksExpanded = !group.linksExpanded;
          this.saveData();
        },
        getRemainingLinksCount(group) {
          if (!group || !group.links) return 0;
          const totalLinks = group.links.length;
          const initialLimit = group.initialLinkCount || 100;
          return Math.max(0, totalLinks - initialLimit);
        },
        increaseVisibleLinks(group) {
          try {
            const perf = this.data?.options?.performance || {};
            const page = Number(perf.pageSize || 200);
            const key = group?.uuid || 'default';
            if (!this._visibleLimits) this._visibleLimits = {};
            this._visibleLimits[key] = (this._visibleLimits[key] || Number(perf.initialLimit || 200)) + page;
            this.$forceUpdate();
          } catch {}
        },

        // --- Inline Editing (Vue way) ---
        startEditing(item) {
          // Cancel any other active editing
          this.data.groups.forEach(g => {
            if (g.editing && g.uuid !== item.uuid) g.editing = false;
            g.links.forEach(l => {
              if (l.editing && l.uuid !== item.uuid) l.editing = false;
            });
          });
          // Permission enforcement: block inline edit for links in shared groups
          try {
            if (item && item.url !== undefined) { // treat as link
              const group = (this.data.groups||[]).find(g => Array.isArray(g.links) && g.links.some(l => l.uuid === item.uuid));
              if (group && group.shared && !this.canEdit(group)) {
                alert(this.getTranslation('error.perm.edit'));
                return;
              }
            }
          } catch {}
          // Store original value in case of escape
          item._originalValue = item.name || item.text;
          this.$set(item, 'editing', true); // Ensure reactivity
          if (item && item.url !== undefined) {
            this.hideLinkPopover();
          }
          // Focus handled by v-focus directive
        },
        saveEditing(item) {
          if (!item) return;
          // Trim and check if changed
          const newValue = (item.name || item.text || '').trim();
          const oldValue = item._originalValue || '';
          const valueKey = item.name !== undefined ? 'name' : 'text';

          // Permission enforcement for links
          try {
            if (item && item.url !== undefined) { // link
              const group = (this.data.groups||[]).find(g => Array.isArray(g.links) && g.links.some(l => l.uuid === item.uuid));
              if (group && group.shared && !this.canEdit(group)) {
                alert(this.getTranslation('error.perm.edit'));
                // revert if was editing
                if (item._originalValue !== undefined) item[valueKey] = item._originalValue;
                item.editing = false; delete item._originalValue; return;
              }
            }
          } catch {}

          if (newValue === '') { // Revert if empty
            item[valueKey] = oldValue;
          } else {
            item[valueKey] = newValue; // Update with trimmed value
            if (newValue !== oldValue) {
              const nowTs = item && item.url !== undefined
                ? this.touchLink(item)
                : this.touchGroup(item);
              this.saveData();
              // Mark local edit timestamp + hash for conflict resolution (links only)
              try {
                if (item && item.url !== undefined) {
                  const nb = Object.assign({}, item.ncBookmarks||{}, { localUpdatedAt: nowTs });
                  // Do NOT update lastHash here; keep last synced signature as baseline
                  this.$set(item, 'ncBookmarks', nb);
                  debugLog('log', '[NC SYNC] Inline edit marked localUpdatedAt', { id: nb.id, localUpdatedAt: nb.localUpdatedAt });
                }
              } catch {}
              // If this is a link editing its text inline, broadcast to shared group
              try {
                // Check if item is a link (has url property, even if empty)
                if (item.url !== undefined) {
                  const group = (this.data.groups||[]).find(g=>Array.isArray(g.links) && g.links.some(l=>
                    item.uuid && l.uuid === item.uuid
                  ));
                  if (group) {
                    this.touchGroup(group, nowTs);
                    // Update version for sync tracking (only for shared groups)
                    if (group.shared) {
                      group.version = (group.version || 0) + 1;
                      debugLog('log', '[SYNC] Updated group version after inline edit', { groupId: group.groupId, version: group.version });
                    }

                    // Event-log integration for inline edit (for ALL groups with event-log)
                    if (group.useEventLog && group.eventLog && this.eventLogManager) {
                      // Only track what actually changed
                      const changes = {};
                      const oldValues = {};

                      // For inline edit, we mainly change the text
                      if (oldValue !== newValue) {
                        changes.text = newValue;
                        oldValues.text = oldValue;
                      }

                      changes.lastModified = nowTs;

                      debugLog('log', '[INLINE-EDIT] Creating event-log entry for link edit:', {
                        groupName: group.name,
                        groupId: group.groupId,
                        linkId: item.uuid,
                        oldText: oldValue,
                        newText: newValue,
                        isShared: group.shared
                      });

                      // Create and apply event using helper
                      this.createAndApplyEvent(group, {
                        type: 'link-edit',
                        linkId: item.uuid,
                        data: changes  // Just the changes, not wrapped
                      });
                    } else if (group.shared && group.groupTopic && group.groupKey && !group.useEventLog) {
                      // Legacy sync ONLY if event-log is NOT active and group is shared
                      const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                      // Ensure all fields are strings, not null/undefined
                      const linkToShare = {
                        uuid: item.uuid,
                        text: item.text || '',
                        url: item.url || '',
                        keywords: item.keywords || '',
                        emoji: item.emoji || '',
                        lastModified: item.lastModified || nowTs
                      };
                      debugLog('log', '[SYNC] Broadcasting inline-edited link (legacy)', {
                        uuid: linkToShare.uuid,
                        text: linkToShare.text,
                        url: linkToShare.url,
                        hasUrl: !!linkToShare.url && linkToShare.url !== ''
                      });
                      const env = { v:1, type:'share-links', ts:Date.now(), from, groupId: group.groupId, selection:{ groups:[], links:[linkToShare] }, mode:'merge', msgId:(Math.random().toString(36).slice(2)+Date.now()) };
                      sharing.sendToGroup(group, env);
                    }
                  }
                }
              } catch (error) {
                debugLog('error', '[SYNC] Failed to broadcast inline edit:', error);
              }
            }
          }
          item.editing = false;
          delete item._originalValue;
        },
        cancelEditing(item) {
          if (item && item.editing) {
            const valueKey = item.name !== undefined ? 'name' : 'text';
            if (item._originalValue !== undefined) {
              item[valueKey] = item._originalValue; // Revert to original
            }
            item.editing = false;
            delete item._originalValue;
          }
        },

        // --- Context Menus (Vue way) ---
        showMenu(event, type, item, groupContext = null) {
          event.preventDefault();
          event.stopPropagation(); // Verhindert, dass der globale Klick-Listener sofort schließt

          this.hideMenus(); // Andere Menüs ausblenden

          this.contextMenuTarget = { type: type, item: item, groupContext: groupContext };

          // Verwende nextTick, um sicherzustellen, dass das Menü-Element (falls neu gerendert) im DOM ist
        this.$nextTick(() => {
          const menuId = type === 'link' ? 'linkMenu' : 'groupMenu';
          const menu = document.getElementById(menuId);
          if (!menu) {
            debugLog('error', "Context menu element not found:", menuId);
            return;
          }

            // Stelle sicher, dass das Menü sichtbar ist, um Dimensionen zu messen (kann kurz unsichtbar bleiben)
            const initialDisplay = menu.style.display;
            const initialVisibility = menu.style.visibility;
            menu.style.display = 'block'; // Muss block sein für offsetWidth/Height
            menu.style.visibility = 'hidden'; // Aber noch nicht sichtbar machen

            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;

            // Reset styles before calculating final position
            menu.style.display = initialDisplay; // Zurücksetzen, falls es vorher none war
            menu.style.visibility = initialVisibility; // Zurücksetzen

            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const padding = 5; // Kleiner Abstand zum Rand

            let x = event.clientX;
            let y = event.clientY;

            // Berechne maximale erlaubte X/Y-Koordinaten
            const maxX = windowWidth - menuWidth - padding;
            const maxY = windowHeight - menuHeight - padding;

            // Stelle sicher, dass x und y innerhalb der Grenzen liegen
            x = Math.max(padding, Math.min(x, maxX));
            y = Math.max(padding, Math.min(y, maxY));

            // Setze den Stil und mache das Menü sichtbar
          this.contextMenuStyle = { top: `${y}px`, left: `${x}px` };
          if (type === 'link') this.isLinkMenuVisible = true;
          if (type === 'group') this.isGroupMenuVisible = true;

          // After showing, adjust any submenus to open left if near viewport edge
          this.$nextTick(() => {
            try {
              const padding2 = 8;
              const winW = window.innerWidth;
              const subs = menu.querySelectorAll('.submenu');
              subs.forEach((li) => {
                const fly = li.querySelector(':scope > .context-submenu');
                if (!fly) return;
                // Temporarily show to measure
                const prevDisp = fly.style.display;
                const prevVis = fly.style.visibility;
                fly.style.display = 'block';
                fly.style.visibility = 'hidden';
                const flyW = fly.offsetWidth || 220;
                // Position check relative to viewport
                const liRect = li.getBoundingClientRect();
                const wouldRight = liRect.right + flyW + padding2 <= winW;
                if (!wouldRight) li.classList.add('open-left'); else li.classList.remove('open-left');
                // restore
                fly.style.display = prevDisp;
                fly.style.visibility = prevVis;
              });
            } catch (e) { debugLog('warn', 'submenu adjust failed', e); }
          });

            // Optional: Kleiner Timeout, falls es immer noch Probleme gibt (normalerweise nicht nötig)
            /*
            setTimeout(() => {
                if (type === 'link') this.isLinkMenuVisible = true;
                if (type === 'group') this.isGroupMenuVisible = true;
            }, 0);
            */
          });
        },
        showLinkMenu(event, group, link) {
          this.showMenu(event, 'link', link, group);
        },
        showGroupMenu(event, group) {
          this.showMenu(event, 'group', group);
        },
        hideMenus() {
          this.isLinkMenuVisible = false;
          this.isGroupMenuVisible = false;
          this.contextMenuTarget = null; // Clear the target
        },
        // Search removed by request
        showLinkEditModal(link) {
          // Find the original link object in the data to ensure reactivity
          let originalLink = null;
          let parentGroup = null;
          for (const group of this.data.groups) {
            originalLink = group.links.find(l => 
              link.uuid && l.uuid === link.uuid
            );
            if (originalLink) {
              parentGroup = group;
              break;
            }
          }
          if (originalLink) {
            if (!this.canEdit(parentGroup)) { alert(this.getTranslation('error.perm.edit')); return; }
            
            // Prepare link data with defaults
            const linkData = JSON.parse(JSON.stringify(originalLink));
            if (linkData.infoHtml === undefined) linkData.infoHtml = '';
            if (linkData.keywords === undefined) linkData.keywords = '';
            if (linkData.color === undefined) linkData.color = '';
            // Include favicon fields in edit dialog data
            if (linkData.favicon === undefined) linkData.favicon = null;
            if (linkData.faviconError === undefined) linkData.faviconError = false;

            // Store original values for event-log comparison
            const originalValues = {
              text: originalLink.text || '',
              url: originalLink.url || '',
              keywords: originalLink.keywords || '',
              color: originalLink.color || '',
              infoHtml: originalLink.infoHtml || '',
              emoji: originalLink.emoji || ''
            };
            
            // Use the generic dialog
            this.openGenericEditDialog(
              'link',
              linkData,
              this.linkEditDesign,
              this.getTranslation('menu.link.editLink'),
              (editedData) => {
                // Normalize URL
                let url = MB.Utils.ensureProtocol((editedData.url || '').trim());
                editedData.url = url;
                
                // Apply changes to the original link
                Object.assign(originalLink, editedData);
                const nowTs = this.touchLink(originalLink);
                originalLink.lastEdited = nowTs;
                this.touchGroup(parentGroup, nowTs);

                // Ensure favicon fields are properly copied
                if ('favicon' in editedData) {
                  this.$set(originalLink, 'favicon', editedData.favicon);
                }
                if ('faviconError' in editedData) {
                  this.$set(originalLink, 'faviconError', editedData.faviconError);
                }
                if ('faviconSource' in editedData) {
                  this.$set(originalLink, 'faviconSource', editedData.faviconSource);
                }
                if ('faviconRuleId' in editedData) {
                  this.$set(originalLink, 'faviconRuleId', editedData.faviconRuleId);
                }
                
                // Event log for changes
                const changes = [];
                if (originalValues.text !== (editedData.text || '')) changes.push('text');
                if (originalValues.url !== url) changes.push('url');
                if (originalValues.keywords !== (editedData.keywords || '')) changes.push('keywords');
                if (originalValues.color !== (editedData.color || '')) changes.push('color');
                if (originalValues.infoHtml !== (editedData.infoHtml || '')) changes.push('info');
                if (originalValues.emoji !== (editedData.emoji || '')) changes.push('emoji');
                
                // Event-Log sync for shared groups with event-log enabled
                if (changes.length > 0 && parentGroup && parentGroup.useEventLog && this.eventLogManager) {
                  const changedData = {};
                  if (changes.includes('text')) changedData.text = editedData.text || '';
                  if (changes.includes('url')) changedData.url = url || '';
                  if (changes.includes('keywords')) changedData.keywords = editedData.keywords || '';
                  if (changes.includes('color')) changedData.color = editedData.color || '';
                  if (changes.includes('info')) changedData.infoHtml = this.sanitizeHtml(editedData.infoHtml || '');
                  if (changes.includes('emoji')) changedData.emoji = editedData.emoji || '';
                  changedData.lastModified = nowTs;

                  this.createAndApplyEvent(parentGroup, {
                    type: 'link-edit',
                    linkId: originalLink.uuid,
                    data: changedData
                  });
                }
                
                if (changes.length > 0 && parentGroup && (!parentGroup.useEventLog || !this.eventLogManager)) {
                  const event = {
                    type: 'link-edited',
                    ts: nowTs,
                    by: this.data.identity?.uuid || 'unknown',
                    linkId: originalLink.uuid,
                    text: `Edited link "${editedData.text || url}" (${changes.join(', ')})`
                  };
                  this.eventLogManager.addEvent(event, parentGroup);
                }
                
                // Save and sync
                this.saveData();
                
                // Sync to group members if this is a shared/synced group with proper topic/key
                try {
                  const sharing = window.sharing;
                  const canSyncGroup = sharing && parentGroup && parentGroup.shared && parentGroup.groupId && parentGroup.groupTopic && parentGroup.groupKey && !parentGroup.groupKey.startsWith('contact:');
                  if (canSyncGroup) {
                    const snapshot = {
                      action: 'update',
                      element: 'link',
                      group: this.serializeGroupMetaForSync(parentGroup),
                      link: this.serializeLinkForSync(originalLink),
                      ts: Date.now()
                    };
                    sharing.sendToGroup(parentGroup, snapshot);
                  }
                } catch {}
              }
            );
          }
          this.hideMenus();
        },
        async saveLinkEditModal() {
          if (!this.editLink) return;
          let originalLink = null;
          let parentGroup = null;
          // Find the original link to update
          for (const group of this.data.groups) {
            originalLink = group.links.find(l => 
              this.editLink.uuid && l.uuid === this.editLink.uuid
            );
            if (originalLink) {
              parentGroup = group;
              break;
            }
          }
          // Normalize URL
          let url = MB.Utils.ensureProtocol(this.editLink.url || '');

          if (originalLink) {
            if (!this.canEdit(parentGroup)) { alert(this.getTranslation('error.perm.edit')); return; }
            // Update existing link
            this.$set(originalLink, 'text', this.editLink.text.trim() || '');
            this.$set(originalLink, 'url', url || ''); // Use empty string instead of null
            this.$set(originalLink, 'keywords', this.editLink.keywords?.trim() || '');
            this.$set(originalLink, 'color', this.editLink.color || '');
            this.$set(originalLink, 'infoHtml', this.sanitizeHtml(this.editLink.infoHtml?.trim() || ''));
            // Update local timestamps for conflict resolution
            const nowTs = this.touchLink(originalLink);
            try {
              const nb = Object.assign({}, originalLink.ncBookmarks||{}, { localUpdatedAt: nowTs });
              // Do NOT update lastHash here; keep last synced signature as baseline
              this.$set(originalLink, 'ncBookmarks', nb);
              debugLog('log', '[NC SYNC] Marked local link edit', { id: nb.id, localUpdatedAt: nb.localUpdatedAt });
            } catch {}

            // Copy favicon from dialog state if present
            if (this.editLink.favicon) {
              this.$set(originalLink, 'favicon', this.editLink.favicon);
              this.$set(originalLink, 'faviconError', false);
            } else if (this.editLink.faviconError) {
              this.$set(originalLink, 'faviconError', true);
            }
            // Update version for sync tracking
            this.touchGroup(parentGroup, nowTs);
            if (parentGroup.shared) {
              parentGroup.version = (parentGroup.version || 0) + 1;
              debugLog('log', '[SYNC] Updated group version after editing link', { groupId: parentGroup.groupId, version: parentGroup.version });
              
              // Event-log integration for edit
              debugLog('log', '[EVENT-LOG] Checking for event-log edit', {
                hasEventLog: !!parentGroup.eventLog,
                hasManager: !!this.eventLogManager,
                eventLogLength: parentGroup.eventLog?.length || 0
              });
              
              if (parentGroup.useEventLog && parentGroup.eventLog && this.eventLogManager) {
                // Capture what actually changed using stored original values
                const changes = {};
                const oldValues = {};
                
                // Use the stored original values, not the current link values
                const origValues = this.editLinkOriginalValues || {};
                
                const newText = this.editLink.text.trim() || '';
                const oldText = origValues.text || '';
                if (newText !== oldText) {
                  changes.text = newText;
                  oldValues.text = oldText;
                }
                
                const newUrl = url || '';
                const oldUrl = origValues.url || '';
                if (newUrl !== oldUrl) {
                  changes.url = newUrl;
                  oldValues.url = oldUrl;
                }
                
                const newKeywords = this.editLink.keywords?.trim() || '';
                const oldKeywords = origValues.keywords || '';
                if (newKeywords !== oldKeywords) {
                  changes.keywords = newKeywords;
                  oldValues.keywords = oldKeywords;
                }
                
                const newColor = this.editLink.color || '';
                const oldColor = origValues.color || '';
                // Only track color changes if it actually changed (not both empty/default)
                if (newColor !== oldColor && !((!newColor || newColor === 'default') && (!oldColor || oldColor === 'default'))) {
                  changes.color = newColor;
                  oldValues.color = oldColor;
                }
                
                const newInfo = this.sanitizeHtml(this.editLink.infoHtml?.trim() || '');
                const oldInfo = origValues.infoHtml || '';
                // Only track info changes if content actually changed
                if (newInfo !== oldInfo && !(newInfo === '' && oldInfo === '')) {
                  changes.infoHtml = newInfo;
                  oldValues.infoHtml = oldInfo;
                }
                
                // Only create event if something actually changed
                // Emoji change
                const newEmoji = (this.editLink.emoji || '').trim();
                const oldEmoji = (origValues.emoji || '').trim();
                if (newEmoji !== oldEmoji) {
                  changes.emoji = newEmoji;
                  oldValues.emoji = oldEmoji;
                }

                if (Object.keys(changes).length > 0) {
                  changes.lastModified = nowTs;
                  // Create and apply event using helper
                  this.createAndApplyEvent(parentGroup, {
                    type: 'link-edit',
                    linkId: originalLink.uuid,
                    data: changes  // Just the changes, not wrapped
                  });
                } // Close if (Object.keys(changes).length > 0)
              }
            }
            
            this.saveData();
            // Broadcast change to shared group (legacy sync only)
            try {
              if (parentGroup.shared && parentGroup.groupTopic && parentGroup.groupKey && !parentGroup.useEventLog) {
                const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                // Ensure all fields are strings, not null/undefined
                const linkToShare = { 
                  uuid: originalLink.uuid, 
                  text: originalLink.text || '', 
                  url: originalLink.url || '', 
                  keywords: originalLink.keywords || '',
                  emoji: originalLink.emoji || '',
                  infoHtml: originalLink.infoHtml || '',
                  lastModified: originalLink.lastModified || nowTs
                };
                debugLog('log', '[SYNC] Broadcasting edited link', { uuid: linkToShare.uuid, hasUrl: !!linkToShare.url, text: linkToShare.text });
                const env = { v:1, type:'share-links', ts:Date.now(), from, groupId: parentGroup.groupId||parentGroup.uuid, selection:{ groups:[], links:[linkToShare] }, mode:'merge', msgId:(Math.random().toString(36).slice(2)+Date.now()) };
                await sharing.sendToGroup(parentGroup, env);
              }
            } catch {}
          } else {
            // Create new link via dialog
            const targetGroup = (this.data.groups || []).find(g => g.uuid === this.pendingNewLinkGroupId);
            if (!targetGroup) { debugLog('warn', 'No target group for new link'); return; }
            if (!this.canAdd(targetGroup)) { alert(this.getTranslation('error.perm.add')); return; }
            const nowTs = Date.now();
            const newLink = {
              uuid: this.generateUUID(), // UUID is the only identifier
              text: this.editLink.text.trim(),
              url: url || null,
              keywords: this.editLink.keywords?.trim() || '',
              color: this.editLink.color || '',
              emoji: this.editLink.emoji || '',
              infoHtml: this.sanitizeHtml(this.editLink.infoHtml?.trim() || ''),
              index: (targetGroup.links && targetGroup.links.length ? Math.max(...targetGroup.links.map(l => l.index)) + 1 : 0),
              column: 0,
              favicon: this.editLink.favicon || null,
              faviconError: this.editLink.faviconError || false,
              editing: false,
              isMouseOver: false,
              createdAt: nowTs,
              lastModified: nowTs,
            };
            targetGroup.links.push(newLink);
            const linkTimestamp = this.touchLink(newLink, nowTs);
            this.touchGroup(targetGroup, linkTimestamp);

            // Fetch favicon if autoFetchFavicon is enabled and URL is valid
            if (this.data.options?.links?.autoFetchFavicon && url && MB.Utils.isValidHttpUrl(url)) {
              this.tryFetchAndSetFavicon(newLink, url);
            }

            this.saveData();

            // Update version for sync tracking (only for shared groups)
            if (targetGroup.shared) {
              targetGroup.version = (targetGroup.version || 0) + 1;
            }

            // Event-log integration for new link from dialog (for ALL groups with event-log)
            if (targetGroup.useEventLog && targetGroup.eventLog && this.eventLogManager) {
              const event = {
                type: 'link-add',
                data: {
                  linkId: newLink.uuid,
                  data: {
                    uuid: newLink.uuid,
                    text: newLink.text || '',
                    url: newLink.url || '',
                    rawUrlInput: newLink.rawUrlInput || '',
                    keywords: newLink.keywords || '',
                    color: newLink.color || '',
                    emoji: newLink.emoji || '',
                    infoHtml: this.sanitizeHtml(newLink.infoHtml || ''),
                    column: newLink.column || 0,
                    index: newLink.index || 0,
                    createdAt: newLink.createdAt || linkTimestamp,
                    lastModified: newLink.lastModified || linkTimestamp
                  }
                },
                authorId: this.data.identity?.uuid,
                timestamp: Date.now()
              };

              debugLog('log', '[EVENT-LOG] Creating link-add event from dialog', event);

              // Apply event locally
              const added = this.eventLogManager.addEvent(event, targetGroup);
              debugLog('log', '[EVENT-LOG] Event added:', added, 'New event count:', targetGroup.eventLog?.length || 0);

              // Send event to all members (only for shared groups)
              if (targetGroup.shared) {
                const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                const syncEvent = {
                  v: 1,
                  type: 'sync-event',
                  ts: Date.now(),
                  from,
                  groupId: targetGroup.groupId,
                  event: event,
                  msgId: (Math.random().toString(36).slice(2) + Date.now())
                };

                try {
                  await sharing.sendToGroup(targetGroup, syncEvent);
                  debugLog('log', '[EVENT-LOG] Sent link-add event to group members', {
                    groupId: targetGroup.groupId,
                    linkId: newLink.uuid
                  });
                } catch (error) {
                  debugLog('error', '[EVENT-LOG] Failed to send add event:', error);
                }
              }
            }
            
            // Broadcast to shared group (legacy only)
            try {
              if (targetGroup.shared && targetGroup.groupTopic && targetGroup.groupKey && !targetGroup.useEventLog) {
                const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                // Ensure all fields are strings, not null/undefined
                const linkToShare = { 
                  uuid: newLink.uuid, 
                  text: newLink.text || '', 
                  url: newLink.url || '', 
                  keywords: newLink.keywords || '', 
                  emoji: newLink.emoji || '',
                  column: newLink.column || 0, 
                  index: newLink.index || 0,
                  createdAt: newLink.createdAt || linkTimestamp,
                  lastModified: newLink.lastModified || linkTimestamp 
                };
                debugLog('log', '[SYNC] Broadcasting new link from dialog', { uuid: linkToShare.uuid, hasUrl: !!linkToShare.url, text: linkToShare.text });
                const env = { v:1, type:'share-links', ts:Date.now(), from, groupId: targetGroup.groupId||targetGroup.uuid, selection:{ groups:[], links:[linkToShare] }, mode:'merge', msgId:(Math.random().toString(36).slice(2)+Date.now()) };
                await sharing.sendToGroup(targetGroup, env);
              }
            } catch {}
          }
          // Close generic edit dialog if open
          const genModal = document.getElementById('genericEditModal');
          if (genModal) {
            const inst = bootstrap.Modal.getInstance(genModal);
            if (inst) inst.hide();
          }
          // Reset states
          this.linkModalVisible = false;
          this.editLink = null;
          this.editLinkOriginalValues = null;
          this.pendingNewLinkGroupId = null;
        },
        openAddLinkDialog(group) {
          if (!group) return;
          if (!this.canAdd(group)) { alert(this.getTranslation('error.perm.add')); return; }
          const targetGroup = group;
          const linkData = { text: '', url: '', keywords: '', color: '', infoHtml: '', faviconUrl: '' };
          const title = this.getTranslation('group.link.add') || 'Add';
          this.openGenericEditDialog(
            'link',
            linkData,
            this.linkEditDesign,
            title,
            async (edited) => {
              try {
                if (!this.canAdd(targetGroup)) { alert(this.getTranslation('error.perm.add')); return; }
                const url = MB.Utils.ensureProtocol(edited.url || '');
                const rawInput = (edited.url || '').trim();
                const neighbors = (targetGroup.links || []).filter(l => l.column === 0).sort((a,b)=>a.index-b.index);
                const last = neighbors[neighbors.length - 1];
                const newLink = {
                  uuid: this.generateUUID(),
                  text: (edited.text || '').trim(),
                  url: url || null,
                  rawUrlInput: rawInput,
                  keywords: (edited.keywords || '').trim(),
                  color: edited.color || '',
                  infoHtml: this.sanitizeHtml((edited.infoHtml || '').trim()),
                  index: last ? (last.index + 1) : 0,
                  column: 0,
                  favicon: null,
                  faviconError: false,
                  editing: false,
                  isMouseOver: false,
                };
                if (!Array.isArray(targetGroup.links)) this.$set(targetGroup, 'links', []);
                targetGroup.links.push(newLink);

                // Fetch favicon if autoFetchFavicon is enabled and URL is valid
                if (this.data.options?.links?.autoFetchFavicon && url) {
                  this.tryFetchAndSetFavicon(newLink, url, rawInput);
                }

                this.saveData();

                // Update version for sync tracking (only for shared groups)
                if (targetGroup.shared) {
                  targetGroup.version = (targetGroup.version || 0) + 1;
                }

                // Event-log integration (for ALL groups with event-log)
                if (targetGroup.useEventLog && targetGroup.eventLog && this.eventLogManager) {
                  const event = {
                    type: 'link-add',
                    data: { linkId: newLink.uuid, data: {
                      uuid: newLink.uuid,
                      text: newLink.text || '',
                      url: newLink.url || '',
                      rawUrlInput: newLink.rawUrlInput || '',
                      keywords: newLink.keywords || '',
                      color: newLink.color || '',
                      infoHtml: newLink.infoHtml || '',
                      column: newLink.column || 0,
                      index: newLink.index || 0
                    }},
                    authorId: this.data.identity?.uuid,
                    timestamp: Date.now()
                  };
                  this.eventLogManager.addEvent(event, targetGroup);
                  // Only send sync events for shared groups
                  if (targetGroup.shared) {
                    try {
                      const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                      const syncEvent = MB.Sync.buildEnvelope(this, 'sync-event', { groupId: targetGroup.groupId, event });
                      await sharing.sendToGroup(targetGroup, syncEvent);
                    } catch (e) { debugLog('warn','[EVENT-LOG] send add failed', e); }
                  }
                }
                // Legacy share-links broadcast
                try {
                  if (targetGroup.shared && targetGroup.groupTopic && targetGroup.groupKey) {
                    const from = { uuid: this.data.identity?.uuid, name: this.data.identity?.name||'' };
                    const linkToShare = { uuid: newLink.uuid, text: newLink.text || '', url: newLink.url || '', keywords: newLink.keywords || '', emoji: newLink.emoji || '', column: newLink.column || 0, index: newLink.index || 0 };
                    const env = MB.Sync.buildEnvelope(this, 'share-links', { from, groupId: targetGroup.groupId||targetGroup.uuid, selection:{ groups:[], links:[linkToShare] }, mode:'merge' });
                    await sharing.sendToGroup(targetGroup, env);
                  }
                } catch {}
              } catch (e) {
                debugLog('error', '[ADD] failed', e);
              }
            }
          );
        },
        async fetchMetadataForEditLink(force) {
          try {
            const url = (this.editLink?.url || '').trim();
            if (!url) return;
            this.metadataMessage = '';
            // Title
            if (force || (this.data.options?.links?.autoFetchTitle && (!this.editLink.text || this.editLink.text === this.editLink.url))) {
              this.titleFetchState = 'loading';
              const title = await this.tryFetchTitle(url);
              if (title) {
                this.editLink.text = title;
                this.titleFetchState = 'ok';
              } else {
                this.titleFetchState = 'fail';
              }
            }
            // Favicon
            if (this.data.options?.links?.autoFetchFavicon) {
              this.faviconFetchState = 'loading';
              try {
                await this.tryFetchAndSetFavicon(this.editLink, url);
                this.faviconFetchState = 'ok';
              } catch {
                this.faviconFetchState = 'fail';
              }
            }
          } catch (e) {
            this.metadataMessage = 'Metadata fetch failed';
            this.titleFetchState = this.titleFetchState === 'loading' ? 'fail' : this.titleFetchState;
            this.faviconFetchState = this.faviconFetchState === 'loading' ? 'fail' : this.faviconFetchState;
          }
        },
        isLikelyValidUrl(url) {
          if (!url) return false;
          const s = url.trim();
          // Allow schemes like http, https, ftp, smb, nfs, file, mailto, ws, wss
          const re = /^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)(?:\/\/)?\S+$/;
          // Also allow mailto: with address
          const mail = /^mailto:\S+@\S+$/i;
          return re.test(s) || mail.test(s);
        },
        async tryFetchTitle(url) {
          if (!url) return null;

          // Only use extension for all web requests
          if (this.extensionAvailable) {
            try {
              const metadata = await MB.Extension.fetchMetadata(url);
              if (metadata.title) {
                debugLog('log', 'Extension fetched title:', metadata.title);
                return metadata.title;
              }
            } catch (e) {
              debugLog('warn', 'Extension title fetch failed:', e.message);
            }
          }

          // Fallback: derive a readable title from the hostname/path if extension not available
          try {
            const u = new URL(url);
            const host = (u.hostname || '').replace(/^www\./i, '');
            // Use last non-empty path segment if present
            const segs = (u.pathname || '').split('/').filter(Boolean);
            const last = segs.length ? segs[segs.length - 1] : '';
            const pretty = (s) => s.replace(/[-_]+/g, ' ').replace(/\s+/g, ' ').trim();
            return pretty(last || host) || host || url;
          } catch {
            return url;
          }
        },
        async tryFetchAndSetFavicon(link, url, rawInput = null) {
          if (!url) return;

          // 0) Apply favicon rules first (no network if match exists)
          const rawCandidate = rawInput != null ? rawInput : (link?.rawUrlInput ?? null);
          const normalizedRaw = rawCandidate != null ? String(rawCandidate).trim() : null;
          if (this.applyFaviconRulesToLink(link, null, normalizedRaw)) return;

          // 1) Use extension for all web requests
          if (this.extensionAvailable) {
            try {
              const metadata = await MB.Extension.fetchMetadata(url);

              if (metadata.favicon) {
                debugLog('log', 'Extension fetched favicon successfully');
                // Store base64 favicon directly
                this.$set(link, 'favicon', metadata.favicon);
                this.$set(link, 'faviconError', false);
                this.$set(link, 'faviconSource', 'extension');
                this.$set(link, 'faviconRuleId', null);
              } else {
                debugLog('warn', 'Extension could not fetch favicon');
                this.$set(link, 'faviconError', true);
              }
            } catch (e) {
              debugLog('warn', 'Extension favicon fetch failed:', e.message);
              this.$set(link, 'faviconError', true);
            }
          } else if (this.data.options?.links?.autoFetchFavicon) {
            // 2) Extension not available but option is enabled - mark as error
            debugLog('warn', 'Favicon fetch requested but extension not available');
            this.$set(link, 'faviconError', true);
          }
        },
        
        // Link detail popover helpers
        shouldShowLinkPopover() {
          const linksOptions = this.data?.options?.links;
          return linksOptions?.showLinkPopover !== false;
        },
        normalizeTimestampValue(value) {
          if (value === null || value === undefined) return null;
          if (value instanceof Date) return value.getTime();
          if (typeof value === 'number' && Number.isFinite(value)) return value;
          if (typeof value === 'string') {
            const trimmed = value.trim();
            if (!trimmed) return null;
            const numeric = Number(trimmed);
            if (!Number.isNaN(numeric) && Number.isFinite(numeric)) return numeric;
            const parsed = Date.parse(trimmed);
            if (!Number.isNaN(parsed)) return parsed;
          }
          return null;
        },
        getLinkDisplayTitle(link) {
          if (!link) return '';
          const text = typeof link.text === 'string' ? link.text.trim() : '';
          if (text) return text;

          const url = (link.url || '').trim();
          if (!url) return this.getTranslation('link.popover.untitled') || 'Untitled link';

          try {
            const parsed = new URL(url);
            const host = (parsed.hostname || '').replace(/^www\./i, '');
            const segments = (parsed.pathname || '').split('/').filter(Boolean);
            const lastSegment = segments.length ? segments[segments.length - 1] : '';
            const candidate = lastSegment || host;
            if (!candidate) return url;
            return candidate.replace(/[-_]+/g, ' ');
          } catch {
            return url;
          }
        },
        buildLinkDisplayUrl(url) {
          if (!url) return '';
          try {
            const parsed = new URL(url);
            const host = (parsed.hostname || '').replace(/^www\./i, '');
            let display = host;
            if (parsed.pathname && parsed.pathname !== '/') display += parsed.pathname;
            if (parsed.search) display += parsed.search;
            if (display.length > 80) display = display.slice(0, 77) + '…';
            return display;
          } catch {
            return url.length > 80 ? url.slice(0, 77) + '…' : url;
          }
        },
        formatPopoverTimestamp(value) {
          const notAvailable = this.getTranslation('link.popover.notAvailable') || '—';
          const normalized = this.normalizeTimestampValue(value);
          if (normalized === null) {
            return { full: notAvailable, relative: '', raw: null };
          }

          const locale = (this.data?.options?.common?.language || navigator.language || 'en').toString();
          let full = '';
          try {
            full = new Intl.DateTimeFormat(locale, { dateStyle: 'medium', timeStyle: 'medium' }).format(new Date(normalized));
          } catch {
            try {
              full = new Date(normalized).toLocaleString();
            } catch {
              full = String(normalized);
            }
          }

          let relative = '';
          if (typeof Intl !== 'undefined' && typeof Intl.RelativeTimeFormat === 'function') {
            try {
              const diffSeconds = Math.round((normalized - Date.now()) / 1000);
              const absSeconds = Math.abs(diffSeconds);
              const units = [
                { unit: 'year', value: 31557600 },
                { unit: 'month', value: 2629800 },
                { unit: 'week', value: 604800 },
                { unit: 'day', value: 86400 },
                { unit: 'hour', value: 3600 },
                { unit: 'minute', value: 60 }
              ];
              let selectedUnit = 'second';
              let divisor = 1;
              for (const entry of units) {
                if (absSeconds >= entry.value) {
                  selectedUnit = entry.unit;
                  divisor = entry.value;
                  break;
                }
              }
              const formatter = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
              const valueInUnit = selectedUnit === 'second'
                ? diffSeconds
                : Math.round(diffSeconds / divisor);
              relative = formatter.format(valueInUnit, selectedUnit);
            } catch {}
          }

          return { full, relative, raw: normalized };
        },
        getPopoverFavicon(link) {
          if (!link) return '';
          if (link.favicon) return link.favicon;

          const utils = (typeof MB !== 'undefined' && MB && MB.Utils) ? MB.Utils : null;
          const rawUrl = link.url || '';
          const ensuredUrl = utils?.ensureProtocol ? utils.ensureProtocol(rawUrl) : rawUrl;
          const isValid = utils?.isValidHttpUrl ? utils.isValidHttpUrl(ensuredUrl) : /^https?:\/\//i.test(ensuredUrl);
          if (!isValid) {
            return '';
          }

          try {
            const parsed = new URL(ensuredUrl);
            const domainParam = encodeURIComponent(parsed.origin || parsed.href);
            return `https://www.google.com/s2/favicons?sz=64&domain_url=${domainParam}`;
          } catch {
            return '';
          }
        },
        showLinkPopover(event, link) {
          try {
            if (!this.shouldShowLinkPopover()) {
              this.hideLinkPopover();
              return;
            }
            if (!link || link.editing) {
              this.hideLinkPopover();
              return;
            }

            if (this.linkPopoverHideTimer) {
              clearTimeout(this.linkPopoverHideTimer);
              this.linkPopoverHideTimer = null;
            }

            const isPointerCoarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
            if (isPointerCoarse && event?.type !== 'focusin') return;

            const target = event?.currentTarget || (event?.target && typeof event.target.closest === 'function'
              ? event.target.closest('.linkContainerListItem')
              : null);
            if (!target) return;

            const popover = this.linkPopover;
            popover.link = link;
            popover.url = link.url || '';
            popover.displayUrl = this.buildLinkDisplayUrl(link.url || '');
            popover.titleHtml = this.sanitizeInlineNoAnchor(this.getLinkDisplayTitle(link));
            popover.rawUrlInput = link.rawUrlInput || '';
            popover.favicon = this.getPopoverFavicon(link);
            let needsSave = false;
            let createdDisplay = this.formatPopoverTimestamp(link.createdAt);
            if (createdDisplay.raw === null) {
              const fallbackCreated = this.touchLink(link);
              createdDisplay = this.formatPopoverTimestamp(fallbackCreated);
              needsSave = true;
            }

            let updatedDisplay = this.formatPopoverTimestamp(link.lastModified ?? link.updatedAt ?? link.modifiedAt ?? null);
            if (updatedDisplay.raw === null) {
              const fallbackUpdated = this.touchLink(link);
              updatedDisplay = this.formatPopoverTimestamp(fallbackUpdated);
              needsSave = true;
            }

            if (createdDisplay.raw && updatedDisplay.raw && updatedDisplay.raw < createdDisplay.raw) {
              updatedDisplay = createdDisplay;
            }

            popover.createdAt = createdDisplay;
            popover.updatedAt = updatedDisplay;
            if (needsSave) {
              const parentGroup = (this.data.groups || []).find(g => Array.isArray(g.links) && g.links.includes(link));
              const referenceTs = updatedDisplay.raw || createdDisplay.raw;
              if (parentGroup && referenceTs) {
                this.touchGroup(parentGroup, referenceTs);
              }
              this.saveData();
            }
            popover.keywords = this.parseKeywords(link.keywords);
            popover.emoji = (link.emoji || '').trim();
            popover.uuid = link.uuid || '';

            const rect = target.getBoundingClientRect();
            const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            const margin = 16;
            const widthHint = 320;

            let left = rect.right + margin;
            let top = rect.top;

            if (left + widthHint > viewportWidth - margin) {
              left = rect.left - widthHint - margin;
            }
            if (left < margin) left = Math.max(margin, rect.left);
            if (top < margin) top = margin;

            popover.style = {
              top: `${top}px`,
              left: `${left}px`
            };
            popover.visible = true;

            this.$nextTick(() => {
              const el = document.querySelector('.link-detail-popover');
              if (!el) return;
              const popRect = el.getBoundingClientRect();
              let adjustedLeft = popRect.left;
              let adjustedTop = popRect.top;

              if (popRect.right > viewportWidth - margin) {
                adjustedLeft = Math.max(margin, viewportWidth - popRect.width - margin);
              }
              if (popRect.left < margin) {
                adjustedLeft = margin;
              }
              if (popRect.bottom > viewportHeight - margin) {
                adjustedTop = Math.max(margin, viewportHeight - popRect.height - margin);
              }
              if (popRect.top < margin) {
                adjustedTop = margin;
              }

              if (adjustedLeft !== popRect.left || adjustedTop !== popRect.top) {
                this.linkPopover.style = {
                  top: `${adjustedTop}px`,
                  left: `${adjustedLeft}px`
                };
              }
            });
          } catch (e) {
            debugLog('warn', '[POPOVER] Failed to show link popover', e);
          }
        },
        queueHideLinkPopover() {
          if (this.linkPopoverHideTimer) {
            clearTimeout(this.linkPopoverHideTimer);
          }
          this.linkPopoverHideTimer = setTimeout(() => {
            this.hideLinkPopover();
          }, 150);
        },
        cancelHideLinkPopover() {
          if (this.linkPopoverHideTimer) {
            clearTimeout(this.linkPopoverHideTimer);
            this.linkPopoverHideTimer = null;
          }
        },
        hideLinkPopover() {
          this.cancelHideLinkPopover();
          if (this.linkPopover.visible) {
            this.linkPopover.visible = false;
            this.linkPopover.link = null;
          }
        },
        touchGroup(group, timestamp = Date.now()) {
          if (!group) return;
          const normalized = this.normalizeTimestampValue(timestamp);
          const ts = normalized ?? Date.now();
          const created = this.normalizeTimestampValue(group.createdAt) ?? ts;
          this.$set(group, 'createdAt', created);
          this.$set(group, 'lastModified', ts);
          return ts;
        },
        touchLink(link, timestamp = Date.now()) {
          if (!link) return Date.now();
          const normalized = this.normalizeTimestampValue(timestamp);
          const ts = normalized ?? Date.now();
          const created = this.normalizeTimestampValue(link.createdAt) ?? ts;
          this.$set(link, 'createdAt', created);
          this.$set(link, 'lastModified', ts);
          return ts;
        },
        ensureAllTimestamps() {
          const now = Date.now();
          let updated = false;
          (this.data.groups || []).forEach(group => {
            const groupCreated = this.normalizeTimestampValue(group.createdAt);
            const groupModified = this.normalizeTimestampValue(group.lastModified);
            if (groupCreated === null) {
              this.$set(group, 'createdAt', now);
              updated = true;
            } else if (group.createdAt !== groupCreated) {
              this.$set(group, 'createdAt', groupCreated);
            }
            if (groupModified === null) {
              this.$set(group, 'lastModified', groupCreated ?? now);
              updated = true;
            } else if (group.lastModified !== groupModified) {
              this.$set(group, 'lastModified', groupModified);
            }
            (group.links || []).forEach(link => {
              const linkCreated = this.normalizeTimestampValue(link.createdAt);
              const linkModified = this.normalizeTimestampValue(link.lastModified);
              if (linkCreated === null) {
                this.$set(link, 'createdAt', now);
                updated = true;
              } else if (link.createdAt !== linkCreated) {
                this.$set(link, 'createdAt', linkCreated);
              }
              if (linkModified === null) {
                this.$set(link, 'lastModified', linkCreated ?? now);
                updated = true;
              } else if (link.lastModified !== linkModified) {
                this.$set(link, 'lastModified', linkModified);
              }
            });
          });
          return updated;
        },
        
        // Info popup methods
        showInfoPopup(event, htmlContent) {
          if (this.infoPopupTimer) {
            clearTimeout(this.infoPopupTimer);
          }
          
          this.infoPopupContent = this.sanitizeHtml(String(htmlContent || ''));
          const popup = document.getElementById('infoPopup');
          if (!popup) return;
          
          popup.classList.add('show');
          
          // Position the popup near the cursor
          const rect = event.target.getBoundingClientRect();
          const popupWidth = 400; // max-width from CSS
          const popupHeight = 300; // max-height from CSS
          
          let left = rect.right + 10;
          let top = rect.top;
          
          // Adjust if popup would go off screen
          if (left + popupWidth > window.innerWidth) {
            left = rect.left - popupWidth - 10;
          }
          if (top + popupHeight > window.innerHeight) {
            top = window.innerHeight - popupHeight - 10;
          }
          
          popup.style.left = left + 'px';
          popup.style.top = top + 'px';
        },
        
        hideInfoPopup() {
          // Add a small delay to prevent flickering when moving between elements
          this.infoPopupTimer = setTimeout(() => {
            const popup = document.getElementById('infoPopup');
            if (popup) {
              popup.classList.remove('show');
              this.infoPopupContent = '';
            }
          }, 200);
        },
        
        toggleGroupInfo(group) {
          this.$set(group, 'infoExpanded', !group.infoExpanded);
        },
        
        // Helper methods for JSON serialization to avoid redundancy
        serializeLinkForSync(link) {
          return {
            uuid: link.uuid || '',
            text: link.text || '',
            url: link.url || '',
            keywords: link.keywords || '',
            emoji: link.emoji || '',
            infoHtml: link.infoHtml || '',
            column: link.column || 0,
            index: typeof link.index === 'number' ? link.index : 0
          };
        },
        
        serializeGroupMetaForSync(group) {
          return {
            name: group.name || '',
            emoji: group.emoji || '',
            color: group.color || '',
            favicon: group.favicon || '',
            faviconSource: group.faviconSource || null,
            faviconRuleId: group.faviconRuleId || null,
            infoHtml: group.infoHtml || ''
          };
        },
        
        serializeGroupForSync(group) {
          return {
            ...this.serializeGroupMetaForSync(group),
            groupId: group.groupId || group.uuid,
            links: (group.links || []).map(l => this.serializeLinkForSync(l)),
            version: group.version || 0,  // CRITICAL: Always include version for sync
            // Include event-log data if available
            useEventLog: group.useEventLog || false,
            eventLog: group.eventLog || [],
            snapshot: group.snapshot || null,
            headEventId: group.headEventId || null,
            vectorClock: group.vectorClock || {}
          };
        },
        // Innerhalb von methods: { ... } der Vue-Instanz 'app'
        showGroupEditModal(group) {
          const originalGroup = this.data.groups.find(g => g.uuid === group.uuid);
          if (originalGroup) {
            // Prepare group data with defaults
            const groupData = JSON.parse(JSON.stringify(originalGroup));
            // Ensure prefs structure exists
            if (!groupData.prefs) groupData.prefs = { inbound: { perMember: {} } };
            if (!groupData.prefs.inbound) groupData.prefs.inbound = { perMember: {} };
            if (!groupData.prefs.inbound.perMember) groupData.prefs.inbound.perMember = {};
            if (groupData.emoji === undefined) groupData.emoji = '';
            if (groupData.keywords === undefined) groupData.keywords = '';
            if (groupData.color === undefined) groupData.color = '';
            if (groupData.titleFormatting === undefined) groupData.titleFormatting = '';
            if (groupData.linkColor === undefined) groupData.linkColor = '';
            if (groupData.infoHtml === undefined) groupData.infoHtml = '';
            if (groupData.favicon === undefined) groupData.favicon = '';
            if (groupData.faviconError === undefined) groupData.faviconError = false;
            if (groupData.faviconLoading === undefined) groupData.faviconLoading = false;
            if (groupData.faviconSource === undefined) groupData.faviconSource = null;
            if (groupData.faviconRuleId === undefined) groupData.faviconRuleId = null;
            
            // Use the generic dialog
            this.openGenericEditDialog(
              'group',
              groupData,
              this.groupEditDesign,
              this.getTranslation('menu.group.editGroup'),
              (editedData) => {
                // Apply changes to the original group
                const nowTs = Date.now();
                Object.assign(originalGroup, editedData);
                originalGroup.lastEdited = nowTs;
                this.touchGroup(originalGroup, nowTs);

                // Save and sync
                this.saveData();
                
                // Sync to group members if this is a shared/synced group with proper topic/key
                try {
                  const sharing = window.sharing;
                  const canSyncGroup = sharing && originalGroup && originalGroup.shared && originalGroup.groupId && originalGroup.groupTopic && originalGroup.groupKey && !originalGroup.groupKey.startsWith('contact:');
                  if (canSyncGroup) {
                    const snapshot = {
                      action: 'update',
                      element: 'group',
                      group: this.serializeGroupMetaForSync(originalGroup),
                      ts: Date.now()
                    };
                    sharing.sendToGroup(originalGroup, snapshot);
                  }
                } catch {}
              }
            );
          } else {
            debugLog('error', "Original group not found for editing:", group.uuid);
          }
          this.hideMenus(); // Menü trotzdem schließen
        },
        saveGroupEditModal() {
          if (!this.editGroup) return;
          const originalGroup = this.data.groups.find(g => g.uuid === this.editGroup.uuid);
          if (originalGroup) {
            const nowTs = Date.now();
            this.$set(originalGroup, 'name', this.editGroup.name.trim() || 'Group');
            this.$set(originalGroup, 'keywords', this.editGroup.keywords?.trim() || '');
            this.$set(originalGroup, 'color', this.editGroup.color || '');
            this.$set(originalGroup, 'titleFormatting', this.editGroup.titleFormatting || '');
            this.$set(originalGroup, 'infoHtml', this.sanitizeHtml(this.editGroup.infoHtml?.trim() || ''));
            // Persist formatting fields correctly (override precedence: defaults < group < link)
            this.$set(originalGroup, 'linkFormatting', this.editGroup.linkFormatting || '');
            this.$set(originalGroup, 'badgeFormatting', this.editGroup.badgeFormatting || '');
            this.$set(originalGroup, 'pillFormatting', this.editGroup.pillFormatting || '');
            this.$set(originalGroup, 'infoHtml', this.editGroup.infoHtml?.trim() || '');
            const op = Number(this.editGroup.opacity);
            const clamped = isNaN(op) ? 100 : Math.max(0, Math.min(100, op));
            this.$set(originalGroup, 'opacity', clamped);
            this.touchGroup(originalGroup, nowTs);
            this.saveData();
            // Broadcast group-meta and snapshot if shared (Owner only)
            try {
              if (originalGroup.shared && originalGroup.groupTopic && originalGroup.groupKey && this.isOwnerOfGroup(originalGroup)) {
                const from = { uuid: this.data.identity?.uuid, name:this.data.identity?.name||'' };
                sharing.sendToGroup(originalGroup, { 
                  v:1, 
                  type:'group-meta', 
                  ts:Date.now(), 
                  from, 
                  groupId: originalGroup.groupId||originalGroup.uuid, 
                  ...this.serializeGroupMetaForSync(originalGroup) 
                });
                const snapshot = { 
                  v:1, 
                  type:'group-update', 
                  ts:Date.now(), 
                  from, 
                  ...this.serializeGroupForSync(originalGroup), 
                  msgId:(Math.random().toString(36).slice(2)+Date.now()) 
                };
                sharing.sendToGroup(originalGroup, snapshot);
              }
            } catch {}
          }
          // Use Bootstrap 5 JS API
          const modalElement = document.getElementById('groupEditModal');
          const modalInstance = bootstrap.Modal.getInstance(modalElement);
          if (modalInstance) {
            modalInstance.hide();
          }
          this.editGroup = null; // Clear edit state
        },
        
        // JSON Inspector methods
        inspectGroupJSON(group) {
          const originalGroup = this.data.groups.find(g => g.uuid === group.uuid);
          if (originalGroup) {
            this.inspectedGroup = originalGroup;
            // Pretty print JSON with 2 space indentation
            this.inspectedGroupJSON = JSON.stringify(originalGroup, null, 2);
            
            // Show the modal
            this.$nextTick(() => {
              const modalElement = document.getElementById('jsonInspectorModal');
              if (modalElement) {
                const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
                modalInstance.show();
              }
            });
          }
        },
        
        copyGroupJSON() {
          if (!this.inspectedGroupJSON) return;
          
          // Create a temporary textarea to copy from
          const textarea = document.createElement('textarea');
          textarea.value = this.inspectedGroupJSON;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          
          try {
            document.execCommand('copy');
            // Show success feedback
            const copyBtn = event.target.closest('button');
            if (copyBtn) {
              const originalText = copyBtn.innerHTML;
              copyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16"><path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.267.267 0 0 1 .02-.022z"/></svg> Copied!';
              setTimeout(() => {
                copyBtn.innerHTML = originalText;
              }, 2000);
            }
          } catch (err) {
            debugLog('error', 'Failed to copy JSON:', err);
            alert('Failed to copy JSON to clipboard');
          } finally {
            document.body.removeChild(textarea);
          }
        },
        
        formatBytes(bytes) {
          if (bytes === 0) return '0 Bytes';
          const k = 1024;
          const sizes = ['Bytes', 'KB', 'MB', 'GB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        },
        
        // Event Log Helper Methods
        getSortedEventLog(eventLog) {
          if (!eventLog || !Array.isArray(eventLog)) return [];
          // Sort by timestamp descending (newest first)
          return [...eventLog].sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        },
        
        formatEventTime(timestamp) {
          if (!timestamp) return 'N/A';
          const date = new Date(timestamp);
          const now = new Date();
          const diffMs = now - date;
          const diffMins = Math.floor(diffMs / CONSTS.MINUTE_MS);
          const diffHours = Math.floor(diffMs / 3600000);
          const diffDays = Math.floor(diffMs / 86400000);
          
          // Format full date and time with seconds
          const fullDateTime = moment(date).format('L LTS'); // Date + time with seconds
          
          // Calculate relative time
          let relativeTime;
          if (diffMins < 1) relativeTime = 'Just now';
          else if (diffMins < 60) relativeTime = `${diffMins} min ago`;
          else if (diffHours < 24) relativeTime = `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
          else if (diffDays < 7) relativeTime = `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
          else relativeTime = null;
          
          // Return both: full date/time and relative time (if recent)
          if (relativeTime) {
            return `${fullDateTime} (${relativeTime})`;
          } else {
            return fullDateTime;
          }
        },
        
        getEventTypeBadgeClass(type) {
          const typeClasses = {
            'link-add': 'bg-success',
            'link-edit': 'bg-primary',
            'link-delete': 'bg-danger',
            'snapshot': 'bg-info',
            'member-join': 'bg-warning',
            'member-leave': 'bg-secondary'
          };
          return typeClasses[type] || 'bg-secondary';
        },
        
        getAuthorName(authorId) {
          if (!authorId) return 'System';
          if (authorId === 'system') return 'System';
          if (authorId === this.data.identity?.uuid) return 'You';
          
          // Try to find in contacts
          const contact = this.data.contacts?.find(c => c.uuid === authorId);
          if (contact) return contact.name;
          
          // Try to find in group members
          if (this.inspectedGroup && this.inspectedGroup.members) {
            const member = this.inspectedGroup.members.find(m => m.uuid === authorId);
            if (member) return member.name;
          }
          
          // Show shortened UUID as fallback
          return authorId.substring(0, 8) + '...';
        },
        
        getEventDetailsFormatted(event) {
          const details = this.getEventDetails(event);
          
          // Support both event structures
          const eventType = event.operation?.type || event.type;
          const eventData = event.operation?.data || event.data;
          
          // For multi-field edits, format as list
          if (eventType === 'link-edit' && eventData) {
            // For operation structure, data contains changes directly
            // For legacy structure, data.changes contains the changes
            const changes = event.operation ? eventData : (eventData.changes || eventData);
            const lines = [];
            
            if (!eventData.oldValues) {
              // Reconstruct old values from history
              const eventLog = this.inspectedGroup?.eventLog;
              const reconstructed = this.reconstructOldValues(event, eventLog);
              const oldValues = reconstructed || {};
              
              // Show reconstructed old → new format
              if (changes.text !== undefined) {
                const oldText = oldValues.text || '';
                const newText = changes.text || '';
                const oldDisplay = oldText ? `"${this.escapeHtml(oldText)}"` : '<em>empty</em>';
                const newDisplay = newText ? `"${this.escapeHtml(newText)}"` : '<em>empty</em>';
                lines.push(`<strong>Text:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.url !== undefined) {
                const oldUrl = oldValues.url || '';
                const newUrl = changes.url || '';
                const shortOld = oldUrl.length > 40 ? oldUrl.substring(0, 40) + '...' : oldUrl;
                const shortNew = newUrl.length > 40 ? newUrl.substring(0, 40) + '...' : newUrl;
                const oldDisplay = oldUrl ? `"${this.escapeHtml(shortOld)}"` : '<em>empty</em>';
                const newDisplay = newUrl ? `"${this.escapeHtml(shortNew)}"` : '<em>empty</em>';
                lines.push(`<strong>URL:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.keywords !== undefined) {
                const oldKeywords = oldValues.keywords || '';
                const newKeywords = changes.keywords || '';
                const oldDisplay = oldKeywords ? `"${this.escapeHtml(oldKeywords)}"` : '<em>empty</em>';
                const newDisplay = newKeywords ? `"${this.escapeHtml(newKeywords)}"` : '<em>empty</em>';
                lines.push(`<strong>Keywords:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.color !== undefined) {
                const oldColor = oldValues.color || 'default';
                const newColor = changes.color || 'default';
                lines.push(`<strong>Color:</strong> <span style="background-color: ${oldColor === 'default' ? '#f8f9fa' : oldColor}; padding: 2px 6px; border-radius: 3px;">${this.escapeHtml(oldColor)}</span> → <span style="background-color: ${newColor === 'default' ? '#f8f9fa' : newColor}; padding: 2px 6px; border-radius: 3px;">${this.escapeHtml(newColor)}</span>`);
              }
              if (changes.infoHtml !== undefined) {
                lines.push(`<strong>Info text:</strong> updated`);
              }
            } else {
              // New events with oldValues - show old → new format
              const oldValues = eventData.oldValues;
              
              if (changes.text !== undefined) {
                const oldText = oldValues.text || '';
                const newText = changes.text || '';
                const oldDisplay = oldText ? `"${this.escapeHtml(oldText)}"` : '<em>empty</em>';
                const newDisplay = newText ? `"${this.escapeHtml(newText)}"` : '<em>empty</em>';
                lines.push(`<strong>Text:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.url !== undefined) {
                const oldUrl = oldValues.url || '';
                const newUrl = changes.url || '';
                const shortOld = oldUrl.length > 40 ? oldUrl.substring(0, 40) + '...' : oldUrl;
                const shortNew = newUrl.length > 40 ? newUrl.substring(0, 40) + '...' : newUrl;
                const oldDisplay = oldUrl ? `"${this.escapeHtml(shortOld)}"` : '<em>empty</em>';
                const newDisplay = newUrl ? `"${this.escapeHtml(shortNew)}"` : '<em>empty</em>';
                lines.push(`<strong>URL:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.keywords !== undefined) {
                const oldKeywords = oldValues.keywords || '';
                const newKeywords = changes.keywords || '';
                const oldDisplay = oldKeywords ? `"${this.escapeHtml(oldKeywords)}"` : '<em>empty</em>';
                const newDisplay = newKeywords ? `"${this.escapeHtml(newKeywords)}"` : '<em>empty</em>';
                lines.push(`<strong>Keywords:</strong> ${oldDisplay} → ${newDisplay}`);
              }
              if (changes.color !== undefined) {
                const oldColor = oldValues.color || 'default';
                const newColor = changes.color || 'default';
                lines.push(`<strong>Color:</strong> <span style="background-color: ${oldColor === 'default' ? '#f8f9fa' : oldColor}; padding: 2px 6px; border-radius: 3px;">${this.escapeHtml(oldColor)}</span> → <span style="background-color: ${newColor === 'default' ? '#f8f9fa' : newColor}; padding: 2px 6px; border-radius: 3px;">${this.escapeHtml(newColor)}</span>`);
              }
              if (changes.infoHtml !== undefined) {
                lines.push(`<strong>Info text:</strong> updated`);
              }
            }
            
            return this.sanitizeHtml(lines.join('<br>'));
          }
          
          // For simple cases, escape HTML and return sanitized
          return this.sanitizeHtml(this.escapeHtml(details));
        },
        
        escapeHtml(text) {
          const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
          };
          return text.replace(/[&<>"']/g, m => map[m]);
        },
        // Sanitize strings for safe v-html usage (small allowlist)
        sanitizeHtml(input) {
          try {
            const html = String(input || '');
            const allowedTags = new Set(['b','i','strong','em','u','br','p','ul','ol','li','span','a','small','code','pre']);
            const allowedAttrs = { a: new Set(['href','title','target','rel']) };
            const div = document.createElement('div');
            div.innerHTML = html;
            const traverse = (node) => {
              // Remove script/style and disallowed nodes
              if (node.nodeType === 1) {
                const tag = node.tagName.toLowerCase();
                if (!allowedTags.has(tag)) {
                  node.replaceWith(document.createTextNode(node.textContent || ''));
                  return;
                }
                // Remove event handlers and non-allowed attributes
                [...node.attributes].forEach(attr => {
                  const name = attr.name.toLowerCase();
                  if (name.startsWith('on')) node.removeAttribute(attr.name);
                  if (tag === 'a') {
                    if (!allowedAttrs.a.has(name)) node.removeAttribute(attr.name);
                    if (name === 'href') {
                      const href = (attr.value || '').trim();
                      const safe = /^(https?:|mailto:)/i.test(href) ? href : '#';
                      node.setAttribute('href', safe);
                      node.setAttribute('rel', 'noopener noreferrer');
                    }
                    if (name === 'target') {
                      node.setAttribute('target', '_blank');
                    }
                  } else {
                    if (name !== 'title') node.removeAttribute(attr.name);
                  }
                });
              }
              // Recurse children
              for (const child of [...node.childNodes]) traverse(child);
            };
            for (const child of [...div.childNodes]) traverse(child);
            return div.innerHTML;
          } catch (e) {
            debugLog('warn', 'sanitizeHtml failed', e);
            return '';
          }
        },
        // Sanitize inline HTML for link text inside an <a>: unwrap any nested anchors
        sanitizeInlineNoAnchor(input) {
          try {
            const html = this.sanitizeHtml(input || '');
            const div = document.createElement('div');
            div.innerHTML = html;
            const anchors = div.querySelectorAll('a');
            anchors.forEach(a => {
              const span = document.createElement('span');
              span.innerHTML = a.innerHTML; // keep inner formatting, drop href/target
              a.parentNode.replaceChild(span, a);
            });
            return div.innerHTML;
          } catch (e) {
            debugLog('warn', 'sanitizeInlineNoAnchor failed', e);
            return '';
          }
        },
        // Central keyword parsing helper
        parseKeywords(value) {
          if (!value) return [];
          if (Array.isArray(value)) return value.map(s => String(s).trim()).filter(Boolean);
          if (typeof value === 'string') return value.split(/[,;]+/).map(s => s.trim()).filter(Boolean);
          return [];
        },
        
        reconstructOldValues(event, allEvents) {
          // Find the previous state of this link by going through history
          // Support both event structures
          const linkId = event.operation?.linkId || event.data?.linkId;
          if (!linkId || !allEvents) return null;
          
          // Find events for this link before the current event
          const linkEvents = allEvents.filter(e => {
            const eLinkId = e.operation?.linkId || e.data?.linkId;
            return eLinkId === linkId && e.timestamp < event.timestamp;
          }).sort((a, b) => a.timestamp - b.timestamp);
          
          // Start with initial values (from link-add or snapshot)
          let currentState = {
            text: '',
            url: '', 
            keywords: '',
            color: '',
            infoHtml: ''
          };
          
          // Apply all changes up to (but not including) this event
          for (const evt of linkEvents) {
            const evtType = evt.operation?.type || evt.type;
            const evtData = evt.operation?.data || evt.data;
            
            if (evtType === 'link-add') {
              // Initial creation - data is either directly in evtData or in evtData.data
              const linkData = evt.operation ? evtData : (evtData?.data || evtData);
              if (linkData) {
                currentState = {
                  text: linkData.text || '',
                  url: linkData.url || '',
                  keywords: linkData.keywords || '',
                  color: linkData.color || '',
                  infoHtml: linkData.infoHtml || ''
                };
              }
            } else if (evtType === 'link-edit') {
              // Apply changes - for operation structure, changes are directly in evtData
              // For legacy structure, changes are in evtData.changes
              const changes = evt.operation ? evtData : (evtData?.changes || evtData);
              if (changes) {
                if (changes.text !== undefined) currentState.text = changes.text;
                if (changes.url !== undefined) currentState.url = changes.url;
                if (changes.keywords !== undefined) currentState.keywords = changes.keywords;
                if (changes.color !== undefined) currentState.color = changes.color;
                if (changes.infoHtml !== undefined) currentState.infoHtml = changes.infoHtml;
              }
            }
          }
          
          return currentState;
        },
        
        getEventDetails(event) {
          // Support both event structures
          const eventType = event.operation?.type || event.type;
          const eventData = event.operation?.data || event.data;
          
          if (!event || !eventData) return '';
          
          switch(eventType) {
            case 'link-add':
              // For operation structure, data contains link data directly
              // For legacy structure, data.data contains the link data
              const addedLink = event.operation ? eventData : (eventData.data || eventData);
              if (!addedLink) return 'Added link';
              return `Added: "${addedLink.text || 'Untitled'}" → ${addedLink.url || 'No URL'}`;
            
            case 'link-edit':
              // For operation structure, data contains changes directly
              // For legacy structure, data.changes contains the changes  
              const changes = event.operation ? eventData : (eventData.changes || eventData);
              if (!changes) return 'Edited link';
              
              const changeDetails = [];
              
              // For old events without oldValues, reconstruct from history
              if (!eventData.oldValues) {
                // Get the event log from the current inspected group
                const eventLog = this.inspectedGroup?.eventLog;
                const reconstructed = this.reconstructOldValues(event, eventLog);
                const oldValues = reconstructed || {};
                // Use reconstructed old values
                if (changes.text !== undefined) {
                  const oldText = oldValues.text || '';
                  const newText = changes.text || '';
                  const oldDisplay = oldText || '(empty)';
                  const newDisplay = newText || '(empty)';
                  changeDetails.push(`Text: "${oldDisplay}" → "${newDisplay}"`);
                }
                
                if (changes.url !== undefined) {
                  const oldUrl = oldValues.url || '';
                  const newUrl = changes.url || '';
                  const shortOld = oldUrl ? (oldUrl.length > 30 ? oldUrl.substring(0, 30) + '...' : oldUrl) : '(empty)';
                  const shortNew = newUrl ? (newUrl.length > 30 ? newUrl.substring(0, 30) + '...' : newUrl) : '(empty)';
                  changeDetails.push(`URL: ${shortOld} → ${shortNew}`);
                }
                
                if (changes.keywords !== undefined) {
                  const oldKeywords = oldValues.keywords || '';
                  const newKeywords = changes.keywords || '';
                  const oldDisplay = oldKeywords || '(empty)';
                  const newDisplay = newKeywords || '(empty)';
                  changeDetails.push(`Keywords: "${oldDisplay}" → "${newDisplay}"`);
                }
                
                if (changes.color !== undefined) {
                  const oldColor = oldValues.color || '';
                  const newColor = changes.color || '';
                  if (!((!oldColor || oldColor === 'default') && (!newColor || newColor === 'default'))) {
                    const oldDisplay = oldColor || 'default';
                    const newDisplay = newColor || 'default';
                    changeDetails.push(`Color: ${oldDisplay} → ${newDisplay}`);
                  }
                }
                
                if (changes.infoHtml !== undefined) {
                  const oldInfo = oldValues.infoHtml || '';
                  const newInfo = changes.infoHtml || '';
                  if (oldInfo || newInfo) {
                    changeDetails.push('Info text updated');
                  }
                }
              } else {
                // New events with oldValues - show old → new format
                const oldValues = eventData.oldValues;
                if (changes.text !== undefined) {
                  const oldText = oldValues.text || '';
                  const newText = changes.text || '';
                  const oldDisplay = oldText || '(empty)';
                  const newDisplay = newText || '(empty)';
                  changeDetails.push(`Text: "${oldDisplay}" → "${newDisplay}"`);
                }
                
                if (changes.url !== undefined) {
                  const oldUrl = oldValues.url || '';
                  const newUrl = changes.url || '';
                  // Shorten URLs if too long
                  const shortOld = oldUrl ? (oldUrl.length > 30 ? oldUrl.substring(0, 30) + '...' : oldUrl) : '(empty)';
                  const shortNew = newUrl ? (newUrl.length > 30 ? newUrl.substring(0, 30) + '...' : newUrl) : '(empty)';
                  changeDetails.push(`URL: ${shortOld} → ${shortNew}`);
                }
                
                if (changes.keywords !== undefined) {
                  const oldKeywords = oldValues.keywords || '';
                  const newKeywords = changes.keywords || '';
                  const oldDisplay = oldKeywords || '(empty)';
                  const newDisplay = newKeywords || '(empty)';
                  changeDetails.push(`Keywords: "${oldDisplay}" → "${newDisplay}"`);
                }
                
                if (changes.color !== undefined) {
                  const oldColor = oldValues.color || '';
                  const newColor = changes.color || '';
                  // Only show if really changed
                  if (!((!oldColor || oldColor === 'default') && (!newColor || newColor === 'default'))) {
                    const oldDisplay = oldColor || 'default';
                    const newDisplay = newColor || 'default';
                    changeDetails.push(`Color: ${oldDisplay} → ${newDisplay}`);
                  }
                }
                
                if (changes.infoHtml !== undefined) {
                  const oldInfo = oldValues.infoHtml || '';
                  const newInfo = changes.infoHtml || '';
                  if (oldInfo || newInfo) {
                    changeDetails.push('Info text updated');
                  }
                }
              }
              
              if (changeDetails.length === 0) {
                return 'Link edited';
              }
              
              // If only one change, show it directly
              if (changeDetails.length === 1) {
                return changeDetails[0];
              }
              
              // Multiple changes: show count and first change
              return `${changeDetails.length} changes: ${changeDetails[0]}`;
            
            case 'link-delete':
              // For operation structure, data.deletedLink contains the deleted link
              // For legacy structure, data.deletedLink also contains it
              const deletedLink = eventData.deletedLink || eventData;
              const linkId = event.operation?.linkId || eventData.linkId;
              if (!deletedLink || !deletedLink.text) return `Deleted link ID: ${linkId}`;
              return `Deleted: "${deletedLink.text || 'Untitled'}" (${deletedLink.url || 'No URL'})`;
            
            case 'snapshot':
              const snapshotData = eventData.data || eventData;
              if (!snapshotData) return 'Created snapshot';
              return `Snapshot: ${snapshotData.links?.length || 0} links, ${snapshotData.members?.length || 0} members`;
            
            default:
              return JSON.stringify(eventData).substring(0, 100);
          }
        },
        
        showQrCodeModal(url) {
          this.hideMenus();
          if (!url) return;
          this.qrCodeUrl = url;
          Vue.nextTick(() => { // Ensure modal structure is ready
            const qrCodeDiv = document.getElementById('qrCodeDiv');
            if (qrCodeDiv) {
              qrCodeDiv.innerHTML = ''; // Clear previous QR code
              try {
                new QRCode(qrCodeDiv, {
                  text: url,
                  width: 256, // Adjust size as needed
                  height: 256,
                  colorDark: "#000000",
                  colorLight: "#ffffff",
                  correctLevel: QRCode.CorrectLevel.H
                });
              } catch (e) {
                debugLog('error', "QR Code generation failed:", e);
                qrCodeDiv.innerHTML = "Could not generate QR Code.";
              }
            }
            // Use Bootstrap 5 JS API
            const modalElement = document.getElementById('qrCodeModal');
            const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
            modalInstance.show();
          });
        },

        copyLinkToClipboard(link) {
          if (!link || !link.url) return;

          // Get customizable format from options
          const format = this.data.options?.links?.copyUrlFormat || '{title}: {url}';

          // Replace placeholders with actual values
          const title = link.text || link.url;
          const clipboardText = format
            .replace('{title}', title)
            .replace('{url}', link.url)
            .replace('{text}', title) // Alternative placeholder
            .replace('{keywords}', link.keywords || '')
            .replace('{date}', new Date().toLocaleDateString())
            .replace('{time}', new Date().toLocaleTimeString());

          // Copy to clipboard
          navigator.clipboard.writeText(clipboardText).then(() => {
            // Show success toast
            toastManager.success(
              this.getTranslation('link.urlCopied') || 'URL copied',
              `<code style="word-break: break-all;">${this.escapeHtml(clipboardText.substring(0, 100))}${clipboardText.length > 100 ? '...' : ''}</code>`,
              3000
            );
            debugLog('log', `Copied to clipboard: ${clipboardText}`);
          }).catch(err => {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = clipboardText;
            textArea.style.position = 'fixed';
            textArea.style.top = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand('copy');
              toastManager.success(
                this.getTranslation('link.urlCopied') || 'URL copied',
                `<code style="word-break: break-all;">${this.escapeHtml(clipboardText.substring(0, 100))}${clipboardText.length > 100 ? '...' : ''}</code>`,
                3000
              );
              debugLog('log', `Copied to clipboard (fallback): ${clipboardText}`);
            } catch (fallbackErr) {
              console.error('Failed to copy to clipboard:', fallbackErr);
              toastManager.error(
                this.getTranslation('link.copyFailed') || 'Failed to copy URL',
                this.getTranslation('link.copyError') || 'Could not access clipboard',
                5000
              );
            }
            document.body.removeChild(textArea);
          });
        },

        handleGlobalKeyDown(event) {
          if (this.data?.options?.common?.searchAsYouType &&
            !event.ctrlKey && !event.metaKey && !event.altKey && // Ignore modifier keys
            event.key.length === 1 && // Detect printable characters
            !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) // Ignore if typing in input/textarea
          {
            const searchInput = document.getElementById('searchFilter');
            if (searchInput && document.activeElement !== searchInput) {
              searchInput.focus();
              // Note: The character typed won't automatically appear,
              // but focus is now set for subsequent typing.
              // To add the first char: searchInput.value += event.key; this.filterText = searchInput.value;
            }
          }
        },
        async saveOptionsDialog_OLD_REMOVED() {
          debugLog('log', "saveOptionsDialog called");
          try {
            // Übernehme die Änderungen aus editableOptions in die Hauptdaten
            // Stellen sicher, dass alle Werte korrekt übernommen werden
            this.data.options.common.language = this.editableOptions.common.language;
            this.data.options.common.pageTitle = this.editableOptions.common.pageTitle;
            this.data.options.common.searchAsYouType = this.editableOptions.common.searchAsYouType;
            this.data.options.common.confirmDeleteGroup = !!this.editableOptions.common.confirmDeleteGroup;
            this.data.options.common.confirmDeleteLink = !!this.editableOptions.common.confirmDeleteLink;
            this.data.options.groups.collapseGroupsOnStart = this.editableOptions.groups.collapseGroupsOnStart;
            this.data.options.groups.hoverExpandEnabled = !!this.editableOptions.groups.hoverExpandEnabled;
            this.data.options.groups.hoverExpandDelayMs = Math.max(0, Number(this.editableOptions.groups.hoverExpandDelayMs) || 0);
            this.data.options.groups.defaultGroupFormatting = this.editableOptions.groups.defaultGroupFormatting || '';
            this.data.options.groups.defaultGroupTitleFormatting = this.editableOptions.groups.defaultGroupTitleFormatting || '';
            this.data.options.groups.defaultGroupLinkFormatting = this.editableOptions.groups.defaultGroupLinkFormatting || '';
            this.data.options.groups.defaultGroupBadgeFormatting = this.editableOptions.groups.defaultGroupBadgeFormatting || '';
            this.data.options.groups.defaultGroupPillFormatting = this.editableOptions.groups.defaultGroupPillFormatting || '';
            this.data.options.groups.clearClosesAllGroups = !!this.editableOptions.groups.clearClosesAllGroups;
            this.data.options.groups.keywordClickExpandsAll = !!this.editableOptions.groups.keywordClickExpandsAll;
            this.data.options.groups.searchAutoExpandFound = !!this.editableOptions.groups.searchAutoExpandFound;
            this.data.options.links.openInNewTab = !!this.editableOptions.links.openInNewTab;
            this.data.options.links.addViaDialog = !!this.editableOptions.links.addViaDialog;
            this.data.options.links.autoFetchTitle = !!this.editableOptions.links.autoFetchTitle;
            this.data.options.links.autoFetchFavicon = !!this.editableOptions.links.autoFetchFavicon;
            this.data.options.links.showLinkBadges = !!this.editableOptions.links.showLinkBadges;
            this.data.options.links.showLinkPopover = this.editableOptions.links.showLinkPopover !== false;
            this.data.options.links.defaultLinkFormatting = this.editableOptions.links.defaultLinkFormatting || '';
            this.data.options.links.defaultUrlPrefix = (this.editableOptions.links.defaultUrlPrefix || '').trim();
            this.data.options.links.copyUrlFormat = this.editableOptions.links.copyUrlFormat || '{title}: {url}';
            if (!this.data.options.links.showLinkPopover) {
              this.hideLinkPopover();
            }
            // Button visibility (default to true if undefined)
            if (!this.data.options.buttons) this.data.options.buttons = {};
            this.data.options.buttons.showAddLink = this.editableOptions.buttons?.showAddLink ?? true;
            this.data.options.buttons.showDeleteGroup = this.editableOptions.buttons?.showDeleteGroup ?? true;
            this.data.options.buttons.showCopyUrl = this.editableOptions.buttons?.showCopyUrl ?? true;
            this.data.options.buttons.showQrCode = this.editableOptions.buttons?.showQrCode ?? true;
            this.data.options.buttons.showDeleteLink = this.editableOptions.buttons?.showDeleteLink ?? true;
            // Sharing
            this.data.options.sharing.ntfyServerUrl = (this.editableOptions.sharing.ntfyServerUrl || '').trim();
            this.data.options.sharing.ntfyAuthToken = (this.editableOptions.sharing.ntfyAuthToken || '').trim();
            this.data.options.sharing.defaultTtl = Math.max(0, Number(this.editableOptions.sharing.defaultTtl || 0));
            this.data.options.sharing.quickCodeTtlSec = Math.max(60, Number(this.editableOptions.sharing.quickCodeTtlSec || 180));
            
            // Colors
            if (this.editableOptions.colors) {
              this.data.options.colors = this.data.options.colors || {};
              this.data.options.colors.background = this.editableOptions.colors.background || '';
              this.data.options.colors.toolbarBackground = this.editableOptions.colors.toolbarBackground || '';
              this.data.options.colors.titleBarBackground = this.editableOptions.colors.titleBarBackground || '';
              this.data.options.colors.titleTextColor = this.editableOptions.colors.titleTextColor || '';
              this.data.options.colors.keywordBackground = this.editableOptions.colors.keywordBackground || '';
            }
            
            // Event-Log
            if (this.editableOptions.eventlog) {
              this.data.options.eventlog = this.data.options.eventlog || {};
              this.data.options.eventlog.snapshotInterval = Math.max(10, Math.min(1000, Number(this.editableOptions.eventlog.snapshotInterval || 50)));
              this.data.options.eventlog.maxEvents = Math.max(100, Math.min(10000, Number(this.editableOptions.eventlog.maxEvents || 1000)));
              this.data.options.eventlog.syncStrategy = this.editableOptions.eventlog.syncStrategy || 'owner-leads';
            }
            
            // Update EventLogManager with new settings
            if (this.eventLogManager) {
              this.eventLogManager.maxEvents = this.data.options.eventlog.maxEvents;
              this.eventLogManager.snapshotInterval = this.data.options.eventlog.snapshotInterval;
              debugLog('log', '[SETTINGS] Updated EventLogManager settings', this.data.options.eventlog);
            }
            
            // Group sharing defaults
            if (!this.data.options.groupSharing) this.$set(this.data.options,'groupSharing',{});
            if (!this.data.options.groupSharing.topicPrefix) this.data.options.groupSharing.topicPrefix = 'mb-g-';
            
            // Save custom colors to options
            if (!this.data.options.customColors) {
              this.$set(this.data.options, 'customColors', {});
            }
            this.data.options.customColors = Object.assign({}, this.customColors);

            debugLog('log', "app.data.options updated:", JSON.stringify(this.data.options));

            this.updateSettings(); // Einstellungen anwenden (z.B. Titel)
            debugLog('log', "app.updateSettings called.");

            this.saveData(); // Speichert this.data (inkl. geänderter Optionen)
            debugLog('log', "app.saveData called after saveOptionsDialog.");
            if (sharing) sharing.applyConfig();

            // Propagate identity name changes
            try {
              const newName = this.data.identity?.name || '';
              const oldName = this.prevIdentityName || '';
              if (newName && newName !== oldName) {
                const from = { uuid: this.data.identity?.uuid, name: newName };
                // Notify all contacts (pairwise)
                for (const c of (this.data.contacts||[])) {
                  try { await sharing.sendToContact(c.uuid, { v:1, type:'contact-update', ts:Date.now(), from }); } catch {}
                }
                // Update own name in group rosters and broadcast (owner only)
                for (const g of (this.data.groups||[])) {
                  try {
                    const isOwner = (g?.members||[]).some(m=>m.role==='owner' && m.uuid===this.data.identity?.uuid) || (g.ownerUuid===this.data.identity?.uuid);
                    if (Array.isArray(g.members)) {
                      g.members = g.members.map(m => m.uuid===this.data.identity?.uuid ? Object.assign({}, m, { name: newName }) : m);
                    }
                    if (isOwner && g.shared && g.groupTopic && g.groupKey) {
                      await sharing.sendToGroup(g, { v:1, type:'group-roster', ts:Date.now(), from, groupId: g.groupId, members: g.members||[] });
                    }
                  } catch (error) {
                debugLog('error', '[Sharing] Error processing message headers:', error);
              }
                }
                this.saveData();
              }
            } catch {}

            // Schließe das Modal mit Bootstrap JS API
            const modalElement = document.getElementById('optionsModal');
            if (modalElement) {
              const modalInstance = bootstrap.Modal.getInstance(modalElement);
              if (modalInstance) {
                debugLog('log', "Hiding modal...");
                modalInstance.hide();
              }
            }
            this.editableOptions = null; // Bearbeitungskopie löschen
          } catch (err) {
            debugLog('error', "Error during saveOptionsDialog:", err);
            alert("An error occurred while saving options. Check the console.");
          }
        },

        // Debounced saving to reduce IndexedDB writes
        saveData() {
          if (!this._debouncedSave) {
            this._debouncedSave = debounce(this.saveDataImmediate, 300).bind(this);
          }
          this._debouncedSave();
        },
        async saveDataImmediate() {
          try {
            const savableData = this.getSavableData();
            const parsed = JSON.stringify(savableData);
            // History tracking
            if (this.appInitialized && !this.historyLock) {
              if (this.lastSavedJson && this.lastSavedJson !== parsed) {
                try { this.historyPast.push(JSON.parse(this.lastSavedJson)); } catch { }
                if (this.historyPast.length > 20) this.historyPast.shift();
                this.historyFuture = [];
              }
            }
            if (this.dataId === -1) {
              const newId = await linksDb.links.add({ data: parsed });
              this.dataId = newId;
            } else {
              await linksDb.links.update(this.dataId, { data: parsed });
            }
            this.lastSavedJson = parsed;
            this.$forceUpdate();
            // Update storage usage after save
            this.calculateStorageUsage();
          } catch (error) {
            debugLog('error', "Error saving data:", error);
          }
        },

      }, // end methods
    });

    // Make app global for options access (simple approach)
    window.app = app;

  </script>

  <script>
    let footer = new Vue({
      el: '#footer',
      data: {
        version: '2025.09.20', // Updated version string
      },
    });
  </script>

  <!-- Toast Notification (outside of Vue app) -->
  <div id="toast-notification" style="position: fixed; bottom: 20px; right: 20px; z-index: 11000; display: none;">
    <div class="toast show bg-light text-dark border shadow-sm" role="alert" style="min-width: 250px; border-radius: 8px;">
      <div class="toast-body d-flex align-items-center" style="gap: 8px;">
        <span id="toast-icon" class="me-2"></span>
        <span id="toast-message"></span>
      </div>
    </div>
  </div>

  <script>
    // Simple global toast function for Vue app
    window.showAppToast = function(message, type) {
      const toastEl = document.getElementById('toast-notification');
      const innerToast = toastEl ? toastEl.querySelector('.toast') : null;
      const toastBody = toastEl ? toastEl.querySelector('.toast-body') : null;
      const iconEl = document.getElementById('toast-icon');
      const messageEl = document.getElementById('toast-message');

      if (toastEl && iconEl && messageEl) {
        // Determine theme (dark vs light)
        const selectedTpl = (localStorage.getItem('selectedVisualTemplate') || '').toLowerCase();
        const isDark = (
          (document.documentElement.getAttribute('data-theme') === 'dark') ||
          (localStorage.getItem('darkMode') === 'true') ||
          (document.body.classList && document.body.classList.contains('dark-mode')) ||
          (selectedTpl === 'dark-mode')
        );

        // Apply theme-specific styles for good defaults across templates
        if (innerToast) {
          innerToast.classList.remove('bg-dark','text-white','bg-light','text-dark');
          innerToast.classList.add(isDark ? 'bg-dark' : 'bg-light', isDark ? 'text-white' : 'text-dark');
          innerToast.classList.add('border','shadow-sm');
          innerToast.style.background = isDark ? '#2d3748' : '#ffffff';
          innerToast.style.color = isDark ? '#f7fafc' : '#212529';
          innerToast.style.border = isDark ? '1px solid rgba(255, 255, 255, 0.15)' : '1px solid #dee2e6';
          innerToast.style.borderRadius = '8px';
        }
        if (toastBody) {
          toastBody.style.alignItems = 'center';
          toastBody.style.gap = '8px';
        }

        // Set icon based on type
        if (type === 'success') {
          iconEl.innerHTML = '<span style="color: #198754;">✓</span>';
        } else if (type === 'error') {
          iconEl.innerHTML = '<span style="color: #dc3545;">✗</span>';
        } else if (type === 'warning') {
          iconEl.innerHTML = '<span style="color: #ffc107;">⚠</span>';
        } else {
          iconEl.innerHTML = '<span style="color: #0d6efd;">ℹ</span>';
        }

        messageEl.textContent = message;
        toastEl.style.display = 'block';

        // Auto-hide after 3 seconds
        setTimeout(() => {
          toastEl.style.display = 'none';
        }, 3000);
      }
    };
  </script>

 </body>

</html>
